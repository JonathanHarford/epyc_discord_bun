var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __require = (id) => {
  return import.meta.require(id);
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/tslib/tslib.js
var require_tslib = __commonJS((exports, module) => {
  var __extends;
  var __assign;
  var __rest;
  var __decorate;
  var __param;
  var __esDecorate;
  var __runInitializers;
  var __propKey;
  var __setFunctionName;
  var __metadata;
  var __awaiter;
  var __generator;
  var __exportStar;
  var __values;
  var __read;
  var __spread;
  var __spreadArrays;
  var __spreadArray;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __classPrivateFieldIn;
  var __createBinding;
  var __addDisposableResource;
  var __disposeResources;
  (function(factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
      define("tslib", ["exports"], function(exports2) {
        factory(createExporter(root, createExporter(exports2)));
      });
    } else if (typeof module === "object" && typeof exports === "object") {
      factory(createExporter(root, createExporter(exports)));
    } else {
      factory(createExporter(root));
    }
    function createExporter(exports2, previous) {
      if (exports2 !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports2, "__esModule", { value: true });
        } else {
          exports2.__esModule = true;
        }
      }
      return function(id, v) {
        return exports2[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
      d.__proto__ = b;
    } || function(d, b) {
      for (var p in b)
        if (Object.prototype.hasOwnProperty.call(b, p))
          d[p] = b[p];
    };
    __extends = function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    __rest = function(s, e) {
      var t = {};
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
          t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
            t[p[i]] = s[p[i]];
        }
      return t;
    };
    __decorate = function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1;i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __esDecorate = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== undefined && typeof f !== "function")
          throw new TypeError("Function expected");
        return f;
      }
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1;i >= 0; i--) {
        var context = {};
        for (var p in contextIn)
          context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access)
          context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done)
            throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
          if (result === undefined)
            continue;
          if (result === null || typeof result !== "object")
            throw new TypeError("Object expected");
          if (_ = accept(result.get))
            descriptor.get = _;
          if (_ = accept(result.set))
            descriptor.set = _;
          if (_ = accept(result.init))
            initializers.unshift(_);
        } else if (_ = accept(result)) {
          if (kind === "field")
            initializers.unshift(_);
          else
            descriptor[key] = _;
        }
      }
      if (target)
        Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    __runInitializers = function(thisArg, initializers, value) {
      var useValue = arguments.length > 2;
      for (var i = 0;i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
      }
      return useValue ? value : undefined;
    };
    __propKey = function(x) {
      return typeof x === "symbol" ? x : "".concat(x);
    };
    __setFunctionName = function(f, name, prefix) {
      if (typeof name === "symbol")
        name = name.description ? "[".concat(name.description, "]") : "";
      return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator = function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : undefined, done: true };
      }
    };
    __exportStar = function(m, o) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
          __createBinding(o, m, p);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === undefined)
        k2 = k;
      o[k2] = m[k];
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = undefined;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === undefined || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    __spread = function() {
      for (var ar = [], i = 0;i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    __spreadArrays = function() {
      for (var s = 0, i = 0, il = arguments.length;i < il; i++)
        s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0;i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length;j < jl; j++, k++)
          r[k] = a[j];
      return r;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar;i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function verb(n) {
        if (g[n])
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length)
          resume(q[0][0], q[0][1]);
      }
    };
    __asyncDelegator = function(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function(e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function() {
        return this;
      }, i;
      function verb(n, f) {
        i[n] = o[n] ? function(v) {
          return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw2) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw2 });
      } else {
        cooked.raw = raw2;
      }
      return cooked;
    };
    var __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { default: mod };
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, state, value, kind, f) {
      if (kind === "m")
        throw new TypeError("Private method is not writable");
      if (kind === "a" && !f)
        throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    __classPrivateFieldIn = function(state, receiver) {
      if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
        throw new TypeError("Cannot use 'in' operator on non-object");
      return typeof state === "function" ? receiver === state : state.has(receiver);
    };
    __addDisposableResource = function(env, value, async) {
      if (value !== null && value !== undefined) {
        if (typeof value !== "object" && typeof value !== "function")
          throw new TypeError("Object expected.");
        var dispose;
        if (async) {
          if (!Symbol.asyncDispose)
            throw new TypeError("Symbol.asyncDispose is not defined.");
          dispose = value[Symbol.asyncDispose];
        }
        if (dispose === undefined) {
          if (!Symbol.dispose)
            throw new TypeError("Symbol.dispose is not defined.");
          dispose = value[Symbol.dispose];
        }
        if (typeof dispose !== "function")
          throw new TypeError("Object not disposable.");
        env.stack.push({ value, dispose, async });
      } else if (async) {
        env.stack.push({ async: true });
      }
      return value;
    };
    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    __disposeResources = function(env) {
      function fail(e) {
        env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
        env.hasError = true;
      }
      function next() {
        while (env.stack.length) {
          var rec = env.stack.pop();
          try {
            var result = rec.dispose && rec.dispose.call(rec.value);
            if (rec.async)
              return Promise.resolve(result).then(next, function(e) {
                fail(e);
                return next();
              });
          } catch (e) {
            fail(e);
          }
        }
        if (env.hasError)
          throw env.error;
      }
      return next();
    };
    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
  });
});

// node_modules/@discordjs/util/dist/index.js
var require_dist = __commonJS((exports, module) => {
  var lazy = function(cb) {
    let defaultValue;
    return () => defaultValue ??= cb();
  };
  function* range(range2) {
    let rangeEnd;
    let start = 0;
    let step = 1;
    if (typeof range2 === "number") {
      rangeEnd = range2;
    } else {
      start = range2.start;
      rangeEnd = range2.end;
      step = range2.step ?? 1;
    }
    for (let index = start;index < rangeEnd; index += step) {
      yield index;
    }
  }
  var calculateShardId = function(guildId, shardCount) {
    return Number(BigInt(guildId) >> 22n) % shardCount;
  };
  var shouldUseGlobalFetchAndWebSocket = function() {
    if (typeof globalThis.process === "undefined") {
      return ("fetch" in globalThis) && ("WebSocket" in globalThis);
    }
    if ("versions" in globalThis.process) {
      return ("deno" in globalThis.process.versions) || ("bun" in globalThis.process.versions);
    }
    return false;
  };
  var getUserAgentAppendix = function() {
    if (typeof globalThis.EdgeRuntime !== "undefined") {
      return "Vercel-Edge-Functions";
    }
    if (typeof globalThis.R2 !== "undefined" && typeof globalThis.WebSocketPair !== "undefined") {
      return "Cloudflare-Workers";
    }
    if (typeof globalThis.Netlify !== "undefined") {
      return "Netlify-Edge-Functions";
    }
    if (typeof globalThis.process !== "object") {
      if (typeof globalThis.navigator === "object") {
        return globalThis.navigator.userAgent;
      }
      return "UnknownEnvironment";
    }
    if ("versions" in globalThis.process) {
      if ("deno" in globalThis.process.versions) {
        return `Deno/${globalThis.process.versions.deno}`;
      }
      if ("bun" in globalThis.process.versions) {
        return `Bun/${globalThis.process.versions.bun}`;
      }
      if ("node" in globalThis.process.versions) {
        return `Node.js/${globalThis.process.versions.node}`;
      }
    }
    return "UnknownEnvironment";
  };
  var isJSONEncodable = function(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === "object" && ("toJSON" in maybeEncodable);
  };
  var isEquatable = function(maybeEquatable) {
    return maybeEquatable !== null && typeof maybeEquatable === "object" && ("equals" in maybeEquatable);
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    calculateShardId: () => calculateShardId,
    getUserAgentAppendix: () => getUserAgentAppendix,
    isEquatable: () => isEquatable,
    isJSONEncodable: () => isJSONEncodable,
    lazy: () => lazy,
    range: () => range,
    shouldUseGlobalFetchAndWebSocket: () => shouldUseGlobalFetchAndWebSocket
  });
  module.exports = __toCommonJS(src_exports);
  __name(lazy, "lazy");
  __name(range, "range");
  __name(calculateShardId, "calculateShardId");
  __name(shouldUseGlobalFetchAndWebSocket, "shouldUseGlobalFetchAndWebSocket");
  __name(getUserAgentAppendix, "getUserAgentAppendix");
  __name(isJSONEncodable, "isJSONEncodable");
  __name(isEquatable, "isEquatable");
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMBBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJsbGh0dHBfc3RhdHVzX25hbWUAIRpsbGh0dHBfc2V0X2xlbmllbnRfaGVhZGVycwAiIWxsaHR0cF9zZXRfbGVuaWVudF9jaHVua2VkX2xlbmd0aAAjHWxsaHR0cF9zZXRfbGVuaWVudF9rZWVwX2FsaXZlACQkbGxodHRwX3NldF9sZW5pZW50X3RyYW5zZmVyX2VuY29kaW5nACUYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mAD8JFwEAQQELEQECAwQFCwYHNTk3MS8tJyspCtnkAkUCAAsIABCIgICAAAsZACAAEMKAgIAAGiAAIAI2AjggACABOgAoCxwAIAAgAC8BMiAALQAuIAAQwYCAgAAQgICAgAALKgEBf0HAABDGgICAACIBEMKAgIAAGiABQYCIgIAANgI4IAEgADoAKCABCwoAIAAQyICAgAALBwAgAC0AKAsHACAALQAqCwcAIAAtACsLBwAgAC0AKQsHACAALwEyCwcAIAAtAC4LRQEEfyAAKAIYIQEgAC0ALSECIAAtACghAyAAKAI4IQQgABDCgICAABogACAENgI4IAAgAzoAKCAAIAI6AC0gACABNgIYCxEAIAAgASABIAJqEMOAgIAACxAAIABBAEHcABDMgICAABoLZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI4IgFFDQAgASgCLCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQy4CAgAAACyAAQcOWgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQdGbgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBJEkNABDLgICAAAALIABBAnRBoLOAgABqKAIACyIAAkAgAEEuSQ0AEMuAgIAAAAsgAEECdEGwtICAAGooAgAL7gsBAX9B66iAgAAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBnH9qDvQDY2IAAWFhYWFhYQIDBAVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhBgcICQoLDA0OD2FhYWFhEGFhYWFhYWFhYWFhEWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYRITFBUWFxgZGhthYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2YTc4OTphYWFhYWFhYTthYWE8YWFhYT0+P2FhYWFhYWFhQGFhQWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYUJDREVGR0hJSktMTU5PUFFSU2FhYWFhYWFhVFVWV1hZWlthXF1hYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFeYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhX2BhC0Hhp4CAAA8LQaShgIAADwtBy6yAgAAPC0H+sYCAAA8LQcCkgIAADwtBq6SAgAAPC0GNqICAAA8LQeKmgIAADwtBgLCAgAAPC0G5r4CAAA8LQdekgIAADwtB75+AgAAPC0Hhn4CAAA8LQfqfgIAADwtB8qCAgAAPC0Gor4CAAA8LQa6ygIAADwtBiLCAgAAPC0Hsp4CAAA8LQYKigIAADwtBjp2AgAAPC0HQroCAAA8LQcqjgIAADwtBxbKAgAAPC0HfnICAAA8LQdKcgIAADwtBxKCAgAAPC0HXoICAAA8LQaKfgIAADwtB7a6AgAAPC0GrsICAAA8LQdSlgIAADwtBzK6AgAAPC0H6roCAAA8LQfyrgIAADwtB0rCAgAAPC0HxnYCAAA8LQbuggIAADwtB96uAgAAPC0GQsYCAAA8LQdexgIAADwtBoq2AgAAPC0HUp4CAAA8LQeCrgIAADwtBn6yAgAAPC0HrsYCAAA8LQdWfgIAADwtByrGAgAAPC0HepYCAAA8LQdSegIAADwtB9JyAgAAPC0GnsoCAAA8LQbGdgIAADwtBoJ2AgAAPC0G5sYCAAA8LQbywgIAADwtBkqGAgAAPC0GzpoCAAA8LQemsgIAADwtBrJ6AgAAPC0HUq4CAAA8LQfemgIAADwtBgKaAgAAPC0GwoYCAAA8LQf6egIAADwtBjaOAgAAPC0GJrYCAAA8LQfeigIAADwtBoLGAgAAPC0Gun4CAAA8LQcalgIAADwtB6J6AgAAPC0GTooCAAA8LQcKvgIAADwtBw52AgAAPC0GLrICAAA8LQeGdgIAADwtBja+AgAAPC0HqoYCAAA8LQbStgIAADwtB0q+AgAAPC0HfsoCAAA8LQdKygIAADwtB8LCAgAAPC0GpooCAAA8LQfmjgIAADwtBmZ6AgAAPC0G1rICAAA8LQZuwgIAADwtBkrKAgAAPC0G2q4CAAA8LQcKigIAADwtB+LKAgAAPC0GepYCAAA8LQdCigIAADwtBup6AgAAPC0GBnoCAAA8LEMuAgIAAAAtB1qGAgAAhAQsgAQsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LGQAgACAALQAtQfsBcSABQQBHQQJ0cjoALQsZACAAIAAtAC1B9wFxIAFBAEdBA3RyOgAtCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcaRgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIwIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2ioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCNCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZqAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAjgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZWQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAI8IgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAhQiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGqm4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCQCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB7ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCOCIERQ0AIAQoAigiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEH2iICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCUCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAIcIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBwpmAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAkgiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI4IgRFDQAgBCgCICIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZSUgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjgiBEUNACAEKAJMIgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCOCIERQ0AIAQoAlQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI4IgRFDQAgBCgCWCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL8gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AIAAtAC1BCnENAEEFDwtBBA8LAkAgBEEgcQ0AAkAgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC1kAIABBGGpCADcDACAAQgA3AwAgAEE4akIANwMAIABBMGpCADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvc9wEDKH8DfgV/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8gASEQIAEhESABIRIgASETIAEhFCABIRUgASEWIAEhFyABIRggASEZIAEhGiABIRsgASEcIAEhHSABIR4gASEfIAEhICABISEgASEiIAEhIyABISQgASElIAEhJiABIScgASEoIAEhKQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIipBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4B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AQtBwQEhKgsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA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UGoON+cB5gEBAgMEBQYHCAAAAAAAAAAJCgsMDQ4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8QERITFAALQR4hKgzEAwtCAiErDOUBC0IDISsM5AELQgQhKwzjAQtCBSErDOIBC0IGISsM4QELQgchKwzgAQtCCCErDN8BC0IJISsM3gELQgohKwzdAQtCCyErDNwBC0IMISsM2wELQg0hKwzaAQtCDiErDNkBC0IPISsM2AELQgohKwzXAQtCCyErDNYBC0IMISsM1QELQg0hKwzUAQtCDiErDNMBC0IPISsM0gELQgAhKwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgKi0AAEFQag435QHkAQABAgMEBQYH5gHmAeYB5gHmAeYB5gEICQoLDA3mAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYBDg8QERIT5gELQgIhKwzkAQtCAyErDOMBC0IEISsM4gELQgUhKwzhAQtCBiErDOABC0IHISsM3wELQgghKwzeAQtCCSErDN0BC0IKISsM3AELQgshKwzbAQtCDCErDNoBC0INISsM2QELQg4hKwzYAQtCDyErDNcBC0IKISsM1gELQgshKwzVAQtCDCErDNQBC0INISsM0wELQg4hKwzSAQtCDyErDNEBCyAAQgAgACkDICIrIAIgASIqa60iLH0iLSAtICtWGzcDICArICxWIi5FDdIBQR8hKgzHAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBJCEqDK4DC0EgISoMxgMLIAAgASIqIAIQvoCAgABBf2oOBbYBAMsCAdEB0gELQREhKgyrAwsgAEEBOgAvICohAQzCAwsgASIBIAJHDdIBQSQhKgzCAwsgASInIAJHDR5BxgAhKgzBAwsgACABIgEgAhCygICAACIqDdQBIAEhAQy1AQsgASIqIAJHDSZB0AAhKgy/AwsCQCABIgEgAkcNAEEoISoMvwMLIABBADYCBCAAQYyAgIAANgIIIAAgASABELGAgIAAIioN0wEgASEBDNgBCwJAIAEiKiACRw0AQSkhKgy+AwsgKi0AACIBQSBGDRQgAUEJRw3TASAqQQFqIQEMFQsCQCABIgEgAkYNACABQQFq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AUEBaiEBIARBAWoiBCACRw0ACyAAICo2AgBBgwEhKgzoAgtBACEqIABBADYCACAuIDJrQQNqIQEMygELAkAgASIqIAJHDQBBhAEhKgznAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQYPPgIAAai0AAEcNzAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQYQBISoM5wILIABBADYCACAqIC5rQQVqIQFBIyEqDMkBCwJAIAEiBCACRw0AQYUBISoM5gILAkACQCAELQAAQbR/ag4IAMwBzAHMAcwBzAHMAQHMAQsgBEEBaiEBQe8AISoMzQILIARBAWohAUHwACEqDMwCCwJAIAEiBCACRw0AQYYBISoM5QILIAQtAABBxQBHDckBIARBAWohAQyKAgsCQCABIiogAkcNAEGHASEqDOQCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBiM+AgABqLQAARw3JASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBhwEhKgzkAgsgAEEANgIAICogLmtBBGohAUEtISoMxgELAkAgASIqIAJHDQBBiAEhKgzjAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQdDPgIAAai0AAEcNyAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQYgBISoM4wILIABBADYCACAqIC5rQQlqIQFBKSEqDMUBCwJAIAEiASACRw0AQYkBISoM4gILQQEhKiABLQAAQd8ARw3EASABQQFqIQEMiAILAkAgASIqIAJHDQBBigEhKgzhAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQNAIAQtAAAgAUGMz4CAAGotAABHDcUBIAFBAUYNtwIgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBigEhKgzgAgsCQCABIiogAkcNAEGLASEqDOACCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBjs+AgABqLQAARw3FASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBiwEhKgzgAgsgAEEANgIAICogLmtBA2ohAUECISoMwgELAkAgASIqIAJHDQBB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AABBt39qDgcBrgGuAa4BrgGuAQCuAQsgBEEBaiEEQY4BISoMrwILIARBAWohAUEiISoMqgELAkAgDiACRw0AQaQBISoMxwILIAIgDmsgACgCACIqaiEuIA4hBCAqIQECQANAIAQtAAAgAUHAz4CAAGotAABHDawBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGkASEqDMcCCyAAQQA2AgAgDiAqa0ECaiEBQR0hKgypAQsCQCAEIAJHDQBBpQEhKgzGAgsCQAJAIAQtAABBrn9qDgMArAEBrAELIARBAWohDkGQASEqDK0CCyAEQQFqIQFBBCEqDKgBCwJAIAQgAkcNAEGmASEqDMUCCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCuAa4BrgGuAa4BrgGuAa4BrgGuAQGuAa4BAq4BrgEDrgGuAQSuAQsgBEEBaiEEQYgBISoMrwILIARBAWohCkGJASEqDK4CCyAEQQFqIQtBigEhKgytAgsgBEEBaiEEQY8BISoMrAILIARBAWohBEGRASEqDKsCCwJAIA8gAkcNAEGnASEqDMQCCyACIA9rIAAoAgAiKmohLiAPIQQgKiEBAkADQCAELQAAIAFB7c+AgABqLQAARw2pASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBpwEhKgzEAgsgAEEANgIAIA8gKmtBA2ohAUERISoMpgELAkAgECACRw0AQagBISoMwwILIAIgEGsgACgCACIqaiEuIBAhBCAqIQECQANAIAQtAAAgAUHCz4CAAGotAABHDagBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEGoASEqDMMCCyAAQQA2AgAgECAqa0EDaiEBQSwhKgylAQsCQCARIAJHDQBBqQEhKgzCAgsgAiARayAAKAIAIipqIS4gESEEICohAQJAA0AgBC0AACABQcXPgIAAai0AAEcNpwEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQakBISoMwgILIABBADYCACARICprQQVqIQFBKyEqDKQBCwJAIBIgAkcNAEGqASEqDMECCyACIBJrIAAoAgAiKmohLiASIQQgKiEBAkADQCAELQAAIAFBys+AgABqLQAARw2mASABQQJGDQEgAUEBaiEB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8s+AgABqLQAARw2WASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBugEhKgyxAgsgAEEANgIAIBsgKmtBAmohAUEPISoMkwELAkAgBCACRw0AQbsBISoMsAILAkACQCAELQAAQbd/ag4HAJYBlgGWAZYBlgEBlgELIARBAWohGkGlASEqDJcCCyAEQQFqIRtBpgEhKgyWAgsCQCAcIAJHDQBBvAEhKgyvAgsgAiAcayAAKAIAIipqIS4gHCEEICohAQJAA0AgBC0AACABQfTPgIAAai0AAEcNlAEgAUEHRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbwBISoMrwILIABBADYCACAcICprQQhqIQFBGyEqDJEBCwJAIAQgAkcNAEG9ASEqDK4CCwJAAkACQCAELQAAQb5/ag4SAJUBlQGVAZUBlQGVAZUBlQGVAQGVAZUBlQGVAZUBlQEClQELIARBAWohGUGkASEqDJYCCyAEQQFqIQRBpwEhKgyVAgsgBEEBaiEcQagBISoMlAILAkAgBCACRw0AQb4BISoMrQILIAQtAABBzgBHDZEBIARBAWohBAzWAQsCQCAEIAJHDQBBvwEhKgysAgsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAELQAAQb9/ag4VAAECA6ABBAUGoAGgAaABBwgJCgugAQwNDg+gAQsgBEEBaiEBQegAISoMoQILIARBAWohAUHpACEqDKACCyAEQQFqIQFB7gAhKgyfAgsgBEEBaiEBQfIAISoMngILIARBAWohAUHzACEqDJ0CCyAEQQFqIQFB9gAhKgycAgsgBEEBaiEBQfcAISoMmwILIARBAWohAUH6ACEqDJoCCyAEQQFqIQRBgwEhKgyZAgsgBEEBaiEGQYQBISoMmAILIARBAWohB0GFASEqDJcCCyAEQQFqIQRBkgEhKgyWAgsgBEEBaiEEQZgBISoMlQILIARBAWohBEGgASEqDJQCCyAEQQFqIQRBowEhKgyTAgsgBEEBaiEEQaoBISoMkgILAkAgBCACRg0AIABBkICAgAA2AgggACAENgIEQasBISoMkgILQcABISoMqgILIAAgHSACEKqAgIAAIgENjwEgHSEBDF4LAkAgHiACRg0AIB5BAWohHQyRAQtBwgEhKgyoAgsD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NgIUIABB2o2AgAA2AhAgAEEUNgIMQQAhKgyNAgsgACgCBCEyIABBADYCBCAqICunaiIvIQEgACAyICogLyAuGyIqELWAgIAAIi5FDZMBIABBBzYCHCAAICo2AhQgACAuNgIMQQAhKgyMAgsgACAALwEwQYABcjsBMCABIQELQSohKgzxAQsgKkEVRg3ZASAAQQA2AhwgACABNgIUIABBg4yAgAA2AhAgAEETNgIMQQAhKgyJAgsgKkEVRg3XASAAQQA2AhwgACABNgIUIABBmo+AgAA2AhAgAEEiNgIMQQAhKgyIAgsgACgCBCEqIABBADYCBAJAIAAgKiABELeAgIAAIioNACABQQFqIQEMkwELIABBDDYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyHAgsgKkEVRg3UASAAQQA2AhwgACABNgIUIABBmo+AgAA2AhAgAEEiNgIMQQAhKgyGAgsgACgCBCEqIABBADYCBAJAIAAgKiABELeAgIAAIioNACABQQFqIQEMkgELIABBDTYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyFAgsgKkEVRg3RASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhKgyEAgsgACgCBCEqIABBADYCBAJAIAAgKiABELmAgIAAIioNACABQQFqIQEMkQELIABBDjYCHCAAICo2AgwgACABQQFqNgIUQQAhKgyDAgsgAEEANgIcIAAgATYCFCAAQcCVgIAANgIQIABBAjYCDEEAISoMggILICpBFUYNzQEgAEEANgIcIAAgATYCFCAAQcaMgIAANgIQIABBIzYCDEEAISoMgQILIABBEDYCHCAAIAE2AhQgACAqNgIMQQAhKgyAAgsgACgCBCEEIABBADYCBAJAIAAgBCABELmAgIAAIgQNACABQQFqIQEM+AELIABBETYCHCAAIAQ2AgwgACABQQFqNgIUQQAhKgz/AQsgKkEVRg3JASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhKgz+AQsgACgCBCEqIABBADYCBAJAIAAgKiABELmAgIAAIioNACABQQFqIQEMjgELIABBEzYCHCAAICo2AgwgACABQQFqNgIUQQAhKgz9AQsgACgCBCEEIABBADYCBAJAIAAgBCABELmAgIAAIgQNACAB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AkAgAC0AKUEjTw0AIAEhAQxcCyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMQQAhKgy8AQsgAEEANgIAC0EAISogAEEANgIcIAAgATYCFCAAQZCzgIAANgIQIABBCDYCDAy6AQsgAEEANgIAIDIgL2tBA2ohAQJAIAAtAClBIUcNACABIQEMWQsgAEEANgIcIAAgATYCFCAAQZuKgIAANgIQIABBCDYCDEEAISoMuQELIABBADYCACAyIC9rQQRqIQECQCAALQApIipBXWpBC08NACABIQEMWAsCQCAqQQZLDQBBASAqdEHKAHFFDQAgASEBDFgLQQAhKiAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMDLgBCyAqQRVGDXUgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAISoMtwELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFcLIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMtgELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDE8LIABB0gA2AhwgACABNgIUIAAgKjYCDEEAISoMtQELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDE8LIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMtAELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFQLIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMswELIABBADYCHCAAIAE2AhQgAEHGioCAADYCECAAQQc2AgxBACEqDLIBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxLCyAAQdIANgIcIAAgATYCFCAAICo2AgxBACEqDLEBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxLCyAAQdMANgIcIAAgATYCFCAAICo2AgxBACEqDLABCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxQCyAAQeUANgIcIAAgATYCFCAAICo2AgxBACEqDK8BCyAAQQA2AhwgACABNgIUIABB3IiAgAA2AhAgAEEHNgIMQQAhKgyuAQsgKkE/Rw0BIAFBAWohAQtBBSEqDJMBC0EAISogAEEANgIcIAAgATYCFCAAQf2SgIAANgIQIABBBzYCDAyrAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMRAsgAEHSADYCHCAAIAE2AhQgACAqNgIMQQAhKgyqAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMRAsgAEHTADYCHCAAIAE2AhQgACAqNgIMQQAhKgypAQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMSQsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgyoAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMQQsgAEHSADYCHCAAIC42AhQgACABNgIMQQAhKgynAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMQQsgAEHTADYCHCAAIC42AhQgACABNgIMQQAhKgymAQsgACgCBCEBIABBADYCBAJAIAAgASAuEKeAgIAAIgENACAuIQEMRgsgAEHlADYCHCAAIC42AhQgACABNgIMQQAhKgylAQsgAEEANgIcIAAgLjYCFCAAQcOPgIAANgIQIABBBzYCDEEAISoMpAELIABBADYCHCAAIAE2AhQgAEHDj4CAADYCECAAQQc2AgxBACEqDKMBC0EAISogAEEANgIcIAAgLjYCFCAAQYycgIAANgIQIABBBzYCDAyiAQsgAEEANgIcIAAgLjYCFCAAQYycgIAANgIQIABBBzYCDEEAISoMoQELIABBADYCHCAAIC42AhQgAEH+kYCAADYCECAAQQc2AgxBACEqDKABCyAAQQA2AhwgACABNgIUIABBjpuAgAA2AhAgAEEGNgIMQQAhKgyfAQsgKkEVRg1bIABBADYCHCAAIAE2AhQgAEHMjoCAADYCECAAQSA2AgxBACEqDJ4BCyAAQQA2AgAgKiAua0EGaiEBQSQhKgsgACAqOgApIAAoAgQhKiAAQQA2AgQgACAqIAEQq4CAgAAiKg1YIAEhAQxBCyAAQQA2AgALQQAhKiAAQQA2AhwgACAENgIUIABB8ZuAgAA2AhAgAEEGNgIMDJoBCyABQRVGDVQgAEEANgIcIAAgHTYC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AgAgKiAua0ECaiEBQfUAISoMEAsgASEBAkAgAC0AKUEFRw0AQeMAISoMEAtB4gAhKgwPC0EAISogAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgLkEBajYCFAwnCyAAQQA2AgAgMiAva0ECaiEBQcAAISoMDQsgASEBC0E4ISoMCwsCQCABIikgAkYNAANAAkAgKS0AAEGAvoCAAGotAAAiAUEBRg0AIAFBAkcNAyApQQFqIQEMBAsgKUEBaiIpIAJHDQALQT4hKgwkC0E+ISoMIwsgAEEAOgAsICkhAQwBC0ELISoMCAtBOiEqDAcLIAFBAWohAUEtISoMBgtBKCEqDAULIABBADYCACAvIDBrQQRqIQFBBiEqCyAAICo6ACwgASEBQQwhKgwDCyAAQQA2AgAgMiAva0EHaiEBQQohKgwCCyAAQQA2AgALIABBADoALCAnIQFBCSEqDAALC0EAISogAEEANgIcIAAgIzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAISogAEEANgIcIAAgIjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAISogAEEANgIcIAAgITYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAISogAEEANgIcIAAgIDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAISogAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAISogAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAISogAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAISogAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAISogAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAISogAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAISogAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAISogAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAISogAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAISogAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EA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AAAABQAAAAAAAAAAAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABJbnZhbGlkIGNoYXIgaW4gdXJsIHF1ZXJ5AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fYm9keQBDb250ZW50LUxlbmd0aCBvdmVyZmxvdwBDaHVuayBzaXplIG92ZXJmbG93AFJlc3BvbnNlIG92ZXJmbG93AEludmFsaWQgbWV0aG9kIGZvciBIVFRQL3gueCByZXF1ZXN0AEludmFsaWQgbWV0aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX3Jlc2V0YCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3N0YXR1c19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3ZlcnNpb25fY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl91cmxfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXRob2RfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfZmllbGRfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fbmFtZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdmVyc2lvbgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgSFRUUCB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZSB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlZCB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9yZXNldCBwYXVzZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fdmFsdWUgcGF1c2UAb25fc3RhdHVzX2NvbXBsZXRlIHBhdXNlAG9uX3ZlcnNpb25fY29tcGxldGUgcGF1c2UAb25fdXJsX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl92YWx1ZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAG9uX21ldGhvZF9jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfZmllbGRfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUgcGF1c2UAVW5leHBlY3RlZCBzcGFjZSBhZnRlciBzdGFydCBsaW5lAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX25hbWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBuYW1lAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fbWV0aG9kAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABTV0lUQ0hfUFJPWFkAVVNFX1BST1hZAE1LQUNUSVZJVFkAVU5QUk9DRVNTQUJMRV9FTlRJVFkAQ09QWQBNT1ZFRF9QRVJNQU5FTlRMWQBUT09fRUFSTFkATk9USUZZAEZBSUxFRF9ERVBFTkRFTkNZAEJBRF9HQVRFV0FZAFBMQVkAUFVUAENIRUNLT1VUAEdBVEVXQVlfVElNRU9VVABSRVFVRVNUX1RJTUVPVVQATkVUV09SS19DT05ORUNUX1RJTUVPVVQAQ09OTkVDVElPTl9USU1FT1VUAExPR0lOX1RJTUVPVVQATkVUV09SS19SRUFEX1RJTUVPVVQAUE9TVABNSVNESVJFQ1RFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX0xPQURfQkFMQU5DRURfUkVRVUVTVABCQURfUkVRVUVTVABIVFRQX1JFUVVFU1RfU0VOVF9UT19IVFRQU19QT1JUAFJFUE9SVABJTV9BX1RFQVBPVABSRVNFVF9DT05URU5UAE5PX0NPTlRFTlQAUEFSVElBTF9DT05URU5UAEhQRV9JTlZBTElEX0NPTlNUQU5UAEhQRV9DQl9SRVNFVABHRVQASFBFX1NUUklDVABDT05GTElDVABURU1QT1JBUllfUkVESVJFQ1QAUEVSTUFORU5UX1JFRElSRUNUAENPTk5FQ1QATVVMVElfU1RBVFVTAEhQRV9JTlZBTElEX1NUQVRVUwBUT09fTUFOWV9SRVFVRVNUUwBFQVJMWV9ISU5UUwBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUwBPUFRJT05TAFNXSVRDSElOR19QUk9UT0NPTFMAVkFSSUFOVF9BTFNPX05FR09USUFURVMATVVMVElQTEVfQ0hPSUNFUwBJTlRFUk5BTF9TRVJWRVJfRVJST1IAV0VCX1NFUlZFUl9VTktOT1dOX0VSUk9SAFJBSUxHVU5fRVJST1IASURFTlRJVFlfUFJPVklERVJfQVVUSEVOVElDQVRJT05fRVJST1IAU1NMX0NFUlRJRklDQVRFX0VSUk9SAElOVkFMSURfWF9GT1JXQVJERURfRk9SAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBTRUVfT1RIRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFdFQl9TRVJWRVJfSVNfRE9XTgBURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASEVVUklTVElDX0VYUElSQVRJT04ARElTQ09OTkVDVEVEX09QRVJBVElPTgBOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAFNJVEVfSVNfRlJPWkVOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBJTlZBTElEX1RPS0VOAEZPUkJJRERFTgBFTkhBTkNFX1lPVVJfQ0FMTQBIUEVfSU5WQUxJRF9VUkwAQkxPQ0tFRF9CWV9QQVJFTlRBTF9DT05UUk9MAE1LQ09MAEFDTABIUEVfSU5URVJOQUwAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRV9VTk9GRklDSUFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBSRVRSWV9XSVRIAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABVUklfVE9PX0xPTkcAUFJPQ0VTU0lORwBNSVNDRUxMQU5FT1VTX1BFUlNJU1RFTlRfV0FSTklORwBNSVNDRUxMQU5FT1VTX1dBUk5JTkcASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUAQ09OVElOVUUASFBFX0NCX1NUQVRVU19DT01QTEVURQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfVkVSU0lPTl9DT01QTEVURQBIUEVfQ0JfVVJMX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfSEVBREVSX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9OQU1FX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAEhQRV9DQl9NRVRIT0RfQ09NUExFVEUASFBFX0NCX0hFQURFUl9GSUVMRF9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAElOVkFMSURfU1NMX0NFUlRJRklDQVRFAFBBVVNFAE5PX1JFU1BPTlNFAFVOU1VQUE9SVEVEX01FRElBX1RZUEUAR09ORQBOT1RfQUNDRVBUQUJMRQBTRVJWSUNFX1VOQVZBSUxBQkxFAFJBTkdFX05PVF9TQVRJU0ZJQUJMRQBPUklHSU5fSVNfVU5SRUFDSEFCTEUAUkVTUE9OU0VfSVNfU1RBTEUAUFVSR0UATUVSR0UAUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRQBSRVFVRVNUX0hFQURFUl9UT09fTEFSR0UAUEFZTE9BRF9UT09fTEFSR0UASU5TVUZGSUNJRU5UX1NUT1JBR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UASFBFX1VORVhQRUNURURfU1BBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABOT1RfRk9VTkQAUFJPUEZJTkQAVU5CSU5EAFJFQklORABVTkFVVEhPUklaRUQATUVUSE9EX05PVF9BTExPV0VEAEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEAEFMUkVBRFlfUkVQT1JURUQAQUNDRVBURUQATk9UX0lNUExFTUVOVEVEAExPT1BfREVURUNURUQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABDUkVBVEVEAElNX1VTRUQASFBFX1BBVVNFRABUSU1FT1VUX09DQ1VSRUQAUEFZTUVOVF9SRVFVSVJFRABQUkVDT05ESVRJT05fUkVRVUlSRUQAUFJPWFlfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRABMRU5HVEhfUkVRVUlSRUQAU1NMX0NFUlRJRklDQVRFX1JFUVVJUkVEAFVQR1JBREVfUkVRVUlSRUQAUEFHRV9FWFBJUkVEAFBSRUNPTkRJVElPTl9GQUlMRUQARVhQRUNUQVRJT05fRkFJTEVEAFJFVkFMSURBVElPTl9GQUlMRUQAU1NMX0hBTkRTSEFLRV9GQUlMRUQATE9DS0VEAFRSQU5TRk9STUFUSU9OX0FQUExJRUQATk9UX01PRElGSUVEAE5PVF9FWFRFTkRFRABCQU5EV0lEVEhfTElNSVRfRVhDRUVERUQAU0lURV9JU19PVkVSTE9BREVEAEhFQUQARXhwZWN0ZWQgSFRUUC8AAF4TAAAmEwAAMBAAAPAXAACdEwAAFRIAADkXAADwEgAAChAAAHUSAACtEgAAghMAAE8UAAB/EAAAoBUAACMUAACJEgAAixQAAE0VAADUEQAAzxQAABAYAADJFgAA3BYAAMERAADgFwAAuxQAAHQUAAB8FQAA5RQAAAgXAAAfEAAAZRUAAKMUAAAoFQAAAhUAAJkVAAAsEAAAixkAAE8PAADUDgAAahAAAM4QAAACFwAAiQ4AAG4TAAAcEwAAZhQAAFYXAADBEwAAzRMAAGwTAABoFwAAZhcAAF8XAAAiEwAAzg8AAGkOAADYDgAAYxYAAMsTAACqDgAAKBcAACYXAADFEwAAXRYAAOgRAABnEwAAZRMAAPIWAABzEwAAHRcAAPkWAADzEQAAzw4AAM4VAAAMEgAAsxEAAKURAABhEAAAMhcAALsTAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAwICAgICAAACAgACAgACAgICAgICAgICAAQAAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgACAgICAgAAAgIAAgIAAgICAgICAgICAgADAAQAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv";
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS((exports, module) => {
  module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMBBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9z3AQMofwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdIAEhHiABIR8gASEgIAEhISABISIgASEjIAEhJCABISUgASEmIAEhJyABISggASEpAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiKkF/ag7dAdoBAdkBAgMEBQYHCAkKCwwNDtgBDxDXARES1gETFBUWFxgZGhvgAd8BHB0e1QEfICEiIyQl1AEmJygpKiss0wHSAS0u0QHQAS8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRtsBR0hJSs8BzgFLzQFMzAFNTk9QUVJTVFVW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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA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AAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEqDMQDC0ICISsM5QELQgMhKwzkAQtCBCErDOMBC0IFISsM4gELQgYhKwzhAQtCByErDOABC0IIISsM3wELQgkhKwzeAQtCCiErDN0BC0ILISsM3AELQgwhKwzbAQtCDSErDNoBC0IOISsM2QELQg8hKwzYAQtCCiErDNcBC0ILISsM1gELQgwhKwzVAQtCDSErDNQBC0IOISsM0wELQg8hKwzSAQtCACErAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAqLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiErDOQBC0IDISsM4wELQgQhKwziAQtCBSErDOEBC0IGISsM4AELQgchKwzfAQtCCCErDN4BC0IJISsM3QELQgohKwzcAQtCCyErDNsBC0IMISsM2gELQg0hKwzZAQtCDiErDNgBC0IPISsM1wELQgohKwzWAQtCCyErDNUBC0IMISsM1AELQg0hKwzTAQtCDiErDNIBC0IPISsM0QELIABCACAAKQMgIisgAiABIiprrSIsfSItIC0gK1YbNwMgICsgLFYiLkUN0gFBHyEqDMcDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkISoMrgMLQSAhKgzGAwsgACABIiogAhC+gICAAEF/ag4FtgEAywIB0QHSAQtBESEqDKsDCyAAQQE6AC8gKiEBDMIDCyABIgEgAkcN0gFBJCEqDMIDCyABIicgAkcNHkHGACEqDMEDCyAAIAEiASACELKAgIAAIioN1AEgASEBDLUBCyABIiogAkcNJkHQACEqDL8DCwJAIAEiASACRw0AQSghKgy/AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiKg3TASABIQEM2AELAkAgASIqIAJHDQBBKSEqDL4DCyAqLQAAIgFBIEYNFCABQQlHDdMBICpBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqISoMvAMLAkAg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DQALIAAgKjYCAEGDASEqDOgCC0EAISogAEEANgIAIC4gMmtBA2ohAQzKAQsCQCABIiogAkcNAEGEASEqDOcCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBg8+AgABqLQAARw3MASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBhAEhKgznAgsgAEEANgIAICogLmtBBWohAUEjISoMyQELAkAgASIEIAJHDQBBhQEhKgzmAgsCQAJAIAQtAABBtH9qDggAzAHMAcwBzAHMAcwBAcwBCyAEQQFqIQFB7wAhKgzNAgsgBEEBaiEBQfAAISoMzAILAkAgASIEIAJHDQBBhgEhKgzlAgsgBC0AAEHFAEcNyQEgBEEBaiEBDIoCCwJAIAEiKiACRw0AQYcBISoM5AILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGIz4CAAGotAABHDckBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGHASEqDOQCCyAAQQA2AgAgKiAua0EEaiEBQS0hKgzGAQsCQCABIiogAkcNAEGIASEqDOMCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB0M+AgABqLQAARw3IASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBiAEhKgzjAgsgAEEANgIAICogLmtBCWohAUEpISoMxQELAkAgASIBIAJHDQBBiQEhKgziAgtBASEqIAEtAABB3wBHDcQBIAFBAWohAQyIAgsCQCABIiogAkcNAEGKASEqDOECCyACICprIAAoAgAiLmohMiAqIQQgLiEBA0AgBC0AACABQYzPgIAAai0AAEcNxQEgAUEBRg23AiABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGKASEqDOACCwJAIAEiKiACRw0AQYsBISoM4AILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGOz4CAAGotAABHDcUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGLASEqDOACCyAAQQA2AgAgKiAua0EDaiEBQQIhKgzCAQsCQCABIiogAkcNAEGMASEqDN8CCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFB8M+AgABqLQAARw3EASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBjAEhKgzfAgsgAEEANgIAICogLmtBAmohAUEfISoMwQELAkAgASIqIAJHDQBBjQEhKgzeAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQfLPgIAAai0AAEcNwwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQY0BISoM3gILIABBADYCACAqIC5rQQJqIQFBCSEqDMABCwJAIAEiBCACRw0AQY4BISoM3QILAkACQCAELQAAQbd/ag4HAMMBwwHDAcMBwwEBwwELIARBAWohAUH4ACEqDMQCCyAEQQFqIQFB+QAhKgzDAgsCQCABIiogAkcNAEGPASEqDNwCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBkc+AgABqLQAARw3BASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBjwEhKgzcAgsgAEEANgIAICogLmtBBmohAUEYISoMvgELAkAgASIqIAJHDQBBkAEhKgzbAgsgAiAqayAAKAIAIi5qITIgKiEEIC4hAQJAA0AgBC0AACABQZfPgIAAai0AAEcNwAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAyNgIAQZABISoM2wILIABBADYCACAqIC5rQQNqIQFBFyEqDL0BCwJAIAEiKiACRw0AQZEBISoM2gILIAIgKmsgACgCACIuaiEyICohBCAuIQECQANAIAQtAAAgAUGaz4CAAGotAABHDb8BIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgMjYCAEGRASEqDNoCCyAAQQA2AgAgKiAua0EHaiEBQRUhKgy8AQsCQCABIiogAkcNAEGSASEqDNkCCyACICprIAAoAgAiLmohMiAqIQQgLiEBAkADQCAELQAAIAFBoc+AgABqLQAARw2+ASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIDI2AgBBkgEhKgzZAgsgAEEANgIAICogLmtBBmohAUEeISoMuwELAkAgASIEIAJHDQBBkwEhKgzYAgsgBC0AAEHMAEcN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LjYCAEGqASEqDMECCyAAQQA2AgAgEiAqa0EDaiEBQRQhKgyjAQsCQCAEIAJHDQBBqwEhKgzAAgsCQAJAAkACQCAELQAAQb5/ag4PAAECqAGoAagBqAGoAagBqAGoAagBqAGoAQOoAQsgBEEBaiEPQZMBISoMqQILIARBAWohEEGUASEqDKgCCyAEQQFqIRFBlQEhKgynAgsgBEEBaiESQZYBISoMpgILAkAgBCACRw0AQawBISoMvwILIAQtAABBxQBHDaMBIARBAWohBAznAQsCQCATIAJHDQBBrQEhKgy+AgsgAiATayAAKAIAIipqIS4gEyEEICohAQJAA0AgBC0AACABQc3PgIAAai0AAEcNowEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQa0BISoMvgILIABBADYCACATICprQQNqIQFBDiEqDKABCwJAIAQgAkcNAEGuASEqDL0CCyAELQAAQdAARw2hASAEQQFqIQFBJSEqDJ8BCwJAIBQgAkcNAEGvASEqDLwCCyACIBRrIAAoAgAiKmohLiAUIQQgKiEBAkADQCAELQAAIAFB0M+AgABqLQAARw2hASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBrwEhKgy8AgsgAEEANgIAIBQgKmtBCWohAUEqISoMngELAkAgBCACRw0AQbABISoMuwILAkACQCAELQAAQat/ag4LAKEBoQGhAaEBoQGhAaEBoQGhAQGhAQsgBEEBaiEEQZoBISoMogILIARBAWohFEGbASEqDKECCwJAIAQgAkcNAEGxASEqDLoCCwJAAkAgBC0AAEG/f2oOFACgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEBoAELIARBAWohE0GZASEqDKECCyAEQQFqIQRBnAEhKgygAgsCQCAVIAJHDQBBsgEhKgy5AgsgAiAVayAAKAIAIipqIS4gFSEEICohAQJAA0AgBC0AACABQdnPgIAAai0AAEcNngEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbIBISoMuQILIABBADYCACAVICprQQRqIQFBISEqDJsBCwJAIBYgAkcNAEGzASEqDLgCCyACIBZrIAAoAgAiKmohLiAWIQQgKiEBAkADQCAELQAAIAFB3c+AgABqLQAARw2dASABQQZGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBswEhKgy4AgsgAEEANgIAIBYgKmtBB2ohAUEaISoMmgELAkAgBCACRw0AQbQBISoMtwILAkACQAJAIAQtAABBu39qDhEAngGeAZ4BngGeAZ4BngGeAZ4BAZ4BngGeAZ4BngECngELIARBAWohBEGdASEqDJ8CCyAEQQFqIRVBngEhKgyeAgsgBEEBaiEWQZ8BISoMnQILAkAgFyACRw0AQbUBISoMtgILIAIgF2sgACgCACIqaiEuIBchBCAqIQECQANAIAQtAAAgAUHkz4CAAGotAABHDZsBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgLjYCAEG1ASEqDLYCCyAAQQA2AgAgFyAqa0EGaiEBQSghKgyYAQsCQCAYIAJHDQBBtgEhKgy1AgsgAiAYayAAKAIAIipqIS4gGCEEICohAQJAA0AgBC0AACABQerPgIAAai0AAEcNmgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbYBISoMtQILIABBADYCACAYICprQQNqIQFBByEqDJcBCwJAIAQgAkcNAEG3ASEqDLQCCwJAAkAgBC0AAEG7f2oODgCaAZoBmgGaAZoBmgGaAZoBmgGaAZoBmgEBmgELIARBAWohF0GhASEqDJsCCyAEQQFqIRhBogEhKgyaAgsCQCAZIAJHDQBBuAEhKgyzAgsgAiAZayAAKAIAIipqIS4gGSEEICohAQJAA0AgBC0AACABQe3PgIAAai0AAEcNmAEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAuNgIAQbgBISoMswILIABBADYCACAZICprQQNqIQFBEiEqDJUBCwJAIBogAkcNAEG5ASEqDLICCyACIBprIAAoAgAiKmohLiAaIQQgKiEBAkADQCAELQAAIAFB8M+AgABqLQAARw2XASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIC42AgBBuQEhKgyyAgsgAEEANgIAIBogKmtBAmohAUEgISoMlAELAkAgGyACRw0AQboBISoMsQILIAIgG2sgACgCACIqaiEuIBshBCAqIQECQANAIAQtAAAgAUHyz4CAAGotAABHDZYBIAFB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DM4BCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhKgzNAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKiAgIAAIioNASABIQELQccAISoMsQELICpBFUcNiQEgAEHRADYCHCAAIAE2AhQgAEHjl4CAADYCECAAQRU2AgxBACEqDMkBCyAAKAIEISogAEEANgIEAkAgACAqIAEQp4CAgAAiKg0AIAEhAQxiCyAAQdIANgIcIAAgATYCFCAAICo2AgxBACEqDMgBCyAAQQA2AhwgACAuNgIUIABBwaiAgAA2AhAgAEEHNgIMIABBADYCAEEAISoMxwELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDGELIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMxgELQQAhKiAAQQA2AhwgACABNgIUIABBgJGAgAA2AhAgAEEJNgIMDMUBCyAqQRVGDYMBIABBADYCHCAAIAE2AhQgAEGUjYCAADYCECAAQSE2AgxBACEqDMQBC0EBIS9BACEyQQAhLkEBISoLIAAgKjoAKyABQQFqIQECQAJAIAAtAC1BEHENAAJAAkACQCAALQAqDgMBAAIECyAvRQ0DDAILIC4NAQwCCyAyRQ0BCyAAKAIEISogAEEANgIEAkAgACAqIAEQrYCAgAAiKg0AIAEhAQxgCyAAQdgANgIcIAAgATYCFCAAICo2AgxBACEqDMMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQyyAQsgAEHZADYCHCAAIAE2AhQgACAENgIMQQAhKgzCAQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMsAELIABB2gA2AhwgACABNgIUIAAgBDYCDEEAISoMwQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDK4BCyAAQdwANgIcIAAgATYCFCAAIAQ2AgxBACEqDMABC0EBISoLIAAgKjoAKiABQQFqIQEMXAsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMqgELIABB3gA2AhwgACABNgIUIAAgBDYCDEEAISoMvQELIABBADYCACAyIC9rQQRqIQECQCAALQApQSNPDQAgASEBDFwLIABBADYCHCAAIAE2AhQgAEHTiYCAADYCECAAQQg2AgxBACEqDLwBCyAAQQA2AgALQQAhKiAAQQA2AhwgACABNgIUIABBkLOAgAA2AhAgAEEINgIMDLoBCyAAQQA2AgAgMiAva0EDaiEBAkAgAC0AKUEhRw0AIAEhAQxZCyAAQQA2AhwgACABNgIUIABBm4qAgAA2AhAgAEEINgIMQQAhKgy5AQsgAEEANgIAIDIgL2tBBGohAQJAIAAtACkiKkFdakELTw0AIAEhAQxYCwJAICpBBksNAEEBICp0QcoAcUUNACABIQEMWAtBACEqIABBADYCHCAAIAE2AhQgAEH3iYCAADYCECAAQQg2AgwMuAELICpBFUYNdSAAQQA2AhwgACABNgIUIABBuY2AgAA2AhAgAEEaNgIMQQAhKgy3AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMVwsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgy2AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMTwsgAEHSADYCHCAAIAE2AhQgACAqNgIMQQAhKgy1AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMTwsgAEHTADYCHCAAIAE2AhQgACAqNgIMQQAhKgy0AQsgACgCBCEqIABBADYCBAJAIAAgKiABEKeAgIAAIioNACABIQEMVAsgAEHlADYCHCAAIAE2AhQgACAqNgIMQQAhKgyzAQsgAEEANgIcIAAgATYCFCAAQcaKgIAANgIQIABBBzYCDEEAISoMsgELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDEsLIABB0gA2AhwgACABNgIUIAAgKjYCDEEAISoMsQELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDEsLIABB0wA2AhwgACABNgIUIAAgKjYCDEEAISoMsAELIAAoAgQhKiAAQQA2AgQCQCAAICogARCngICAACIqDQAgASEBDFALIABB5QA2AhwgACABNgIUIAAgKjYCDEEAISoMrwELIABBADYCHCAAIAE2AhQgAEHciICAADYCECAAQQc2AgxBACEqDK4BCyAqQT9HDQEgAUEBaiEB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AAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS((exports, module) => {
  module.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size")
  };
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS((exports, module) => {
  class UndiciError extends Error {
    constructor(message) {
      super(message);
      this.name = "UndiciError";
      this.code = "UND_ERR";
    }
  }

  class ConnectTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ConnectTimeoutError);
      this.name = "ConnectTimeoutError";
      this.message = message || "Connect Timeout Error";
      this.code = "UND_ERR_CONNECT_TIMEOUT";
    }
  }

  class HeadersTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersTimeoutError);
      this.name = "HeadersTimeoutError";
      this.message = message || "Headers Timeout Error";
      this.code = "UND_ERR_HEADERS_TIMEOUT";
    }
  }

  class HeadersOverflowError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, HeadersOverflowError);
      this.name = "HeadersOverflowError";
      this.message = message || "Headers Overflow Error";
      this.code = "UND_ERR_HEADERS_OVERFLOW";
    }
  }

  class BodyTimeoutError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, BodyTimeoutError);
      this.name = "BodyTimeoutError";
      this.message = message || "Body Timeout Error";
      this.code = "UND_ERR_BODY_TIMEOUT";
    }
  }

  class ResponseStatusCodeError extends UndiciError {
    constructor(message, statusCode, headers, body) {
      super(message);
      Error.captureStackTrace(this, ResponseStatusCodeError);
      this.name = "ResponseStatusCodeError";
      this.message = message || "Response Status Code Error";
      this.code = "UND_ERR_RESPONSE_STATUS_CODE";
      this.body = body;
      this.status = statusCode;
      this.statusCode = statusCode;
      this.headers = headers;
    }
  }

  class InvalidArgumentError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidArgumentError);
      this.name = "InvalidArgumentError";
      this.message = message || "Invalid Argument Error";
      this.code = "UND_ERR_INVALID_ARG";
    }
  }

  class InvalidReturnValueError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InvalidReturnValueError);
      this.name = "InvalidReturnValueError";
      this.message = message || "Invalid Return Value Error";
      this.code = "UND_ERR_INVALID_RETURN_VALUE";
    }
  }

  class RequestAbortedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestAbortedError);
      this.name = "AbortError";
      this.message = message || "Request aborted";
      this.code = "UND_ERR_ABORTED";
    }
  }

  class InformationalError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, InformationalError);
      this.name = "InformationalError";
      this.message = message || "Request information";
      this.code = "UND_ERR_INFO";
    }
  }

  class RequestContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, RequestContentLengthMismatchError);
      this.name = "RequestContentLengthMismatchError";
      this.message = message || "Request body length does not match content-length header";
      this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ResponseContentLengthMismatchError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseContentLengthMismatchError);
      this.name = "ResponseContentLengthMismatchError";
      this.message = message || "Response body length does not match content-length header";
      this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
    }
  }

  class ClientDestroyedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientDestroyedError);
      this.name = "ClientDestroyedError";
      this.message = message || "The client is destroyed";
      this.code = "UND_ERR_DESTROYED";
    }
  }

  class ClientClosedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ClientClosedError);
      this.name = "ClientClosedError";
      this.message = message || "The client is closed";
      this.code = "UND_ERR_CLOSED";
    }
  }

  class SocketError extends UndiciError {
    constructor(message, socket) {
      super(message);
      Error.captureStackTrace(this, SocketError);
      this.name = "SocketError";
      this.message = message || "Socket error";
      this.code = "UND_ERR_SOCKET";
      this.socket = socket;
    }
  }

  class NotSupportedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "NotSupportedError";
      this.message = message || "Not supported error";
      this.code = "UND_ERR_NOT_SUPPORTED";
    }
  }

  class BalancedPoolMissingUpstreamError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, NotSupportedError);
      this.name = "MissingUpstreamError";
      this.message = message || "No upstream has been added to the BalancedPool";
      this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
    }
  }

  class HTTPParserError extends Error {
    constructor(message, code, data) {
      super(message);
      Error.captureStackTrace(this, HTTPParserError);
      this.name = "HTTPParserError";
      this.code = code ? `HPE_${code}` : undefined;
      this.data = data ? data.toString() : undefined;
    }
  }

  class ResponseExceededMaxSizeError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, ResponseExceededMaxSizeError);
      this.name = "ResponseExceededMaxSizeError";
      this.message = message || "Response content exceeded max size";
      this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
    }
  }
  module.exports = {
    HTTPParserError,
    UndiciError,
    HeadersTimeoutError,
    HeadersOverflowError,
    BodyTimeoutError,
    RequestContentLengthMismatchError,
    ConnectTimeoutError,
    ResponseStatusCodeError,
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError,
    ClientDestroyedError,
    ClientClosedError,
    InformationalError,
    SocketError,
    NotSupportedError,
    ResponseContentLengthMismatchError,
    BalancedPoolMissingUpstreamError,
    ResponseExceededMaxSizeError
  };
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS((exports, module) => {
  var nop = function() {
  };
  var isStream = function(obj) {
    return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
  };
  var isBlobLike = function(object) {
    return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
  };
  var buildURL = function(url, queryParams) {
    if (url.includes("?") || url.includes("#")) {
      throw new Error('Query params cannot be passed when url already contains "?" or "#".');
    }
    const stringified = stringify(queryParams);
    if (stringified) {
      url += "?" + stringified;
    }
    return url;
  };
  var parseURL = function(url) {
    if (typeof url === "string") {
      url = new URL(url);
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      return url;
    }
    if (!url || typeof url !== "object") {
      throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
    }
    if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
      throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
    }
    if (url.path != null && typeof url.path !== "string") {
      throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
    }
    if (url.pathname != null && typeof url.pathname !== "string") {
      throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
    }
    if (url.hostname != null && typeof url.hostname !== "string") {
      throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
    }
    if (url.origin != null && typeof url.origin !== "string") {
      throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
    }
    if (!/^https?:/.test(url.origin || url.protocol)) {
      throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    }
    if (!(url instanceof URL)) {
      const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
      let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
      let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
      if (origin.endsWith("/")) {
        origin = origin.substring(0, origin.length - 1);
      }
      if (path && !path.startsWith("/")) {
        path = `/${path}`;
      }
      url = new URL(origin + path);
    }
    return url;
  };
  var parseOrigin = function(url) {
    url = parseURL(url);
    if (url.pathname !== "/" || url.search || url.hash) {
      throw new InvalidArgumentError("invalid url");
    }
    return url;
  };
  var getHostname = function(host) {
    if (host[0] === "[") {
      const idx2 = host.indexOf("]");
      assert(idx2 !== -1);
      return host.substr(1, idx2 - 1);
    }
    const idx = host.indexOf(":");
    if (idx === -1)
      return host;
    return host.substr(0, idx);
  };
  var getServerName = function(host) {
    if (!host) {
      return null;
    }
    assert.strictEqual(typeof host, "string");
    const servername = getHostname(host);
    if (net.isIP(servername)) {
      return "";
    }
    return servername;
  };
  var deepClone = function(obj) {
    return JSON.parse(JSON.stringify(obj));
  };
  var isAsyncIterable = function(obj) {
    return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
  };
  var isIterable = function(obj) {
    return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
  };
  var bodyLength = function(body) {
    if (body == null) {
      return 0;
    } else if (isStream(body)) {
      const state = body._readableState;
      return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
    } else if (isBlobLike(body)) {
      return body.size != null ? body.size : null;
    } else if (isBuffer(body)) {
      return body.byteLength;
    }
    return null;
  };
  var isDestroyed = function(stream2) {
    return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
  };
  var isReadableAborted = function(stream2) {
    const state = stream2 && stream2._readableState;
    return isDestroyed(stream2) && state && !state.endEmitted;
  };
  var destroy = function(stream2, err) {
    if (!isStream(stream2) || isDestroyed(stream2)) {
      return;
    }
    if (typeof stream2.destroy === "function") {
      if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
        stream2.socket = null;
      }
      stream2.destroy(err);
    } else if (err) {
      process.nextTick((stream3, err2) => {
        stream3.emit("error", err2);
      }, stream2, err);
    }
    if (stream2.destroyed !== true) {
      stream2[kDestroyed] = true;
    }
  };
  var parseKeepAliveTimeout = function(val) {
    const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
    return m ? parseInt(m[1], 10) * 1000 : null;
  };
  var parseHeaders = function(headers, obj = {}) {
    for (let i = 0;i < headers.length; i += 2) {
      const key = headers[i].toString().toLowerCase();
      let val = obj[key];
      if (!val) {
        if (Array.isArray(headers[i + 1])) {
          obj[key] = headers[i + 1];
        } else {
          obj[key] = headers[i + 1].toString("utf8");
        }
      } else {
        if (!Array.isArray(val)) {
          val = [val];
          obj[key] = val;
        }
        val.push(headers[i + 1].toString("utf8"));
      }
    }
    if (("content-length" in obj) && ("content-disposition" in obj)) {
      obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
    }
    return obj;
  };
  var parseRawHeaders = function(headers) {
    const ret = [];
    let hasContentLength = false;
    let contentDispositionIdx = -1;
    for (let n = 0;n < headers.length; n += 2) {
      const key = headers[n + 0].toString();
      const val = headers[n + 1].toString("utf8");
      if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
        ret.push(key, val);
        hasContentLength = true;
      } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
        contentDispositionIdx = ret.push(key, val) - 1;
      } else {
        ret.push(key, val);
      }
    }
    if (hasContentLength && contentDispositionIdx !== -1) {
      ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
    }
    return ret;
  };
  var isBuffer = function(buffer) {
    return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
  };
  var validateHandler = function(handler, method, upgrade) {
    if (!handler || typeof handler !== "object") {
      throw new InvalidArgumentError("handler must be an object");
    }
    if (typeof handler.onConnect !== "function") {
      throw new InvalidArgumentError("invalid onConnect method");
    }
    if (typeof handler.onError !== "function") {
      throw new InvalidArgumentError("invalid onError method");
    }
    if (typeof handler.onBodySent !== "function" && handler.onBodySent !== undefined) {
      throw new InvalidArgumentError("invalid onBodySent method");
    }
    if (upgrade || method === "CONNECT") {
      if (typeof handler.onUpgrade !== "function") {
        throw new InvalidArgumentError("invalid onUpgrade method");
      }
    } else {
      if (typeof handler.onHeaders !== "function") {
        throw new InvalidArgumentError("invalid onHeaders method");
      }
      if (typeof handler.onData !== "function") {
        throw new InvalidArgumentError("invalid onData method");
      }
      if (typeof handler.onComplete !== "function") {
        throw new InvalidArgumentError("invalid onComplete method");
      }
    }
  };
  var isDisturbed = function(body) {
    return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
  };
  var isErrored = function(body) {
    return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(nodeUtil.inspect(body))));
  };
  var isReadable = function(body) {
    return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(nodeUtil.inspect(body))));
  };
  var getSocketInfo = function(socket) {
    return {
      localAddress: socket.localAddress,
      localPort: socket.localPort,
      remoteAddress: socket.remoteAddress,
      remotePort: socket.remotePort,
      remoteFamily: socket.remoteFamily,
      timeout: socket.timeout,
      bytesWritten: socket.bytesWritten,
      bytesRead: socket.bytesRead
    };
  };
  var ReadableStreamFrom = function(iterable) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    if (ReadableStream.from) {
      return ReadableStream.from(iterable);
    }
    let iterator;
    return new ReadableStream({
      async start() {
        iterator = iterable[Symbol.asyncIterator]();
      },
      async pull(controller) {
        const { done, value } = await iterator.next();
        if (done) {
          queueMicrotask(() => {
            controller.close();
          });
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
          controller.enqueue(new Uint8Array(buf));
        }
        return controller.desiredSize > 0;
      },
      async cancel(reason) {
        await iterator.return();
      }
    }, 0);
  };
  var isFormDataLike = function(object) {
    return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
  };
  var throwIfAborted = function(signal) {
    if (!signal) {
      return;
    }
    if (typeof signal.throwIfAborted === "function") {
      signal.throwIfAborted();
    } else {
      if (signal.aborted) {
        const err = new Error("The operation was aborted");
        err.name = "AbortError";
        throw err;
      }
    }
  };
  var toUSVString = function(val) {
    if (hasToWellFormed) {
      return `${val}`.toWellFormed();
    } else if (nodeUtil.toUSVString) {
      return nodeUtil.toUSVString(val);
    }
    return `${val}`;
  };
  var assert = __require("assert");
  var { kDestroyed, kBodyUsed } = require_symbols();
  var { IncomingMessage } = __require("http");
  var stream = __require("stream");
  var net = __require("net");
  var { InvalidArgumentError } = require_errors();
  var { Blob: Blob2 } = __require("buffer");
  var nodeUtil = __require("util");
  var { stringify } = __require("querystring");
  var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
  var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
  var ReadableStream;
  var hasToWellFormed = !!String.prototype.toWellFormed;
  var kEnumerableProperty = Object.create(null);
  kEnumerableProperty.enumerable = true;
  module.exports = {
    kEnumerableProperty,
    nop,
    isDisturbed,
    isErrored,
    isReadable,
    toUSVString,
    isReadableAborted,
    isBlobLike,
    parseOrigin,
    parseURL,
    getServerName,
    isStream,
    isIterable,
    isAsyncIterable,
    isDestroyed,
    parseRawHeaders,
    parseHeaders,
    parseKeepAliveTimeout,
    destroy,
    bodyLength,
    deepClone,
    ReadableStreamFrom,
    isBuffer,
    validateHandler,
    getSocketInfo,
    isFormDataLike,
    buildURL,
    throwIfAborted,
    nodeMajor,
    nodeMinor,
    nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13
  };
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS((exports, module) => {
  var onTimeout = function() {
    fastNow = Date.now();
    let len = fastTimers.length;
    let idx = 0;
    while (idx < len) {
      const timer = fastTimers[idx];
      if (timer.state === 0) {
        timer.state = fastNow + timer.delay;
      } else if (timer.state > 0 && fastNow >= timer.state) {
        timer.state = -1;
        timer.callback(timer.opaque);
      }
      if (timer.state === -1) {
        timer.state = -2;
        if (idx !== len - 1) {
          fastTimers[idx] = fastTimers.pop();
        } else {
          fastTimers.pop();
        }
        len -= 1;
      } else {
        idx += 1;
      }
    }
    if (fastTimers.length > 0) {
      refreshTimeout();
    }
  };
  var refreshTimeout = function() {
    if (fastNowTimeout && fastNowTimeout.refresh) {
      fastNowTimeout.refresh();
    } else {
      clearTimeout(fastNowTimeout);
      fastNowTimeout = setTimeout(onTimeout, 1000);
      if (fastNowTimeout.unref) {
        fastNowTimeout.unref();
      }
    }
  };
  var fastNow = Date.now();
  var fastNowTimeout;
  var fastTimers = [];

  class Timeout {
    constructor(callback, delay, opaque) {
      this.callback = callback;
      this.delay = delay;
      this.opaque = opaque;
      this.state = -2;
      this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        fastTimers.push(this);
        if (!fastNowTimeout || fastTimers.length === 1) {
          refreshTimeout();
        }
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  module.exports = {
    setTimeout(callback, delay, opaque) {
      return delay < 1000 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
    },
    clearTimeout(timeout) {
      if (timeout instanceof Timeout) {
        timeout.clear();
      } else {
        clearTimeout(timeout);
      }
    }
  };
});

// node_modules/busboy/lib/utils.js
var require_utils = __commonJS((exports, module) => {
  var parseContentType = function(str) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (code !== 47 || i === 0)
          return;
        break;
      }
    }
    if (i === str.length)
      return;
    const type = str.slice(0, i).toLowerCase();
    const subtypeStart = ++i;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (i === subtypeStart)
          return;
        if (parseContentTypeParams(str, i, params) === undefined)
          return;
        break;
      }
    }
    if (i === subtypeStart)
      return;
    const subtype = str.slice(subtypeStart, i).toLowerCase();
    return { type, subtype, params };
  };
  var parseContentTypeParams = function(str, i, params) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code !== 61)
            return;
          break;
        }
      }
      if (i === str.length)
        return;
      name = str.slice(nameStart, i);
      ++i;
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      if (str.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value += str.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value += str.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code] !== 1)
            return;
        }
        if (i === str.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (TOKEN[code] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value = str.slice(valueStart, i);
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var parseDisposition = function(str, defDecoder) {
    if (str.length === 0)
      return;
    const params = Object.create(null);
    let i = 0;
    for (;i < str.length; ++i) {
      const code = str.charCodeAt(i);
      if (TOKEN[code] !== 1) {
        if (parseDispositionParams(str, i, params, defDecoder) === undefined)
          return;
        break;
      }
    }
    const type = str.slice(0, i).toLowerCase();
    return { type, params };
  };
  var parseDispositionParams = function(str, i, params, defDecoder) {
    while (i < str.length) {
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        break;
      if (str.charCodeAt(i++) !== 59)
        return;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (code !== 32 && code !== 9)
          break;
      }
      if (i === str.length)
        return;
      let name;
      const nameStart = i;
      for (;i < str.length; ++i) {
        const code = str.charCodeAt(i);
        if (TOKEN[code] !== 1) {
          if (code === 61)
            break;
          return;
        }
      }
      if (i === str.length)
        return;
      let value = "";
      let valueStart;
      let charset;
      name = str.slice(nameStart, i);
      if (name.charCodeAt(name.length - 1) === 42) {
        const charsetStart = ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (CHARSET[code] !== 1) {
            if (code !== 39)
              return;
            break;
          }
        }
        if (i === str.length)
          return;
        charset = str.slice(charsetStart, i);
        ++i;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (code === 39)
            break;
        }
        if (i === str.length)
          return;
        ++i;
        if (i === str.length)
          return;
        valueStart = i;
        let encode = 0;
        for (;i < str.length; ++i) {
          const code = str.charCodeAt(i);
          if (EXTENDED_VALUE[code] !== 1) {
            if (code === 37) {
              let hexUpper;
              let hexLower;
              if (i + 2 < str.length && (hexUpper = HEX_VALUES[str.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES[str.charCodeAt(i + 2)]) !== -1) {
                const byteVal = (hexUpper << 4) + hexLower;
                value += str.slice(valueStart, i);
                value += String.fromCharCode(byteVal);
                i += 2;
                valueStart = i + 1;
                if (byteVal >= 128)
                  encode = 2;
                else if (encode === 0)
                  encode = 1;
                continue;
              }
              return;
            }
            break;
          }
        }
        value += str.slice(valueStart, i);
        value = convertToUTF8(value, charset, encode);
        if (value === undefined)
          return;
      } else {
        ++i;
        if (i === str.length)
          return;
        if (str.charCodeAt(i) === 34) {
          valueStart = ++i;
          let escaping = false;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (code === 92) {
              if (escaping) {
                valueStart = i;
                escaping = false;
              } else {
                value += str.slice(valueStart, i);
                escaping = true;
              }
              continue;
            }
            if (code === 34) {
              if (escaping) {
                valueStart = i;
                escaping = false;
                continue;
              }
              value += str.slice(valueStart, i);
              break;
            }
            if (escaping) {
              valueStart = i - 1;
              escaping = false;
            }
            if (QDTEXT[code] !== 1)
              return;
          }
          if (i === str.length)
            return;
          ++i;
        } else {
          valueStart = i;
          for (;i < str.length; ++i) {
            const code = str.charCodeAt(i);
            if (TOKEN[code] !== 1) {
              if (i === valueStart)
                return;
              break;
            }
          }
          value = str.slice(valueStart, i);
        }
        value = defDecoder(value, 2);
        if (value === undefined)
          return;
      }
      name = name.toLowerCase();
      if (params[name] === undefined)
        params[name] = value;
    }
    return params;
  };
  var getDecoder = function(charset) {
    let lc;
    while (true) {
      switch (charset) {
        case "utf-8":
        case "utf8":
          return decoders.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return decoders.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return decoders.utf16le;
        case "base64":
          return decoders.base64;
        default:
          if (lc === undefined) {
            lc = true;
            charset = charset.toLowerCase();
            continue;
          }
          return decoders.other.bind(charset);
      }
    }
  };
  var convertToUTF8 = function(data, charset, hint) {
    const decode = getDecoder(charset);
    if (decode)
      return decode(data, hint);
  };
  var basename = function(path) {
    if (typeof path !== "string")
      return "";
    for (let i = path.length - 1;i >= 0; --i) {
      switch (path.charCodeAt(i)) {
        case 47:
        case 92:
          path = path.slice(i + 1);
          return path === ".." || path === "." ? "" : path;
      }
    }
    return path === ".." || path === "." ? "" : path;
  };
  var decoders = {
    utf8: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string") {
        if (hint < 2)
          return data;
        data = Buffer.from(data, "latin1");
      }
      return data.utf8Slice(0, data.length);
    },
    latin1: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        return data;
      return data.latin1Slice(0, data.length);
    },
    utf16le: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.ucs2Slice(0, data.length);
    },
    base64: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      return data.base64Slice(0, data.length);
    },
    other: (data, hint) => {
      if (data.length === 0)
        return "";
      if (typeof data === "string")
        data = Buffer.from(data, "latin1");
      try {
        const decoder = new TextDecoder(exports);
        return decoder.decode(data);
      } catch {
      }
    }
  };
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var QDTEXT = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  var CHARSET = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var EXTENDED_VALUE = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  };
});

// node_modules/streamsearch/lib/sbmh.js
var require_sbmh = __commonJS((exports, module) => {
  var memcmp = function(buf1, pos1, buf2, pos2, num) {
    for (let i = 0;i < num; ++i) {
      if (buf1[pos1 + i] !== buf2[pos2 + i])
        return false;
    }
    return true;
  };
  var feed = function(self2, data) {
    const len = data.length;
    const needle = self2._needle;
    const needleLen = needle.length;
    let pos = -self2._lookbehindSize;
    const lastNeedleCharPos = needleLen - 1;
    const lastNeedleChar = needle[lastNeedleCharPos];
    const end = len - needleLen;
    const occ = self2._occ;
    const lookbehind = self2._lookbehind;
    if (pos < 0) {
      while (pos < 0 && pos <= end) {
        const nextPos = pos + lastNeedleCharPos;
        const ch = nextPos < 0 ? lookbehind[self2._lookbehindSize + nextPos] : data[nextPos];
        if (ch === lastNeedleChar && matchNeedle(self2, data, pos, lastNeedleCharPos)) {
          self2._lookbehindSize = 0;
          ++self2.matches;
          if (pos > -self2._lookbehindSize)
            self2._cb(true, lookbehind, 0, self2._lookbehindSize + pos, false);
          else
            self2._cb(true, undefined, 0, 0, true);
          return self2._bufPos = pos + needleLen;
        }
        pos += occ[ch];
      }
      while (pos < 0 && !matchNeedle(self2, data, pos, len - pos))
        ++pos;
      if (pos < 0) {
        const bytesToCutOff = self2._lookbehindSize + pos;
        if (bytesToCutOff > 0) {
          self2._cb(false, lookbehind, 0, bytesToCutOff, false);
        }
        self2._lookbehindSize -= bytesToCutOff;
        lookbehind.copy(lookbehind, 0, bytesToCutOff, self2._lookbehindSize);
        lookbehind.set(data, self2._lookbehindSize);
        self2._lookbehindSize += len;
        self2._bufPos = len;
        return len;
      }
      self2._cb(false, lookbehind, 0, self2._lookbehindSize, false);
      self2._lookbehindSize = 0;
    }
    pos += self2._bufPos;
    const firstNeedleChar = needle[0];
    while (pos <= end) {
      const ch = data[pos + lastNeedleCharPos];
      if (ch === lastNeedleChar && data[pos] === firstNeedleChar && memcmp(needle, 0, data, pos, lastNeedleCharPos)) {
        ++self2.matches;
        if (pos > 0)
          self2._cb(true, data, self2._bufPos, pos, true);
        else
          self2._cb(true, undefined, 0, 0, true);
        return self2._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < len) {
      if (data[pos] !== firstNeedleChar || !memcmp(data, pos, needle, 0, len - pos)) {
        ++pos;
        continue;
      }
      data.copy(lookbehind, 0, pos, len);
      self2._lookbehindSize = len - pos;
      break;
    }
    if (pos > 0)
      self2._cb(false, data, self2._bufPos, pos < len ? pos : len, true);
    self2._bufPos = len;
    return len;
  };
  var matchNeedle = function(self2, data, pos, len) {
    const lb = self2._lookbehind;
    const lbSize = self2._lookbehindSize;
    const needle = self2._needle;
    for (let i = 0;i < len; ++i, ++pos) {
      const ch = pos < 0 ? lb[lbSize + pos] : data[pos];
      if (ch !== needle[i])
        return false;
    }
    return true;
  };

  class SBMH {
    constructor(needle, cb) {
      if (typeof cb !== "function")
        throw new Error("Missing match callback");
      if (typeof needle === "string")
        needle = Buffer.from(needle);
      else if (!Buffer.isBuffer(needle))
        throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
      const needleLen = needle.length;
      this.maxMatches = Infinity;
      this.matches = 0;
      this._cb = cb;
      this._lookbehindSize = 0;
      this._needle = needle;
      this._bufPos = 0;
      this._lookbehind = Buffer.allocUnsafe(needleLen);
      this._occ = [
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen,
        needleLen
      ];
      if (needleLen > 1) {
        for (let i = 0;i < needleLen - 1; ++i)
          this._occ[needle[i]] = needleLen - 1 - i;
      }
    }
    reset() {
      this.matches = 0;
      this._lookbehindSize = 0;
      this._bufPos = 0;
    }
    push(chunk, pos) {
      let result;
      if (!Buffer.isBuffer(chunk))
        chunk = Buffer.from(chunk, "latin1");
      const chunkLen = chunk.length;
      this._bufPos = pos || 0;
      while (result !== chunkLen && this.matches < this.maxMatches)
        result = feed(this, chunk);
      return result;
    }
    destroy() {
      const lbSize = this._lookbehindSize;
      if (lbSize)
        this._cb(false, this._lookbehind, 0, lbSize, false);
      this.reset();
    }
  }
  module.exports = SBMH;
});

// node_modules/busboy/lib/types/multipart.js
var require_multipart = __commonJS((exports, module) => {
  var noop = function() {
  };
  var callAndUnsetCb = function(self2, err) {
    const cb = self2._writecb;
    self2._writecb = null;
    if (err)
      self2.destroy(err);
    else if (cb)
      cb();
  };
  var nullDecoder = function(val, hint) {
    return val;
  };
  var finalcb = function(self2, cb, err) {
    if (err)
      return cb(err);
    err = checkEndState(self2);
    cb(err);
  };
  var checkEndState = function(self2) {
    if (self2._hparser)
      return new Error("Malformed part header");
    const fileStream = self2._fileStream;
    if (fileStream) {
      self2._fileStream = null;
      fileStream.destroy(new Error("Unexpected end of file"));
    }
    if (!self2._complete)
      return new Error("Unexpected end of form");
  };
  var { Readable, Writable } = __require("stream");
  var StreamSearch = require_sbmh();
  var {
    basename,
    convertToUTF8,
    getDecoder,
    parseContentType,
    parseDisposition
  } = require_utils();
  var BUF_CRLF = Buffer.from("\r\n");
  var BUF_CR = Buffer.from("\r");
  var BUF_DASH = Buffer.from("-");
  var MAX_HEADER_PAIRS = 2000;
  var MAX_HEADER_SIZE = 16 * 1024;
  var HPARSER_NAME = 0;
  var HPARSER_PRE_OWS = 1;
  var HPARSER_VALUE = 2;

  class HeaderParser {
    constructor(cb) {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
      this.cb = cb;
    }
    reset() {
      this.header = Object.create(null);
      this.pairCount = 0;
      this.byteCount = 0;
      this.state = HPARSER_NAME;
      this.name = "";
      this.value = "";
      this.crlf = 0;
    }
    push(chunk, pos, end) {
      let start = pos;
      while (pos < end) {
        switch (this.state) {
          case HPARSER_NAME: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (TOKEN[code] !== 1) {
                if (code !== 58)
                  return -1;
                this.name += chunk.latin1Slice(start, pos);
                if (this.name.length === 0)
                  return -1;
                ++pos;
                done = true;
                this.state = HPARSER_PRE_OWS;
                break;
              }
            }
            if (!done) {
              this.name += chunk.latin1Slice(start, pos);
              break;
            }
          }
          case HPARSER_PRE_OWS: {
            let done = false;
            for (;pos < end; ++pos) {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code = chunk[pos];
              if (code !== 32 && code !== 9) {
                start = pos;
                done = true;
                this.state = HPARSER_VALUE;
                break;
              }
            }
            if (!done)
              break;
          }
          case HPARSER_VALUE:
            switch (this.crlf) {
              case 0:
                for (;pos < end; ++pos) {
                  if (this.byteCount === MAX_HEADER_SIZE)
                    return -1;
                  ++this.byteCount;
                  const code = chunk[pos];
                  if (FIELD_VCHAR[code] !== 1) {
                    if (code !== 13)
                      return -1;
                    ++this.crlf;
                    break;
                  }
                }
                this.value += chunk.latin1Slice(start, pos++);
                break;
              case 1:
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                ++this.crlf;
                break;
              case 2: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code = chunk[pos];
                if (code === 32 || code === 9) {
                  start = pos;
                  this.crlf = 0;
                } else {
                  if (++this.pairCount < MAX_HEADER_PAIRS) {
                    this.name = this.name.toLowerCase();
                    if (this.header[this.name] === undefined)
                      this.header[this.name] = [this.value];
                    else
                      this.header[this.name].push(this.value);
                  }
                  if (code === 13) {
                    ++this.crlf;
                    ++pos;
                  } else {
                    start = pos;
                    this.crlf = 0;
                    this.state = HPARSER_NAME;
                    this.name = "";
                    this.value = "";
                  }
                }
                break;
              }
              case 3: {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                if (chunk[pos++] !== 10)
                  return -1;
                const header = this.header;
                this.reset();
                this.cb(header);
                return pos;
              }
            }
            break;
        }
      }
      return pos;
    }
  }

  class FileStream extends Readable {
    constructor(opts, owner) {
      super(opts);
      this.truncated = false;
      this._readcb = null;
      this.once("end", () => {
        this._read();
        if (--owner._fileEndsLeft === 0 && owner._finalcb) {
          const cb = owner._finalcb;
          owner._finalcb = null;
          process.nextTick(cb);
        }
      });
    }
    _read(n) {
      const cb = this._readcb;
      if (cb) {
        this._readcb = null;
        cb();
      }
    }
  }
  var ignoreData = {
    push: (chunk, pos) => {
    },
    destroy: () => {
    }
  };

  class Multipart extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
        throw new Error("Multipart: Boundary not found");
      const boundary = cfg.conType.params.boundary;
      const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder(cfg.defParamCharset) : nullDecoder;
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : undefined
      };
      const limits = cfg.limits;
      const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
      const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
      const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
      let parts = -1;
      let fields = 0;
      let files = 0;
      let skipPart = false;
      this._fileEndsLeft = 0;
      this._fileStream = undefined;
      this._complete = false;
      let fileSize = 0;
      let field;
      let fieldSize = 0;
      let partCharset;
      let partEncoding;
      let partType;
      let partName;
      let partTruncated = false;
      let hitFilesLimit = false;
      let hitFieldsLimit = false;
      this._hparser = null;
      const hparser = new HeaderParser((header) => {
        this._hparser = null;
        skipPart = false;
        partType = "text/plain";
        partCharset = defCharset;
        partEncoding = "7bit";
        partName = undefined;
        partTruncated = false;
        let filename;
        if (!header["content-disposition"]) {
          skipPart = true;
          return;
        }
        const disp = parseDisposition(header["content-disposition"][0], paramDecoder);
        if (!disp || disp.type !== "form-data") {
          skipPart = true;
          return;
        }
        if (disp.params) {
          if (disp.params.name)
            partName = disp.params.name;
          if (disp.params["filename*"])
            filename = disp.params["filename*"];
          else if (disp.params.filename)
            filename = disp.params.filename;
          if (filename !== undefined && !preservePath)
            filename = basename(filename);
        }
        if (header["content-type"]) {
          const conType = parseContentType(header["content-type"][0]);
          if (conType) {
            partType = `${conType.type}/${conType.subtype}`;
            if (conType.params && typeof conType.params.charset === "string")
              partCharset = conType.params.charset.toLowerCase();
          }
        }
        if (header["content-transfer-encoding"])
          partEncoding = header["content-transfer-encoding"][0].toLowerCase();
        if (partType === "application/octet-stream" || filename !== undefined) {
          if (files === filesLimit) {
            if (!hitFilesLimit) {
              hitFilesLimit = true;
              this.emit("filesLimit");
            }
            skipPart = true;
            return;
          }
          ++files;
          if (this.listenerCount("file") === 0) {
            skipPart = true;
            return;
          }
          fileSize = 0;
          this._fileStream = new FileStream(fileOpts, this);
          ++this._fileEndsLeft;
          this.emit("file", partName, this._fileStream, {
            filename,
            encoding: partEncoding,
            mimeType: partType
          });
        } else {
          if (fields === fieldsLimit) {
            if (!hitFieldsLimit) {
              hitFieldsLimit = true;
              this.emit("fieldsLimit");
            }
            skipPart = true;
            return;
          }
          ++fields;
          if (this.listenerCount("field") === 0) {
            skipPart = true;
            return;
          }
          field = [];
          fieldSize = 0;
        }
      });
      let matchPostBoundary = 0;
      const ssCb = (isMatch, data, start, end, isDataSafe) => {
        retrydata:
          while (data) {
            if (this._hparser !== null) {
              const ret = this._hparser.push(data, start, end);
              if (ret === -1) {
                this._hparser = null;
                hparser.reset();
                this.emit("error", new Error("Malformed part header"));
                break;
              }
              start = ret;
            }
            if (start === end)
              break;
            if (matchPostBoundary !== 0) {
              if (matchPostBoundary === 1) {
                switch (data[start]) {
                  case 45:
                    matchPostBoundary = 2;
                    ++start;
                    break;
                  case 13:
                    matchPostBoundary = 3;
                    ++start;
                    break;
                  default:
                    matchPostBoundary = 0;
                }
                if (start === end)
                  return;
              }
              if (matchPostBoundary === 2) {
                matchPostBoundary = 0;
                if (data[start] === 45) {
                  this._complete = true;
                  this._bparser = ignoreData;
                  return;
                }
                const writecb = this._writecb;
                this._writecb = noop;
                ssCb(false, BUF_DASH, 0, 1, false);
                this._writecb = writecb;
              } else if (matchPostBoundary === 3) {
                matchPostBoundary = 0;
                if (data[start] === 10) {
                  ++start;
                  if (parts >= partsLimit)
                    break;
                  this._hparser = hparser;
                  if (start === end)
                    break;
                  continue retrydata;
                } else {
                  const writecb = this._writecb;
                  this._writecb = noop;
                  ssCb(false, BUF_CR, 0, 1, false);
                  this._writecb = writecb;
                }
              }
            }
            if (!skipPart) {
              if (this._fileStream) {
                let chunk;
                const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fileSize += chunk.length;
                if (fileSize === fileSizeLimit) {
                  if (chunk.length > 0)
                    this._fileStream.push(chunk);
                  this._fileStream.emit("limit");
                  this._fileStream.truncated = true;
                  skipPart = true;
                } else if (!this._fileStream.push(chunk)) {
                  if (this._writecb)
                    this._fileStream._readcb = this._writecb;
                  this._writecb = null;
                }
              } else if (field !== undefined) {
                let chunk;
                const actualLen = Math.min(end - start, fieldSizeLimit - fieldSize);
                if (!isDataSafe) {
                  chunk = Buffer.allocUnsafe(actualLen);
                  data.copy(chunk, 0, start, start + actualLen);
                } else {
                  chunk = data.slice(start, start + actualLen);
                }
                fieldSize += actualLen;
                field.push(chunk);
                if (fieldSize === fieldSizeLimit) {
                  skipPart = true;
                  partTruncated = true;
                }
              }
            }
            break;
          }
        if (isMatch) {
          matchPostBoundary = 1;
          if (this._fileStream) {
            this._fileStream.push(null);
            this._fileStream = null;
          } else if (field !== undefined) {
            let data2;
            switch (field.length) {
              case 0:
                data2 = "";
                break;
              case 1:
                data2 = convertToUTF8(field[0], partCharset, 0);
                break;
              default:
                data2 = convertToUTF8(Buffer.concat(field, fieldSize), partCharset, 0);
            }
            field = undefined;
            fieldSize = 0;
            this.emit("field", partName, data2, {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            });
          }
          if (++parts === partsLimit)
            this.emit("partsLimit");
        }
      };
      this._bparser = new StreamSearch(`\r\n--${boundary}`, ssCb);
      this._writecb = null;
      this._finalcb = null;
      this.write(BUF_CRLF);
    }
    static detect(conType) {
      return conType.type === "multipart" && conType.subtype === "form-data";
    }
    _write(chunk, enc, cb) {
      this._writecb = cb;
      this._bparser.push(chunk, 0);
      if (this._writecb)
        callAndUnsetCb(this);
    }
    _destroy(err, cb) {
      this._hparser = null;
      this._bparser = ignoreData;
      if (!err)
        err = checkEndState(this);
      const fileStream = this._fileStream;
      if (fileStream) {
        this._fileStream = null;
        fileStream.destroy(err);
      }
      cb(err);
    }
    _final(cb) {
      this._bparser.destroy();
      if (!this._complete)
        return cb(new Error("Unexpected end of form"));
      if (this._fileEndsLeft)
        this._finalcb = finalcb.bind(null, this, cb);
      else
        finalcb(this, cb);
    }
  }
  var TOKEN = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  var FIELD_VCHAR = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1
  ];
  module.exports = Multipart;
});

// node_modules/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS((exports, module) => {
  var readPctEnc = function(self2, chunk, pos, len) {
    if (pos >= len)
      return len;
    if (self2._byte === -1) {
      const hexUpper = HEX_VALUES[chunk[pos++]];
      if (hexUpper === -1)
        return -1;
      if (hexUpper >= 8)
        self2._encode = 2;
      if (pos < len) {
        const hexLower = HEX_VALUES[chunk[pos++]];
        if (hexLower === -1)
          return -1;
        if (self2._inKey)
          self2._key += String.fromCharCode((hexUpper << 4) + hexLower);
        else
          self2._val += String.fromCharCode((hexUpper << 4) + hexLower);
        self2._byte = -2;
        self2._lastPos = pos;
      } else {
        self2._byte = hexUpper;
      }
    } else {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self2._inKey)
        self2._key += String.fromCharCode((self2._byte << 4) + hexLower);
      else
        self2._val += String.fromCharCode((self2._byte << 4) + hexLower);
      self2._byte = -2;
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipKeyBytes = function(self2, chunk, pos, len) {
    if (self2._bytesKey > self2.fieldNameSizeLimit) {
      if (!self2._keyTrunc) {
        if (self2._lastPos < pos)
          self2._key += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._keyTrunc = true;
      for (;pos < len; ++pos) {
        const code = chunk[pos];
        if (code === 61 || code === 38)
          break;
        ++self2._bytesKey;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var skipValBytes = function(self2, chunk, pos, len) {
    if (self2._bytesVal > self2.fieldSizeLimit) {
      if (!self2._valTrunc) {
        if (self2._lastPos < pos)
          self2._val += chunk.latin1Slice(self2._lastPos, pos - 1);
      }
      self2._valTrunc = true;
      for (;pos < len; ++pos) {
        if (chunk[pos] === 38)
          break;
        ++self2._bytesVal;
      }
      self2._lastPos = pos;
    }
    return pos;
  };
  var { Writable } = __require("stream");
  var { getDecoder } = require_utils();

  class URLEncoded extends Writable {
    constructor(cfg) {
      const streamOpts = {
        autoDestroy: true,
        emitClose: true,
        highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : undefined
      };
      super(streamOpts);
      let charset = cfg.defCharset || "utf8";
      if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
        charset = cfg.conType.params.charset;
      this.charset = charset;
      const limits = cfg.limits;
      this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
      this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
      this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
      this._inKey = true;
      this._keyTrunc = false;
      this._valTrunc = false;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._fields = 0;
      this._key = "";
      this._val = "";
      this._byte = -2;
      this._lastPos = 0;
      this._encode = 0;
      this._decoder = getDecoder(charset);
    }
    static detect(conType) {
      return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
    }
    _write(chunk, enc, cb) {
      if (this._fields >= this.fieldsLimit)
        return cb();
      let i = 0;
      const len = chunk.length;
      this._lastPos = 0;
      if (this._byte !== -2) {
        i = readPctEnc(this, chunk, i, len);
        if (i === -1)
          return cb(new Error("Malformed urlencoded form"));
        if (i >= len)
          return cb();
        if (this._inKey)
          ++this._bytesKey;
        else
          ++this._bytesVal;
      }
      main:
        while (i < len) {
          if (this._inKey) {
            i = skipKeyBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 61:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  this._inKey = false;
                  continue main;
                case 38:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._key = this._decoder(this._key, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0) {
                    this.emit("field", this._key, "", {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue;
                case 43:
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._key += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._key += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesKey;
                  i = skipKeyBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesKey;
              i = skipKeyBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._key += chunk.latin1Slice(this._lastPos, i);
          } else {
            i = skipValBytes(this, chunk, i, len);
            while (i < len) {
              switch (chunk[i]) {
                case 38:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = ++i;
                  this._inKey = true;
                  this._val = this._decoder(this._val, this._encode);
                  this._encode = 0;
                  if (this._bytesKey > 0 || this._bytesVal > 0) {
                    this.emit("field", this._key, this._val, {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    });
                  }
                  this._key = "";
                  this._val = "";
                  this._keyTrunc = false;
                  this._valTrunc = false;
                  this._bytesKey = 0;
                  this._bytesVal = 0;
                  if (++this._fields >= this.fieldsLimit) {
                    this.emit("fieldsLimit");
                    return cb();
                  }
                  continue main;
                case 43:
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._val += " ";
                  this._lastPos = i + 1;
                  break;
                case 37:
                  if (this._encode === 0)
                    this._encode = 1;
                  if (this._lastPos < i)
                    this._val += chunk.latin1Slice(this._lastPos, i);
                  this._lastPos = i + 1;
                  this._byte = -1;
                  i = readPctEnc(this, chunk, i + 1, len);
                  if (i === -1)
                    return cb(new Error("Malformed urlencoded form"));
                  if (i >= len)
                    return cb();
                  ++this._bytesVal;
                  i = skipValBytes(this, chunk, i, len);
                  continue;
              }
              ++i;
              ++this._bytesVal;
              i = skipValBytes(this, chunk, i, len);
            }
            if (this._lastPos < i)
              this._val += chunk.latin1Slice(this._lastPos, i);
          }
        }
      cb();
    }
    _final(cb) {
      if (this._byte !== -2)
        return cb(new Error("Malformed urlencoded form"));
      if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
        if (this._inKey)
          this._key = this._decoder(this._key, this._encode);
        else
          this._val = this._decoder(this._val, this._encode);
        this.emit("field", this._key, this._val, {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        });
      }
      cb();
    }
  }
  var HEX_VALUES = [
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
  ];
  module.exports = URLEncoded;
});

// node_modules/busboy/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var getInstance = function(cfg) {
    const headers = cfg.headers;
    const conType = parseContentType(headers["content-type"]);
    if (!conType)
      throw new Error("Malformed content type");
    for (const type of TYPES) {
      const matched = type.detect(conType);
      if (!matched)
        continue;
      const instanceCfg = {
        limits: cfg.limits,
        headers,
        conType,
        highWaterMark: undefined,
        fileHwm: undefined,
        defCharset: undefined,
        defParamCharset: undefined,
        preservePath: false
      };
      if (cfg.highWaterMark)
        instanceCfg.highWaterMark = cfg.highWaterMark;
      if (cfg.fileHwm)
        instanceCfg.fileHwm = cfg.fileHwm;
      instanceCfg.defCharset = cfg.defCharset;
      instanceCfg.defParamCharset = cfg.defParamCharset;
      instanceCfg.preservePath = cfg.preservePath;
      return new type(instanceCfg);
    }
    throw new Error(`Unsupported content type: ${headers["content-type"]}`);
  };
  var { parseContentType } = require_utils();
  var TYPES = [
    require_multipart(),
    require_urlencoded()
  ].filter(function(typemod) {
    return typeof typemod.detect === "function";
  });
  module.exports = (cfg) => {
    if (typeof cfg !== "object" || cfg === null)
      cfg = {};
    if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
      throw new Error("Missing Content-Type");
    }
    return getInstance(cfg);
  };
});

// node_modules/undici/lib/fetch/constants.js
var require_constants = __commonJS((exports, module) => {
  var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
  var corsSafeListedMethods = ["GET", "HEAD", "POST"];
  var nullBodyStatus = [101, 204, 205, 304];
  var redirectStatus = [301, 302, 303, 307, 308];
  var badPorts = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ];
  var referrerPolicy = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ];
  var requestRedirect = ["follow", "manual", "error"];
  var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
  var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
  var requestCredentials = ["omit", "same-origin", "include"];
  var requestCache = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ];
  var requestBodyHeader = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    "content-length"
  ];
  var requestDuplex = [
    "half"
  ];
  var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
  var subresource = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ];
  var DOMException2 = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (err) {
      return Object.getPrototypeOf(err).constructor;
    }
  })();
  var channel;
  var structuredClone = globalThis.structuredClone ?? function structuredClone(value, options = undefined) {
    if (arguments.length === 0) {
      throw new TypeError("missing argument");
    }
    if (!channel) {
      channel = new MessageChannel;
    }
    channel.port1.unref();
    channel.port2.unref();
    channel.port1.postMessage(value, options?.transfer);
    return receiveMessageOnPort(channel.port2).message;
  };
  module.exports = {
    DOMException: DOMException2,
    structuredClone,
    subresource,
    forbiddenMethods,
    requestBodyHeader,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    redirectStatus,
    corsSafeListedMethods,
    nullBodyStatus,
    safeMethods,
    badPorts,
    requestDuplex
  };
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS((exports, module) => {
  var getGlobalOrigin = function() {
    return globalThis[globalOrigin];
  };
  var setGlobalOrigin = function(newOrigin) {
    if (newOrigin !== undefined && typeof newOrigin !== "string" && !(newOrigin instanceof URL)) {
      throw new Error("Invalid base url");
    }
    if (newOrigin === undefined) {
      Object.defineProperty(globalThis, globalOrigin, {
        value: undefined,
        writable: true,
        enumerable: false,
        configurable: false
      });
      return;
    }
    const parsedURL = new URL(newOrigin);
    if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
      throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
    }
    Object.defineProperty(globalThis, globalOrigin, {
      value: parsedURL,
      writable: true,
      enumerable: false,
      configurable: false
    });
  };
  var globalOrigin = Symbol.for("undici.globalOrigin.1");
  module.exports = {
    getGlobalOrigin,
    setGlobalOrigin
  };
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS((exports, module) => {
  var responseURL = function(response) {
    const urlList = response.urlList;
    const length = urlList.length;
    return length === 0 ? null : urlList[length - 1].toString();
  };
  var responseLocationURL = function(response, requestFragment) {
    if (!redirectStatus.includes(response.status)) {
      return null;
    }
    let location = response.headersList.get("location");
    if (location !== null && isValidHeaderValue(location)) {
      location = new URL(location, responseURL(response));
    }
    if (location && !location.hash) {
      location.hash = requestFragment;
    }
    return location;
  };
  var requestCurrentURL = function(request) {
    return request.urlList[request.urlList.length - 1];
  };
  var requestBadPort = function(request) {
    const url = requestCurrentURL(request);
    if (urlIsHttpHttpsScheme(url) && badPorts.includes(url.port)) {
      return "blocked";
    }
    return "allowed";
  };
  var isErrorLike = function(object) {
    return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
  };
  var isValidReasonPhrase = function(statusText) {
    for (let i = 0;i < statusText.length; ++i) {
      const c = statusText.charCodeAt(i);
      if (!(c === 9 || c >= 32 && c <= 126 || c >= 128 && c <= 255)) {
        return false;
      }
    }
    return true;
  };
  var isTokenChar = function(c) {
    return !(c >= 127 || c <= 32 || c === "(" || c === ")" || c === "<" || c === ">" || c === "@" || c === "," || c === ";" || c === ":" || c === "\\" || c === '"' || c === "/" || c === "[" || c === "]" || c === "?" || c === "=" || c === "{" || c === "}");
  };
  var isValidHTTPToken = function(characters) {
    if (!characters || typeof characters !== "string") {
      return false;
    }
    for (let i = 0;i < characters.length; ++i) {
      const c = characters.charCodeAt(i);
      if (c > 127 || !isTokenChar(c)) {
        return false;
      }
    }
    return true;
  };
  var isValidHeaderName = function(potentialValue) {
    if (potentialValue.length === 0) {
      return false;
    }
    return isValidHTTPToken(potentialValue);
  };
  var isValidHeaderValue = function(potentialValue) {
    if (potentialValue.startsWith("\t") || potentialValue.startsWith(" ") || potentialValue.endsWith("\t") || potentialValue.endsWith(" ")) {
      return false;
    }
    if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
      return false;
    }
    return true;
  };
  var setRequestReferrerPolicyOnRedirect = function(request, actualResponse) {
    const { headersList } = actualResponse;
    const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
    let policy = "";
    if (policyHeader.length > 0) {
      for (let i = policyHeader.length;i !== 0; i--) {
        const token = policyHeader[i - 1].trim();
        if (referrerPolicyTokens.includes(token)) {
          policy = token;
          break;
        }
      }
    }
    if (policy !== "") {
      request.referrerPolicy = policy;
    }
  };
  var crossOriginResourcePolicyCheck = function() {
    return "allowed";
  };
  var corsCheck = function() {
    return "success";
  };
  var TAOCheck = function() {
    return "success";
  };
  var appendFetchMetadata = function(httpRequest) {
    let header = null;
    header = httpRequest.mode;
    httpRequest.headersList.set("sec-fetch-mode", header);
  };
  var appendRequestOriginHeader = function(request) {
    let serializedOrigin = request.origin;
    if (request.responseTainting === "cors" || request.mode === "websocket") {
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    } else if (request.method !== "GET" && request.method !== "HEAD") {
      switch (request.referrerPolicy) {
        case "no-referrer":
          serializedOrigin = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        case "same-origin":
          if (!sameOrigin(request, requestCurrentURL(request))) {
            serializedOrigin = null;
          }
          break;
        default:
      }
      if (serializedOrigin) {
        request.headersList.append("origin", serializedOrigin);
      }
    }
  };
  var coarsenedSharedCurrentTime = function(crossOriginIsolatedCapability) {
    return performance2.now();
  };
  var createOpaqueTimingInfo = function(timingInfo) {
    return {
      startTime: timingInfo.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: timingInfo.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  };
  var makePolicyContainer = function() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  };
  var clonePolicyContainer = function(policyContainer) {
    return {
      referrerPolicy: policyContainer.referrerPolicy
    };
  };
  var determineRequestsReferrer = function(request) {
    const policy = request.referrerPolicy;
    assert(policy);
    let referrerSource = null;
    if (request.referrer === "client") {
      const globalOrigin = getGlobalOrigin();
      if (!globalOrigin || globalOrigin.origin === "null") {
        return "no-referrer";
      }
      referrerSource = new URL(globalOrigin);
    } else if (request.referrer instanceof URL) {
      referrerSource = request.referrer;
    }
    let referrerURL = stripURLForReferrer(referrerSource);
    const referrerOrigin = stripURLForReferrer(referrerSource, true);
    if (referrerURL.toString().length > 4096) {
      referrerURL = referrerOrigin;
    }
    const areSameOrigin = sameOrigin(request, referrerURL);
    const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
    switch (policy) {
      case "origin":
        return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
      case "unsafe-url":
        return referrerURL;
      case "same-origin":
        return areSameOrigin ? referrerOrigin : "no-referrer";
      case "origin-when-cross-origin":
        return areSameOrigin ? referrerURL : referrerOrigin;
      case "strict-origin-when-cross-origin": {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(referrerURL, currentURL)) {
          return referrerURL;
        }
        if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
          return "no-referrer";
        }
        return referrerOrigin;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
    }
  };
  var stripURLForReferrer = function(url, originOnly) {
    assert(url instanceof URL);
    if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
      return "no-referrer";
    }
    url.username = "";
    url.password = "";
    url.hash = "";
    if (originOnly) {
      url.pathname = "";
      url.search = "";
    }
    return url;
  };
  var isURLPotentiallyTrustworthy = function(url) {
    if (!(url instanceof URL)) {
      return false;
    }
    if (url.href === "about:blank" || url.href === "about:srcdoc") {
      return true;
    }
    if (url.protocol === "data:")
      return true;
    if (url.protocol === "file:")
      return true;
    return isOriginPotentiallyTrustworthy(url.origin);
    function isOriginPotentiallyTrustworthy(origin) {
      if (origin == null || origin === "null")
        return false;
      const originAsURL = new URL(origin);
      if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
        return true;
      }
      if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
        return true;
      }
      return false;
    }
  };
  var bytesMatch = function(bytes, metadataList) {
    if (crypto2 === undefined) {
      return true;
    }
    const parsedMetadata = parseMetadata(metadataList);
    if (parsedMetadata === "no metadata") {
      return true;
    }
    if (parsedMetadata.length === 0) {
      return true;
    }
    const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));
    const strongest = list[0].algo;
    const metadata = list.filter((item) => item.algo === strongest);
    for (const item of metadata) {
      const algorithm = item.algo;
      const expectedValue = item.hash;
      const actualValue = crypto2.createHash(algorithm).update(bytes).digest("base64");
      if (actualValue === expectedValue) {
        return true;
      }
    }
    return false;
  };
  var parseMetadata = function(metadata) {
    const result = [];
    let empty2 = true;
    const supportedHashes = crypto2.getHashes();
    for (const token of metadata.split(" ")) {
      empty2 = false;
      const parsedToken = parseHashWithOptions.exec(token);
      if (parsedToken === null || parsedToken.groups === undefined) {
        continue;
      }
      const algorithm = parsedToken.groups.algo;
      if (supportedHashes.includes(algorithm.toLowerCase())) {
        result.push(parsedToken.groups);
      }
    }
    if (empty2 === true) {
      return "no metadata";
    }
    return result;
  };
  var tryUpgradeRequestToAPotentiallyTrustworthyURL = function(request) {
  };
  var sameOrigin = function(A, B) {
    if (A.origin === B.origin && A.origin === "null") {
      return true;
    }
    if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
      return true;
    }
    return false;
  };
  var createDeferredPromise = function() {
    let res;
    let rej;
    const promise = new Promise((resolve, reject) => {
      res = resolve;
      rej = reject;
    });
    return { promise, resolve: res, reject: rej };
  };
  var isAborted = function(fetchParams) {
    return fetchParams.controller.state === "aborted";
  };
  var isCancelled = function(fetchParams) {
    return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
  };
  var normalizeMethod = function(method) {
    return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
  };
  var serializeJavascriptValueToJSONString = function(value) {
    const result = JSON.stringify(value);
    if (result === undefined) {
      throw new TypeError("Value is not JSON serializable");
    }
    assert(typeof result === "string");
    return result;
  };
  var makeIterator = function(iterator, name, kind) {
    const object = {
      index: 0,
      kind,
      target: iterator
    };
    const i = {
      next() {
        if (Object.getPrototypeOf(this) !== i) {
          throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);
        }
        const { index, kind: kind2, target } = object;
        const values = target();
        const len = values.length;
        if (index >= len) {
          return { value: undefined, done: true };
        }
        const pair = values[index];
        object.index = index + 1;
        return iteratorResult(pair, kind2);
      },
      [Symbol.toStringTag]: `${name} Iterator`
    };
    Object.setPrototypeOf(i, esIteratorPrototype);
    return Object.setPrototypeOf({}, i);
  };
  var iteratorResult = function(pair, kind) {
    let result;
    switch (kind) {
      case "key": {
        result = pair[0];
        break;
      }
      case "value": {
        result = pair[1];
        break;
      }
      case "key+value": {
        result = pair;
        break;
      }
    }
    return { value: result, done: false };
  };
  var fullyReadBody = function(body, processBody, processBodyError) {
    const successSteps = (bytes) => queueMicrotask(() => processBody(bytes));
    const errorSteps = (error) => queueMicrotask(() => processBodyError(error));
    let reader;
    try {
      reader = body.stream.getReader();
    } catch (e) {
      errorSteps(e);
      return;
    }
    readAllBytes(reader, successSteps, errorSteps);
  };
  var isReadableStreamLike = function(stream) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
  };
  var isomorphicDecode = function(input) {
    if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
      return String.fromCharCode(...input);
    }
    return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
  };
  var readableStreamClose = function(controller) {
    try {
      controller.close();
    } catch (err) {
      if (!err.message.includes("Controller is already closed")) {
        throw err;
      }
    }
  };
  var isomorphicEncode = function(input) {
    for (let i = 0;i < input.length; i++) {
      assert(input.charCodeAt(i) <= 255);
    }
    return input;
  };
  async function readAllBytes(reader, successSteps, failureSteps) {
    const bytes = [];
    let byteLength = 0;
    while (true) {
      let done;
      let chunk;
      try {
        ({ done, value: chunk } = await reader.read());
      } catch (e) {
        failureSteps(e);
        return;
      }
      if (done) {
        successSteps(Buffer.concat(bytes, byteLength));
        return;
      }
      if (!isUint8Array(chunk)) {
        failureSteps(new TypeError("Received non-Uint8Array chunk"));
        return;
      }
      bytes.push(chunk);
      byteLength += chunk.length;
    }
  }
  var urlIsLocal = function(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "about:" || protocol === "blob:" || protocol === "data:";
  };
  var urlHasHttpsScheme = function(url) {
    if (typeof url === "string") {
      return url.startsWith("https:");
    }
    return url.protocol === "https:";
  };
  var urlIsHttpHttpsScheme = function(url) {
    assert("protocol" in url);
    const protocol = url.protocol;
    return protocol === "http:" || protocol === "https:";
  };
  var { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = require_constants();
  var { getGlobalOrigin } = require_global();
  var { performance: performance2 } = __require("perf_hooks");
  var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
  var assert = __require("assert");
  var { isUint8Array } = __require("util/types");
  var crypto2;
  try {
    crypto2 = __require("crypto");
  } catch {
  }
  var parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\x21-\x7e]?)?/i;
  var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  var ReadableStream = globalThis.ReadableStream;
  var MAXIMUM_ARGUMENT_LENGTH = 65535;
  var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
  module.exports = {
    isAborted,
    isCancelled,
    createDeferredPromise,
    ReadableStreamFrom,
    toUSVString,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    coarsenedSharedCurrentTime,
    determineRequestsReferrer,
    makePolicyContainer,
    clonePolicyContainer,
    appendFetchMetadata,
    appendRequestOriginHeader,
    TAOCheck,
    corsCheck,
    crossOriginResourcePolicyCheck,
    createOpaqueTimingInfo,
    setRequestReferrerPolicyOnRedirect,
    isValidHTTPToken,
    requestBadPort,
    requestCurrentURL,
    responseURL,
    responseLocationURL,
    isBlobLike,
    isURLPotentiallyTrustworthy,
    isValidReasonPhrase,
    sameOrigin,
    normalizeMethod,
    serializeJavascriptValueToJSONString,
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue,
    hasOwn,
    isErrorLike,
    fullyReadBody,
    bytesMatch,
    isReadableStreamLike,
    readableStreamClose,
    isomorphicEncode,
    isomorphicDecode,
    urlIsLocal,
    urlHasHttpsScheme,
    urlIsHttpHttpsScheme,
    readAllBytes
  };
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS((exports, module) => {
  module.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  };
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS((exports, module) => {
  var { types } = __require("util");
  var { hasOwn, toUSVString } = require_util2();
  var webidl = {};
  webidl.converters = {};
  webidl.util = {};
  webidl.errors = {};
  webidl.errors.exception = function(message) {
    return new TypeError(`${message.header}: ${message.message}`);
  };
  webidl.errors.conversionFailed = function(context) {
    const plural = context.types.length === 1 ? "" : " one of";
    const message = `${context.argument} could not be converted to` + `${plural}: ${context.types.join(", ")}.`;
    return webidl.errors.exception({
      header: context.prefix,
      message
    });
  };
  webidl.errors.invalidArgument = function(context) {
    return webidl.errors.exception({
      header: context.prefix,
      message: `"${context.value}" is an invalid ${context.type}.`
    });
  };
  webidl.brandCheck = function(V, I, opts = undefined) {
    if (opts?.strict !== false && !(V instanceof I)) {
      throw new TypeError("Illegal invocation");
    } else {
      return V?.[Symbol.toStringTag] === I.prototype[Symbol.toStringTag];
    }
  };
  webidl.argumentLengthCheck = function({ length }, min, ctx) {
    if (length < min) {
      throw webidl.errors.exception({
        message: `${min} argument${min !== 1 ? "s" : ""} required, ` + `but${length ? " only" : ""} ${length} found.`,
        ...ctx
      });
    }
  };
  webidl.illegalConstructor = function() {
    throw webidl.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  };
  webidl.util.Type = function(V) {
    switch (typeof V) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (V === null) {
          return "Null";
        }
        return "Object";
      }
    }
  };
  webidl.util.ConvertToInt = function(V, bitLength, signedness, opts = {}) {
    let upperBound;
    let lowerBound;
    if (bitLength === 64) {
      upperBound = Math.pow(2, 53) - 1;
      if (signedness === "unsigned") {
        lowerBound = 0;
      } else {
        lowerBound = Math.pow(-2, 53) + 1;
      }
    } else if (signedness === "unsigned") {
      lowerBound = 0;
      upperBound = Math.pow(2, bitLength) - 1;
    } else {
      lowerBound = Math.pow(-2, bitLength) - 1;
      upperBound = Math.pow(2, bitLength - 1) - 1;
    }
    let x = Number(V);
    if (x === 0) {
      x = 0;
    }
    if (opts.enforceRange === true) {
      if (Number.isNaN(x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${V} to an integer.`
        });
      }
      x = webidl.util.IntegerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw webidl.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
        });
      }
      return x;
    }
    if (!Number.isNaN(x) && opts.clamp === true) {
      x = Math.min(Math.max(x, lowerBound), upperBound);
      if (Math.floor(x) % 2 === 0) {
        x = Math.floor(x);
      } else {
        x = Math.ceil(x);
      }
      return x;
    }
    if (Number.isNaN(x) || x === 0 && Object.is(0, x) || x === Number.POSITIVE_INFINITY || x === Number.NEGATIVE_INFINITY) {
      return 0;
    }
    x = webidl.util.IntegerPart(x);
    x = x % Math.pow(2, bitLength);
    if (signedness === "signed" && x >= Math.pow(2, bitLength) - 1) {
      return x - Math.pow(2, bitLength);
    }
    return x;
  };
  webidl.util.IntegerPart = function(n) {
    const r = Math.floor(Math.abs(n));
    if (n < 0) {
      return -1 * r;
    }
    return r;
  };
  webidl.sequenceConverter = function(converter) {
    return (V) => {
      if (webidl.util.Type(V) !== "Object") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: `Value of type ${webidl.util.Type(V)} is not an Object.`
        });
      }
      const method = V?.[Symbol.iterator]?.();
      const seq = [];
      if (method === undefined || typeof method.next !== "function") {
        throw webidl.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      }
      while (true) {
        const { done, value } = method.next();
        if (done) {
          break;
        }
        seq.push(converter(value));
      }
      return seq;
    };
  };
  webidl.recordConverter = function(keyConverter, valueConverter) {
    return (O) => {
      if (webidl.util.Type(O) !== "Object") {
        throw webidl.errors.exception({
          header: "Record",
          message: `Value of type ${webidl.util.Type(O)} is not an Object.`
        });
      }
      const result = {};
      if (!types.isProxy(O)) {
        const keys2 = Object.keys(O);
        for (const key of keys2) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
        return result;
      }
      const keys = Reflect.ownKeys(O);
      for (const key of keys) {
        const desc = Reflect.getOwnPropertyDescriptor(O, key);
        if (desc?.enumerable) {
          const typedKey = keyConverter(key);
          const typedValue = valueConverter(O[key]);
          result[typedKey] = typedValue;
        }
      }
      return result;
    };
  };
  webidl.interfaceConverter = function(i) {
    return (V, opts = {}) => {
      if (opts.strict !== false && !(V instanceof i)) {
        throw webidl.errors.exception({
          header: i.name,
          message: `Expected ${V} to be an instance of ${i.name}.`
        });
      }
      return V;
    };
  };
  webidl.dictionaryConverter = function(converters) {
    return (dictionary) => {
      const type = webidl.util.Type(dictionary);
      const dict = {};
      if (type === "Null" || type === "Undefined") {
        return dict;
      } else if (type !== "Object") {
        throw webidl.errors.exception({
          header: "Dictionary",
          message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
        });
      }
      for (const options of converters) {
        const { key, defaultValue, required, converter } = options;
        if (required === true) {
          if (!hasOwn(dictionary, key)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${key}".`
            });
          }
        }
        let value = dictionary[key];
        const hasDefault = hasOwn(options, "defaultValue");
        if (hasDefault && value !== null) {
          value = value ?? defaultValue;
        }
        if (required || hasDefault || value !== undefined) {
          value = converter(value);
          if (options.allowedValues && !options.allowedValues.includes(value)) {
            throw webidl.errors.exception({
              header: "Dictionary",
              message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
            });
          }
          dict[key] = value;
        }
      }
      return dict;
    };
  };
  webidl.nullableConverter = function(converter) {
    return (V) => {
      if (V === null) {
        return V;
      }
      return converter(V);
    };
  };
  webidl.converters.DOMString = function(V, opts = {}) {
    if (V === null && opts.legacyNullToEmptyString) {
      return "";
    }
    if (typeof V === "symbol") {
      throw new TypeError("Could not convert argument of type symbol to string.");
    }
    return String(V);
  };
  webidl.converters.ByteString = function(V) {
    const x = webidl.converters.DOMString(V);
    for (let index = 0;index < x.length; index++) {
      const charCode = x.charCodeAt(index);
      if (charCode > 255) {
        throw new TypeError("Cannot convert argument to a ByteString because the character at " + `index ${index} has a value of ${charCode} which is greater than 255.`);
      }
    }
    return x;
  };
  webidl.converters.USVString = toUSVString;
  webidl.converters.boolean = function(V) {
    const x = Boolean(V);
    return x;
  };
  webidl.converters.any = function(V) {
    return V;
  };
  webidl.converters["long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "signed");
    return x;
  };
  webidl.converters["unsigned long long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 64, "unsigned");
    return x;
  };
  webidl.converters["unsigned long"] = function(V) {
    const x = webidl.util.ConvertToInt(V, 32, "unsigned");
    return x;
  };
  webidl.converters["unsigned short"] = function(V, opts) {
    const x = webidl.util.ConvertToInt(V, 16, "unsigned", opts);
    return x;
  };
  webidl.converters.ArrayBuffer = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isAnyArrayBuffer(V)) {
      throw webidl.errors.conversionFailed({
        prefix: `${V}`,
        argument: `${V}`,
        types: ["ArrayBuffer"]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.TypedArray = function(V, T, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isTypedArray(V) || V.constructor.name !== T.name) {
      throw webidl.errors.conversionFailed({
        prefix: `${T.name}`,
        argument: `${V}`,
        types: [T.name]
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.DataView = function(V, opts = {}) {
    if (webidl.util.Type(V) !== "Object" || !types.isDataView(V)) {
      throw webidl.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    }
    if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
      throw webidl.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    }
    return V;
  };
  webidl.converters.BufferSource = function(V, opts = {}) {
    if (types.isAnyArrayBuffer(V)) {
      return webidl.converters.ArrayBuffer(V, opts);
    }
    if (types.isTypedArray(V)) {
      return webidl.converters.TypedArray(V, V.constructor);
    }
    if (types.isDataView(V)) {
      return webidl.converters.DataView(V, opts);
    }
    throw new TypeError(`Could not convert ${V} to a BufferSource.`);
  };
  webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(webidl.converters.ByteString);
  webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(webidl.converters["sequence<ByteString>"]);
  webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(webidl.converters.ByteString, webidl.converters.ByteString);
  module.exports = {
    webidl
  };
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS((exports, module) => {
  var dataURLProcessor = function(dataURL) {
    assert(dataURL.protocol === "data:");
    let input = URLSerializer(dataURL, true);
    input = input.slice(5);
    const position = { position: 0 };
    let mimeType = collectASequenceOfCodePointsFast(",", input, position);
    const mimeTypeLength = mimeType.length;
    mimeType = removeASCIIWhitespace(mimeType, true, true);
    if (position.position >= input.length) {
      return "failure";
    }
    position.position++;
    const encodedBody = input.slice(mimeTypeLength + 1);
    let body = stringPercentDecode(encodedBody);
    if (/;(\u0020){0,}base64$/i.test(mimeType)) {
      const stringBody = isomorphicDecode(body);
      body = forgivingBase64(stringBody);
      if (body === "failure") {
        return "failure";
      }
      mimeType = mimeType.slice(0, -6);
      mimeType = mimeType.replace(/(\u0020)+$/, "");
      mimeType = mimeType.slice(0, -1);
    }
    if (mimeType.startsWith(";")) {
      mimeType = "text/plain" + mimeType;
    }
    let mimeTypeRecord = parseMIMEType(mimeType);
    if (mimeTypeRecord === "failure") {
      mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
    }
    return { mimeType: mimeTypeRecord, body };
  };
  var URLSerializer = function(url, excludeFragment = false) {
    const href = url.href;
    if (!excludeFragment) {
      return href;
    }
    const hash = href.lastIndexOf("#");
    if (hash === -1) {
      return href;
    }
    return href.slice(0, hash);
  };
  var collectASequenceOfCodePoints = function(condition, input, position) {
    let result = "";
    while (position.position < input.length && condition(input[position.position])) {
      result += input[position.position];
      position.position++;
    }
    return result;
  };
  var collectASequenceOfCodePointsFast = function(char, input, position) {
    const idx = input.indexOf(char, position.position);
    const start = position.position;
    if (idx === -1) {
      position.position = input.length;
      return input.slice(start);
    }
    position.position = idx;
    return input.slice(start, position.position);
  };
  var stringPercentDecode = function(input) {
    const bytes = encoder.encode(input);
    return percentDecode(bytes);
  };
  var percentDecode = function(input) {
    const output = [];
    for (let i = 0;i < input.length; i++) {
      const byte = input[i];
      if (byte !== 37) {
        output.push(byte);
      } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
        output.push(37);
      } else {
        const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
        const bytePoint = Number.parseInt(nextTwoBytes, 16);
        output.push(bytePoint);
        i += 2;
      }
    }
    return Uint8Array.from(output);
  };
  var parseMIMEType = function(input) {
    input = removeHTTPWhitespace(input, true, true);
    const position = { position: 0 };
    const type = collectASequenceOfCodePointsFast("/", input, position);
    if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
      return "failure";
    }
    if (position.position > input.length) {
      return "failure";
    }
    position.position++;
    let subtype = collectASequenceOfCodePointsFast(";", input, position);
    subtype = removeHTTPWhitespace(subtype, false, true);
    if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
      return "failure";
    }
    const typeLowercase = type.toLowerCase();
    const subtypeLowercase = subtype.toLowerCase();
    const mimeType = {
      type: typeLowercase,
      subtype: subtypeLowercase,
      parameters: new Map,
      essence: `${typeLowercase}/${subtypeLowercase}`
    };
    while (position.position < input.length) {
      position.position++;
      collectASequenceOfCodePoints((char) => HTTP_WHITESPACE_REGEX.test(char), input, position);
      let parameterName = collectASequenceOfCodePoints((char) => char !== ";" && char !== "=", input, position);
      parameterName = parameterName.toLowerCase();
      if (position.position < input.length) {
        if (input[position.position] === ";") {
          continue;
        }
        position.position++;
      }
      if (position.position > input.length) {
        break;
      }
      let parameterValue = null;
      if (input[position.position] === '"') {
        parameterValue = collectAnHTTPQuotedString(input, position, true);
        collectASequenceOfCodePointsFast(";", input, position);
      } else {
        parameterValue = collectASequenceOfCodePointsFast(";", input, position);
        parameterValue = removeHTTPWhitespace(parameterValue, false, true);
        if (parameterValue.length === 0) {
          continue;
        }
      }
      if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
        mimeType.parameters.set(parameterName, parameterValue);
      }
    }
    return mimeType;
  };
  var forgivingBase64 = function(data) {
    data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
    if (data.length % 4 === 0) {
      data = data.replace(/=?=$/, "");
    }
    if (data.length % 4 === 1) {
      return "failure";
    }
    if (/[^+/0-9A-Za-z]/.test(data)) {
      return "failure";
    }
    const binary = atob2(data);
    const bytes = new Uint8Array(binary.length);
    for (let byte = 0;byte < binary.length; byte++) {
      bytes[byte] = binary.charCodeAt(byte);
    }
    return bytes;
  };
  var collectAnHTTPQuotedString = function(input, position, extractValue) {
    const positionStart = position.position;
    let value = "";
    assert(input[position.position] === '"');
    position.position++;
    while (true) {
      value += collectASequenceOfCodePoints((char) => char !== '"' && char !== "\\", input, position);
      if (position.position >= input.length) {
        break;
      }
      const quoteOrBackslash = input[position.position];
      position.position++;
      if (quoteOrBackslash === "\\") {
        if (position.position >= input.length) {
          value += "\\";
          break;
        }
        value += input[position.position];
        position.position++;
      } else {
        assert(quoteOrBackslash === '"');
        break;
      }
    }
    if (extractValue) {
      return value;
    }
    return input.slice(positionStart, position.position);
  };
  var serializeAMimeType = function(mimeType) {
    assert(mimeType !== "failure");
    const { parameters, essence } = mimeType;
    let serialization = essence;
    for (let [name, value] of parameters.entries()) {
      serialization += ";";
      serialization += name;
      serialization += "=";
      if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
        value = value.replace(/(\\|")/g, "\\$1");
        value = '"' + value;
        value += '"';
      }
      serialization += value;
    }
    return serialization;
  };
  var isHTTPWhiteSpace = function(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === " ";
  };
  var removeHTTPWhitespace = function(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isHTTPWhiteSpace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isHTTPWhiteSpace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  };
  var isASCIIWhitespace = function(char) {
    return char === "\r" || char === "\n" || char === "\t" || char === "\f" || char === " ";
  };
  var removeASCIIWhitespace = function(str, leading = true, trailing = true) {
    let lead = 0;
    let trail = str.length - 1;
    if (leading) {
      for (;lead < str.length && isASCIIWhitespace(str[lead]); lead++)
        ;
    }
    if (trailing) {
      for (;trail > 0 && isASCIIWhitespace(str[trail]); trail--)
        ;
    }
    return str.slice(lead, trail + 1);
  };
  var assert = __require("assert");
  var { atob: atob2 } = __require("buffer");
  var { isomorphicDecode } = require_util2();
  var encoder = new TextEncoder;
  var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
  var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
  var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  module.exports = {
    dataURLProcessor,
    URLSerializer,
    collectASequenceOfCodePoints,
    collectASequenceOfCodePointsFast,
    stringPercentDecode,
    parseMIMEType,
    collectAnHTTPQuotedString,
    serializeAMimeType
  };
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS((exports, module) => {
  var processBlobParts = function(parts, options) {
    const bytes = [];
    for (const element of parts) {
      if (typeof element === "string") {
        let s = element;
        if (options.endings === "native") {
          s = convertLineEndingsNative(s);
        }
        bytes.push(new TextEncoder().encode(s));
      } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
        if (!element.buffer) {
          bytes.push(new Uint8Array(element));
        } else {
          bytes.push(new Uint8Array(element.buffer, element.byteOffset, element.byteLength));
        }
      } else if (isBlobLike(element)) {
        bytes.push(element);
      }
    }
    return bytes;
  };
  var convertLineEndingsNative = function(s) {
    let nativeLineEnding = "\n";
    if (process.platform === "win32") {
      nativeLineEnding = "\r\n";
    }
    return s.replace(/\r?\n/g, nativeLineEnding);
  };
  var isFileLike = function(object) {
    return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
  };
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { types } = __require("util");
  var { kState } = require_symbols2();
  var { isBlobLike } = require_util2();
  var { webidl } = require_webidl();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var { kEnumerableProperty } = require_util();

  class File extends Blob2 {
    constructor(fileBits, fileName, options = {}) {
      webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
      fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
      fileName = webidl.converters.USVString(fileName);
      options = webidl.converters.FilePropertyBag(options);
      const n = fileName;
      let t = options.type;
      let d;
      substep: {
        if (t) {
          t = parseMIMEType(t);
          if (t === "failure") {
            t = "";
            break substep;
          }
          t = serializeAMimeType(t).toLowerCase();
        }
        d = options.lastModified;
      }
      super(processBlobParts(fileBits, options), { type: t });
      this[kState] = {
        name: n,
        lastModified: d,
        type: t
      };
    }
    get name() {
      webidl.brandCheck(this, File);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, File);
      return this[kState].lastModified;
    }
    get type() {
      webidl.brandCheck(this, File);
      return this[kState].type;
    }
  }

  class FileLike {
    constructor(blobLike, fileName, options = {}) {
      const n = fileName;
      const t = options.type;
      const d = options.lastModified ?? Date.now();
      this[kState] = {
        blobLike,
        name: n,
        type: t,
        lastModified: d
      };
    }
    stream(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.stream(...args);
    }
    arrayBuffer(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.arrayBuffer(...args);
    }
    slice(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.slice(...args);
    }
    text(...args) {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.text(...args);
    }
    get size() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.size;
    }
    get type() {
      webidl.brandCheck(this, FileLike);
      return this[kState].blobLike.type;
    }
    get name() {
      webidl.brandCheck(this, FileLike);
      return this[kState].name;
    }
    get lastModified() {
      webidl.brandCheck(this, FileLike);
      return this[kState].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(File.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: true
    },
    name: kEnumerableProperty,
    lastModified: kEnumerableProperty
  });
  webidl.converters.Blob = webidl.interfaceConverter(Blob2);
  webidl.converters.BlobPart = function(V, opts) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V, opts);
      }
    }
    return webidl.converters.USVString(V, opts);
  };
  webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(webidl.converters.BlobPart);
  webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
    {
      key: "lastModified",
      converter: webidl.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (value) => {
        value = webidl.converters.DOMString(value);
        value = value.toLowerCase();
        if (value !== "native") {
          value = "transparent";
        }
        return value;
      },
      defaultValue: "transparent"
    }
  ]);
  module.exports = { File, FileLike, isFileLike };
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS((exports, module) => {
  var makeEntry = function(name, value, filename) {
    name = Buffer.from(name).toString("utf8");
    if (typeof value === "string") {
      value = Buffer.from(value).toString("utf8");
    } else {
      if (!isFileLike(value)) {
        value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
      }
      if (filename !== undefined) {
        const options = {
          type: value.type,
          lastModified: value.lastModified
        };
        value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
      }
    }
    return { name, value };
  };
  var { isBlobLike, toUSVString, makeIterator } = require_util2();
  var { kState } = require_symbols2();
  var { File: UndiciFile, FileLike, isFileLike } = require_file();
  var { webidl } = require_webidl();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var File = NativeFile ?? UndiciFile;

  class FormData2 {
    constructor(form) {
      if (form !== undefined) {
        throw webidl.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      }
      this[kState] = [];
    }
    append(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? webidl.converters.USVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      this[kState].push(entry);
    }
    delete(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
      name = webidl.converters.USVString(name);
      this[kState] = this[kState].filter((entry) => entry.name !== name);
    }
    get(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
      name = webidl.converters.USVString(name);
      const idx = this[kState].findIndex((entry) => entry.name === name);
      if (idx === -1) {
        return null;
      }
      return this[kState][idx].value;
    }
    getAll(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
      name = webidl.converters.USVString(name);
      return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
    }
    has(name) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
      name = webidl.converters.USVString(name);
      return this[kState].findIndex((entry) => entry.name === name) !== -1;
    }
    set(name, value, filename = undefined) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
      if (arguments.length === 3 && !isBlobLike(value)) {
        throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
      }
      name = webidl.converters.USVString(name);
      value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
      filename = arguments.length === 3 ? toUSVString(filename) : undefined;
      const entry = makeEntry(name, value, filename);
      const idx = this[kState].findIndex((entry2) => entry2.name === name);
      if (idx !== -1) {
        this[kState] = [
          ...this[kState].slice(0, idx),
          entry,
          ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
        ];
      } else {
        this[kState].push(entry);
      }
    }
    entries() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key+value");
    }
    keys() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "key");
    }
    values() {
      webidl.brandCheck(this, FormData2);
      return makeIterator(() => this[kState].map((pair) => [pair.name, pair.value]), "FormData", "value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, FormData2);
      webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
  }
  FormData2.prototype[Symbol.iterator] = FormData2.prototype.entries;
  Object.defineProperties(FormData2.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: true
    }
  });
  module.exports = { FormData: FormData2 };
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS((exports, module) => {
  var extractBody = function(object, keepalive = false) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    let stream = null;
    if (object instanceof ReadableStream) {
      stream = object;
    } else if (isBlobLike(object)) {
      stream = object.stream();
    } else {
      stream = new ReadableStream({
        async pull(controller) {
          controller.enqueue(typeof source === "string" ? new TextEncoder().encode(source) : source);
          queueMicrotask(() => readableStreamClose(controller));
        },
        start() {
        },
        type: undefined
      });
    }
    assert(isReadableStreamLike(stream));
    let action = null;
    let source = null;
    let length = null;
    let type = null;
    if (typeof object === "string") {
      source = object;
      type = "text/plain;charset=UTF-8";
    } else if (object instanceof URLSearchParams) {
      source = object.toString();
      type = "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isArrayBuffer(object)) {
      source = new Uint8Array(object.slice());
    } else if (ArrayBuffer.isView(object)) {
      source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
    } else if (util.isFormDataLike(object)) {
      const boundary = `----formdata-undici-${Math.random()}`.replace(".", "").slice(0, 32);
      const prefix = `--${boundary}\r\nContent-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
      const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
      const enc = new TextEncoder;
      const blobParts = [];
      const rn = new Uint8Array([13, 10]);
      length = 0;
      let hasUnknownSizeValue = false;
      for (const [name, value] of object) {
        if (typeof value === "string") {
          const chunk2 = enc.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"` + `\r\n\r\n${normalizeLinefeeds(value)}\r\n`);
          blobParts.push(chunk2);
          length += chunk2.byteLength;
        } else {
          const chunk2 = enc.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + "\r\n" + `Content-Type: ${value.type || "application/octet-stream"}\r\n\r\n`);
          blobParts.push(chunk2, value, rn);
          if (typeof value.size === "number") {
            length += chunk2.byteLength + value.size + rn.byteLength;
          } else {
            hasUnknownSizeValue = true;
          }
        }
      }
      const chunk = enc.encode(`--${boundary}--`);
      blobParts.push(chunk);
      length += chunk.byteLength;
      if (hasUnknownSizeValue) {
        length = null;
      }
      source = object;
      action = async function* () {
        for (const part of blobParts) {
          if (part.stream) {
            yield* part.stream();
          } else {
            yield part;
          }
        }
      };
      type = "multipart/form-data; boundary=" + boundary;
    } else if (isBlobLike(object)) {
      source = object;
      length = object.size;
      if (object.type) {
        type = object.type;
      }
    } else if (typeof object[Symbol.asyncIterator] === "function") {
      if (keepalive) {
        throw new TypeError("keepalive");
      }
      if (util.isDisturbed(object) || object.locked) {
        throw new TypeError("Response body object should not be disturbed or locked");
      }
      stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
    }
    if (typeof source === "string" || util.isBuffer(source)) {
      length = Buffer.byteLength(source);
    }
    if (action != null) {
      let iterator;
      stream = new ReadableStream({
        async start() {
          iterator = action(object)[Symbol.asyncIterator]();
        },
        async pull(controller) {
          const { value, done } = await iterator.next();
          if (done) {
            queueMicrotask(() => {
              controller.close();
            });
          } else {
            if (!isErrored(stream)) {
              controller.enqueue(new Uint8Array(value));
            }
          }
          return controller.desiredSize > 0;
        },
        async cancel(reason) {
          await iterator.return();
        },
        type: undefined
      });
    }
    const body = { stream, source, length };
    return [body, type];
  };
  var safelyExtractBody = function(object, keepalive = false) {
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    if (object instanceof ReadableStream) {
      assert(!util.isDisturbed(object), "The body has already been consumed.");
      assert(!object.locked, "The stream is locked.");
    }
    return extractBody(object, keepalive);
  };
  var cloneBody = function(body) {
    const [out1, out2] = body.stream.tee();
    const out2Clone = structuredClone(out2, { transfer: [out2] });
    const [, finalClone] = out2Clone.tee();
    body.stream = out1;
    return {
      stream: finalClone,
      length: body.length,
      source: body.source
    };
  };
  async function* consumeBody(body) {
    if (body) {
      if (isUint8Array(body)) {
        yield body;
      } else {
        const stream = body.stream;
        if (util.isDisturbed(stream)) {
          throw new TypeError("The body has already been consumed.");
        }
        if (stream.locked) {
          throw new TypeError("The stream is locked.");
        }
        stream[kBodyUsed] = true;
        yield* stream;
      }
    }
  }
  var throwIfAborted = function(state) {
    if (state.aborted) {
      throw new DOMException2("The operation was aborted.", "AbortError");
    }
  };
  var bodyMixinMethods = function(instance) {
    const methods = {
      blob() {
        return specConsumeBody(this, (bytes) => {
          let mimeType = bodyMimeType(this);
          if (mimeType === "failure") {
            mimeType = "";
          } else if (mimeType) {
            mimeType = serializeAMimeType(mimeType);
          }
          return new Blob2([bytes], { type: mimeType });
        }, instance);
      },
      arrayBuffer() {
        return specConsumeBody(this, (bytes) => {
          return new Uint8Array(bytes).buffer;
        }, instance);
      },
      text() {
        return specConsumeBody(this, utf8DecodeBytes, instance);
      },
      json() {
        return specConsumeBody(this, parseJSONFromBytes, instance);
      },
      async formData() {
        webidl.brandCheck(this, instance);
        throwIfAborted(this[kState]);
        const contentType = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(contentType)) {
          const headers = {};
          for (const [key, value] of this.headers)
            headers[key.toLowerCase()] = value;
          const responseFormData = new FormData2;
          let busboy;
          try {
            busboy = Busboy({
              headers,
              defParamCharset: "utf8"
            });
          } catch (err) {
            throw new DOMException2(`${err}`, "AbortError");
          }
          busboy.on("field", (name, value) => {
            responseFormData.append(name, value);
          });
          busboy.on("file", (name, value, info) => {
            const { filename, encoding, mimeType } = info;
            const chunks = [];
            if (encoding === "base64" || encoding.toLowerCase() === "base64") {
              let base64chunk = "";
              value.on("data", (chunk) => {
                base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                const end = base64chunk.length - base64chunk.length % 4;
                chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                base64chunk = base64chunk.slice(end);
              });
              value.on("end", () => {
                chunks.push(Buffer.from(base64chunk, "base64"));
                responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
              });
            } else {
              value.on("data", (chunk) => {
                chunks.push(chunk);
              });
              value.on("end", () => {
                responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
              });
            }
          });
          const busboyResolve = new Promise((resolve, reject) => {
            busboy.on("finish", resolve);
            busboy.on("error", (err) => reject(new TypeError(err)));
          });
          if (this.body !== null)
            for await (const chunk of consumeBody(this[kState].body))
              busboy.write(chunk);
          busboy.end();
          await busboyResolve;
          return responseFormData;
        } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
          let entries;
          try {
            let text = "";
            const textDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
            for await (const chunk of consumeBody(this[kState].body)) {
              if (!isUint8Array(chunk)) {
                throw new TypeError("Expected Uint8Array chunk");
              }
              text += textDecoder.decode(chunk, { stream: true });
            }
            text += textDecoder.decode();
            entries = new URLSearchParams(text);
          } catch (err) {
            throw Object.assign(new TypeError, { cause: err });
          }
          const formData = new FormData2;
          for (const [name, value] of entries) {
            formData.append(name, value);
          }
          return formData;
        } else {
          await Promise.resolve();
          throwIfAborted(this[kState]);
          throw webidl.errors.exception({
            header: `${instance.name}.formData`,
            message: "Could not parse content as FormData."
          });
        }
      }
    };
    return methods;
  };
  var mixinBody = function(prototype) {
    Object.assign(prototype.prototype, bodyMixinMethods(prototype));
  };
  async function specConsumeBody(object, convertBytesToJSValue, instance) {
    webidl.brandCheck(object, instance);
    throwIfAborted(object[kState]);
    if (bodyUnusable(object[kState].body)) {
      throw new TypeError("Body is unusable");
    }
    const promise = createDeferredPromise();
    const errorSteps = (error) => promise.reject(error);
    const successSteps = (data) => {
      try {
        promise.resolve(convertBytesToJSValue(data));
      } catch (e) {
        errorSteps(e);
      }
    };
    if (object[kState].body == null) {
      successSteps(new Uint8Array);
      return promise.promise;
    }
    fullyReadBody(object[kState].body, successSteps, errorSteps);
    return promise.promise;
  }
  var bodyUnusable = function(body) {
    return body != null && (body.stream.locked || util.isDisturbed(body.stream));
  };
  var utf8DecodeBytes = function(buffer) {
    if (buffer.length === 0) {
      return "";
    }
    if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
      buffer = buffer.subarray(3);
    }
    const output = new TextDecoder().decode(buffer);
    return output;
  };
  var parseJSONFromBytes = function(bytes) {
    return JSON.parse(utf8DecodeBytes(bytes));
  };
  var bodyMimeType = function(object) {
    const { headersList } = object[kState];
    const contentType = headersList.get("content-type");
    if (contentType === null) {
      return "failure";
    }
    return parseMIMEType(contentType);
  };
  var Busboy = require_lib();
  var util = require_util();
  var {
    ReadableStreamFrom,
    isBlobLike,
    isReadableStreamLike,
    readableStreamClose,
    createDeferredPromise,
    fullyReadBody
  } = require_util2();
  var { FormData: FormData2 } = require_formdata();
  var { kState } = require_symbols2();
  var { webidl } = require_webidl();
  var { DOMException: DOMException2, structuredClone } = require_constants();
  var { Blob: Blob2, File: NativeFile } = __require("buffer");
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { isErrored } = require_util();
  var { isUint8Array, isArrayBuffer } = __require("util/types");
  var { File: UndiciFile } = require_file();
  var { parseMIMEType, serializeAMimeType } = require_dataURL();
  var ReadableStream = globalThis.ReadableStream;
  var File = NativeFile ?? UndiciFile;
  module.exports = {
    extractBody,
    safelyExtractBody,
    cloneBody,
    mixinBody
  };
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS((exports, module) => {
  var processHeaderValue = function(key, val) {
    if (val && typeof val === "object") {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    val = val != null ? `${val}` : "";
    if (headerCharRegex.exec(val) !== null) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    }
    return `${key}: ${val}\r\n`;
  };
  var processHeader = function(request, key, val) {
    if (val && (typeof val === "object" && !Array.isArray(val))) {
      throw new InvalidArgumentError(`invalid ${key} header`);
    } else if (val === undefined) {
      return;
    }
    if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      request.host = val;
    } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
      request.contentLength = parseInt(val, 10);
      if (!Number.isFinite(request.contentLength)) {
        throw new InvalidArgumentError("invalid content-length header");
      }
    } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
      request.contentType = val;
      request.headers += processHeaderValue(key, val);
    } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
      throw new InvalidArgumentError("invalid transfer-encoding header");
    } else if (key.length === 10 && key.toLowerCase() === "connection") {
      const value = typeof val === "string" ? val.toLowerCase() : null;
      if (value !== "close" && value !== "keep-alive") {
        throw new InvalidArgumentError("invalid connection header");
      } else if (value === "close") {
        request.reset = true;
      }
    } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
      throw new InvalidArgumentError("invalid keep-alive header");
    } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
      throw new InvalidArgumentError("invalid upgrade header");
    } else if (key.length === 6 && key.toLowerCase() === "expect") {
      throw new NotSupportedError("expect header not supported");
    } else if (tokenRegExp.exec(key) === null) {
      throw new InvalidArgumentError("invalid header key");
    } else {
      if (Array.isArray(val)) {
        for (let i = 0;i < val.length; i++) {
          request.headers += processHeaderValue(key, val[i]);
        }
      } else {
        request.headers += processHeaderValue(key, val);
      }
    }
  };
  var {
    InvalidArgumentError,
    NotSupportedError
  } = require_errors();
  var assert = __require("assert");
  var util = require_util();
  var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
  var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  var invalidPathRegex = /[^\u0021-\u00ff]/;
  var kHandler = Symbol("handler");
  var channels = {};
  var extractBody;
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.create = diagnosticsChannel.channel("undici:request:create");
    channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
    channels.headers = diagnosticsChannel.channel("undici:request:headers");
    channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
    channels.error = diagnosticsChannel.channel("undici:request:error");
  } catch {
    channels.create = { hasSubscribers: false };
    channels.bodySent = { hasSubscribers: false };
    channels.headers = { hasSubscribers: false };
    channels.trailers = { hasSubscribers: false };
    channels.error = { hasSubscribers: false };
  }

  class Request {
    constructor(origin, {
      path,
      method,
      body,
      headers,
      query,
      idempotent,
      blocking,
      upgrade,
      headersTimeout,
      bodyTimeout,
      reset,
      throwOnError
    }, handler) {
      if (typeof path !== "string") {
        throw new InvalidArgumentError("path must be a string");
      } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
        throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
      } else if (invalidPathRegex.exec(path) !== null) {
        throw new InvalidArgumentError("invalid request path");
      }
      if (typeof method !== "string") {
        throw new InvalidArgumentError("method must be a string");
      } else if (tokenRegExp.exec(method) === null) {
        throw new InvalidArgumentError("invalid request method");
      }
      if (upgrade && typeof upgrade !== "string") {
        throw new InvalidArgumentError("upgrade must be a string");
      }
      if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("invalid headersTimeout");
      }
      if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("invalid bodyTimeout");
      }
      if (reset != null && typeof reset !== "boolean") {
        throw new InvalidArgumentError("invalid reset");
      }
      this.headersTimeout = headersTimeout;
      this.bodyTimeout = bodyTimeout;
      this.throwOnError = throwOnError === true;
      this.method = method;
      if (body == null) {
        this.body = null;
      } else if (util.isStream(body)) {
        this.body = body;
      } else if (util.isBuffer(body)) {
        this.body = body.byteLength ? body : null;
      } else if (ArrayBuffer.isView(body)) {
        this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
      } else if (body instanceof ArrayBuffer) {
        this.body = body.byteLength ? Buffer.from(body) : null;
      } else if (typeof body === "string") {
        this.body = body.length ? Buffer.from(body) : null;
      } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
        this.body = body;
      } else {
        throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
      }
      this.completed = false;
      this.aborted = false;
      this.upgrade = upgrade || null;
      this.path = query ? util.buildURL(path, query) : path;
      this.origin = origin;
      this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
      this.blocking = blocking == null ? false : blocking;
      this.reset = reset == null ? null : reset;
      this.host = null;
      this.contentLength = null;
      this.contentType = null;
      this.headers = "";
      if (Array.isArray(headers)) {
        if (headers.length % 2 !== 0) {
          throw new InvalidArgumentError("headers array must be even");
        }
        for (let i = 0;i < headers.length; i += 2) {
          processHeader(this, headers[i], headers[i + 1]);
        }
      } else if (headers && typeof headers === "object") {
        const keys = Object.keys(headers);
        for (let i = 0;i < keys.length; i++) {
          const key = keys[i];
          processHeader(this, key, headers[key]);
        }
      } else if (headers != null) {
        throw new InvalidArgumentError("headers must be an object or an array");
      }
      if (util.isFormDataLike(this.body)) {
        if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
          throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
        }
        if (!extractBody) {
          extractBody = require_body().extractBody;
        }
        const [bodyStream, contentType] = extractBody(body);
        if (this.contentType == null) {
          this.contentType = contentType;
          this.headers += `content-type: ${contentType}\r\n`;
        }
        this.body = bodyStream.stream;
        this.contentLength = bodyStream.length;
      } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
        this.contentType = body.type;
        this.headers += `content-type: ${body.type}\r\n`;
      }
      util.validateHandler(handler, method, upgrade);
      this.servername = util.getServerName(this.host);
      this[kHandler] = handler;
      if (channels.create.hasSubscribers) {
        channels.create.publish({ request: this });
      }
    }
    onBodySent(chunk) {
      if (this[kHandler].onBodySent) {
        try {
          this[kHandler].onBodySent(chunk);
        } catch (err) {
          this.onError(err);
        }
      }
    }
    onRequestSent() {
      if (channels.bodySent.hasSubscribers) {
        channels.bodySent.publish({ request: this });
      }
    }
    onConnect(abort) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onConnect(abort);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      assert(!this.aborted);
      assert(!this.completed);
      if (channels.headers.hasSubscribers) {
        channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
      }
      return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
    }
    onData(chunk) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onData(chunk);
    }
    onUpgrade(statusCode, headers, socket) {
      assert(!this.aborted);
      assert(!this.completed);
      return this[kHandler].onUpgrade(statusCode, headers, socket);
    }
    onComplete(trailers) {
      assert(!this.aborted);
      this.completed = true;
      if (channels.trailers.hasSubscribers) {
        channels.trailers.publish({ request: this, trailers });
      }
      return this[kHandler].onComplete(trailers);
    }
    onError(error) {
      if (channels.error.hasSubscribers) {
        channels.error.publish({ request: this, error });
      }
      if (this.aborted) {
        return;
      }
      this.aborted = true;
      return this[kHandler].onError(error);
    }
    addHeader(key, value) {
      processHeader(this, key, value);
      return this;
    }
  }
  module.exports = Request;
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS((exports, module) => {
  var EventEmitter = __require("events");

  class Dispatcher extends EventEmitter {
    dispatch() {
      throw new Error("not implemented");
    }
    close() {
      throw new Error("not implemented");
    }
    destroy() {
      throw new Error("not implemented");
    }
  }
  module.exports = Dispatcher;
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS((exports, module) => {
  var Dispatcher = require_dispatcher();
  var {
    ClientDestroyedError,
    ClientClosedError,
    InvalidArgumentError
  } = require_errors();
  var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
  var kDestroyed = Symbol("destroyed");
  var kClosed = Symbol("closed");
  var kOnDestroyed = Symbol("onDestroyed");
  var kOnClosed = Symbol("onClosed");
  var kInterceptedDispatch = Symbol("Intercepted Dispatch");

  class DispatcherBase extends Dispatcher {
    constructor() {
      super();
      this[kDestroyed] = false;
      this[kOnDestroyed] = null;
      this[kClosed] = false;
      this[kOnClosed] = [];
    }
    get destroyed() {
      return this[kDestroyed];
    }
    get closed() {
      return this[kClosed];
    }
    get interceptors() {
      return this[kInterceptors];
    }
    set interceptors(newInterceptors) {
      if (newInterceptors) {
        for (let i = newInterceptors.length - 1;i >= 0; i--) {
          const interceptor = this[kInterceptors][i];
          if (typeof interceptor !== "function") {
            throw new InvalidArgumentError("interceptor must be an function");
          }
        }
      }
      this[kInterceptors] = newInterceptors;
    }
    close(callback) {
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.close((err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        queueMicrotask(() => callback(new ClientDestroyedError, null));
        return;
      }
      if (this[kClosed]) {
        if (this[kOnClosed]) {
          this[kOnClosed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      this[kClosed] = true;
      this[kOnClosed].push(callback);
      const onClosed = () => {
        const callbacks = this[kOnClosed];
        this[kOnClosed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kClose]().then(() => this.destroy()).then(() => {
        queueMicrotask(onClosed);
      });
    }
    destroy(err, callback) {
      if (typeof err === "function") {
        callback = err;
        err = null;
      }
      if (callback === undefined) {
        return new Promise((resolve, reject) => {
          this.destroy(err, (err2, data) => {
            return err2 ? reject(err2) : resolve(data);
          });
        });
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      if (this[kDestroyed]) {
        if (this[kOnDestroyed]) {
          this[kOnDestroyed].push(callback);
        } else {
          queueMicrotask(() => callback(null, null));
        }
        return;
      }
      if (!err) {
        err = new ClientDestroyedError;
      }
      this[kDestroyed] = true;
      this[kOnDestroyed] = this[kOnDestroyed] || [];
      this[kOnDestroyed].push(callback);
      const onDestroyed = () => {
        const callbacks = this[kOnDestroyed];
        this[kOnDestroyed] = null;
        for (let i = 0;i < callbacks.length; i++) {
          callbacks[i](null, null);
        }
      };
      this[kDestroy](err).then(() => {
        queueMicrotask(onDestroyed);
      });
    }
    [kInterceptedDispatch](opts, handler) {
      if (!this[kInterceptors] || this[kInterceptors].length === 0) {
        this[kInterceptedDispatch] = this[kDispatch];
        return this[kDispatch](opts, handler);
      }
      let dispatch = this[kDispatch].bind(this);
      for (let i = this[kInterceptors].length - 1;i >= 0; i--) {
        dispatch = this[kInterceptors][i](dispatch);
      }
      this[kInterceptedDispatch] = dispatch;
      return dispatch(opts, handler);
    }
    dispatch(opts, handler) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      try {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object.");
        }
        if (this[kDestroyed] || this[kOnDestroyed]) {
          throw new ClientDestroyedError;
        }
        if (this[kClosed]) {
          throw new ClientClosedError;
        }
        return this[kInterceptedDispatch](opts, handler);
      } catch (err) {
        if (typeof handler.onError !== "function") {
          throw new InvalidArgumentError("invalid onError method");
        }
        handler.onError(err);
        return false;
      }
    }
  }
  module.exports = DispatcherBase;
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS((exports, module) => {
  var buildConnector = function({ maxCachedSessions, socketPath, timeout, ...opts }) {
    if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
      throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
    }
    const options = { path: socketPath, ...opts };
    const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
    timeout = timeout == null ? 1e4 : timeout;
    return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
      let socket;
      if (protocol === "https:") {
        if (!tls) {
          tls = __require("tls");
        }
        servername = servername || options.servername || util.getServerName(host) || null;
        const sessionKey = servername || hostname;
        const session = sessionCache.get(sessionKey) || null;
        assert(sessionKey);
        socket = tls.connect({
          highWaterMark: 16384,
          ...options,
          servername,
          session,
          localAddress,
          socket: httpSocket,
          port: port || 443,
          host: hostname
        });
        socket.on("session", function(session2) {
          sessionCache.set(sessionKey, session2);
        });
      } else {
        assert(!httpSocket, "httpSocket can only be sent on TLS update");
        socket = net.connect({
          highWaterMark: 64 * 1024,
          ...options,
          localAddress,
          port: port || 80,
          host: hostname
        });
      }
      if (options.keepAlive == null || options.keepAlive) {
        const keepAliveInitialDelay = options.keepAliveInitialDelay === undefined ? 60000 : options.keepAliveInitialDelay;
        socket.setKeepAlive(true, keepAliveInitialDelay);
      }
      const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
      socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(null, this);
        }
      }).on("error", function(err) {
        cancelTimeout();
        if (callback) {
          const cb = callback;
          callback = null;
          cb(err);
        }
      });
      return socket;
    };
  };
  var setupTimeout = function(onConnectTimeout2, timeout) {
    if (!timeout) {
      return () => {
      };
    }
    let s1 = null;
    let s2 = null;
    const timeoutId = setTimeout(() => {
      s1 = setImmediate(() => {
        if (process.platform === "win32") {
          s2 = setImmediate(() => onConnectTimeout2());
        } else {
          onConnectTimeout2();
        }
      });
    }, timeout);
    return () => {
      clearTimeout(timeoutId);
      clearImmediate(s1);
      clearImmediate(s2);
    };
  };
  var onConnectTimeout = function(socket) {
    util.destroy(socket, new ConnectTimeoutError);
  };
  var net = __require("net");
  var assert = __require("assert");
  var util = require_util();
  var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
  var tls;
  var SessionCache;
  if (global.FinalizationRegistry) {
    SessionCache = class WeakSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
        this._sessionRegistry = new global.FinalizationRegistry((key) => {
          if (this._sessionCache.size < this._maxCachedSessions) {
            return;
          }
          const ref = this._sessionCache.get(key);
          if (ref !== undefined && ref.deref() === undefined) {
            this._sessionCache.delete(key);
          }
        });
      }
      get(sessionKey) {
        const ref = this._sessionCache.get(sessionKey);
        return ref ? ref.deref() : null;
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        this._sessionCache.set(sessionKey, new WeakRef(session));
        this._sessionRegistry.register(session, sessionKey);
      }
    };
  } else {
    SessionCache = class SimpleSessionCache {
      constructor(maxCachedSessions) {
        this._maxCachedSessions = maxCachedSessions;
        this._sessionCache = new Map;
      }
      get(sessionKey) {
        return this._sessionCache.get(sessionKey);
      }
      set(sessionKey, session) {
        if (this._maxCachedSessions === 0) {
          return;
        }
        if (this._sessionCache.size >= this._maxCachedSessions) {
          const { value: oldestKey } = this._sessionCache.keys().next();
          this._sessionCache.delete(oldestKey);
        }
        this._sessionCache.set(sessionKey, session);
      }
    };
  }
  module.exports = buildConnector;
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS((exports) => {
  var enumToMap = function(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (typeof value === "number") {
        res[key] = value;
      }
    });
    return res;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enumToMap = undefined;
  exports.enumToMap = enumToMap;
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = undefined;
  var utils_1 = require_utils2();
  var ERROR;
  (function(ERROR2) {
    ERROR2[ERROR2["OK"] = 0] = "OK";
    ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
    ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
    ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
    ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR2[ERROR2["USER"] = 24] = "USER";
  })(ERROR = exports.ERROR || (exports.ERROR = {}));
  var TYPE;
  (function(TYPE2) {
    TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
    TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
    TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
  })(TYPE = exports.TYPE || (exports.TYPE = {}));
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
    FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
    FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
    FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
  })(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
  var LENIENT_FLAGS;
  (function(LENIENT_FLAGS2) {
    LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
  })(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
  var METHODS;
  (function(METHODS2) {
    METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
    METHODS2[METHODS2["GET"] = 1] = "GET";
    METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
    METHODS2[METHODS2["POST"] = 3] = "POST";
    METHODS2[METHODS2["PUT"] = 4] = "PUT";
    METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
    METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
    METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
    METHODS2[METHODS2["COPY"] = 8] = "COPY";
    METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
    METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
    METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
    METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
    METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
    METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
    METHODS2[METHODS2["BIND"] = 16] = "BIND";
    METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
    METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
    METHODS2[METHODS2["ACL"] = 19] = "ACL";
    METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
    METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
    METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
    METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
    METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
    METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
    METHODS2[METHODS2["LINK"] = 31] = "LINK";
    METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
    METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
    METHODS2[METHODS2["PRI"] = 34] = "PRI";
    METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
    METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
    METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
    METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
    METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
    METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
  })(METHODS = exports.METHODS || (exports.METHODS = {}));
  exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS["M-SEARCH"],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    METHODS.SOURCE
  ];
  exports.METHODS_ICE = [
    METHODS.SOURCE
  ];
  exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    METHODS.GET,
    METHODS.POST
  ];
  exports.METHOD_MAP = utils_1.enumToMap(METHODS);
  exports.H_METHOD_MAP = {};
  Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
      exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
  });
  var FINISH;
  (function(FINISH2) {
    FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
    FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
  })(FINISH = exports.FINISH || (exports.FINISH = {}));
  exports.ALPHA = [];
  for (let i = "A".charCodeAt(0);i <= "Z".charCodeAt(0); i++) {
    exports.ALPHA.push(String.fromCharCode(i));
    exports.ALPHA.push(String.fromCharCode(i + 32));
  }
  exports.NUM_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9
  };
  exports.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
  };
  exports.NUM = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
  ];
  exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
  exports.MARK = ["-", "_", ".", "!", "~", "*", "\'", "(", ")"];
  exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
  exports.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "\'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~"
  ].concat(exports.ALPHANUM);
  exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let i = 128;i <= 255; i++) {
    exports.URL_CHAR.push(i);
  }
  exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
  exports.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "\'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~"
  ].concat(exports.ALPHANUM);
  exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
  exports.HEADER_CHARS = ["\t"];
  for (let i = 32;i <= 255; i++) {
    if (i !== 127) {
      exports.HEADER_CHARS.push(i);
    }
  }
  exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
  exports.MAJOR = exports.NUM_MAP;
  exports.MINOR = exports.MAJOR;
  var HEADER_STATE;
  (function(HEADER_STATE2) {
    HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
  })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
  exports.SPECIAL_HEADERS = {
    connection: HEADER_STATE.CONNECTION,
    "content-length": HEADER_STATE.CONTENT_LENGTH,
    "proxy-connection": HEADER_STATE.CONNECTION,
    "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
    upgrade: HEADER_STATE.UPGRADE
  };
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS((exports, module) => {
  var parseLocation = function(statusCode, headers) {
    if (redirectableStatusCodes.indexOf(statusCode) === -1) {
      return null;
    }
    for (let i = 0;i < headers.length; i += 2) {
      if (headers[i].toString().toLowerCase() === "location") {
        return headers[i + 1];
      }
    }
  };
  var shouldRemoveHeader = function(header, removeContent, unknownOrigin) {
    return header.length === 4 && header.toString().toLowerCase() === "host" || removeContent && header.toString().toLowerCase().indexOf("content-") === 0 || unknownOrigin && header.length === 13 && header.toString().toLowerCase() === "authorization" || unknownOrigin && header.length === 6 && header.toString().toLowerCase() === "cookie";
  };
  var cleanRequestHeaders = function(headers, removeContent, unknownOrigin) {
    const ret = [];
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
          ret.push(headers[i], headers[i + 1]);
        }
      }
    } else if (headers && typeof headers === "object") {
      for (const key of Object.keys(headers)) {
        if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
          ret.push(key, headers[key]);
        }
      }
    } else {
      assert(headers == null, "headers must be an object or an array");
    }
    return ret;
  };
  var util = require_util();
  var { kBodyUsed } = require_symbols();
  var assert = __require("assert");
  var { InvalidArgumentError } = require_errors();
  var EE = __require("events");
  var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
  var kBody = Symbol("body");

  class BodyAsyncIterable {
    constructor(body) {
      this[kBody] = body;
      this[kBodyUsed] = false;
    }
    async* [Symbol.asyncIterator]() {
      assert(!this[kBodyUsed], "disturbed");
      this[kBodyUsed] = true;
      yield* this[kBody];
    }
  }

  class RedirectHandler {
    constructor(dispatch, maxRedirections, opts, handler) {
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      util.validateHandler(handler, opts.method, opts.upgrade);
      this.dispatch = dispatch;
      this.location = null;
      this.abort = null;
      this.opts = { ...opts, maxRedirections: 0 };
      this.maxRedirections = maxRedirections;
      this.handler = handler;
      this.history = [];
      if (util.isStream(this.opts.body)) {
        if (util.bodyLength(this.opts.body) === 0) {
          this.opts.body.on("data", function() {
            assert(false);
          });
        }
        if (typeof this.opts.body.readableDidRead !== "boolean") {
          this.opts.body[kBodyUsed] = false;
          EE.prototype.on.call(this.opts.body, "data", function() {
            this[kBodyUsed] = true;
          });
        }
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
        this.opts.body = new BodyAsyncIterable(this.opts.body);
      }
    }
    onConnect(abort) {
      this.abort = abort;
      this.handler.onConnect(abort, { history: this.history });
    }
    onUpgrade(statusCode, headers, socket) {
      this.handler.onUpgrade(statusCode, headers, socket);
    }
    onError(error) {
      this.handler.onError(error);
    }
    onHeaders(statusCode, headers, resume, statusText) {
      this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
      if (this.opts.origin) {
        this.history.push(new URL(this.opts.path, this.opts.origin));
      }
      if (!this.location) {
        return this.handler.onHeaders(statusCode, headers, resume, statusText);
      }
      const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
      const path = search ? `${pathname}${search}` : pathname;
      this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
      this.opts.path = path;
      this.opts.origin = origin;
      this.opts.maxRedirections = 0;
      this.opts.query = null;
      if (statusCode === 303 && this.opts.method !== "HEAD") {
        this.opts.method = "GET";
        this.opts.body = null;
      }
    }
    onData(chunk) {
      if (this.location) {
      } else {
        return this.handler.onData(chunk);
      }
    }
    onComplete(trailers) {
      if (this.location) {
        this.location = null;
        this.abort = null;
        this.dispatch(this.opts, this);
      } else {
        this.handler.onComplete(trailers);
      }
    }
    onBodySent(chunk) {
      if (this.handler.onBodySent) {
        this.handler.onBodySent(chunk);
      }
    }
  }
  module.exports = RedirectHandler;
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS((exports, module) => {
  var createRedirectInterceptor = function({ maxRedirections: defaultMaxRedirections }) {
    return (dispatch) => {
      return function Intercept(opts, handler) {
        const { maxRedirections = defaultMaxRedirections } = opts;
        if (!maxRedirections) {
          return dispatch(opts, handler);
        }
        const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
        opts = { ...opts, maxRedirections: 0 };
        return dispatch(opts, redirectHandler);
      };
    };
  };
  var RedirectHandler = require_RedirectHandler();
  module.exports = createRedirectInterceptor;
});

// node_modules/undici/lib/client.js
var require_client = __commonJS((exports, module) => {
  async function lazyllhttp() {
    const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : undefined;
    let mod;
    try {
      mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
    } catch (e) {
      mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
    }
    return await WebAssembly.instantiate(mod, {
      env: {
        wasm_on_url: (p, at, len) => {
          return 0;
        },
        wasm_on_status: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_begin: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageBegin() || 0;
        },
        wasm_on_header_field: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_header_value: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
        },
        wasm_on_body: (p, at, len) => {
          assert.strictEqual(currentParser.ptr, p);
          const start = at - currentBufferPtr + currentBufferRef.byteOffset;
          return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
        },
        wasm_on_message_complete: (p) => {
          assert.strictEqual(currentParser.ptr, p);
          return currentParser.onMessageComplete() || 0;
        }
      }
    });
  }
  var onParserTimeout = function(parser) {
    const { socket, timeoutType, client } = parser;
    if (timeoutType === TIMEOUT_HEADERS) {
      if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
        assert(!parser.paused, "cannot be paused while waiting for headers");
        util.destroy(socket, new HeadersTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_BODY) {
      if (!parser.paused) {
        util.destroy(socket, new BodyTimeoutError);
      }
    } else if (timeoutType === TIMEOUT_IDLE) {
      assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
      util.destroy(socket, new InformationalError("socket idle timeout"));
    }
  };
  var onSocketReadable = function() {
    const { [kParser]: parser } = this;
    parser.readMore();
  };
  var onSocketError = function(err) {
    const { [kParser]: parser } = this;
    assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
    if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    this[kError] = err;
    onError(this[kClient], err);
  };
  var onError = function(client, err) {
    if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
      assert(client[kPendingIdx] === client[kRunningIdx]);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
      assert(client[kSize] === 0);
    }
  };
  var onSocketEnd = function() {
    const { [kParser]: parser } = this;
    if (parser.statusCode && !parser.shouldKeepAlive) {
      parser.onMessageComplete();
      return;
    }
    util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
  };
  var onSocketClose = function() {
    const { [kClient]: client } = this;
    if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {
      this[kParser].onMessageComplete();
    }
    this[kParser].destroy();
    this[kParser] = null;
    const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
    client[kSocket] = null;
    if (client.destroyed) {
      assert(client[kPending] === 0);
      const requests = client[kQueue].splice(client[kRunningIdx]);
      for (let i = 0;i < requests.length; i++) {
        const request = requests[i];
        errorRequest(client, request, err);
      }
    } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
      const request = client[kQueue][client[kRunningIdx]];
      client[kQueue][client[kRunningIdx]++] = null;
      errorRequest(client, request, err);
    }
    client[kPendingIdx] = client[kRunningIdx];
    assert(client[kRunning] === 0);
    client.emit("disconnect", client[kUrl], [client], err);
    resume(client);
  };
  async function connect(client) {
    assert(!client[kConnecting]);
    assert(!client[kSocket]);
    let { host, hostname, protocol, port } = client[kUrl];
    if (hostname[0] === "[") {
      const idx = hostname.indexOf("]");
      assert(idx !== -1);
      const ip = hostname.substr(1, idx - 1);
      assert(net.isIP(ip));
      hostname = ip;
    }
    client[kConnecting] = true;
    if (channels.beforeConnect.hasSubscribers) {
      channels.beforeConnect.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        },
        connector: client[kConnector]
      });
    }
    try {
      const socket = await new Promise((resolve, reject) => {
        client[kConnector]({
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName],
          localAddress: client[kLocalAddress]
        }, (err, socket2) => {
          if (err) {
            reject(err);
          } else {
            resolve(socket2);
          }
        });
      });
      if (client.destroyed) {
        util.destroy(socket.on("error", () => {
        }), new ClientDestroyedError);
        return;
      }
      if (!llhttpInstance) {
        llhttpInstance = await llhttpPromise;
        llhttpPromise = null;
      }
      client[kConnecting] = false;
      assert(socket);
      socket[kNoRef] = false;
      socket[kWriting] = false;
      socket[kReset] = false;
      socket[kBlocking] = false;
      socket[kError] = null;
      socket[kParser] = new Parser(client, socket, llhttpInstance);
      socket[kClient] = client;
      socket[kCounter] = 0;
      socket[kMaxRequests] = client[kMaxRequests];
      socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
      client[kSocket] = socket;
      if (channels.connected.hasSubscribers) {
        channels.connected.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          socket
        });
      }
      client.emit("connect", client[kUrl], [client]);
    } catch (err) {
      if (client.destroyed) {
        return;
      }
      client[kConnecting] = false;
      if (channels.connectError.hasSubscribers) {
        channels.connectError.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector],
          error: err
        });
      }
      if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        assert(client[kRunning] === 0);
        while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
          const request = client[kQueue][client[kPendingIdx]++];
          errorRequest(client, request, err);
        }
      } else {
        onError(client, err);
      }
      client.emit("connectionError", client[kUrl], [client], err);
    }
    resume(client);
  }
  var emitDrain = function(client) {
    client[kNeedDrain] = 0;
    client.emit("drain", client[kUrl], [client]);
  };
  var resume = function(client, sync) {
    if (client[kResuming] === 2) {
      return;
    }
    client[kResuming] = 2;
    _resume(client, sync);
    client[kResuming] = 0;
    if (client[kRunningIdx] > 256) {
      client[kQueue].splice(0, client[kRunningIdx]);
      client[kPendingIdx] -= client[kRunningIdx];
      client[kRunningIdx] = 0;
    }
  };
  var _resume = function(client, sync) {
    while (true) {
      if (client.destroyed) {
        assert(client[kPending] === 0);
        return;
      }
      if (client[kClosedResolve] && !client[kSize]) {
        client[kClosedResolve]();
        client[kClosedResolve] = null;
        return;
      }
      const socket = client[kSocket];
      if (socket && !socket.destroyed) {
        if (client[kSize] === 0) {
          if (!socket[kNoRef] && socket.unref) {
            socket.unref();
            socket[kNoRef] = true;
          }
        } else if (socket[kNoRef] && socket.ref) {
          socket.ref();
          socket[kNoRef] = false;
        }
        if (client[kSize] === 0) {
          if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
            socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
          }
        } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
          if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
            const request2 = client[kQueue][client[kRunningIdx]];
            const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
            socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
          }
        }
      }
      if (client[kBusy]) {
        client[kNeedDrain] = 2;
      } else if (client[kNeedDrain] === 2) {
        if (sync) {
          client[kNeedDrain] = 1;
          process.nextTick(emitDrain, client);
        } else {
          emitDrain(client);
        }
        continue;
      }
      if (client[kPending] === 0) {
        return;
      }
      if (client[kRunning] >= (client[kPipelining] || 1)) {
        return;
      }
      const request = client[kQueue][client[kPendingIdx]];
      if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
        if (client[kRunning] > 0) {
          return;
        }
        client[kServerName] = request.servername;
        if (socket && socket.servername !== request.servername) {
          util.destroy(socket, new InformationalError("servername changed"));
          return;
        }
      }
      if (client[kConnecting]) {
        return;
      }
      if (!socket) {
        connect(client);
        return;
      }
      if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
        return;
      }
      if (client[kRunning] > 0 && !request.idempotent) {
        return;
      }
      if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
        return;
      }
      if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {
        request.body.on("data", function() {
          assert(false);
        }).on("error", function(err) {
          errorRequest(client, request, err);
        }).on("end", function() {
          util.destroy(this);
        });
        request.body = null;
      }
      if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
        return;
      }
      if (!request.aborted && write(client, request)) {
        client[kPendingIdx]++;
      } else {
        client[kQueue].splice(client[kPendingIdx], 1);
      }
    }
  };
  var write = function(client, request) {
    const { body, method, path, host, upgrade, headers, blocking, reset } = request;
    const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
    if (body && typeof body.read === "function") {
      body.read(0);
    }
    let contentLength = util.bodyLength(body);
    if (contentLength === null) {
      contentLength = request.contentLength;
    }
    if (contentLength === 0 && !expectsPayload) {
      contentLength = null;
    }
    if (request.contentLength !== null && request.contentLength !== contentLength) {
      if (client[kStrictContentLength]) {
        errorRequest(client, request, new RequestContentLengthMismatchError);
        return false;
      }
      process.emitWarning(new RequestContentLengthMismatchError);
    }
    const socket = client[kSocket];
    try {
      request.onConnect((err) => {
        if (request.aborted || request.completed) {
          return;
        }
        errorRequest(client, request, err || new RequestAbortedError);
        util.destroy(socket, new InformationalError("aborted"));
      });
    } catch (err) {
      errorRequest(client, request, err);
    }
    if (request.aborted) {
      return false;
    }
    if (method === "HEAD") {
      socket[kReset] = true;
    }
    if (upgrade || method === "CONNECT") {
      socket[kReset] = true;
    }
    if (reset != null) {
      socket[kReset] = reset;
    }
    if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
      socket[kReset] = true;
    }
    if (blocking) {
      socket[kBlocking] = true;
    }
    let header = `${method} ${path} HTTP/1.1\r\n`;
    if (typeof host === "string") {
      header += `host: ${host}\r\n`;
    } else {
      header += client[kHostHeader];
    }
    if (upgrade) {
      header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`;
    } else if (client[kPipelining] && !socket[kReset]) {
      header += "connection: keep-alive\r\n";
    } else {
      header += "connection: close\r\n";
    }
    if (headers) {
      header += headers;
    }
    if (channels.sendHeaders.hasSubscribers) {
      channels.sendHeaders.publish({ request, headers: header, socket });
    }
    if (!body) {
      if (contentLength === 0) {
        socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
      } else {
        assert(contentLength === null, "no body must not have content length");
        socket.write(`${header}\r\n`, "latin1");
      }
      request.onRequestSent();
    } else if (util.isBuffer(body)) {
      assert(contentLength === body.byteLength, "buffer body must have content length");
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
      socket.write(body);
      socket.uncork();
      request.onBodySent(body);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
    } else if (util.isBlobLike(body)) {
      if (typeof body.stream === "function") {
        writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
      } else {
        writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
      }
    } else if (util.isStream(body)) {
      writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
    } else if (util.isIterable(body)) {
      writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
    } else {
      assert(false);
    }
    return true;
  };
  var writeStream = function({ body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
    let finished = false;
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    const onData = function(chunk) {
      if (finished) {
        return;
      }
      try {
        if (!writer.write(chunk) && this.pause) {
          this.pause();
        }
      } catch (err) {
        util.destroy(this, err);
      }
    };
    const onDrain = function() {
      if (finished) {
        return;
      }
      if (body.resume) {
        body.resume();
      }
    };
    const onAbort = function() {
      onFinished(new RequestAbortedError);
    };
    const onFinished = function(err) {
      if (finished) {
        return;
      }
      finished = true;
      assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
      socket.off("drain", onDrain).off("error", onFinished);
      body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
      if (!err) {
        try {
          writer.end();
        } catch (er) {
          err = er;
        }
      }
      writer.destroy(err);
      if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
        util.destroy(body, err);
      } else {
        util.destroy(body);
      }
    };
    body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
    if (body.resume) {
      body.resume();
    }
    socket.on("drain", onDrain).on("error", onFinished);
  };
  async function writeBlob({ body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength === body.size, "blob body must have content length");
    try {
      if (contentLength != null && contentLength !== body.size) {
        throw new RequestContentLengthMismatchError;
      }
      const buffer = Buffer.from(await body.arrayBuffer());
      socket.cork();
      socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
      socket.write(buffer);
      socket.uncork();
      request.onBodySent(buffer);
      request.onRequestSent();
      if (!expectsPayload) {
        socket[kReset] = true;
      }
      resume(client);
    } catch (err) {
      util.destroy(socket, err);
    }
  }
  async function writeIterable({ body, client, request, socket, contentLength, header, expectsPayload }) {
    assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
    let callback = null;
    function onDrain() {
      if (callback) {
        const cb = callback;
        callback = null;
        cb();
      }
    }
    const waitForDrain = () => new Promise((resolve, reject) => {
      assert(callback === null);
      if (socket[kError]) {
        reject(socket[kError]);
      } else {
        callback = resolve;
      }
    });
    socket.on("close", onDrain).on("drain", onDrain);
    const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
    try {
      for await (const chunk of body) {
        if (socket[kError]) {
          throw socket[kError];
        }
        if (!writer.write(chunk)) {
          await waitForDrain();
        }
      }
      writer.end();
    } catch (err) {
      writer.destroy(err);
    } finally {
      socket.off("close", onDrain).off("drain", onDrain);
    }
  }
  var errorRequest = function(client, request, err) {
    try {
      request.onError(err);
      assert(request.aborted);
    } catch (err2) {
      client.emit("error", err2);
    }
  };
  var assert = __require("assert");
  var net = __require("net");
  var util = require_util();
  var timers = require_timers();
  var Request = require_request();
  var DispatcherBase = require_dispatcher_base();
  var {
    RequestContentLengthMismatchError,
    ResponseContentLengthMismatchError,
    InvalidArgumentError,
    RequestAbortedError,
    HeadersTimeoutError,
    HeadersOverflowError,
    SocketError,
    InformationalError,
    BodyTimeoutError,
    HTTPParserError,
    ResponseExceededMaxSizeError,
    ClientDestroyedError
  } = require_errors();
  var buildConnector = require_connect();
  var {
    kUrl,
    kReset,
    kServerName,
    kClient,
    kBusy,
    kParser,
    kConnect,
    kBlocking,
    kResuming,
    kRunning,
    kPending,
    kSize,
    kWriting,
    kQueue,
    kConnected,
    kConnecting,
    kNeedDrain,
    kNoRef,
    kKeepAliveDefaultTimeout,
    kHostHeader,
    kPendingIdx,
    kRunningIdx,
    kError,
    kPipelining,
    kSocket,
    kKeepAliveTimeoutValue,
    kMaxHeadersSize,
    kKeepAliveMaxTimeout,
    kKeepAliveTimeoutThreshold,
    kHeadersTimeout,
    kBodyTimeout,
    kStrictContentLength,
    kConnector,
    kMaxRedirections,
    kMaxRequests,
    kCounter,
    kClose,
    kDestroy,
    kDispatch,
    kInterceptors,
    kLocalAddress,
    kMaxResponseSize
  } = require_symbols();
  var FastBuffer = Buffer[Symbol.species];
  var kClosedResolve = Symbol("kClosedResolve");
  var channels = {};
  try {
    const diagnosticsChannel = __require("diagnostics_channel");
    channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
    channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
    channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
    channels.connected = diagnosticsChannel.channel("undici:client:connected");
  } catch {
    channels.sendHeaders = { hasSubscribers: false };
    channels.beforeConnect = { hasSubscribers: false };
    channels.connectError = { hasSubscribers: false };
    channels.connected = { hasSubscribers: false };
  }

  class Client extends DispatcherBase {
    constructor(url, {
      interceptors,
      maxHeaderSize,
      headersTimeout,
      socketTimeout,
      requestTimeout,
      connectTimeout,
      bodyTimeout,
      idleTimeout,
      keepAlive,
      keepAliveTimeout,
      maxKeepAliveTimeout,
      keepAliveMaxTimeout,
      keepAliveTimeoutThreshold,
      socketPath,
      pipelining,
      tls,
      strictContentLength,
      maxCachedSessions,
      maxRedirections,
      connect: connect2,
      maxRequestsPerClient,
      localAddress,
      maxResponseSize,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout
    } = {}) {
      super();
      if (keepAlive !== undefined) {
        throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
      }
      if (socketTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (requestTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
      }
      if (idleTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
      }
      if (maxKeepAliveTimeout !== undefined) {
        throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
      }
      if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
        throw new InvalidArgumentError("invalid maxHeaderSize");
      }
      if (socketPath != null && typeof socketPath !== "string") {
        throw new InvalidArgumentError("invalid socketPath");
      }
      if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
        throw new InvalidArgumentError("invalid connectTimeout");
      }
      if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveTimeout");
      }
      if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
        throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
      }
      if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
        throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
      }
      if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
        throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
      }
      if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
        throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
      }
      if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
        throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
      }
      if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
        throw new InvalidArgumentError("localAddress must be valid string IP address");
      }
      if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
        throw new InvalidArgumentError("maxResponseSize must be a positive number");
      }
      if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
        throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
      }
      if (typeof connect2 !== "function") {
        connect2 = buildConnector({
          ...tls,
          maxCachedSessions,
          socketPath,
          timeout: connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect2
        });
      }
      this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
      this[kUrl] = util.parseOrigin(url);
      this[kConnector] = connect2;
      this[kSocket] = null;
      this[kPipelining] = pipelining != null ? pipelining : 1;
      this[kMaxHeadersSize] = maxHeaderSize || 16384;
      this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4000 : keepAliveTimeout;
      this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600000 : keepAliveMaxTimeout;
      this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1000 : keepAliveTimeoutThreshold;
      this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
      this[kServerName] = null;
      this[kLocalAddress] = localAddress != null ? localAddress : null;
      this[kResuming] = 0;
      this[kNeedDrain] = 0;
      this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r\n`;
      this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300000;
      this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300000;
      this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
      this[kMaxRedirections] = maxRedirections;
      this[kMaxRequests] = maxRequestsPerClient;
      this[kClosedResolve] = null;
      this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
      this[kQueue] = [];
      this[kRunningIdx] = 0;
      this[kPendingIdx] = 0;
    }
    get pipelining() {
      return this[kPipelining];
    }
    set pipelining(value) {
      this[kPipelining] = value;
      resume(this, true);
    }
    get [kPending]() {
      return this[kQueue].length - this[kPendingIdx];
    }
    get [kRunning]() {
      return this[kPendingIdx] - this[kRunningIdx];
    }
    get [kSize]() {
      return this[kQueue].length - this[kRunningIdx];
    }
    get [kConnected]() {
      return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
    }
    get [kBusy]() {
      const socket = this[kSocket];
      return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
    }
    [kConnect](cb) {
      connect(this);
      this.once("connect", cb);
    }
    [kDispatch](opts, handler) {
      const origin = opts.origin || this[kUrl].origin;
      const request = new Request(origin, opts, handler);
      this[kQueue].push(request);
      if (this[kResuming]) {
      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
        this[kResuming] = 1;
        process.nextTick(resume, this);
      } else {
        resume(this, true);
      }
      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
        this[kNeedDrain] = 2;
      }
      return this[kNeedDrain] < 2;
    }
    async[kClose]() {
      return new Promise((resolve) => {
        if (!this[kSize]) {
          resolve(null);
        } else {
          this[kClosedResolve] = resolve;
        }
      });
    }
    async[kDestroy](err) {
      return new Promise((resolve) => {
        const requests = this[kQueue].splice(this[kPendingIdx]);
        for (let i = 0;i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
        const callback = () => {
          if (this[kClosedResolve]) {
            this[kClosedResolve]();
            this[kClosedResolve] = null;
          }
          resolve();
        };
        if (!this[kSocket]) {
          queueMicrotask(callback);
        } else {
          util.destroy(this[kSocket].on("close", callback), err);
        }
        resume(this);
      });
    }
  }
  var constants = require_constants2();
  var createRedirectInterceptor = require_redirectInterceptor();
  var EMPTY_BUF = Buffer.alloc(0);
  var llhttpInstance = null;
  var llhttpPromise = lazyllhttp();
  llhttpPromise.catch();
  var currentParser = null;
  var currentBufferRef = null;
  var currentBufferSize = 0;
  var currentBufferPtr = null;
  var TIMEOUT_HEADERS = 1;
  var TIMEOUT_BODY = 2;
  var TIMEOUT_IDLE = 3;

  class Parser {
    constructor(client, socket, { exports: exports2 }) {
      assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
      this.llhttp = exports2;
      this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
      this.client = client;
      this.socket = socket;
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.statusCode = null;
      this.statusText = "";
      this.upgrade = false;
      this.headers = [];
      this.headersSize = 0;
      this.headersMaxSize = client[kMaxHeadersSize];
      this.shouldKeepAlive = false;
      this.paused = false;
      this.resume = this.resume.bind(this);
      this.bytesRead = 0;
      this.keepAlive = "";
      this.contentLength = "";
      this.connection = "";
      this.maxResponseSize = client[kMaxResponseSize];
    }
    setTimeout(value, type) {
      this.timeoutType = type;
      if (value !== this.timeoutValue) {
        timers.clearTimeout(this.timeout);
        if (value) {
          this.timeout = timers.setTimeout(onParserTimeout, value, this);
          if (this.timeout.unref) {
            this.timeout.unref();
          }
        } else {
          this.timeout = null;
        }
        this.timeoutValue = value;
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) {
        return;
      }
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_resume(this.ptr);
      assert(this.timeoutType === TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      this.paused = false;
      this.execute(this.socket.read() || EMPTY_BUF);
      this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        const chunk = this.socket.read();
        if (chunk === null) {
          break;
        }
        this.execute(chunk);
      }
    }
    execute(data) {
      assert(this.ptr != null);
      assert(currentParser == null);
      assert(!this.paused);
      const { socket, llhttp } = this;
      if (data.length > currentBufferSize) {
        if (currentBufferPtr) {
          llhttp.free(currentBufferPtr);
        }
        currentBufferSize = Math.ceil(data.length / 4096) * 4096;
        currentBufferPtr = llhttp.malloc(currentBufferSize);
      }
      new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
      try {
        let ret;
        try {
          currentBufferRef = data;
          currentParser = this;
          ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
        } catch (err) {
          throw err;
        } finally {
          currentParser = null;
          currentBufferRef = null;
        }
        const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
        if (ret === constants.ERROR.PAUSED_UPGRADE) {
          this.onUpgrade(data.slice(offset));
        } else if (ret === constants.ERROR.PAUSED) {
          this.paused = true;
          socket.unshift(data.slice(offset));
        } else if (ret !== constants.ERROR.OK) {
          const ptr = llhttp.llhttp_get_error_reason(this.ptr);
          let message = "";
          if (ptr) {
            const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
            message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
          }
          throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
        }
      } catch (err) {
        util.destroy(socket, err);
      }
    }
    destroy() {
      assert(this.ptr != null);
      assert(currentParser == null);
      this.llhttp.llhttp_free(this.ptr);
      this.ptr = null;
      timers.clearTimeout(this.timeout);
      this.timeout = null;
      this.timeoutValue = null;
      this.timeoutType = null;
      this.paused = false;
    }
    onStatus(buf) {
      this.statusText = buf.toString();
    }
    onMessageBegin() {
      const { socket, client } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
    }
    onHeaderField(buf) {
      const len = this.headers.length;
      if ((len & 1) === 0) {
        this.headers.push(buf);
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      this.trackHeader(buf.length);
    }
    onHeaderValue(buf) {
      let len = this.headers.length;
      if ((len & 1) === 1) {
        this.headers.push(buf);
        len += 1;
      } else {
        this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
      }
      const key = this.headers[len - 2];
      if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
        this.keepAlive += buf.toString();
      } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
        this.connection += buf.toString();
      } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
        this.contentLength += buf.toString();
      }
      this.trackHeader(buf.length);
    }
    trackHeader(len) {
      this.headersSize += len;
      if (this.headersSize >= this.headersMaxSize) {
        util.destroy(this.socket, new HeadersOverflowError);
      }
    }
    onUpgrade(head) {
      const { upgrade, client, socket, headers, statusCode } = this;
      assert(upgrade);
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(!socket.destroyed);
      assert(socket === client[kSocket]);
      assert(!this.paused);
      assert(request.upgrade || request.method === "CONNECT");
      this.statusCode = null;
      this.statusText = "";
      this.shouldKeepAlive = null;
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      socket.unshift(head);
      socket[kParser].destroy();
      socket[kParser] = null;
      socket[kClient] = null;
      socket[kError] = null;
      socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
      client[kSocket] = null;
      client[kQueue][client[kRunningIdx]++] = null;
      client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
      try {
        request.onUpgrade(statusCode, headers, socket);
      } catch (err) {
        util.destroy(socket, err);
      }
      resume(client);
    }
    onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
      const { client, socket, headers, statusText } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      if (!request) {
        return -1;
      }
      assert(!this.upgrade);
      assert(this.statusCode < 200);
      if (statusCode === 100) {
        util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
        return -1;
      }
      if (upgrade && !request.upgrade) {
        util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
        return -1;
      }
      assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
      this.statusCode = statusCode;
      this.shouldKeepAlive = shouldKeepAlive || request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
      if (this.statusCode >= 200) {
        const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
        this.setTimeout(bodyTimeout, TIMEOUT_BODY);
      } else if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      if (request.method === "CONNECT") {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      if (upgrade) {
        assert(client[kRunning] === 1);
        this.upgrade = true;
        return 2;
      }
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (this.shouldKeepAlive && client[kPipelining]) {
        const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
        if (keepAliveTimeout != null) {
          const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);
          if (timeout <= 0) {
            socket[kReset] = true;
          } else {
            client[kKeepAliveTimeoutValue] = timeout;
          }
        } else {
          client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
        }
      } else {
        socket[kReset] = true;
      }
      let pause;
      try {
        pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
      } catch (err) {
        util.destroy(socket, err);
        return -1;
      }
      if (request.method === "HEAD") {
        return 1;
      }
      if (statusCode < 200) {
        return 1;
      }
      if (socket[kBlocking]) {
        socket[kBlocking] = false;
        resume(client);
      }
      return pause ? constants.ERROR.PAUSED : 0;
    }
    onBody(buf) {
      const { client, socket, statusCode, maxResponseSize } = this;
      if (socket.destroyed) {
        return -1;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
      if (this.timeout) {
        if (this.timeout.refresh) {
          this.timeout.refresh();
        }
      }
      assert(statusCode >= 200);
      if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
        util.destroy(socket, new ResponseExceededMaxSizeError);
        return -1;
      }
      this.bytesRead += buf.length;
      try {
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      } catch (err) {
        util.destroy(socket, err);
        return -1;
      }
    }
    onMessageComplete() {
      const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
      if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
        return -1;
      }
      if (upgrade) {
        return;
      }
      const request = client[kQueue][client[kRunningIdx]];
      assert(request);
      assert(statusCode >= 100);
      this.statusCode = null;
      this.statusText = "";
      this.bytesRead = 0;
      this.contentLength = "";
      this.keepAlive = "";
      this.connection = "";
      assert(this.headers.length % 2 === 0);
      this.headers = [];
      this.headersSize = 0;
      if (statusCode < 200) {
        return;
      }
      if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
        util.destroy(socket, new ResponseContentLengthMismatchError);
        return -1;
      }
      try {
        request.onComplete(headers);
      } catch (err) {
        errorRequest(client, request, err);
      }
      client[kQueue][client[kRunningIdx]++] = null;
      if (socket[kWriting]) {
        assert.strictEqual(client[kRunning], 0);
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (!shouldKeepAlive) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (socket[kReset] && client[kRunning] === 0) {
        util.destroy(socket, new InformationalError("reset"));
        return constants.ERROR.PAUSED;
      } else if (client[kPipelining] === 1) {
        setImmediate(resume, client);
      } else {
        resume(client);
      }
    }
  }

  class AsyncWriter {
    constructor({ socket, request, contentLength, client, expectsPayload, header }) {
      this.socket = socket;
      this.request = request;
      this.contentLength = contentLength;
      this.client = client;
      this.bytesWritten = 0;
      this.expectsPayload = expectsPayload;
      this.header = header;
      socket[kWriting] = true;
    }
    write(chunk) {
      const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return false;
      }
      const len = Buffer.byteLength(chunk);
      if (!len) {
        return true;
      }
      if (contentLength !== null && bytesWritten + len > contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        }
        process.emitWarning(new RequestContentLengthMismatchError);
      }
      socket.cork();
      if (bytesWritten === 0) {
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        if (contentLength === null) {
          socket.write(`${header}transfer-encoding: chunked\r\n`, "latin1");
        } else {
          socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, "latin1");
        }
      }
      if (contentLength === null) {
        socket.write(`\r\n${len.toString(16)}\r\n`, "latin1");
      }
      this.bytesWritten += len;
      const ret = socket.write(chunk);
      socket.uncork();
      request.onBodySent(chunk);
      if (!ret) {
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
      }
      return ret;
    }
    end() {
      const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
      request.onRequestSent();
      socket[kWriting] = false;
      if (socket[kError]) {
        throw socket[kError];
      }
      if (socket.destroyed) {
        return;
      }
      if (bytesWritten === 0) {
        if (expectsPayload) {
          socket.write(`${header}content-length: 0\r\n\r\n`, "latin1");
        } else {
          socket.write(`${header}\r\n`, "latin1");
        }
      } else if (contentLength === null) {
        socket.write("\r\n0\r\n\r\n", "latin1");
      }
      if (contentLength !== null && bytesWritten !== contentLength) {
        if (client[kStrictContentLength]) {
          throw new RequestContentLengthMismatchError;
        } else {
          process.emitWarning(new RequestContentLengthMismatchError);
        }
      }
      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
        if (socket[kParser].timeout.refresh) {
          socket[kParser].timeout.refresh();
        }
      }
      resume(client);
    }
    destroy(err) {
      const { socket, client } = this;
      socket[kWriting] = false;
      if (err) {
        assert(client[kRunning] <= 1, "pipeline should only contain this request");
        util.destroy(socket, err);
      }
    }
  }
  module.exports = Client;
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS((exports, module) => {
  var kSize = 2048;
  var kMask = kSize - 1;

  class FixedCircularBuffer {
    constructor() {
      this.bottom = 0;
      this.top = 0;
      this.list = new Array(kSize);
      this.next = null;
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
      this.list[this.top] = data;
      this.top = this.top + 1 & kMask;
    }
    shift() {
      const nextItem = this.list[this.bottom];
      if (nextItem === undefined)
        return null;
      this.list[this.bottom] = undefined;
      this.bottom = this.bottom + 1 & kMask;
      return nextItem;
    }
  }
  module.exports = class FixedQueue {
    constructor() {
      this.head = this.tail = new FixedCircularBuffer;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(data) {
      if (this.head.isFull()) {
        this.head = this.head.next = new FixedCircularBuffer;
      }
      this.head.push(data);
    }
    shift() {
      const tail = this.tail;
      const next = tail.shift();
      if (tail.isEmpty() && tail.next !== null) {
        this.tail = tail.next;
      }
      return next;
    }
  };
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS((exports, module) => {
  var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
  var kPool = Symbol("pool");

  class PoolStats {
    constructor(pool) {
      this[kPool] = pool;
    }
    get connected() {
      return this[kPool][kConnected];
    }
    get free() {
      return this[kPool][kFree];
    }
    get pending() {
      return this[kPool][kPending];
    }
    get queued() {
      return this[kPool][kQueued];
    }
    get running() {
      return this[kPool][kRunning];
    }
    get size() {
      return this[kPool][kSize];
    }
  }
  module.exports = PoolStats;
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS((exports, module) => {
  var DispatcherBase = require_dispatcher_base();
  var FixedQueue = require_fixed_queue();
  var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
  var PoolStats = require_pool_stats();
  var kClients = Symbol("clients");
  var kNeedDrain = Symbol("needDrain");
  var kQueue = Symbol("queue");
  var kClosedResolve = Symbol("closed resolve");
  var kOnDrain = Symbol("onDrain");
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kGetDispatcher = Symbol("get dispatcher");
  var kAddClient = Symbol("add client");
  var kRemoveClient = Symbol("remove client");
  var kStats = Symbol("stats");

  class PoolBase extends DispatcherBase {
    constructor() {
      super();
      this[kQueue] = new FixedQueue;
      this[kClients] = [];
      this[kQueued] = 0;
      const pool = this;
      this[kOnDrain] = function onDrain(origin, targets) {
        const queue = pool[kQueue];
        let needDrain = false;
        while (!needDrain) {
          const item = queue.shift();
          if (!item) {
            break;
          }
          pool[kQueued]--;
          needDrain = !this.dispatch(item.opts, item.handler);
        }
        this[kNeedDrain] = needDrain;
        if (!this[kNeedDrain] && pool[kNeedDrain]) {
          pool[kNeedDrain] = false;
          pool.emit("drain", origin, [pool, ...targets]);
        }
        if (pool[kClosedResolve] && queue.isEmpty()) {
          Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
        }
      };
      this[kOnConnect] = (origin, targets) => {
        pool.emit("connect", origin, [pool, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        pool.emit("disconnect", origin, [pool, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        pool.emit("connectionError", origin, [pool, ...targets], err);
      };
      this[kStats] = new PoolStats(this);
    }
    get [kBusy]() {
      return this[kNeedDrain];
    }
    get [kConnected]() {
      return this[kClients].filter((client) => client[kConnected]).length;
    }
    get [kFree]() {
      return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
    }
    get [kPending]() {
      let ret = this[kQueued];
      for (const { [kPending]: pending } of this[kClients]) {
        ret += pending;
      }
      return ret;
    }
    get [kRunning]() {
      let ret = 0;
      for (const { [kRunning]: running } of this[kClients]) {
        ret += running;
      }
      return ret;
    }
    get [kSize]() {
      let ret = this[kQueued];
      for (const { [kSize]: size } of this[kClients]) {
        ret += size;
      }
      return ret;
    }
    get stats() {
      return this[kStats];
    }
    async[kClose]() {
      if (this[kQueue].isEmpty()) {
        return Promise.all(this[kClients].map((c) => c.close()));
      } else {
        return new Promise((resolve) => {
          this[kClosedResolve] = resolve;
        });
      }
    }
    async[kDestroy](err) {
      while (true) {
        const item = this[kQueue].shift();
        if (!item) {
          break;
        }
        item.handler.onError(err);
      }
      return Promise.all(this[kClients].map((c) => c.destroy(err)));
    }
    [kDispatch](opts, handler) {
      const dispatcher = this[kGetDispatcher]();
      if (!dispatcher) {
        this[kNeedDrain] = true;
        this[kQueue].push({ opts, handler });
        this[kQueued]++;
      } else if (!dispatcher.dispatch(opts, handler)) {
        dispatcher[kNeedDrain] = true;
        this[kNeedDrain] = !this[kGetDispatcher]();
      }
      return !this[kNeedDrain];
    }
    [kAddClient](client) {
      client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
      this[kClients].push(client);
      if (this[kNeedDrain]) {
        process.nextTick(() => {
          if (this[kNeedDrain]) {
            this[kOnDrain](client[kUrl], [this, client]);
          }
        });
      }
      return this;
    }
    [kRemoveClient](client) {
      client.close(() => {
        const idx = this[kClients].indexOf(client);
        if (idx !== -1) {
          this[kClients].splice(idx, 1);
        }
      });
      this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
    }
  }
  module.exports = {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  };
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS((exports, module) => {
  var defaultFactory = function(origin, opts) {
    return new Client(origin, opts);
  };
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kGetDispatcher
  } = require_pool_base();
  var Client = require_client();
  var {
    InvalidArgumentError
  } = require_errors();
  var util = require_util();
  var { kUrl, kInterceptors } = require_symbols();
  var buildConnector = require_connect();
  var kOptions = Symbol("options");
  var kConnections = Symbol("connections");
  var kFactory = Symbol("factory");

  class Pool extends PoolBase {
    constructor(origin, {
      connections,
      factory = defaultFactory,
      connect,
      connectTimeout,
      tls,
      maxCachedSessions,
      socketPath,
      autoSelectFamily,
      autoSelectFamilyAttemptTimeout,
      ...options
    } = {}) {
      super();
      if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
        throw new InvalidArgumentError("invalid connections");
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (typeof connect !== "function") {
        connect = buildConnector({
          ...tls,
          maxCachedSessions,
          socketPath,
          timeout: connectTimeout == null ? 1e4 : connectTimeout,
          ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined,
          ...connect
        });
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
      this[kConnections] = connections || null;
      this[kUrl] = util.parseOrigin(origin);
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kFactory] = factory;
    }
    [kGetDispatcher]() {
      let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
      if (dispatcher) {
        return dispatcher;
      }
      if (!this[kConnections] || this[kClients].length < this[kConnections]) {
        dispatcher = this[kFactory](this[kUrl], this[kOptions]);
        this[kAddClient](dispatcher);
      }
      return dispatcher;
    }
  }
  module.exports = Pool;
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS((exports, module) => {
  var getGreatestCommonDivisor = function(a, b) {
    if (b === 0)
      return a;
    return getGreatestCommonDivisor(b, a % b);
  };
  var defaultFactory = function(origin, opts) {
    return new Pool(origin, opts);
  };
  var {
    BalancedPoolMissingUpstreamError,
    InvalidArgumentError
  } = require_errors();
  var {
    PoolBase,
    kClients,
    kNeedDrain,
    kAddClient,
    kRemoveClient,
    kGetDispatcher
  } = require_pool_base();
  var Pool = require_pool();
  var { kUrl, kInterceptors } = require_symbols();
  var { parseOrigin } = require_util();
  var kFactory = Symbol("factory");
  var kOptions = Symbol("options");
  var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
  var kCurrentWeight = Symbol("kCurrentWeight");
  var kIndex = Symbol("kIndex");
  var kWeight = Symbol("kWeight");
  var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
  var kErrorPenalty = Symbol("kErrorPenalty");

  class BalancedPool extends PoolBase {
    constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
      super();
      this[kOptions] = opts;
      this[kIndex] = -1;
      this[kCurrentWeight] = 0;
      this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
      this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
      if (!Array.isArray(upstreams)) {
        upstreams = [upstreams];
      }
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
      this[kFactory] = factory;
      for (const upstream of upstreams) {
        this.addUpstream(upstream);
      }
      this._updateBalancedPoolStats();
    }
    addUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
        return this;
      }
      const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
      this[kAddClient](pool);
      pool.on("connect", () => {
        pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
      });
      pool.on("connectionError", () => {
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
        this._updateBalancedPoolStats();
      });
      pool.on("disconnect", (...args) => {
        const err = args[2];
        if (err && err.code === "UND_ERR_SOCKET") {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        }
      });
      for (const client of this[kClients]) {
        client[kWeight] = this[kMaxWeightPerServer];
      }
      this._updateBalancedPoolStats();
      return this;
    }
    _updateBalancedPoolStats() {
      this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
    }
    removeUpstream(upstream) {
      const upstreamOrigin = parseOrigin(upstream).origin;
      const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
      if (pool) {
        this[kRemoveClient](pool);
      }
      return this;
    }
    get upstreams() {
      return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
    }
    [kGetDispatcher]() {
      if (this[kClients].length === 0) {
        throw new BalancedPoolMissingUpstreamError;
      }
      const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
      if (!dispatcher) {
        return;
      }
      const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
      if (allClientsBusy) {
        return;
      }
      let counter = 0;
      let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
      while (counter++ < this[kClients].length) {
        this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
        const pool = this[kClients][this[kIndex]];
        if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
          maxWeightIndex = this[kIndex];
        }
        if (this[kIndex] === 0) {
          this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
          if (this[kCurrentWeight] <= 0) {
            this[kCurrentWeight] = this[kMaxWeightPerServer];
          }
        }
        if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
          return pool;
        }
      }
      this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
      this[kIndex] = maxWeightIndex;
      return this[kClients][maxWeightIndex];
    }
  }
  module.exports = BalancedPool;
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS((exports, module) => {
  var { kConnected, kSize } = require_symbols();

  class CompatWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value[kConnected] === 0 && this.value[kSize] === 0 ? undefined : this.value;
    }
  }

  class CompatFinalizer {
    constructor(finalizer) {
      this.finalizer = finalizer;
    }
    register(dispatcher, key) {
      dispatcher.on("disconnect", () => {
        if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
          this.finalizer(key);
        }
      });
    }
  }
  module.exports = function() {
    return {
      WeakRef: global.WeakRef || CompatWeakRef,
      FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
    };
  };
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS((exports, module) => {
  var defaultFactory = function(origin, opts) {
    return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
  };
  var { InvalidArgumentError } = require_errors();
  var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
  var DispatcherBase = require_dispatcher_base();
  var Pool = require_pool();
  var Client = require_client();
  var util = require_util();
  var createRedirectInterceptor = require_redirectInterceptor();
  var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
  var kOnConnect = Symbol("onConnect");
  var kOnDisconnect = Symbol("onDisconnect");
  var kOnConnectionError = Symbol("onConnectionError");
  var kMaxRedirections = Symbol("maxRedirections");
  var kOnDrain = Symbol("onDrain");
  var kFactory = Symbol("factory");
  var kFinalizer = Symbol("finalizer");
  var kOptions = Symbol("options");

  class Agent extends DispatcherBase {
    constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
      super();
      if (typeof factory !== "function") {
        throw new InvalidArgumentError("factory must be a function.");
      }
      if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
        throw new InvalidArgumentError("connect must be a function or an object");
      }
      if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
        throw new InvalidArgumentError("maxRedirections must be a positive number");
      }
      if (connect && typeof connect !== "function") {
        connect = { ...connect };
      }
      this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
      this[kOptions] = { ...util.deepClone(options), connect };
      this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : undefined;
      this[kMaxRedirections] = maxRedirections;
      this[kFactory] = factory;
      this[kClients] = new Map;
      this[kFinalizer] = new FinalizationRegistry((key) => {
        const ref = this[kClients].get(key);
        if (ref !== undefined && ref.deref() === undefined) {
          this[kClients].delete(key);
        }
      });
      const agent = this;
      this[kOnDrain] = (origin, targets) => {
        agent.emit("drain", origin, [agent, ...targets]);
      };
      this[kOnConnect] = (origin, targets) => {
        agent.emit("connect", origin, [agent, ...targets]);
      };
      this[kOnDisconnect] = (origin, targets, err) => {
        agent.emit("disconnect", origin, [agent, ...targets], err);
      };
      this[kOnConnectionError] = (origin, targets, err) => {
        agent.emit("connectionError", origin, [agent, ...targets], err);
      };
    }
    get [kRunning]() {
      let ret = 0;
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          ret += client[kRunning];
        }
      }
      return ret;
    }
    [kDispatch](opts, handler) {
      let key;
      if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
        key = String(opts.origin);
      } else {
        throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
      }
      const ref = this[kClients].get(key);
      let dispatcher = ref ? ref.deref() : null;
      if (!dispatcher) {
        dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].set(key, new WeakRef2(dispatcher));
        this[kFinalizer].register(dispatcher, key);
      }
      return dispatcher.dispatch(opts, handler);
    }
    async[kClose]() {
      const closePromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          closePromises.push(client.close());
        }
      }
      await Promise.all(closePromises);
    }
    async[kDestroy](err) {
      const destroyPromises = [];
      for (const ref of this[kClients].values()) {
        const client = ref.deref();
        if (client) {
          destroyPromises.push(client.destroy(err));
        }
      }
      await Promise.all(destroyPromises);
    }
  }
  module.exports = Agent;
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS((exports, module) => {
  var isLocked = function(self2) {
    return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
  };
  var isUnusable = function(self2) {
    return util.isDisturbed(self2) || isLocked(self2);
  };
  async function consume(stream, type) {
    if (isUnusable(stream)) {
      throw new TypeError("unusable");
    }
    assert(!stream[kConsume]);
    return new Promise((resolve, reject) => {
      stream[kConsume] = {
        type,
        stream,
        resolve,
        reject,
        length: 0,
        body: []
      };
      stream.on("error", function(err) {
        consumeFinish(this[kConsume], err);
      }).on("close", function() {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError);
        }
      });
      process.nextTick(consumeStart, stream[kConsume]);
    });
  }
  var consumeStart = function(consume2) {
    if (consume2.body === null) {
      return;
    }
    const { _readableState: state } = consume2.stream;
    for (const chunk of state.buffer) {
      consumePush(consume2, chunk);
    }
    if (state.endEmitted) {
      consumeEnd(this[kConsume]);
    } else {
      consume2.stream.on("end", function() {
        consumeEnd(this[kConsume]);
      });
    }
    consume2.stream.resume();
    while (consume2.stream.read() != null) {
    }
  };
  var consumeEnd = function(consume2) {
    const { type, body, resolve, stream, length } = consume2;
    try {
      if (type === "text") {
        resolve(toUSVString(Buffer.concat(body)));
      } else if (type === "json") {
        resolve(JSON.parse(Buffer.concat(body)));
      } else if (type === "arrayBuffer") {
        const dst = new Uint8Array(length);
        let pos = 0;
        for (const buf of body) {
          dst.set(buf, pos);
          pos += buf.byteLength;
        }
        resolve(dst);
      } else if (type === "blob") {
        if (!Blob2) {
          Blob2 = __require("buffer").Blob;
        }
        resolve(new Blob2(body, { type: stream[kContentType] }));
      }
      consumeFinish(consume2);
    } catch (err) {
      stream.destroy(err);
    }
  };
  var consumePush = function(consume2, chunk) {
    consume2.length += chunk.length;
    consume2.body.push(chunk);
  };
  var consumeFinish = function(consume2, err) {
    if (consume2.body === null) {
      return;
    }
    if (err) {
      consume2.reject(err);
    } else {
      consume2.resolve();
    }
    consume2.type = null;
    consume2.stream = null;
    consume2.resolve = null;
    consume2.reject = null;
    consume2.length = 0;
    consume2.body = null;
  };
  var assert = __require("assert");
  var { Readable } = __require("stream");
  var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
  var util = require_util();
  var { ReadableStreamFrom, toUSVString } = require_util();
  var Blob2;
  var kConsume = Symbol("kConsume");
  var kReading = Symbol("kReading");
  var kBody = Symbol("kBody");
  var kAbort = Symbol("abort");
  var kContentType = Symbol("kContentType");
  module.exports = class BodyReadable extends Readable {
    constructor({
      resume,
      abort,
      contentType = "",
      highWaterMark = 64 * 1024
    }) {
      super({
        autoDestroy: true,
        read: resume,
        highWaterMark
      });
      this._readableState.dataEmitted = false;
      this[kAbort] = abort;
      this[kConsume] = null;
      this[kBody] = null;
      this[kContentType] = contentType;
      this[kReading] = false;
    }
    destroy(err) {
      if (this.destroyed) {
        return this;
      }
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      if (err) {
        this[kAbort]();
      }
      return super.destroy(err);
    }
    emit(ev, ...args) {
      if (ev === "data") {
        this._readableState.dataEmitted = true;
      } else if (ev === "error") {
        this._readableState.errorEmitted = true;
      }
      return super.emit(ev, ...args);
    }
    on(ev, ...args) {
      if (ev === "data" || ev === "readable") {
        this[kReading] = true;
      }
      return super.on(ev, ...args);
    }
    addListener(ev, ...args) {
      return this.on(ev, ...args);
    }
    off(ev, ...args) {
      const ret = super.off(ev, ...args);
      if (ev === "data" || ev === "readable") {
        this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      }
      return ret;
    }
    removeListener(ev, ...args) {
      return this.off(ev, ...args);
    }
    push(chunk) {
      if (this[kConsume] && chunk !== null && this.readableLength === 0) {
        consumePush(this[kConsume], chunk);
        return this[kReading] ? super.push(chunk) : true;
      }
      return super.push(chunk);
    }
    async text() {
      return consume(this, "text");
    }
    async json() {
      return consume(this, "json");
    }
    async blob() {
      return consume(this, "blob");
    }
    async arrayBuffer() {
      return consume(this, "arrayBuffer");
    }
    async formData() {
      throw new NotSupportedError;
    }
    get bodyUsed() {
      return util.isDisturbed(this);
    }
    get body() {
      if (!this[kBody]) {
        this[kBody] = ReadableStreamFrom(this);
        if (this[kConsume]) {
          this[kBody].getReader();
          assert(this[kBody].locked);
        }
      }
      return this[kBody];
    }
    async dump(opts) {
      let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
      const signal = opts && opts.signal;
      const abortFn = () => {
        this.destroy();
      };
      if (signal) {
        if (typeof signal !== "object" || !("aborted" in signal)) {
          throw new InvalidArgumentError("signal must be an AbortSignal");
        }
        util.throwIfAborted(signal);
        signal.addEventListener("abort", abortFn, { once: true });
      }
      try {
        for await (const chunk of this) {
          util.throwIfAborted(signal);
          limit -= Buffer.byteLength(chunk);
          if (limit < 0) {
            return;
          }
        }
      } catch {
        util.throwIfAborted(signal);
      } finally {
        if (signal) {
          signal.removeEventListener("abort", abortFn);
        }
      }
    }
  };
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS((exports, module) => {
  async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
    assert(body);
    let chunks = [];
    let limit = 0;
    for await (const chunk of body) {
      chunks.push(chunk);
      limit += chunk.length;
      if (limit > 128 * 1024) {
        chunks = null;
        break;
      }
    }
    if (statusCode === 204 || !contentType || !chunks) {
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
      return;
    }
    try {
      if (contentType.startsWith("application/json")) {
        const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
      if (contentType.startsWith("text/")) {
        const payload = toUSVString(Buffer.concat(chunks));
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
        return;
      }
    } catch (err) {
    }
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
  }
  var assert = __require("assert");
  var {
    ResponseStatusCodeError
  } = require_errors();
  var { toUSVString } = require_util();
  module.exports = { getResolveErrorBodyCallback };
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS((exports, module) => {
  var abort = function(self2) {
    if (self2.abort) {
      self2.abort();
    } else {
      self2.onError(new RequestAbortedError);
    }
  };
  var addSignal = function(self2, signal) {
    self2[kSignal] = null;
    self2[kListener] = null;
    if (!signal) {
      return;
    }
    if (signal.aborted) {
      abort(self2);
      return;
    }
    self2[kSignal] = signal;
    self2[kListener] = () => {
      abort(self2);
    };
    if ("addEventListener" in self2[kSignal]) {
      self2[kSignal].addEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].addListener("abort", self2[kListener]);
    }
  };
  var removeSignal = function(self2) {
    if (!self2[kSignal]) {
      return;
    }
    if ("removeEventListener" in self2[kSignal]) {
      self2[kSignal].removeEventListener("abort", self2[kListener]);
    } else {
      self2[kSignal].removeListener("abort", self2[kListener]);
    }
    self2[kSignal] = null;
    self2[kListener] = null;
  };
  var { RequestAbortedError } = require_errors();
  var kListener = Symbol("kListener");
  var kSignal = Symbol("kSignal");
  module.exports = {
    addSignal,
    removeSignal
  };
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS((exports, module) => {
  var request = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        request.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new RequestHandler(opts, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var Readable = require_readable();
  var {
    InvalidArgumentError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class RequestHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
          throw new InvalidArgumentError("invalid highWaterMark");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_REQUEST");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.body = body;
      this.trailers = {};
      this.context = null;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError;
      this.highWaterMark = highWaterMark;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
      const contentType = parsedHeaders["content-type"];
      const body = new Readable({ resume, abort, contentType, highWaterMark });
      this.callback = null;
      this.res = body;
      if (callback !== null) {
        if (this.throwOnError && statusCode >= 400) {
          this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body, contentType, statusCode, statusMessage, headers });
        } else {
          this.runInAsyncScope(callback, null, null, {
            statusCode,
            headers,
            trailers: this.trailers,
            opaque,
            body,
            context
          });
        }
      }
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      util.parseHeaders(trailers, this.trailers);
      res.push(null);
    }
    onError(err) {
      const { res, callback, body, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (res) {
        this.res = null;
        queueMicrotask(() => {
          util.destroy(res, err);
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = request;
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS((exports, module) => {
  var stream = function(opts, factory, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        stream.call(this, opts, factory, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      this.dispatch(opts, new StreamHandler(opts, factory, callback));
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { finished, PassThrough } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { getResolveErrorBodyCallback } = require_util3();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();

  class StreamHandler extends AsyncResource {
    constructor(opts, factory, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
      try {
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("invalid factory");
        }
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_STREAM");
      } catch (err) {
        if (util.isStream(body)) {
          util.destroy(body.on("error", util.nop), err);
        }
        throw err;
      }
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.factory = factory;
      this.callback = callback;
      this.res = null;
      this.abort = null;
      this.context = null;
      this.trailers = null;
      this.body = body;
      this.onInfo = onInfo || null;
      this.throwOnError = throwOnError || false;
      if (util.isStream(body)) {
        body.on("error", (err) => {
          this.onError(err);
        });
      }
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume, statusMessage) {
      const { factory, opaque, context, callback, responseHeaders } = this;
      const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      if (statusCode < 200) {
        if (this.onInfo) {
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.factory = null;
      let res;
      if (this.throwOnError && statusCode >= 400) {
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        res = new PassThrough;
        this.callback = null;
        this.runInAsyncScope(getResolveErrorBodyCallback, null, { callback, body: res, contentType, statusCode, statusMessage, headers });
      } else {
        res = this.runInAsyncScope(factory, null, {
          statusCode,
          headers,
          opaque,
          context
        });
        if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
          throw new InvalidReturnValueError("expected Writable");
        }
        finished(res, { readable: false }, (err) => {
          const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
          this.res = null;
          if (err || !res2.readable) {
            util.destroy(res2, err);
          }
          this.callback = null;
          this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
          if (err) {
            abort();
          }
        });
      }
      res.on("drain", resume);
      this.res = res;
      const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
      return needDrain !== true;
    }
    onData(chunk) {
      const { res } = this;
      return res.write(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      removeSignal(this);
      this.trailers = util.parseHeaders(trailers);
      res.end();
    }
    onError(err) {
      const { res, callback, opaque, body } = this;
      removeSignal(this);
      this.factory = null;
      if (res) {
        this.res = null;
        util.destroy(res, err);
      } else if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
      if (body) {
        this.body = null;
        util.destroy(body, err);
      }
    }
  }
  module.exports = stream;
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS((exports, module) => {
  var pipeline = function(opts, handler) {
    try {
      const pipelineHandler = new PipelineHandler(opts, handler);
      this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
      return pipelineHandler.ret;
    } catch (err) {
      return new PassThrough().destroy(err);
    }
  };
  var {
    Readable,
    Duplex,
    PassThrough
  } = __require("stream");
  var {
    InvalidArgumentError,
    InvalidReturnValueError,
    RequestAbortedError
  } = require_errors();
  var util = require_util();
  var { AsyncResource } = __require("async_hooks");
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");
  var kResume = Symbol("resume");

  class PipelineRequest extends Readable {
    constructor() {
      super({ autoDestroy: true });
      this[kResume] = null;
    }
    _read() {
      const { [kResume]: resume } = this;
      if (resume) {
        this[kResume] = null;
        resume();
      }
    }
    _destroy(err, callback) {
      this._read();
      callback(err);
    }
  }

  class PipelineResponse extends Readable {
    constructor(resume) {
      super({ autoDestroy: true });
      this[kResume] = resume;
    }
    _read() {
      this[kResume]();
    }
    _destroy(err, callback) {
      if (!err && !this._readableState.endEmitted) {
        err = new RequestAbortedError;
      }
      callback(err);
    }
  }

  class PipelineHandler extends AsyncResource {
    constructor(opts, handler) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof handler !== "function") {
        throw new InvalidArgumentError("invalid handler");
      }
      const { signal, method, opaque, onInfo, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      if (method === "CONNECT") {
        throw new InvalidArgumentError("invalid method");
      }
      if (onInfo && typeof onInfo !== "function") {
        throw new InvalidArgumentError("invalid onInfo callback");
      }
      super("UNDICI_PIPELINE");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.handler = handler;
      this.abort = null;
      this.context = null;
      this.onInfo = onInfo || null;
      this.req = new PipelineRequest().on("error", util.nop);
      this.ret = new Duplex({
        readableObjectMode: opts.objectMode,
        autoDestroy: true,
        read: () => {
          const { body } = this;
          if (body && body.resume) {
            body.resume();
          }
        },
        write: (chunk, encoding, callback) => {
          const { req } = this;
          if (req.push(chunk, encoding) || req._readableState.destroyed) {
            callback();
          } else {
            req[kResume] = callback;
          }
        },
        destroy: (err, callback) => {
          const { body, req, res, ret, abort } = this;
          if (!err && !ret._readableState.endEmitted) {
            err = new RequestAbortedError;
          }
          if (abort && err) {
            abort();
          }
          util.destroy(body, err);
          util.destroy(req, err);
          util.destroy(res, err);
          removeSignal(this);
          callback(err);
        }
      }).on("prefinish", () => {
        const { req } = this;
        req.push(null);
      });
      this.res = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      const { ret, res } = this;
      assert(!res, "pipeline cannot be retried");
      if (ret.destroyed) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders(statusCode, rawHeaders, resume) {
      const { opaque, handler, context } = this;
      if (statusCode < 200) {
        if (this.onInfo) {
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          this.onInfo({ statusCode, headers });
        }
        return;
      }
      this.res = new PipelineResponse(resume);
      let body;
      try {
        this.handler = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        body = this.runInAsyncScope(handler, null, {
          statusCode,
          headers,
          opaque,
          body: this.res,
          context
        });
      } catch (err) {
        this.res.on("error", util.nop);
        throw err;
      }
      if (!body || typeof body.on !== "function") {
        throw new InvalidReturnValueError("expected Readable");
      }
      body.on("data", (chunk) => {
        const { ret, body: body2 } = this;
        if (!ret.push(chunk) && body2.pause) {
          body2.pause();
        }
      }).on("error", (err) => {
        const { ret } = this;
        util.destroy(ret, err);
      }).on("end", () => {
        const { ret } = this;
        ret.push(null);
      }).on("close", () => {
        const { ret } = this;
        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError);
        }
      });
      this.body = body;
    }
    onData(chunk) {
      const { res } = this;
      return res.push(chunk);
    }
    onComplete(trailers) {
      const { res } = this;
      res.push(null);
    }
    onError(err) {
      const { ret } = this;
      this.handler = null;
      util.destroy(ret, err);
    }
  }
  module.exports = pipeline;
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS((exports, module) => {
  var upgrade = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        upgrade.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const upgradeHandler = new UpgradeHandler(opts, callback);
      this.dispatch({
        ...opts,
        method: opts.method || "GET",
        upgrade: opts.protocol || "Websocket"
      }, upgradeHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var { AsyncResource } = __require("async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();
  var assert = __require("assert");

  class UpgradeHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_UPGRADE");
      this.responseHeaders = responseHeaders || null;
      this.opaque = opaque || null;
      this.callback = callback;
      this.abort = null;
      this.context = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = null;
    }
    onHeaders() {
      throw new SocketError("bad upgrade", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      assert.strictEqual(statusCode, 101);
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = upgrade;
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS((exports, module) => {
  var connect = function(opts, callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        connect.call(this, opts, (err, data) => {
          return err ? reject(err) : resolve(data);
        });
      });
    }
    try {
      const connectHandler = new ConnectHandler(opts, callback);
      this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
    } catch (err) {
      if (typeof callback !== "function") {
        throw err;
      }
      const opaque = opts && opts.opaque;
      queueMicrotask(() => callback(err, { opaque }));
    }
  };
  var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
  var { AsyncResource } = __require("async_hooks");
  var util = require_util();
  var { addSignal, removeSignal } = require_abort_signal();

  class ConnectHandler extends AsyncResource {
    constructor(opts, callback) {
      if (!opts || typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (typeof callback !== "function") {
        throw new InvalidArgumentError("invalid callback");
      }
      const { signal, opaque, responseHeaders } = opts;
      if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
        throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
      }
      super("UNDICI_CONNECT");
      this.opaque = opaque || null;
      this.responseHeaders = responseHeaders || null;
      this.callback = callback;
      this.abort = null;
      addSignal(this, signal);
    }
    onConnect(abort, context) {
      if (!this.callback) {
        throw new RequestAbortedError;
      }
      this.abort = abort;
      this.context = context;
    }
    onHeaders() {
      throw new SocketError("bad connect", null);
    }
    onUpgrade(statusCode, rawHeaders, socket) {
      const { callback, opaque, context } = this;
      removeSignal(this);
      this.callback = null;
      const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        socket,
        opaque,
        context
      });
    }
    onError(err) {
      const { callback, opaque } = this;
      removeSignal(this);
      if (callback) {
        this.callback = null;
        queueMicrotask(() => {
          this.runInAsyncScope(callback, null, err, { opaque });
        });
      }
    }
  }
  module.exports = connect;
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS((exports, module) => {
  exports.request = require_api_request();
  exports.stream = require_api_stream();
  exports.pipeline = require_api_pipeline();
  exports.upgrade = require_api_upgrade();
  exports.connect = require_api_connect();
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS((exports, module) => {
  var { UndiciError } = require_errors();

  class MockNotMatchedError extends UndiciError {
    constructor(message) {
      super(message);
      Error.captureStackTrace(this, MockNotMatchedError);
      this.name = "MockNotMatchedError";
      this.message = message || "The request does not match any registered mock dispatches";
      this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
    }
  }
  module.exports = {
    MockNotMatchedError
  };
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS((exports, module) => {
  module.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected")
  };
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS((exports, module) => {
  var matchValue = function(match, value) {
    if (typeof match === "string") {
      return match === value;
    }
    if (match instanceof RegExp) {
      return match.test(value);
    }
    if (typeof match === "function") {
      return match(value) === true;
    }
    return false;
  };
  var lowerCaseEntries = function(headers) {
    return Object.fromEntries(Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue];
    }));
  };
  var getHeaderByName = function(headers, key) {
    if (Array.isArray(headers)) {
      for (let i = 0;i < headers.length; i += 2) {
        if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
          return headers[i + 1];
        }
      }
      return;
    } else if (typeof headers.get === "function") {
      return headers.get(key);
    } else {
      return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
    }
  };
  var buildHeadersFromArray = function(headers) {
    const clone = headers.slice();
    const entries = [];
    for (let index = 0;index < clone.length; index += 2) {
      entries.push([clone[index], clone[index + 1]]);
    }
    return Object.fromEntries(entries);
  };
  var matchHeaders = function(mockDispatch2, headers) {
    if (typeof mockDispatch2.headers === "function") {
      if (Array.isArray(headers)) {
        headers = buildHeadersFromArray(headers);
      }
      return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
    }
    if (typeof mockDispatch2.headers === "undefined") {
      return true;
    }
    if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
      return false;
    }
    for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
      const headerValue = getHeaderByName(headers, matchHeaderName);
      if (!matchValue(matchHeaderValue, headerValue)) {
        return false;
      }
    }
    return true;
  };
  var safeUrl = function(path) {
    if (typeof path !== "string") {
      return path;
    }
    const pathSegments = path.split("?");
    if (pathSegments.length !== 2) {
      return path;
    }
    const qp = new URLSearchParams(pathSegments.pop());
    qp.sort();
    return [...pathSegments, qp.toString()].join("?");
  };
  var matchKey = function(mockDispatch2, { path, method, body, headers }) {
    const pathMatch = matchValue(mockDispatch2.path, path);
    const methodMatch = matchValue(mockDispatch2.method, method);
    const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
    const headersMatch = matchHeaders(mockDispatch2, headers);
    return pathMatch && methodMatch && bodyMatch && headersMatch;
  };
  var getResponseData = function(data) {
    if (Buffer.isBuffer(data)) {
      return data;
    } else if (typeof data === "object") {
      return JSON.stringify(data);
    } else {
      return data.toString();
    }
  };
  var getMockDispatch = function(mockDispatches, key) {
    const basePath = key.query ? buildURL(key.path, key.query) : key.path;
    const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
    let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
    }
    matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
    if (matchedMockDispatches.length === 0) {
      throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
    }
    return matchedMockDispatches[0];
  };
  var addMockDispatch = function(mockDispatches, key, data) {
    const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
    const replyData = typeof data === "function" ? { callback: data } : { ...data };
    const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
    mockDispatches.push(newMockDispatch);
    return newMockDispatch;
  };
  var deleteMockDispatch = function(mockDispatches, key) {
    const index = mockDispatches.findIndex((dispatch) => {
      if (!dispatch.consumed) {
        return false;
      }
      return matchKey(dispatch, key);
    });
    if (index !== -1) {
      mockDispatches.splice(index, 1);
    }
  };
  var buildKey = function(opts) {
    const { path, method, body, headers, query } = opts;
    return {
      path,
      method,
      body,
      headers,
      query
    };
  };
  var generateKeyValues = function(data) {
    return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
      ...keyValuePairs,
      Buffer.from(`${key}`),
      Array.isArray(value) ? value.map((x) => Buffer.from(`${x}`)) : Buffer.from(`${value}`)
    ], []);
  };
  var getStatusText = function(statusCode) {
    return STATUS_CODES[statusCode] || "unknown";
  };
  async function getResponse(body) {
    const buffers = [];
    for await (const data of body) {
      buffers.push(data);
    }
    return Buffer.concat(buffers).toString("utf8");
  }
  var mockDispatch = function(opts, handler) {
    const key = buildKey(opts);
    const mockDispatch2 = getMockDispatch(this[kDispatches], key);
    mockDispatch2.timesInvoked++;
    if (mockDispatch2.data.callback) {
      mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
    }
    const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
    const { timesInvoked, times } = mockDispatch2;
    mockDispatch2.consumed = !persist && timesInvoked >= times;
    mockDispatch2.pending = timesInvoked < times;
    if (error !== null) {
      deleteMockDispatch(this[kDispatches], key);
      handler.onError(error);
      return true;
    }
    if (typeof delay === "number" && delay > 0) {
      setTimeout(() => {
        handleReply(this[kDispatches]);
      }, delay);
    } else {
      handleReply(this[kDispatches]);
    }
    function handleReply(mockDispatches, _data = data) {
      const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
      const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
      if (isPromise(body)) {
        body.then((newData) => handleReply(mockDispatches, newData));
        return;
      }
      const responseData = getResponseData(body);
      const responseHeaders = generateKeyValues(headers);
      const responseTrailers = generateKeyValues(trailers);
      handler.abort = nop;
      handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
      handler.onData(Buffer.from(responseData));
      handler.onComplete(responseTrailers);
      deleteMockDispatch(mockDispatches, key);
    }
    function resume() {
    }
    return true;
  };
  var buildMockDispatch = function() {
    const agent = this[kMockAgent];
    const origin = this[kOrigin];
    const originalDispatch = this[kOriginalDispatch];
    return function dispatch(opts, handler) {
      if (agent.isMockActive) {
        try {
          mockDispatch.call(this, opts, handler);
        } catch (error) {
          if (error instanceof MockNotMatchedError) {
            const netConnect = agent[kGetNetConnect]();
            if (netConnect === false) {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
            }
            if (checkNetConnect(netConnect, origin)) {
              originalDispatch.call(this, opts, handler);
            } else {
              throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
            }
          } else {
            throw error;
          }
        }
      } else {
        originalDispatch.call(this, opts, handler);
      }
    };
  };
  var checkNetConnect = function(netConnect, origin) {
    const url = new URL(origin);
    if (netConnect === true) {
      return true;
    } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
      return true;
    }
    return false;
  };
  var buildMockOptions = function(opts) {
    if (opts) {
      const { agent, ...mockOptions } = opts;
      return mockOptions;
    }
  };
  var { MockNotMatchedError } = require_mock_errors();
  var {
    kDispatches,
    kMockAgent,
    kOriginalDispatch,
    kOrigin,
    kGetNetConnect
  } = require_mock_symbols();
  var { buildURL, nop } = require_util();
  var { STATUS_CODES } = __require("http");
  var {
    types: {
      isPromise
    }
  } = __require("util");
  module.exports = {
    getResponseData,
    getMockDispatch,
    addMockDispatch,
    deleteMockDispatch,
    buildKey,
    generateKeyValues,
    matchValue,
    getResponse,
    getStatusText,
    mockDispatch,
    buildMockDispatch,
    checkNetConnect,
    buildMockOptions,
    getHeaderByName
  };
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS((exports, module) => {
  var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kDispatchKey,
    kDefaultHeaders,
    kDefaultTrailers,
    kContentLength,
    kMockDispatch
  } = require_mock_symbols();
  var { InvalidArgumentError } = require_errors();
  var { buildURL } = require_util();

  class MockScope {
    constructor(mockDispatch) {
      this[kMockDispatch] = mockDispatch;
    }
    delay(waitInMs) {
      if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
        throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
      }
      this[kMockDispatch].delay = waitInMs;
      return this;
    }
    persist() {
      this[kMockDispatch].persist = true;
      return this;
    }
    times(repeatTimes) {
      if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
        throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
      }
      this[kMockDispatch].times = repeatTimes;
      return this;
    }
  }

  class MockInterceptor {
    constructor(opts, mockDispatches) {
      if (typeof opts !== "object") {
        throw new InvalidArgumentError("opts must be an object");
      }
      if (typeof opts.path === "undefined") {
        throw new InvalidArgumentError("opts.path must be defined");
      }
      if (typeof opts.method === "undefined") {
        opts.method = "GET";
      }
      if (typeof opts.path === "string") {
        if (opts.query) {
          opts.path = buildURL(opts.path, opts.query);
        } else {
          const parsedURL = new URL(opts.path, "data://");
          opts.path = parsedURL.pathname + parsedURL.search;
        }
      }
      if (typeof opts.method === "string") {
        opts.method = opts.method.toUpperCase();
      }
      this[kDispatchKey] = buildKey(opts);
      this[kDispatches] = mockDispatches;
      this[kDefaultHeaders] = {};
      this[kDefaultTrailers] = {};
      this[kContentLength] = false;
    }
    createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
      const responseData = getResponseData(data);
      const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
      const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
      const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
      return { statusCode, data, headers, trailers };
    }
    validateReplyParameters(statusCode, data, responseOptions) {
      if (typeof statusCode === "undefined") {
        throw new InvalidArgumentError("statusCode must be defined");
      }
      if (typeof data === "undefined") {
        throw new InvalidArgumentError("data must be defined");
      }
      if (typeof responseOptions !== "object") {
        throw new InvalidArgumentError("responseOptions must be an object");
      }
    }
    reply(replyData) {
      if (typeof replyData === "function") {
        const wrappedDefaultsCallback = (opts) => {
          const resolvedData = replyData(opts);
          if (typeof resolvedData !== "object") {
            throw new InvalidArgumentError("reply options callback must return an object");
          }
          const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
          this.validateReplyParameters(statusCode2, data2, responseOptions2);
          return {
            ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
          };
        };
        const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
        return new MockScope(newMockDispatch2);
      }
      const [statusCode, data = "", responseOptions = {}] = [...arguments];
      this.validateReplyParameters(statusCode, data, responseOptions);
      const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
      return new MockScope(newMockDispatch);
    }
    replyWithError(error) {
      if (typeof error === "undefined") {
        throw new InvalidArgumentError("error must be defined");
      }
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
      return new MockScope(newMockDispatch);
    }
    defaultReplyHeaders(headers) {
      if (typeof headers === "undefined") {
        throw new InvalidArgumentError("headers must be defined");
      }
      this[kDefaultHeaders] = headers;
      return this;
    }
    defaultReplyTrailers(trailers) {
      if (typeof trailers === "undefined") {
        throw new InvalidArgumentError("trailers must be defined");
      }
      this[kDefaultTrailers] = trailers;
      return this;
    }
    replyContentLength() {
      this[kContentLength] = true;
      return this;
    }
  }
  exports.MockInterceptor = MockInterceptor;
  exports.MockScope = MockScope;
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Client = require_client();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockClient extends Client {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockClient;
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS((exports, module) => {
  var { promisify } = __require("util");
  var Pool = require_pool();
  var { buildMockDispatch } = require_mock_utils();
  var {
    kDispatches,
    kMockAgent,
    kClose,
    kOriginalClose,
    kOrigin,
    kOriginalDispatch,
    kConnected
  } = require_mock_symbols();
  var { MockInterceptor } = require_mock_interceptor();
  var Symbols = require_symbols();
  var { InvalidArgumentError } = require_errors();

  class MockPool extends Pool {
    constructor(origin, opts) {
      super(origin, opts);
      if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      this[kMockAgent] = opts.agent;
      this[kOrigin] = origin;
      this[kDispatches] = [];
      this[kConnected] = 1;
      this[kOriginalDispatch] = this.dispatch;
      this[kOriginalClose] = this.close.bind(this);
      this.dispatch = buildMockDispatch.call(this);
      this.close = this[kClose];
    }
    get [Symbols.kConnected]() {
      return this[kConnected];
    }
    intercept(opts) {
      return new MockInterceptor(opts, this[kDispatches]);
    }
    async[kClose]() {
      await promisify(this[kOriginalClose])();
      this[kConnected] = 0;
      this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
    }
  }
  module.exports = MockPool;
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS((exports, module) => {
  var singulars = {
    pronoun: "it",
    is: "is",
    was: "was",
    this: "this"
  };
  var plurals = {
    pronoun: "they",
    is: "are",
    was: "were",
    this: "these"
  };
  module.exports = class Pluralizer {
    constructor(singular, plural) {
      this.singular = singular;
      this.plural = plural;
    }
    pluralize(count) {
      const one = count === 1;
      const keys = one ? singulars : plurals;
      const noun = one ? this.singular : this.plural;
      return { ...keys, count, noun };
    }
  };
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS((exports, module) => {
  var { Transform } = __require("stream");
  var { Console } = __require("console");
  module.exports = class PendingInterceptorsFormatter {
    constructor({ disableColors } = {}) {
      this.transform = new Transform({
        transform(chunk, _enc, cb) {
          cb(null, chunk);
        }
      });
      this.logger = new Console({
        stdout: this.transform,
        inspectOptions: {
          colors: !disableColors && !process.env.CI
        }
      });
    }
    format(pendingInterceptors) {
      const withPrettyHeaders = pendingInterceptors.map(({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        "Status code": statusCode,
        Persistent: persist ? "\u2705" : "\u274C",
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }));
      this.logger.table(withPrettyHeaders);
      return this.transform.read().toString();
    }
  };
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS((exports, module) => {
  var { kClients } = require_symbols();
  var Agent = require_agent();
  var {
    kAgent,
    kMockAgentSet,
    kMockAgentGet,
    kDispatches,
    kIsMockActive,
    kNetConnect,
    kGetNetConnect,
    kOptions,
    kFactory
  } = require_mock_symbols();
  var MockClient = require_mock_client();
  var MockPool = require_mock_pool();
  var { matchValue, buildMockOptions } = require_mock_utils();
  var { InvalidArgumentError, UndiciError } = require_errors();
  var Dispatcher = require_dispatcher();
  var Pluralizer = require_pluralizer();
  var PendingInterceptorsFormatter = require_pending_interceptors_formatter();

  class FakeWeakRef {
    constructor(value) {
      this.value = value;
    }
    deref() {
      return this.value;
    }
  }

  class MockAgent extends Dispatcher {
    constructor(opts) {
      super(opts);
      this[kNetConnect] = true;
      this[kIsMockActive] = true;
      if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument opts.agent must implement Agent");
      }
      const agent = opts && opts.agent ? opts.agent : new Agent(opts);
      this[kAgent] = agent;
      this[kClients] = agent[kClients];
      this[kOptions] = buildMockOptions(opts);
    }
    get(origin) {
      let dispatcher = this[kMockAgentGet](origin);
      if (!dispatcher) {
        dispatcher = this[kFactory](origin);
        this[kMockAgentSet](origin, dispatcher);
      }
      return dispatcher;
    }
    dispatch(opts, handler) {
      this.get(opts.origin);
      return this[kAgent].dispatch(opts, handler);
    }
    async close() {
      await this[kAgent].close();
      this[kClients].clear();
    }
    deactivate() {
      this[kIsMockActive] = false;
    }
    activate() {
      this[kIsMockActive] = true;
    }
    enableNetConnect(matcher) {
      if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
        if (Array.isArray(this[kNetConnect])) {
          this[kNetConnect].push(matcher);
        } else {
          this[kNetConnect] = [matcher];
        }
      } else if (typeof matcher === "undefined") {
        this[kNetConnect] = true;
      } else {
        throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
      }
    }
    disableNetConnect() {
      this[kNetConnect] = false;
    }
    get isMockActive() {
      return this[kIsMockActive];
    }
    [kMockAgentSet](origin, dispatcher) {
      this[kClients].set(origin, new FakeWeakRef(dispatcher));
    }
    [kFactory](origin) {
      const mockOptions = Object.assign({ agent: this }, this[kOptions]);
      return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
    }
    [kMockAgentGet](origin) {
      const ref = this[kClients].get(origin);
      if (ref) {
        return ref.deref();
      }
      if (typeof origin !== "string") {
        const dispatcher = this[kFactory]("http://localhost:9999");
        this[kMockAgentSet](origin, dispatcher);
        return dispatcher;
      }
      for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
        const nonExplicitDispatcher = nonExplicitRef.deref();
        if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
          const dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
          dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
          return dispatcher;
        }
      }
    }
    [kGetNetConnect]() {
      return this[kNetConnect];
    }
    pendingInterceptors() {
      const mockAgentClients = this[kClients];
      return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
    }
    assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter } = {}) {
      const pending = this.pendingInterceptors();
      if (pending.length === 0) {
        return;
      }
      const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
      throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
    }
  }
  module.exports = MockAgent;
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS((exports, module) => {
  var defaultProtocolPort = function(protocol) {
    return protocol === "https:" ? 443 : 80;
  };
  var buildProxyOptions = function(opts) {
    if (typeof opts === "string") {
      opts = { uri: opts };
    }
    if (!opts || !opts.uri) {
      throw new InvalidArgumentError("Proxy opts.uri is mandatory");
    }
    return {
      uri: opts.uri,
      protocol: opts.protocol || "https"
    };
  };
  var defaultFactory = function(origin, opts) {
    return new Pool(origin, opts);
  };
  var buildHeaders = function(headers) {
    if (Array.isArray(headers)) {
      const headersPair = {};
      for (let i = 0;i < headers.length; i += 2) {
        headersPair[headers[i]] = headers[i + 1];
      }
      return headersPair;
    }
    return headers;
  };
  var throwIfProxyAuthIsSent = function(headers) {
    const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
    if (existProxyAuth) {
      throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
    }
  };
  var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
  var { URL: URL2 } = __require("url");
  var Agent = require_agent();
  var Pool = require_pool();
  var DispatcherBase = require_dispatcher_base();
  var { InvalidArgumentError, RequestAbortedError } = require_errors();
  var buildConnector = require_connect();
  var kAgent = Symbol("proxy agent");
  var kClient = Symbol("proxy client");
  var kProxyHeaders = Symbol("proxy headers");
  var kRequestTls = Symbol("request tls settings");
  var kProxyTls = Symbol("proxy tls settings");
  var kConnectEndpoint = Symbol("connect endpoint function");

  class ProxyAgent extends DispatcherBase {
    constructor(opts) {
      super(opts);
      this[kProxy] = buildProxyOptions(opts);
      this[kAgent] = new Agent(opts);
      this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      const { clientFactory = defaultFactory } = opts;
      if (typeof clientFactory !== "function") {
        throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
      }
      this[kRequestTls] = opts.requestTls;
      this[kProxyTls] = opts.proxyTls;
      this[kProxyHeaders] = opts.headers || {};
      if (opts.auth && opts.token) {
        throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
      } else if (opts.auth) {
        this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
      } else if (opts.token) {
        this[kProxyHeaders]["proxy-authorization"] = opts.token;
      }
      const resolvedUrl = new URL2(opts.uri);
      const { origin, port, host } = resolvedUrl;
      const connect = buildConnector({ ...opts.proxyTls });
      this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
      this[kClient] = clientFactory(resolvedUrl, { connect });
      this[kAgent] = new Agent({
        ...opts,
        connect: async (opts2, callback) => {
          let requestedHost = opts2.host;
          if (!opts2.port) {
            requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
          }
          try {
            const { socket, statusCode } = await this[kClient].connect({
              origin,
              port,
              path: requestedHost,
              signal: opts2.signal,
              headers: {
                ...this[kProxyHeaders],
                host
              }
            });
            if (statusCode !== 200) {
              socket.on("error", () => {
              }).destroy();
              callback(new RequestAbortedError("Proxy response !== 200 when HTTP Tunneling"));
            }
            if (opts2.protocol !== "https:") {
              callback(null, socket);
              return;
            }
            let servername;
            if (this[kRequestTls]) {
              servername = this[kRequestTls].servername;
            } else {
              servername = opts2.servername;
            }
            this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
          } catch (err) {
            callback(err);
          }
        }
      });
    }
    dispatch(opts, handler) {
      const { host } = new URL2(opts.origin);
      const headers = buildHeaders(opts.headers);
      throwIfProxyAuthIsSent(headers);
      return this[kAgent].dispatch({
        ...opts,
        headers: {
          ...headers,
          host
        }
      }, handler);
    }
    async[kClose]() {
      await this[kAgent].close();
      await this[kClient].close();
    }
    async[kDestroy]() {
      await this[kAgent].destroy();
      await this[kClient].destroy();
    }
  }
  module.exports = ProxyAgent;
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS((exports, module) => {
  var setGlobalDispatcher = function(agent) {
    if (!agent || typeof agent.dispatch !== "function") {
      throw new InvalidArgumentError("Argument agent must implement Agent");
    }
    Object.defineProperty(globalThis, globalDispatcher, {
      value: agent,
      writable: true,
      enumerable: false,
      configurable: false
    });
  };
  var getGlobalDispatcher = function() {
    return globalThis[globalDispatcher];
  };
  var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
  var { InvalidArgumentError } = require_errors();
  var Agent = require_agent();
  if (getGlobalDispatcher() === undefined) {
    setGlobalDispatcher(new Agent);
  }
  module.exports = {
    setGlobalDispatcher,
    getGlobalDispatcher
  };
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS((exports, module) => {
  module.exports = class DecoratorHandler {
    constructor(handler) {
      this.handler = handler;
    }
    onConnect(...args) {
      return this.handler.onConnect(...args);
    }
    onError(...args) {
      return this.handler.onError(...args);
    }
    onUpgrade(...args) {
      return this.handler.onUpgrade(...args);
    }
    onHeaders(...args) {
      return this.handler.onHeaders(...args);
    }
    onData(...args) {
      return this.handler.onData(...args);
    }
    onComplete(...args) {
      return this.handler.onComplete(...args);
    }
    onBodySent(...args) {
      return this.handler.onBodySent(...args);
    }
  };
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS((exports, module) => {
  var headerValueNormalize = function(potentialValue) {
    let i = potentialValue.length;
    while (/[\r\n\t ]/.test(potentialValue.charAt(--i)))
      ;
    return potentialValue.slice(0, i + 1).replace(/^[\r\n\t ]+/, "");
  };
  var fill = function(headers, object) {
    if (Array.isArray(object)) {
      for (const header of object) {
        if (header.length !== 2) {
          throw webidl.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${header.length}.`
          });
        }
        headers.append(header[0], header[1]);
      }
    } else if (typeof object === "object" && object !== null) {
      for (const [key, value] of Object.entries(object)) {
        headers.append(key, value);
      }
    } else {
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    }
  };
  var { kHeadersList } = require_symbols();
  var { kGuard } = require_symbols2();
  var { kEnumerableProperty } = require_util();
  var {
    makeIterator,
    isValidHeaderName,
    isValidHeaderValue
  } = require_util2();
  var { webidl } = require_webidl();
  var assert = __require("assert");
  var kHeadersMap = Symbol("headers map");
  var kHeadersSortedMap = Symbol("headers map sorted");

  class HeadersList {
    cookies = null;
    constructor(init) {
      if (init instanceof HeadersList) {
        this[kHeadersMap] = new Map(init[kHeadersMap]);
        this[kHeadersSortedMap] = init[kHeadersSortedMap];
        this.cookies = init.cookies;
      } else {
        this[kHeadersMap] = new Map(init);
        this[kHeadersSortedMap] = null;
      }
    }
    contains(name) {
      name = name.toLowerCase();
      return this[kHeadersMap].has(name);
    }
    clear() {
      this[kHeadersMap].clear();
      this[kHeadersSortedMap] = null;
      this.cookies = null;
    }
    append(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      const exists = this[kHeadersMap].get(lowercaseName);
      if (exists) {
        const delimiter = lowercaseName === "cookie" ? "; " : ", ";
        this[kHeadersMap].set(lowercaseName, {
          name: exists.name,
          value: `${exists.value}${delimiter}${value}`
        });
      } else {
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      if (lowercaseName === "set-cookie") {
        this.cookies ??= [];
        this.cookies.push(value);
      }
    }
    set(name, value) {
      this[kHeadersSortedMap] = null;
      const lowercaseName = name.toLowerCase();
      if (lowercaseName === "set-cookie") {
        this.cookies = [value];
      }
      return this[kHeadersMap].set(lowercaseName, { name, value });
    }
    delete(name) {
      this[kHeadersSortedMap] = null;
      name = name.toLowerCase();
      if (name === "set-cookie") {
        this.cookies = null;
      }
      return this[kHeadersMap].delete(name);
    }
    get(name) {
      if (!this.contains(name)) {
        return null;
      }
      return this[kHeadersMap].get(name.toLowerCase())?.value ?? null;
    }
    *[Symbol.iterator]() {
      for (const [name, { value }] of this[kHeadersMap]) {
        yield [name, value];
      }
    }
    get entries() {
      const headers = {};
      if (this[kHeadersMap].size) {
        for (const { name, value } of this[kHeadersMap].values()) {
          headers[name] = value;
        }
      }
      return headers;
    }
  }

  class Headers {
    constructor(init = undefined) {
      this[kHeadersList] = new HeadersList;
      this[kGuard] = "none";
      if (init !== undefined) {
        init = webidl.converters.HeadersInit(init);
        fill(this, init);
      }
    }
    append(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      return this[kHeadersList].append(name, value);
    }
    delete(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.delete",
          value: name,
          type: "header name"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      if (!this[kHeadersList].contains(name)) {
        return;
      }
      return this[kHeadersList].delete(name);
    }
    get(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.get",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].get(name);
    }
    has(name) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
      name = webidl.converters.ByteString(name);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.has",
          value: name,
          type: "header name"
        });
      }
      return this[kHeadersList].contains(name);
    }
    set(name, value) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
      name = webidl.converters.ByteString(name);
      value = webidl.converters.ByteString(value);
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.set",
          value,
          type: "header value"
        });
      }
      if (this[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (this[kGuard] === "request-no-cors") {
      }
      return this[kHeadersList].set(name, value);
    }
    getSetCookie() {
      webidl.brandCheck(this, Headers);
      const list = this[kHeadersList].cookies;
      if (list) {
        return [...list];
      }
      return [];
    }
    get [kHeadersSortedMap]() {
      if (this[kHeadersList][kHeadersSortedMap]) {
        return this[kHeadersList][kHeadersSortedMap];
      }
      const headers = [];
      const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
      const cookies = this[kHeadersList].cookies;
      for (const [name, value] of names) {
        if (name === "set-cookie") {
          for (const value2 of cookies) {
            headers.push([name, value2]);
          }
        } else {
          assert(value !== null);
          headers.push([name, value]);
        }
      }
      this[kHeadersList][kHeadersSortedMap] = headers;
      return headers;
    }
    keys() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key");
    }
    values() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "value");
    }
    entries() {
      webidl.brandCheck(this, Headers);
      return makeIterator(() => [...this[kHeadersSortedMap].values()], "Headers", "key+value");
    }
    forEach(callbackFn, thisArg = globalThis) {
      webidl.brandCheck(this, Headers);
      webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
      if (typeof callbackFn !== "function") {
        throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
      }
      for (const [key, value] of this) {
        callbackFn.apply(thisArg, [value, key, this]);
      }
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      webidl.brandCheck(this, Headers);
      return this[kHeadersList];
    }
  }
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  Object.defineProperties(Headers.prototype, {
    append: kEnumerableProperty,
    delete: kEnumerableProperty,
    get: kEnumerableProperty,
    has: kEnumerableProperty,
    set: kEnumerableProperty,
    getSetCookie: kEnumerableProperty,
    keys: kEnumerableProperty,
    values: kEnumerableProperty,
    entries: kEnumerableProperty,
    forEach: kEnumerableProperty,
    [Symbol.iterator]: { enumerable: false },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: true
    }
  });
  webidl.converters.HeadersInit = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (V[Symbol.iterator]) {
        return webidl.converters["sequence<sequence<ByteString>>"](V);
      }
      return webidl.converters["record<ByteString, ByteString>"](V);
    }
    throw webidl.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  };
  module.exports = {
    fill,
    Headers,
    HeadersList
  };
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS((exports, module) => {
  var cloneResponse = function(response) {
    if (response.internalResponse) {
      return filterResponse(cloneResponse(response.internalResponse), response.type);
    }
    const newResponse = makeResponse({ ...response, body: null });
    if (response.body != null) {
      newResponse.body = cloneBody(response.body);
    }
    return newResponse;
  };
  var makeResponse = function(init) {
    return {
      aborted: false,
      rangeRequested: false,
      timingAllowPassed: false,
      requestIncludesCredentials: false,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList,
      urlList: init.urlList ? [...init.urlList] : []
    };
  };
  var makeNetworkError = function(reason) {
    const isError = isErrorLike(reason);
    return makeResponse({
      type: "error",
      status: 0,
      error: isError ? reason : new Error(reason ? String(reason) : reason),
      aborted: reason && reason.name === "AbortError"
    });
  };
  var makeFilteredResponse = function(response, state) {
    state = {
      internalResponse: response,
      ...state
    };
    return new Proxy(response, {
      get(target, p) {
        return p in state ? state[p] : target[p];
      },
      set(target, p, value) {
        assert(!(p in state));
        target[p] = value;
        return true;
      }
    });
  };
  var filterResponse = function(response, type) {
    if (type === "basic") {
      return makeFilteredResponse(response, {
        type: "basic",
        headersList: response.headersList
      });
    } else if (type === "cors") {
      return makeFilteredResponse(response, {
        type: "cors",
        headersList: response.headersList
      });
    } else if (type === "opaque") {
      return makeFilteredResponse(response, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    } else if (type === "opaqueredirect") {
      return makeFilteredResponse(response, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    } else {
      assert(false);
    }
  };
  var makeAppropriateNetworkError = function(fetchParams) {
    assert(isCancelled(fetchParams));
    return isAborted(fetchParams) ? makeNetworkError(new DOMException2("The operation was aborted.", "AbortError")) : makeNetworkError("Request was cancelled.");
  };
  var initializeResponse = function(response, init, body) {
    if (init.status !== null && (init.status < 200 || init.status > 599)) {
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    }
    if (("statusText" in init) && init.statusText != null) {
      if (!isValidReasonPhrase(String(init.statusText))) {
        throw new TypeError("Invalid statusText");
      }
    }
    if (("status" in init) && init.status != null) {
      response[kState].status = init.status;
    }
    if (("statusText" in init) && init.statusText != null) {
      response[kState].statusText = init.statusText;
    }
    if (("headers" in init) && init.headers != null) {
      fill(response[kHeaders], init.headers);
    }
    if (body) {
      if (nullBodyStatus.includes(response.status)) {
        throw webidl.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + response.status
        });
      }
      response[kState].body = body.body;
      if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
        response[kState].headersList.append("content-type", body.type);
      }
    }
  };
  var { Headers, HeadersList, fill } = require_headers();
  var { extractBody, cloneBody, mixinBody } = require_body();
  var util = require_util();
  var { kEnumerableProperty } = util;
  var {
    isValidReasonPhrase,
    isCancelled,
    isAborted,
    isBlobLike,
    serializeJavascriptValueToJSONString,
    isErrorLike,
    isomorphicEncode
  } = require_util2();
  var {
    redirectStatus,
    nullBodyStatus,
    DOMException: DOMException2
  } = require_constants();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { FormData: FormData2 } = require_formdata();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList } = require_symbols();
  var assert = __require("assert");
  var { types } = __require("util");
  var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;

  class Response2 {
    static error() {
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response2;
      responseObject[kState] = makeNetworkError();
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      return responseObject;
    }
    static json(data = undefined, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
      if (init !== null) {
        init = webidl.converters.ResponseInit(init);
      }
      const bytes = new TextEncoder("utf-8").encode(serializeJavascriptValueToJSONString(data));
      const body = extractBody(bytes);
      const relevantRealm = { settingsObject: {} };
      const responseObject = new Response2;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "response";
      responseObject[kHeaders][kRealm] = relevantRealm;
      initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
      return responseObject;
    }
    static redirect(url, status = 302) {
      const relevantRealm = { settingsObject: {} };
      webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
      url = webidl.converters.USVString(url);
      status = webidl.converters["unsigned short"](status);
      let parsedURL;
      try {
        parsedURL = new URL(url, getGlobalOrigin());
      } catch (err) {
        throw Object.assign(new TypeError("Failed to parse URL from " + url), {
          cause: err
        });
      }
      if (!redirectStatus.includes(status)) {
        throw new RangeError("Invalid status code " + status);
      }
      const responseObject = new Response2;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      responseObject[kState].status = status;
      const value = isomorphicEncode(URLSerializer(parsedURL));
      responseObject[kState].headersList.append("location", value);
      return responseObject;
    }
    constructor(body = null, init = {}) {
      if (body !== null) {
        body = webidl.converters.BodyInit(body);
      }
      init = webidl.converters.ResponseInit(init);
      this[kRealm] = { settingsObject: {} };
      this[kState] = makeResponse({});
      this[kHeaders] = new Headers;
      this[kHeaders][kGuard] = "response";
      this[kHeaders][kHeadersList] = this[kState].headersList;
      this[kHeaders][kRealm] = this[kRealm];
      let bodyWithType = null;
      if (body != null) {
        const [extractedBody, type] = extractBody(body);
        bodyWithType = { body: extractedBody, type };
      }
      initializeResponse(this, init, bodyWithType);
    }
    get type() {
      webidl.brandCheck(this, Response2);
      return this[kState].type;
    }
    get url() {
      webidl.brandCheck(this, Response2);
      const urlList = this[kState].urlList;
      const url = urlList[urlList.length - 1] ?? null;
      if (url === null) {
        return "";
      }
      return URLSerializer(url, true);
    }
    get redirected() {
      webidl.brandCheck(this, Response2);
      return this[kState].urlList.length > 1;
    }
    get status() {
      webidl.brandCheck(this, Response2);
      return this[kState].status;
    }
    get ok() {
      webidl.brandCheck(this, Response2);
      return this[kState].status >= 200 && this[kState].status <= 299;
    }
    get statusText() {
      webidl.brandCheck(this, Response2);
      return this[kState].statusText;
    }
    get headers() {
      webidl.brandCheck(this, Response2);
      return this[kHeaders];
    }
    get body() {
      webidl.brandCheck(this, Response2);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Response2);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    clone() {
      webidl.brandCheck(this, Response2);
      if (this.bodyUsed || this.body && this.body.locked) {
        throw webidl.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      }
      const clonedResponse = cloneResponse(this[kState]);
      const clonedResponseObject = new Response2;
      clonedResponseObject[kState] = clonedResponse;
      clonedResponseObject[kRealm] = this[kRealm];
      clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
      clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      return clonedResponseObject;
    }
  }
  mixinBody(Response2);
  Object.defineProperties(Response2.prototype, {
    type: kEnumerableProperty,
    url: kEnumerableProperty,
    status: kEnumerableProperty,
    ok: kEnumerableProperty,
    redirected: kEnumerableProperty,
    statusText: kEnumerableProperty,
    headers: kEnumerableProperty,
    clone: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: true
    }
  });
  Object.defineProperties(Response2, {
    json: kEnumerableProperty,
    redirect: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.ReadableStream = webidl.interfaceConverter(ReadableStream);
  webidl.converters.FormData = webidl.interfaceConverter(FormData2);
  webidl.converters.URLSearchParams = webidl.interfaceConverter(URLSearchParams);
  webidl.converters.XMLHttpRequestBodyInit = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false });
    }
    if (types.isAnyArrayBuffer(V) || types.isTypedArray(V) || types.isDataView(V)) {
      return webidl.converters.BufferSource(V);
    }
    if (util.isFormDataLike(V)) {
      return webidl.converters.FormData(V, { strict: false });
    }
    if (V instanceof URLSearchParams) {
      return webidl.converters.URLSearchParams(V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.BodyInit = function(V) {
    if (V instanceof ReadableStream) {
      return webidl.converters.ReadableStream(V);
    }
    if (V?.[Symbol.asyncIterator]) {
      return V;
    }
    return webidl.converters.XMLHttpRequestBodyInit(V);
  };
  webidl.converters.ResponseInit = webidl.dictionaryConverter([
    {
      key: "status",
      converter: webidl.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: webidl.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    }
  ]);
  module.exports = {
    makeNetworkError,
    makeResponse,
    makeAppropriateNetworkError,
    filterResponse,
    Response: Response2,
    cloneResponse
  };
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS((exports, module) => {
  var makeRequest = function(init) {
    const request = {
      method: "GET",
      localURLsOnly: false,
      unsafeRequest: false,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: false,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: false,
      credentials: "same-origin",
      useCredentials: false,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: false,
      historyNavigation: false,
      userActivation: false,
      taintedOrigin: false,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: false,
      done: false,
      timingAllowFailed: false,
      ...init,
      headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList
    };
    request.url = request.urlList[0];
    return request;
  };
  var cloneRequest = function(request) {
    const newRequest = makeRequest({ ...request, body: null });
    if (request.body != null) {
      newRequest.body = cloneBody(request.body);
    }
    return newRequest;
  };
  var { extractBody, mixinBody, cloneBody } = require_body();
  var { Headers, fill: fillHeaders, HeadersList } = require_headers();
  var { FinalizationRegistry } = require_dispatcher_weakref()();
  var util = require_util();
  var {
    isValidHTTPToken,
    sameOrigin,
    normalizeMethod,
    makePolicyContainer
  } = require_util2();
  var {
    forbiddenMethods,
    corsSafeListedMethods,
    referrerPolicy,
    requestRedirect,
    requestMode,
    requestCredentials,
    requestCache,
    requestDuplex
  } = require_constants();
  var { kEnumerableProperty } = util;
  var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
  var { webidl } = require_webidl();
  var { getGlobalOrigin } = require_global();
  var { URLSerializer } = require_dataURL();
  var { kHeadersList } = require_symbols();
  var assert = __require("assert");
  var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
  var TransformStream = globalThis.TransformStream;
  var kInit = Symbol("init");
  var kAbortController = Symbol("abortController");
  var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
    signal.removeEventListener("abort", abort);
  });

  class Request {
    constructor(input, init = {}) {
      if (input === kInit) {
        return;
      }
      webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
      input = webidl.converters.RequestInfo(input);
      init = webidl.converters.RequestInit(init);
      this[kRealm] = {
        settingsObject: {
          baseUrl: getGlobalOrigin(),
          get origin() {
            return this.baseUrl?.origin;
          },
          policyContainer: makePolicyContainer()
        }
      };
      let request = null;
      let fallbackMode = null;
      const baseUrl = this[kRealm].settingsObject.baseUrl;
      let signal = null;
      if (typeof input === "string") {
        let parsedURL;
        try {
          parsedURL = new URL(input, baseUrl);
        } catch (err) {
          throw new TypeError("Failed to parse URL from " + input, { cause: err });
        }
        if (parsedURL.username || parsedURL.password) {
          throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + input);
        }
        request = makeRequest({ urlList: [parsedURL] });
        fallbackMode = "cors";
      } else {
        assert(input instanceof Request);
        request = input[kState];
        signal = input[kSignal];
      }
      const origin = this[kRealm].settingsObject.origin;
      let window2 = "client";
      if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
        window2 = request.window;
      }
      if (init.window != null) {
        throw new TypeError(`'window' option '${window2}' must be null`);
      }
      if ("window" in init) {
        window2 = "no-window";
      }
      request = makeRequest({
        method: request.method,
        headersList: request.headersList,
        unsafeRequest: request.unsafeRequest,
        client: this[kRealm].settingsObject,
        window: window2,
        priority: request.priority,
        origin: request.origin,
        referrer: request.referrer,
        referrerPolicy: request.referrerPolicy,
        mode: request.mode,
        credentials: request.credentials,
        cache: request.cache,
        redirect: request.redirect,
        integrity: request.integrity,
        keepalive: request.keepalive,
        reloadNavigation: request.reloadNavigation,
        historyNavigation: request.historyNavigation,
        urlList: [...request.urlList]
      });
      if (Object.keys(init).length > 0) {
        if (request.mode === "navigate") {
          request.mode = "same-origin";
        }
        request.reloadNavigation = false;
        request.historyNavigation = false;
        request.origin = "client";
        request.referrer = "client";
        request.referrerPolicy = "";
        request.url = request.urlList[request.urlList.length - 1];
        request.urlList = [request.url];
      }
      if (init.referrer !== undefined) {
        const referrer = init.referrer;
        if (referrer === "") {
          request.referrer = "no-referrer";
        } else {
          let parsedReferrer;
          try {
            parsedReferrer = new URL(referrer, baseUrl);
          } catch (err) {
            throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
          }
          request.referrer = parsedReferrer;
        }
      }
      if (init.referrerPolicy !== undefined) {
        request.referrerPolicy = init.referrerPolicy;
      }
      let mode;
      if (init.mode !== undefined) {
        mode = init.mode;
      } else {
        mode = fallbackMode;
      }
      if (mode === "navigate") {
        throw webidl.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      }
      if (mode != null) {
        request.mode = mode;
      }
      if (init.credentials !== undefined) {
        request.credentials = init.credentials;
      }
      if (init.cache !== undefined) {
        request.cache = init.cache;
      }
      if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
        throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
      }
      if (init.redirect !== undefined) {
        request.redirect = init.redirect;
      }
      if (init.integrity !== undefined && init.integrity != null) {
        request.integrity = String(init.integrity);
      }
      if (init.keepalive !== undefined) {
        request.keepalive = Boolean(init.keepalive);
      }
      if (init.method !== undefined) {
        let method = init.method;
        if (!isValidHTTPToken(init.method)) {
          throw TypeError(`'${init.method}' is not a valid HTTP method.`);
        }
        if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
          throw TypeError(`'${init.method}' HTTP method is unsupported.`);
        }
        method = normalizeMethod(init.method);
        request.method = method;
      }
      if (init.signal !== undefined) {
        signal = init.signal;
      }
      this[kState] = request;
      const ac = new AbortController;
      this[kSignal] = ac.signal;
      this[kSignal][kRealm] = this[kRealm];
      if (signal != null) {
        if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
          throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
        }
        if (signal.aborted) {
          ac.abort(signal.reason);
        } else {
          this[kAbortController] = ac;
          const acRef = new WeakRef(ac);
          const abort = function() {
            const ac2 = acRef.deref();
            if (ac2 !== undefined) {
              ac2.abort(this.reason);
            }
          };
          try {
            if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
              setMaxListeners(100, signal);
            } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
              setMaxListeners(100, signal);
            }
          } catch {
          }
          signal.addEventListener("abort", abort, { once: true });
          requestFinalizer.register(ac, { signal, abort });
        }
      }
      this[kHeaders] = new Headers;
      this[kHeaders][kHeadersList] = request.headersList;
      this[kHeaders][kGuard] = "request";
      this[kHeaders][kRealm] = this[kRealm];
      if (mode === "no-cors") {
        if (!corsSafeListedMethods.includes(request.method)) {
          throw new TypeError(`'${request.method} is unsupported in no-cors mode.`);
        }
        this[kHeaders][kGuard] = "request-no-cors";
      }
      if (Object.keys(init).length !== 0) {
        let headers = new Headers(this[kHeaders]);
        if (init.headers !== undefined) {
          headers = init.headers;
        }
        this[kHeaders][kHeadersList].clear();
        if (headers.constructor.name === "Headers") {
          for (const [key, val] of headers) {
            this[kHeaders].append(key, val);
          }
        } else {
          fillHeaders(this[kHeaders], headers);
        }
      }
      const inputBody = input instanceof Request ? input[kState].body : null;
      if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      }
      let initBody = null;
      if (init.body != null) {
        const [extractedBody, contentType] = extractBody(init.body, request.keepalive);
        initBody = extractedBody;
        if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
          this[kHeaders].append("content-type", contentType);
        }
      }
      const inputOrInitBody = initBody ?? inputBody;
      if (inputOrInitBody != null && inputOrInitBody.source == null) {
        if (initBody != null && init.duplex == null) {
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        }
        if (request.mode !== "same-origin" && request.mode !== "cors") {
          throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
        }
        request.useCORSPreflightFlag = true;
      }
      let finalBody = inputOrInitBody;
      if (initBody == null && inputBody != null) {
        if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
          throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
        }
        if (!TransformStream) {
          TransformStream = __require("stream/web").TransformStream;
        }
        const identityTransform = new TransformStream;
        inputBody.stream.pipeThrough(identityTransform);
        finalBody = {
          source: inputBody.source,
          length: inputBody.length,
          stream: identityTransform.readable
        };
      }
      this[kState].body = finalBody;
    }
    get method() {
      webidl.brandCheck(this, Request);
      return this[kState].method;
    }
    get url() {
      webidl.brandCheck(this, Request);
      return URLSerializer(this[kState].url);
    }
    get headers() {
      webidl.brandCheck(this, Request);
      return this[kHeaders];
    }
    get destination() {
      webidl.brandCheck(this, Request);
      return this[kState].destination;
    }
    get referrer() {
      webidl.brandCheck(this, Request);
      if (this[kState].referrer === "no-referrer") {
        return "";
      }
      if (this[kState].referrer === "client") {
        return "about:client";
      }
      return this[kState].referrer.toString();
    }
    get referrerPolicy() {
      webidl.brandCheck(this, Request);
      return this[kState].referrerPolicy;
    }
    get mode() {
      webidl.brandCheck(this, Request);
      return this[kState].mode;
    }
    get credentials() {
      return this[kState].credentials;
    }
    get cache() {
      webidl.brandCheck(this, Request);
      return this[kState].cache;
    }
    get redirect() {
      webidl.brandCheck(this, Request);
      return this[kState].redirect;
    }
    get integrity() {
      webidl.brandCheck(this, Request);
      return this[kState].integrity;
    }
    get keepalive() {
      webidl.brandCheck(this, Request);
      return this[kState].keepalive;
    }
    get isReloadNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].reloadNavigation;
    }
    get isHistoryNavigation() {
      webidl.brandCheck(this, Request);
      return this[kState].historyNavigation;
    }
    get signal() {
      webidl.brandCheck(this, Request);
      return this[kSignal];
    }
    get body() {
      webidl.brandCheck(this, Request);
      return this[kState].body ? this[kState].body.stream : null;
    }
    get bodyUsed() {
      webidl.brandCheck(this, Request);
      return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
    }
    get duplex() {
      webidl.brandCheck(this, Request);
      return "half";
    }
    clone() {
      webidl.brandCheck(this, Request);
      if (this.bodyUsed || this.body?.locked) {
        throw new TypeError("unusable");
      }
      const clonedRequest = cloneRequest(this[kState]);
      const clonedRequestObject = new Request(kInit);
      clonedRequestObject[kState] = clonedRequest;
      clonedRequestObject[kRealm] = this[kRealm];
      clonedRequestObject[kHeaders] = new Headers;
      clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
      clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
      clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
      const ac = new AbortController;
      if (this.signal.aborted) {
        ac.abort(this.signal.reason);
      } else {
        this.signal.addEventListener("abort", () => {
          ac.abort(this.signal.reason);
        }, { once: true });
      }
      clonedRequestObject[kSignal] = ac.signal;
      return clonedRequestObject;
    }
  }
  mixinBody(Request);
  Object.defineProperties(Request.prototype, {
    method: kEnumerableProperty,
    url: kEnumerableProperty,
    headers: kEnumerableProperty,
    redirect: kEnumerableProperty,
    clone: kEnumerableProperty,
    signal: kEnumerableProperty,
    duplex: kEnumerableProperty,
    destination: kEnumerableProperty,
    body: kEnumerableProperty,
    bodyUsed: kEnumerableProperty,
    isHistoryNavigation: kEnumerableProperty,
    isReloadNavigation: kEnumerableProperty,
    keepalive: kEnumerableProperty,
    integrity: kEnumerableProperty,
    cache: kEnumerableProperty,
    credentials: kEnumerableProperty,
    attribute: kEnumerableProperty,
    referrerPolicy: kEnumerableProperty,
    referrer: kEnumerableProperty,
    mode: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: true
    }
  });
  webidl.converters.Request = webidl.interfaceConverter(Request);
  webidl.converters.RequestInfo = function(V) {
    if (typeof V === "string") {
      return webidl.converters.USVString(V);
    }
    if (V instanceof Request) {
      return webidl.converters.Request(V);
    }
    return webidl.converters.USVString(V);
  };
  webidl.converters.AbortSignal = webidl.interfaceConverter(AbortSignal);
  webidl.converters.RequestInit = webidl.dictionaryConverter([
    {
      key: "method",
      converter: webidl.converters.ByteString
    },
    {
      key: "headers",
      converter: webidl.converters.HeadersInit
    },
    {
      key: "body",
      converter: webidl.nullableConverter(webidl.converters.BodyInit)
    },
    {
      key: "referrer",
      converter: webidl.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: webidl.converters.DOMString,
      allowedValues: referrerPolicy
    },
    {
      key: "mode",
      converter: webidl.converters.DOMString,
      allowedValues: requestMode
    },
    {
      key: "credentials",
      converter: webidl.converters.DOMString,
      allowedValues: requestCredentials
    },
    {
      key: "cache",
      converter: webidl.converters.DOMString,
      allowedValues: requestCache
    },
    {
      key: "redirect",
      converter: webidl.converters.DOMString,
      allowedValues: requestRedirect
    },
    {
      key: "integrity",
      converter: webidl.converters.DOMString
    },
    {
      key: "keepalive",
      converter: webidl.converters.boolean
    },
    {
      key: "signal",
      converter: webidl.nullableConverter((signal) => webidl.converters.AbortSignal(signal, { strict: false }))
    },
    {
      key: "window",
      converter: webidl.converters.any
    },
    {
      key: "duplex",
      converter: webidl.converters.DOMString,
      allowedValues: requestDuplex
    }
  ]);
  module.exports = { Request, makeRequest };
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  async function fetch2(input, init = {}) {
    webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const p = createDeferredPromise();
    let requestObject;
    try {
      requestObject = new Request(input, init);
    } catch (e) {
      p.reject(e);
      return p.promise;
    }
    const request = requestObject[kState];
    if (requestObject.signal.aborted) {
      abortFetch(p, request, null, requestObject.signal.reason);
      return p.promise;
    }
    const globalObject = request.client.globalObject;
    if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
      request.serviceWorkers = "none";
    }
    let responseObject = null;
    const relevantRealm = null;
    let locallyAborted = false;
    let controller = null;
    requestObject.signal.addEventListener("abort", () => {
      locallyAborted = true;
      abortFetch(p, request, responseObject, requestObject.signal.reason);
      if (controller != null) {
        controller.abort();
      }
    }, { once: true });
    const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
    const processResponse = (response) => {
      if (locallyAborted) {
        return;
      }
      if (response.aborted) {
        abortFetch(p, request, responseObject, controller.serializedAbortReason);
        return;
      }
      if (response.type === "error") {
        p.reject(Object.assign(new TypeError("fetch failed"), { cause: response.error }));
        return;
      }
      responseObject = new Response2;
      responseObject[kState] = response;
      responseObject[kRealm] = relevantRealm;
      responseObject[kHeaders][kHeadersList] = response.headersList;
      responseObject[kHeaders][kGuard] = "immutable";
      responseObject[kHeaders][kRealm] = relevantRealm;
      p.resolve(responseObject);
    };
    controller = fetching({
      request,
      processResponseEndOfBody: handleFetchDone,
      processResponse,
      dispatcher: init.dispatcher ?? getGlobalDispatcher()
    });
    return p.promise;
  }
  var finalizeAndReportTiming = function(response, initiatorType = "other") {
    if (response.type === "error" && response.aborted) {
      return;
    }
    if (!response.urlList?.length) {
      return;
    }
    const originalURL = response.urlList[0];
    let timingInfo = response.timingInfo;
    let cacheState = response.cacheState;
    if (!urlIsHttpHttpsScheme(originalURL)) {
      return;
    }
    if (timingInfo === null) {
      return;
    }
    if (!timingInfo.timingAllowPassed) {
      timingInfo = createOpaqueTimingInfo({
        startTime: timingInfo.startTime
      });
      cacheState = "";
    }
    timingInfo.endTime = coarsenedSharedCurrentTime();
    response.timingInfo = timingInfo;
    markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState);
  };
  var markResourceTiming = function(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
    if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
      performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState);
    }
  };
  var abortFetch = function(p, request, responseObject, error) {
    if (!error) {
      error = new DOMException2("The operation was aborted.", "AbortError");
    }
    p.reject(error);
    if (request.body != null && isReadable(request.body?.stream)) {
      request.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
    if (responseObject == null) {
      return;
    }
    const response = responseObject[kState];
    if (response.body != null && isReadable(response.body?.stream)) {
      response.body.stream.cancel(error).catch((err) => {
        if (err.code === "ERR_INVALID_STATE") {
          return;
        }
        throw err;
      });
    }
  };
  var fetching = function({
    request,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseEndOfBody,
    processResponseConsumeBody,
    useParallelQueue = false,
    dispatcher
  }) {
    let taskDestination = null;
    let crossOriginIsolatedCapability = false;
    if (request.client != null) {
      taskDestination = request.client.globalObject;
      crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
    }
    const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
    const timingInfo = createOpaqueTimingInfo({
      startTime: currenTime
    });
    const fetchParams = {
      controller: new Fetch(dispatcher),
      request,
      timingInfo,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseConsumeBody,
      processResponseEndOfBody,
      taskDestination,
      crossOriginIsolatedCapability
    };
    assert(!request.body || request.body.stream);
    if (request.window === "client") {
      request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
    }
    if (request.origin === "client") {
      request.origin = request.client?.origin;
    }
    if (request.policyContainer === "client") {
      if (request.client != null) {
        request.policyContainer = clonePolicyContainer(request.client.policyContainer);
      } else {
        request.policyContainer = makePolicyContainer();
      }
    }
    if (!request.headersList.contains("accept")) {
      const value = "*/*";
      request.headersList.append("accept", value);
    }
    if (!request.headersList.contains("accept-language")) {
      request.headersList.append("accept-language", "*");
    }
    if (request.priority === null) {
    }
    if (subresource.includes(request.destination)) {
    }
    mainFetch(fetchParams).catch((err) => {
      fetchParams.controller.terminate(err);
    });
    return fetchParams.controller;
  };
  async function mainFetch(fetchParams, recursive = false) {
    const request = fetchParams.request;
    let response = null;
    if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
      response = makeNetworkError("local URLs only");
    }
    tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
    if (requestBadPort(request) === "blocked") {
      response = makeNetworkError("bad port");
    }
    if (request.referrerPolicy === "") {
      request.referrerPolicy = request.policyContainer.referrerPolicy;
    }
    if (request.referrer !== "no-referrer") {
      request.referrer = determineRequestsReferrer(request);
    }
    if (response === null) {
      response = await (async () => {
        const currentURL = requestCurrentURL(request);
        if (sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || currentURL.protocol === "data:" || (request.mode === "navigate" || request.mode === "websocket")) {
          request.responseTainting = "basic";
          return await schemeFetch(fetchParams);
        }
        if (request.mode === "same-origin") {
          return makeNetworkError('request mode cannot be "same-origin"');
        }
        if (request.mode === "no-cors") {
          if (request.redirect !== "follow") {
            return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
          }
          request.responseTainting = "opaque";
          return await schemeFetch(fetchParams);
        }
        if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
          return makeNetworkError("URL scheme must be a HTTP(S) scheme");
        }
        request.responseTainting = "cors";
        return await httpFetch(fetchParams);
      })();
    }
    if (recursive) {
      return response;
    }
    if (response.status !== 0 && !response.internalResponse) {
      if (request.responseTainting === "cors") {
      }
      if (request.responseTainting === "basic") {
        response = filterResponse(response, "basic");
      } else if (request.responseTainting === "cors") {
        response = filterResponse(response, "cors");
      } else if (request.responseTainting === "opaque") {
        response = filterResponse(response, "opaque");
      } else {
        assert(false);
      }
    }
    let internalResponse = response.status === 0 ? response : response.internalResponse;
    if (internalResponse.urlList.length === 0) {
      internalResponse.urlList.push(...request.urlList);
    }
    if (!request.timingAllowFailed) {
      response.timingAllowPassed = true;
    }
    if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
      response = internalResponse = makeNetworkError();
    }
    if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
      internalResponse.body = null;
      fetchParams.controller.dump = true;
    }
    if (request.integrity) {
      const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
      if (request.responseTainting === "opaque" || response.body == null) {
        processBodyError(response.error);
        return;
      }
      const processBody = (bytes) => {
        if (!bytesMatch(bytes, request.integrity)) {
          processBodyError("integrity mismatch");
          return;
        }
        response.body = safelyExtractBody(bytes)[0];
        fetchFinale(fetchParams, response);
      };
      await fullyReadBody(response.body, processBody, processBodyError);
    } else {
      fetchFinale(fetchParams, response);
    }
  }
  async function schemeFetch(fetchParams) {
    if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
      return makeAppropriateNetworkError(fetchParams);
    }
    const { request } = fetchParams;
    const { protocol: scheme } = requestCurrentURL(request);
    switch (scheme) {
      case "about:": {
        return makeNetworkError("about scheme is not supported");
      }
      case "blob:": {
        if (!resolveObjectURL) {
          resolveObjectURL = __require("buffer").resolveObjectURL;
        }
        const blobURLEntry = requestCurrentURL(request);
        if (blobURLEntry.search.length !== 0) {
          return makeNetworkError("NetworkError when attempting to fetch resource.");
        }
        const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
        if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
          return makeNetworkError("invalid method");
        }
        const bodyWithType = safelyExtractBody(blobURLEntryObject);
        const body = bodyWithType[0];
        const length = isomorphicEncode(`${body.length}`);
        const type = bodyWithType[1] ?? "";
        const response = makeResponse({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: length }],
            ["content-type", { name: "Content-Type", value: type }]
          ]
        });
        response.body = body;
        return response;
      }
      case "data:": {
        const currentURL = requestCurrentURL(request);
        const dataURLStruct = dataURLProcessor(currentURL);
        if (dataURLStruct === "failure") {
          return makeNetworkError("failed to fetch the data URL");
        }
        const mimeType = serializeAMimeType(dataURLStruct.mimeType);
        return makeResponse({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: mimeType }]
          ],
          body: safelyExtractBody(dataURLStruct.body)[0]
        });
      }
      case "file:": {
        return makeNetworkError("not implemented... yet...");
      }
      case "http:":
      case "https:": {
        return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
      }
      default: {
        return makeNetworkError("unknown scheme");
      }
    }
  }
  var finalizeResponse = function(fetchParams, response) {
    fetchParams.request.done = true;
    if (fetchParams.processResponseDone != null) {
      queueMicrotask(() => fetchParams.processResponseDone(response));
    }
  };
  async function fetchFinale(fetchParams, response) {
    if (response.type === "error") {
      response.urlList = [fetchParams.request.urlList[0]];
      response.timingInfo = createOpaqueTimingInfo({
        startTime: fetchParams.timingInfo.startTime
      });
    }
    const processResponseEndOfBody = () => {
      fetchParams.request.done = true;
      if (fetchParams.processResponseEndOfBody != null) {
        queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
      }
    };
    if (fetchParams.processResponse != null) {
      queueMicrotask(() => fetchParams.processResponse(response));
    }
    if (response.body == null) {
      processResponseEndOfBody();
    } else {
      const identityTransformAlgorithm = (chunk, controller) => {
        controller.enqueue(chunk);
      };
      const transformStream = new TransformStream({
        start() {
        },
        transform: identityTransformAlgorithm,
        flush: processResponseEndOfBody
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      response.body = { stream: response.body.stream.pipeThrough(transformStream) };
    }
    if (fetchParams.processResponseConsumeBody != null) {
      const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
      const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
      if (response.body == null) {
        queueMicrotask(() => processBody(null));
      } else {
        await fullyReadBody(response.body, processBody, processBodyError);
      }
    }
  }
  async function httpFetch(fetchParams) {
    const request = fetchParams.request;
    let response = null;
    let actualResponse = null;
    const timingInfo = fetchParams.timingInfo;
    if (request.serviceWorkers === "all") {
    }
    if (response === null) {
      if (request.redirect === "follow") {
        request.serviceWorkers = "none";
      }
      actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
      if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
        return makeNetworkError("cors failure");
      }
      if (TAOCheck(request, response) === "failure") {
        request.timingAllowFailed = true;
      }
    }
    if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(request.origin, request.client, request.destination, actualResponse) === "blocked") {
      return makeNetworkError("blocked");
    }
    if (redirectStatus.includes(actualResponse.status)) {
      if (request.redirect !== "manual") {
        fetchParams.controller.connection.destroy();
      }
      if (request.redirect === "error") {
        response = makeNetworkError("unexpected redirect");
      } else if (request.redirect === "manual") {
        response = actualResponse;
      } else if (request.redirect === "follow") {
        response = await httpRedirectFetch(fetchParams, response);
      } else {
        assert(false);
      }
    }
    response.timingInfo = timingInfo;
    return response;
  }
  async function httpRedirectFetch(fetchParams, response) {
    const request = fetchParams.request;
    const actualResponse = response.internalResponse ? response.internalResponse : response;
    let locationURL;
    try {
      locationURL = responseLocationURL(actualResponse, requestCurrentURL(request).hash);
      if (locationURL == null) {
        return response;
      }
    } catch (err) {
      return makeNetworkError(err);
    }
    if (!urlIsHttpHttpsScheme(locationURL)) {
      return makeNetworkError("URL scheme must be a HTTP(S) scheme");
    }
    if (request.redirectCount === 20) {
      return makeNetworkError("redirect count exceeded");
    }
    request.redirectCount += 1;
    if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
      return makeNetworkError('cross origin not allowed for request mode "cors"');
    }
    if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
      return makeNetworkError('URL cannot contain credentials for request mode "cors"');
    }
    if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
      return makeNetworkError();
    }
    if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !["GET", "HEAD"].includes(request.method)) {
      request.method = "GET";
      request.body = null;
      for (const headerName of requestBodyHeader) {
        request.headersList.delete(headerName);
      }
    }
    if (!sameOrigin(requestCurrentURL(request), locationURL)) {
      request.headersList.delete("authorization");
    }
    if (request.body != null) {
      assert(request.body.source != null);
      request.body = safelyExtractBody(request.body.source)[0];
    }
    const timingInfo = fetchParams.timingInfo;
    timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
    if (timingInfo.redirectStartTime === 0) {
      timingInfo.redirectStartTime = timingInfo.startTime;
    }
    request.urlList.push(locationURL);
    setRequestReferrerPolicyOnRedirect(request, actualResponse);
    return mainFetch(fetchParams, true);
  }
  async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
    const request = fetchParams.request;
    let httpFetchParams = null;
    let httpRequest = null;
    let response = null;
    const httpCache = null;
    const revalidatingFlag = false;
    if (request.window === "no-window" && request.redirect === "error") {
      httpFetchParams = fetchParams;
      httpRequest = request;
    } else {
      httpRequest = makeRequest(request);
      httpFetchParams = { ...fetchParams };
      httpFetchParams.request = httpRequest;
    }
    const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
    const contentLength = httpRequest.body ? httpRequest.body.length : null;
    let contentLengthHeaderValue = null;
    if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
      contentLengthHeaderValue = "0";
    }
    if (contentLength != null) {
      contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
    }
    if (contentLengthHeaderValue != null) {
      httpRequest.headersList.append("content-length", contentLengthHeaderValue);
    }
    if (contentLength != null && httpRequest.keepalive) {
    }
    if (httpRequest.referrer instanceof URL) {
      httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
    }
    appendRequestOriginHeader(httpRequest);
    appendFetchMetadata(httpRequest);
    if (!httpRequest.headersList.contains("user-agent")) {
      httpRequest.headersList.append("user-agent", "undici");
    }
    if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
      httpRequest.headersList.append("cache-control", "max-age=0");
    }
    if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
      if (!httpRequest.headersList.contains("pragma")) {
        httpRequest.headersList.append("pragma", "no-cache");
      }
      if (!httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "no-cache");
      }
    }
    if (httpRequest.headersList.contains("range")) {
      httpRequest.headersList.append("accept-encoding", "identity");
    }
    if (!httpRequest.headersList.contains("accept-encoding")) {
      if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
        httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
      } else {
        httpRequest.headersList.append("accept-encoding", "gzip, deflate");
      }
    }
    if (includeCredentials) {
    }
    if (httpCache == null) {
      httpRequest.cache = "no-store";
    }
    if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") {
    }
    if (response == null) {
      if (httpRequest.mode === "only-if-cached") {
        return makeNetworkError("only if cached");
      }
      const forwardResponse = await httpNetworkFetch(httpFetchParams, includeCredentials, isNewConnectionFetch);
      if (!safeMethods.includes(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) {
      }
      if (revalidatingFlag && forwardResponse.status === 304) {
      }
      if (response == null) {
        response = forwardResponse;
      }
    }
    response.urlList = [...httpRequest.urlList];
    if (httpRequest.headersList.contains("range")) {
      response.rangeRequested = true;
    }
    response.requestIncludesCredentials = includeCredentials;
    if (response.status === 407) {
      if (request.window === "no-window") {
        return makeNetworkError();
      }
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError("proxy authentication required");
    }
    if (response.status === 421 && !isNewConnectionFetch && (request.body == null || request.body.source != null)) {
      if (isCancelled(fetchParams)) {
        return makeAppropriateNetworkError(fetchParams);
      }
      fetchParams.controller.connection.destroy();
      response = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
    }
    if (isAuthenticationFetch) {
    }
    return response;
  }
  async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
    assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
    fetchParams.controller.connection = {
      abort: null,
      destroyed: false,
      destroy(err) {
        if (!this.destroyed) {
          this.destroyed = true;
          this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
        }
      }
    };
    const request = fetchParams.request;
    let response = null;
    const timingInfo = fetchParams.timingInfo;
    const httpCache = null;
    if (httpCache == null) {
      request.cache = "no-store";
    }
    const newConnection = forceNewConnection ? "yes" : "no";
    if (request.mode === "websocket") {
    } else {
    }
    let requestBody = null;
    if (request.body == null && fetchParams.processRequestEndOfBody) {
      queueMicrotask(() => fetchParams.processRequestEndOfBody());
    } else if (request.body != null) {
      const processBodyChunk = async function* (bytes) {
        if (isCancelled(fetchParams)) {
          return;
        }
        yield bytes;
        fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
      };
      const processEndOfBody = () => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (fetchParams.processRequestEndOfBody) {
          fetchParams.processRequestEndOfBody();
        }
      };
      const processBodyError = (e) => {
        if (isCancelled(fetchParams)) {
          return;
        }
        if (e.name === "AbortError") {
          fetchParams.controller.abort();
        } else {
          fetchParams.controller.terminate(e);
        }
      };
      requestBody = async function* () {
        try {
          for await (const bytes of request.body.stream) {
            yield* processBodyChunk(bytes);
          }
          processEndOfBody();
        } catch (err) {
          processBodyError(err);
        }
      }();
    }
    try {
      const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
      if (socket) {
        response = makeResponse({ status, statusText, headersList, socket });
      } else {
        const iterator = body[Symbol.asyncIterator]();
        fetchParams.controller.next = () => iterator.next();
        response = makeResponse({ status, statusText, headersList });
      }
    } catch (err) {
      if (err.name === "AbortError") {
        fetchParams.controller.connection.destroy();
        return makeAppropriateNetworkError(fetchParams);
      }
      return makeNetworkError(err);
    }
    const pullAlgorithm = () => {
      fetchParams.controller.resume();
    };
    const cancelAlgorithm = (reason) => {
      fetchParams.controller.abort(reason);
    };
    if (!ReadableStream) {
      ReadableStream = __require("stream/web").ReadableStream;
    }
    const stream = new ReadableStream({
      async start(controller) {
        fetchParams.controller.controller = controller;
      },
      async pull(controller) {
        await pullAlgorithm(controller);
      },
      async cancel(reason) {
        await cancelAlgorithm(reason);
      }
    }, {
      highWaterMark: 0,
      size() {
        return 1;
      }
    });
    response.body = { stream };
    fetchParams.controller.on("terminated", onAborted);
    fetchParams.controller.resume = async () => {
      while (true) {
        let bytes;
        let isFailure;
        try {
          const { done, value } = await fetchParams.controller.next();
          if (isAborted(fetchParams)) {
            break;
          }
          bytes = done ? undefined : value;
        } catch (err) {
          if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
            bytes = undefined;
          } else {
            bytes = err;
            isFailure = true;
          }
        }
        if (bytes === undefined) {
          readableStreamClose(fetchParams.controller.controller);
          finalizeResponse(fetchParams, response);
          return;
        }
        timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
        if (isFailure) {
          fetchParams.controller.terminate(bytes);
          return;
        }
        fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
        if (isErrored(stream)) {
          fetchParams.controller.terminate();
          return;
        }
        if (!fetchParams.controller.controller.desiredSize) {
          return;
        }
      }
    };
    function onAborted(reason) {
      if (isAborted(fetchParams)) {
        response.aborted = true;
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(fetchParams.controller.serializedAbortReason);
        }
      } else {
        if (isReadable(stream)) {
          fetchParams.controller.controller.error(new TypeError("terminated", {
            cause: isErrorLike(reason) ? reason : undefined
          }));
        }
      }
      fetchParams.controller.connection.destroy();
    }
    return response;
    async function dispatch({ body }) {
      const url = requestCurrentURL(request);
      const agent = fetchParams.controller.dispatcher;
      return new Promise((resolve, reject) => agent.dispatch({
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
        headers: request.headersList.entries,
        maxRedirections: 0,
        upgrade: request.mode === "websocket" ? "websocket" : undefined
      }, {
        body: null,
        abort: null,
        onConnect(abort) {
          const { connection } = fetchParams.controller;
          if (connection.destroyed) {
            abort(new DOMException2("The operation was aborted.", "AbortError"));
          } else {
            fetchParams.controller.on("terminated", abort);
            this.abort = connection.abort = abort;
          }
        },
        onHeaders(status, headersList, resume, statusText) {
          if (status < 200) {
            return;
          }
          let codings = [];
          let location = "";
          const headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            const key = headersList[n + 0].toString("latin1");
            const val = headersList[n + 1].toString("latin1");
            if (key.toLowerCase() === "content-encoding") {
              codings = val.toLowerCase().split(",").map((x) => x.trim());
            } else if (key.toLowerCase() === "location") {
              location = val;
            }
            headers.append(key, val);
          }
          this.body = new Readable({ read: resume });
          const decoders = [];
          const willFollow = request.redirect === "follow" && location && redirectStatus.includes(status);
          if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
            for (const coding of codings) {
              if (coding === "x-gzip" || coding === "gzip") {
                decoders.push(zlib.createGunzip());
              } else if (coding === "deflate") {
                decoders.push(zlib.createInflate());
              } else if (coding === "br") {
                decoders.push(zlib.createBrotliDecompress());
              } else {
                decoders.length = 0;
                break;
              }
            }
          }
          resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length ? pipeline(this.body, ...decoders, () => {
            }) : this.body.on("error", () => {
            })
          });
          return true;
        },
        onData(chunk) {
          if (fetchParams.controller.dump) {
            return;
          }
          const bytes = chunk;
          timingInfo.encodedBodySize += bytes.byteLength;
          return this.body.push(bytes);
        },
        onComplete() {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          fetchParams.controller.ended = true;
          this.body.push(null);
        },
        onError(error) {
          if (this.abort) {
            fetchParams.controller.off("terminated", this.abort);
          }
          this.body?.destroy(error);
          fetchParams.controller.terminate(error);
          reject(error);
        },
        onUpgrade(status, headersList, socket) {
          if (status !== 101) {
            return;
          }
          const headers = new Headers;
          for (let n = 0;n < headersList.length; n += 2) {
            const key = headersList[n + 0].toString("latin1");
            const val = headersList[n + 1].toString("latin1");
            headers.append(key, val);
          }
          resolve({
            status,
            statusText: STATUS_CODES[status],
            headersList: headers[kHeadersList],
            socket
          });
          return true;
        }
      }));
    }
  }
  var {
    Response: Response2,
    makeNetworkError,
    makeAppropriateNetworkError,
    filterResponse,
    makeResponse
  } = require_response();
  var { Headers } = require_headers();
  var { Request, makeRequest } = require_request2();
  var zlib = __require("zlib");
  var {
    bytesMatch,
    makePolicyContainer,
    clonePolicyContainer,
    requestBadPort,
    TAOCheck,
    appendRequestOriginHeader,
    responseLocationURL,
    requestCurrentURL,
    setRequestReferrerPolicyOnRedirect,
    tryUpgradeRequestToAPotentiallyTrustworthyURL,
    createOpaqueTimingInfo,
    appendFetchMetadata,
    corsCheck,
    crossOriginResourcePolicyCheck,
    determineRequestsReferrer,
    coarsenedSharedCurrentTime,
    createDeferredPromise,
    isBlobLike,
    sameOrigin,
    isCancelled,
    isAborted,
    isErrorLike,
    fullyReadBody,
    readableStreamClose,
    isomorphicEncode,
    urlIsLocal,
    urlIsHttpHttpsScheme,
    urlHasHttpsScheme
  } = require_util2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var assert = __require("assert");
  var { safelyExtractBody } = require_body();
  var {
    redirectStatus,
    nullBodyStatus,
    safeMethods,
    requestBodyHeader,
    subresource,
    DOMException: DOMException2
  } = require_constants();
  var { kHeadersList } = require_symbols();
  var EE = __require("events");
  var { Readable, pipeline } = __require("stream");
  var { isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
  var { dataURLProcessor, serializeAMimeType } = require_dataURL();
  var { TransformStream } = __require("stream/web");
  var { getGlobalDispatcher } = require_global2();
  var { webidl } = require_webidl();
  var { STATUS_CODES } = __require("http");
  var resolveObjectURL;
  var ReadableStream = globalThis.ReadableStream;

  class Fetch extends EE {
    constructor(dispatcher) {
      super();
      this.dispatcher = dispatcher;
      this.connection = null;
      this.dump = false;
      this.state = "ongoing";
      this.setMaxListeners(21);
    }
    terminate(reason) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "terminated";
      this.connection?.destroy(reason);
      this.emit("terminated", reason);
    }
    abort(error) {
      if (this.state !== "ongoing") {
        return;
      }
      this.state = "aborted";
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      this.serializedAbortReason = error;
      this.connection?.destroy(error);
      this.emit("terminated", error);
    }
  }
  module.exports = {
    fetch: fetch2,
    Fetch,
    fetching,
    finalizeAndReportTiming
  };
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS((exports, module) => {
  module.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  };
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var kState = Symbol("ProgressEvent state");

  class ProgressEvent extends Event {
    constructor(type, eventInitDict = {}) {
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
      super(type, eventInitDict);
      this[kState] = {
        lengthComputable: eventInitDict.lengthComputable,
        loaded: eventInitDict.loaded,
        total: eventInitDict.total
      };
    }
    get lengthComputable() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].lengthComputable;
    }
    get loaded() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].loaded;
    }
    get total() {
      webidl.brandCheck(this, ProgressEvent);
      return this[kState].total;
    }
  }
  webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "loaded",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: webidl.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ]);
  module.exports = {
    ProgressEvent
  };
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS((exports, module) => {
  var getEncoding = function(label) {
    if (!label) {
      return "failure";
    }
    switch (label.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  };
  module.exports = {
    getEncoding
  };
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS((exports, module) => {
  var readOperation = function(fr, blob, type, encodingName) {
    if (fr[kState] === "loading") {
      throw new DOMException2("Invalid state", "InvalidStateError");
    }
    fr[kState] = "loading";
    fr[kResult] = null;
    fr[kError] = null;
    const stream = blob.stream();
    const reader = stream.getReader();
    const bytes = [];
    let chunkPromise = reader.read();
    let isFirstChunk = true;
    (async () => {
      while (!fr[kAborted]) {
        try {
          const { done, value } = await chunkPromise;
          if (isFirstChunk && !fr[kAborted]) {
            queueMicrotask(() => {
              fireAProgressEvent("loadstart", fr);
            });
          }
          isFirstChunk = false;
          if (!done && types.isUint8Array(value)) {
            bytes.push(value);
            if ((fr[kLastProgressEventFired] === undefined || Date.now() - fr[kLastProgressEventFired] >= 50) && !fr[kAborted]) {
              fr[kLastProgressEventFired] = Date.now();
              queueMicrotask(() => {
                fireAProgressEvent("progress", fr);
              });
            }
            chunkPromise = reader.read();
          } else if (done) {
            queueMicrotask(() => {
              fr[kState] = "done";
              try {
                const result = packageData(bytes, type, blob.type, encodingName);
                if (fr[kAborted]) {
                  return;
                }
                fr[kResult] = result;
                fireAProgressEvent("load", fr);
              } catch (error) {
                fr[kError] = error;
                fireAProgressEvent("error", fr);
              }
              if (fr[kState] !== "loading") {
                fireAProgressEvent("loadend", fr);
              }
            });
            break;
          }
        } catch (error) {
          if (fr[kAborted]) {
            return;
          }
          queueMicrotask(() => {
            fr[kState] = "done";
            fr[kError] = error;
            fireAProgressEvent("error", fr);
            if (fr[kState] !== "loading") {
              fireAProgressEvent("loadend", fr);
            }
          });
          break;
        }
      }
    })();
  };
  var fireAProgressEvent = function(e, reader) {
    const event = new ProgressEvent(e, {
      bubbles: false,
      cancelable: false
    });
    reader.dispatchEvent(event);
  };
  var packageData = function(bytes, type, mimeType, encodingName) {
    switch (type) {
      case "DataURL": {
        let dataURL = "data:";
        const parsed = parseMIMEType(mimeType || "application/octet-stream");
        if (parsed !== "failure") {
          dataURL += serializeAMimeType(parsed);
        }
        dataURL += ";base64,";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          dataURL += btoa(decoder.write(chunk));
        }
        dataURL += btoa(decoder.end());
        return dataURL;
      }
      case "Text": {
        let encoding = "failure";
        if (encodingName) {
          encoding = getEncoding(encodingName);
        }
        if (encoding === "failure" && mimeType) {
          const type2 = parseMIMEType(mimeType);
          if (type2 !== "failure") {
            encoding = getEncoding(type2.parameters.get("charset"));
          }
        }
        if (encoding === "failure") {
          encoding = "UTF-8";
        }
        return decode(bytes, encoding);
      }
      case "ArrayBuffer": {
        const sequence = combineByteSequences(bytes);
        return sequence.buffer;
      }
      case "BinaryString": {
        let binaryString = "";
        const decoder = new StringDecoder("latin1");
        for (const chunk of bytes) {
          binaryString += decoder.write(chunk);
        }
        binaryString += decoder.end();
        return binaryString;
      }
    }
  };
  var decode = function(ioQueue, encoding) {
    const bytes = combineByteSequences(ioQueue);
    const BOMEncoding = BOMSniffing(bytes);
    let slice = 0;
    if (BOMEncoding !== null) {
      encoding = BOMEncoding;
      slice = BOMEncoding === "UTF-8" ? 3 : 2;
    }
    const sliced = bytes.slice(slice);
    return new TextDecoder(encoding).decode(sliced);
  };
  var BOMSniffing = function(ioQueue) {
    const [a, b, c] = ioQueue;
    if (a === 239 && b === 187 && c === 191) {
      return "UTF-8";
    } else if (a === 254 && b === 255) {
      return "UTF-16BE";
    } else if (a === 255 && b === 254) {
      return "UTF-16LE";
    }
    return null;
  };
  var combineByteSequences = function(sequences) {
    const size = sequences.reduce((a, b) => {
      return a + b.byteLength;
    }, 0);
    let offset = 0;
    return sequences.reduce((a, b) => {
      a.set(b, offset);
      offset += b.byteLength;
      return a;
    }, new Uint8Array(size));
  };
  var {
    kState,
    kError,
    kResult,
    kAborted,
    kLastProgressEventFired
  } = require_symbols3();
  var { ProgressEvent } = require_progressevent();
  var { getEncoding } = require_encoding();
  var { DOMException: DOMException2 } = require_constants();
  var { serializeAMimeType, parseMIMEType } = require_dataURL();
  var { types } = __require("util");
  var { StringDecoder } = __require("string_decoder");
  var { btoa } = __require("buffer");
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  module.exports = {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  };
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS((exports, module) => {
  var {
    staticPropertyDescriptors,
    readOperation,
    fireAProgressEvent
  } = require_util4();
  var {
    kState,
    kError,
    kResult,
    kEvents,
    kAborted
  } = require_symbols3();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class FileReader extends EventTarget {
    constructor() {
      super();
      this[kState] = "empty";
      this[kResult] = null;
      this[kError] = null;
      this[kEvents] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    readAsArrayBuffer(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "ArrayBuffer");
    }
    readAsBinaryString(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "BinaryString");
    }
    readAsText(blob, encoding = undefined) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
      blob = webidl.converters.Blob(blob, { strict: false });
      if (encoding !== undefined) {
        encoding = webidl.converters.DOMString(encoding);
      }
      readOperation(this, blob, "Text", encoding);
    }
    readAsDataURL(blob) {
      webidl.brandCheck(this, FileReader);
      webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
      blob = webidl.converters.Blob(blob, { strict: false });
      readOperation(this, blob, "DataURL");
    }
    abort() {
      if (this[kState] === "empty" || this[kState] === "done") {
        this[kResult] = null;
        return;
      }
      if (this[kState] === "loading") {
        this[kState] = "done";
        this[kResult] = null;
      }
      this[kAborted] = true;
      fireAProgressEvent("abort", this);
      if (this[kState] !== "loading") {
        fireAProgressEvent("loadend", this);
      }
    }
    get readyState() {
      webidl.brandCheck(this, FileReader);
      switch (this[kState]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      webidl.brandCheck(this, FileReader);
      return this[kResult];
    }
    get error() {
      webidl.brandCheck(this, FileReader);
      return this[kError];
    }
    get onloadend() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadend;
    }
    set onloadend(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadend) {
        this.removeEventListener("loadend", this[kEvents].loadend);
      }
      if (typeof fn === "function") {
        this[kEvents].loadend = fn;
        this.addEventListener("loadend", fn);
      } else {
        this[kEvents].loadend = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].error) {
        this.removeEventListener("error", this[kEvents].error);
      }
      if (typeof fn === "function") {
        this[kEvents].error = fn;
        this.addEventListener("error", fn);
      } else {
        this[kEvents].error = null;
      }
    }
    get onloadstart() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].loadstart;
    }
    set onloadstart(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].loadstart) {
        this.removeEventListener("loadstart", this[kEvents].loadstart);
      }
      if (typeof fn === "function") {
        this[kEvents].loadstart = fn;
        this.addEventListener("loadstart", fn);
      } else {
        this[kEvents].loadstart = null;
      }
    }
    get onprogress() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].progress;
    }
    set onprogress(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].progress) {
        this.removeEventListener("progress", this[kEvents].progress);
      }
      if (typeof fn === "function") {
        this[kEvents].progress = fn;
        this.addEventListener("progress", fn);
      } else {
        this[kEvents].progress = null;
      }
    }
    get onload() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].load;
    }
    set onload(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].load) {
        this.removeEventListener("load", this[kEvents].load);
      }
      if (typeof fn === "function") {
        this[kEvents].load = fn;
        this.addEventListener("load", fn);
      } else {
        this[kEvents].load = null;
      }
    }
    get onabort() {
      webidl.brandCheck(this, FileReader);
      return this[kEvents].abort;
    }
    set onabort(fn) {
      webidl.brandCheck(this, FileReader);
      if (this[kEvents].abort) {
        this.removeEventListener("abort", this[kEvents].abort);
      }
      if (typeof fn === "function") {
        this[kEvents].abort = fn;
        this.addEventListener("abort", fn);
      } else {
        this[kEvents].abort = null;
      }
    }
  }
  FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
  FileReader.LOADING = FileReader.prototype.LOADING = 1;
  FileReader.DONE = FileReader.prototype.DONE = 2;
  Object.defineProperties(FileReader.prototype, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors,
    readAsArrayBuffer: kEnumerableProperty,
    readAsBinaryString: kEnumerableProperty,
    readAsText: kEnumerableProperty,
    readAsDataURL: kEnumerableProperty,
    abort: kEnumerableProperty,
    readyState: kEnumerableProperty,
    result: kEnumerableProperty,
    error: kEnumerableProperty,
    onloadstart: kEnumerableProperty,
    onprogress: kEnumerableProperty,
    onload: kEnumerableProperty,
    onabort: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onloadend: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(FileReader, {
    EMPTY: staticPropertyDescriptors,
    LOADING: staticPropertyDescriptors,
    DONE: staticPropertyDescriptors
  });
  module.exports = {
    FileReader
  };
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS((exports, module) => {
  module.exports = {
    kConstruct: Symbol("constructable")
  };
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS((exports, module) => {
  var urlEquals = function(A, B, excludeFragment = false) {
    const serializedA = URLSerializer(A, excludeFragment);
    const serializedB = URLSerializer(B, excludeFragment);
    return serializedA === serializedB;
  };
  var fieldValues = function(header) {
    assert(header !== null);
    const values = [];
    for (let value of header.split(",")) {
      value = value.trim();
      if (!value.length) {
        continue;
      } else if (!isValidHeaderName(value)) {
        continue;
      }
      values.push(value);
    }
    return values;
  };
  var assert = __require("assert");
  var { URLSerializer } = require_dataURL();
  var { isValidHeaderName } = require_util2();
  module.exports = {
    urlEquals,
    fieldValues
  };
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { urlEquals, fieldValues: getFieldValues } = require_util5();
  var { kEnumerableProperty, isDisturbed } = require_util();
  var { kHeadersList } = require_symbols();
  var { webidl } = require_webidl();
  var { Response: Response2, cloneResponse } = require_response();
  var { Request } = require_request2();
  var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
  var { fetching } = require_fetch();
  var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
  var assert = __require("assert");
  var { getGlobalDispatcher } = require_global2();

  class Cache {
    #relevantRequestResponseList;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
      this.#relevantRequestResponseList = arguments[1];
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      const p = await this.matchAll(request, options);
      if (p.length === 0) {
        return;
      }
      return p[0];
    }
    async matchAll(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const responses = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          responses.push(requestResponse[1]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          responses.push(requestResponse[1]);
        }
      }
      const responseList = [];
      for (const response of responses) {
        const responseObject = new Response2(response.body?.source ?? null);
        const body = responseObject[kState].body;
        responseObject[kState] = response;
        responseObject[kState].body = body;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseList.push(responseObject);
      }
      return Object.freeze(responseList);
    }
    async add(request) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
      request = webidl.converters.RequestInfo(request);
      const requests = [request];
      const responseArrayPromise = this.addAll(requests);
      return await responseArrayPromise;
    }
    async addAll(requests) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
      requests = webidl.converters["sequence<RequestInfo>"](requests);
      const responsePromises = [];
      const requestList = [];
      for (const request of requests) {
        if (typeof request === "string") {
          continue;
        }
        const r = request[kState];
        if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
        }
      }
      const fetchControllers = [];
      for (const request of requests) {
        const r = new Request(request)[kState];
        if (!urlIsHttpHttpsScheme(r.url)) {
          throw webidl.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        }
        r.initiator = "fetch";
        r.destination = "subresource";
        requestList.push(r);
        const responsePromise = createDeferredPromise();
        fetchControllers.push(fetching({
          request: r,
          dispatcher: getGlobalDispatcher(),
          processResponse(response) {
            if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
              responsePromise.reject(webidl.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            } else if (response.headersList.contains("vary")) {
              const fieldValues = getFieldValues(response.headersList.get("vary"));
              for (const fieldValue of fieldValues) {
                if (fieldValue === "*") {
                  responsePromise.reject(webidl.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const controller of fetchControllers) {
                    controller.abort();
                  }
                  return;
                }
              }
            }
          },
          processResponseEndOfBody(response) {
            if (response.aborted) {
              responsePromise.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            responsePromise.resolve(response);
          }
        }));
        responsePromises.push(responsePromise.promise);
      }
      const p = Promise.all(responsePromises);
      const responses = await p;
      const operations = [];
      let index = 0;
      for (const response of responses) {
        const operation = {
          type: "put",
          request: requestList[index],
          response
        };
        operations.push(operation);
        index++;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(undefined);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async put(request, response) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
      request = webidl.converters.RequestInfo(request);
      response = webidl.converters.Response(response);
      let innerRequest = null;
      if (request instanceof Request) {
        innerRequest = request[kState];
      } else {
        innerRequest = new Request(request)[kState];
      }
      if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      }
      const innerResponse = response[kState];
      if (innerResponse.status === 206) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      }
      if (innerResponse.headersList.contains("vary")) {
        const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
        for (const fieldValue of fieldValues) {
          if (fieldValue === "*") {
            throw webidl.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
          }
        }
      }
      if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
        throw webidl.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      }
      const clonedResponse = cloneResponse(innerResponse);
      const bodyReadPromise = createDeferredPromise();
      if (innerResponse.body != null) {
        const stream = innerResponse.body.stream;
        const reader = stream.getReader();
        readAllBytes(reader, (bytes2) => bodyReadPromise.resolve(bytes2), (error) => bodyReadPromise.reject(error));
      } else {
        bodyReadPromise.resolve(undefined);
      }
      const operations = [];
      const operation = {
        type: "put",
        request: innerRequest,
        response: clonedResponse
      };
      operations.push(operation);
      const bytes = await bodyReadPromise.promise;
      if (clonedResponse.body != null) {
        clonedResponse.body.source = bytes;
      }
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      try {
        this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve();
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async delete(request, options = {}) {
      webidl.brandCheck(this, Cache);
      webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request instanceof Request) {
        r = request[kState];
        if (r.method !== "GET" && !options.ignoreMethod) {
          return false;
        }
      } else {
        assert(typeof request === "string");
        r = new Request(request)[kState];
      }
      const operations = [];
      const operation = {
        type: "delete",
        request: r,
        options
      };
      operations.push(operation);
      const cacheJobPromise = createDeferredPromise();
      let errorData = null;
      let requestResponses;
      try {
        requestResponses = this.#batchCacheOperations(operations);
      } catch (e) {
        errorData = e;
      }
      queueMicrotask(() => {
        if (errorData === null) {
          cacheJobPromise.resolve(!!requestResponses?.length);
        } else {
          cacheJobPromise.reject(errorData);
        }
      });
      return cacheJobPromise.promise;
    }
    async keys(request = undefined, options = {}) {
      webidl.brandCheck(this, Cache);
      if (request !== undefined)
        request = webidl.converters.RequestInfo(request);
      options = webidl.converters.CacheQueryOptions(options);
      let r = null;
      if (request !== undefined) {
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return [];
          }
        } else if (typeof request === "string") {
          r = new Request(request)[kState];
        }
      }
      const promise = createDeferredPromise();
      const requests = [];
      if (request === undefined) {
        for (const requestResponse of this.#relevantRequestResponseList) {
          requests.push(requestResponse[0]);
        }
      } else {
        const requestResponses = this.#queryCache(r, options);
        for (const requestResponse of requestResponses) {
          requests.push(requestResponse[0]);
        }
      }
      queueMicrotask(() => {
        const requestList = [];
        for (const request2 of requests) {
          const requestObject = new Request("https://a");
          requestObject[kState] = request2;
          requestObject[kHeaders][kHeadersList] = request2.headersList;
          requestObject[kHeaders][kGuard] = "immutable";
          requestObject[kRealm] = request2.client;
          requestList.push(requestObject);
        }
        promise.resolve(Object.freeze(requestList));
      });
      return promise.promise;
    }
    #batchCacheOperations(operations) {
      const cache = this.#relevantRequestResponseList;
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (this.#queryCache(operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = this.#queryCache(operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = this.#queryCache(operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        this.#relevantRequestResponseList.length = 0;
        this.#relevantRequestResponseList = backupCache;
        throw e;
      }
    }
    #queryCache(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? this.#relevantRequestResponseList;
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (this.#requestMatchesCachedItem(requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    }
    #requestMatchesCachedItem(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    }
  }
  Object.defineProperties(Cache.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: true
    },
    match: kEnumerableProperty,
    matchAll: kEnumerableProperty,
    add: kEnumerableProperty,
    addAll: kEnumerableProperty,
    put: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  var cacheQueryOptionConverters = [
    {
      key: "ignoreSearch",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreMethod",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "ignoreVary",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
  webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
    ...cacheQueryOptionConverters,
    {
      key: "cacheName",
      converter: webidl.converters.DOMString
    }
  ]);
  webidl.converters.Response = webidl.interfaceConverter(Response2);
  webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(webidl.converters.RequestInfo);
  module.exports = {
    Cache
  };
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS((exports, module) => {
  var { kConstruct } = require_symbols4();
  var { Cache } = require_cache();
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();

  class CacheStorage {
    #caches = new Map;
    constructor() {
      if (arguments[0] !== kConstruct) {
        webidl.illegalConstructor();
      }
    }
    async match(request, options = {}) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
      request = webidl.converters.RequestInfo(request);
      options = webidl.converters.MultiCacheQueryOptions(options);
      if (options.cacheName != null) {
        if (this.#caches.has(options.cacheName)) {
          const cacheList = this.#caches.get(options.cacheName);
          const cache = new Cache(kConstruct, cacheList);
          return await cache.match(request, options);
        }
      } else {
        for (const cacheList of this.#caches.values()) {
          const cache = new Cache(kConstruct, cacheList);
          const response = await cache.match(request, options);
          if (response !== undefined) {
            return response;
          }
        }
      }
    }
    async has(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.has(cacheName);
    }
    async open(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
      cacheName = webidl.converters.DOMString(cacheName);
      if (this.#caches.has(cacheName)) {
        const cache2 = this.#caches.get(cacheName);
        return new Cache(kConstruct, cache2);
      }
      const cache = [];
      this.#caches.set(cacheName, cache);
      return new Cache(kConstruct, cache);
    }
    async delete(cacheName) {
      webidl.brandCheck(this, CacheStorage);
      webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
      cacheName = webidl.converters.DOMString(cacheName);
      return this.#caches.delete(cacheName);
    }
    async keys() {
      webidl.brandCheck(this, CacheStorage);
      const keys = this.#caches.keys();
      return [...keys];
    }
  }
  Object.defineProperties(CacheStorage.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: true
    },
    match: kEnumerableProperty,
    has: kEnumerableProperty,
    open: kEnumerableProperty,
    delete: kEnumerableProperty,
    keys: kEnumerableProperty
  });
  module.exports = {
    CacheStorage
  };
});

// node_modules/undici/lib/cookies/constants.js
var require_constants3 = __commonJS((exports, module) => {
  var maxAttributeValueSize = 1024;
  var maxNameValuePairSize = 4096;
  module.exports = {
    maxAttributeValueSize,
    maxNameValuePairSize
  };
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS((exports, module) => {
  var isCTLExcludingHtab = function(value) {
    if (value.length === 0) {
      return false;
    }
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
        return false;
      }
    }
  };
  var validateCookieName = function(name) {
    for (const char of name) {
      const code = char.charCodeAt(0);
      if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
        throw new Error("Invalid cookie name");
      }
    }
  };
  var validateCookieValue = function(value) {
    for (const char of value) {
      const code = char.charCodeAt(0);
      if (code < 33 || code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
        throw new Error("Invalid header value");
      }
    }
  };
  var validateCookiePath = function(path) {
    for (const char of path) {
      const code = char.charCodeAt(0);
      if (code < 33 || char === ";") {
        throw new Error("Invalid cookie path");
      }
    }
  };
  var validateCookieDomain = function(domain) {
    if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
      throw new Error("Invalid cookie domain");
    }
  };
  var toIMFDate = function(date) {
    if (typeof date === "number") {
      date = new Date(date);
    }
    const days = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    const months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    const dayName = days[date.getUTCDay()];
    const day = date.getUTCDate().toString().padStart(2, "0");
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();
    const hour = date.getUTCHours().toString().padStart(2, "0");
    const minute = date.getUTCMinutes().toString().padStart(2, "0");
    const second = date.getUTCSeconds().toString().padStart(2, "0");
    return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
  };
  var validateCookieMaxAge = function(maxAge) {
    if (maxAge < 0) {
      throw new Error("Invalid cookie max-age");
    }
  };
  var stringify = function(cookie) {
    if (cookie.name.length === 0) {
      return null;
    }
    validateCookieName(cookie.name);
    validateCookieValue(cookie.value);
    const out = [`${cookie.name}=${cookie.value}`];
    if (cookie.name.startsWith("__Secure-")) {
      cookie.secure = true;
    }
    if (cookie.name.startsWith("__Host-")) {
      cookie.secure = true;
      cookie.domain = null;
      cookie.path = "/";
    }
    if (cookie.secure) {
      out.push("Secure");
    }
    if (cookie.httpOnly) {
      out.push("HttpOnly");
    }
    if (typeof cookie.maxAge === "number") {
      validateCookieMaxAge(cookie.maxAge);
      out.push(`Max-Age=${cookie.maxAge}`);
    }
    if (cookie.domain) {
      validateCookieDomain(cookie.domain);
      out.push(`Domain=${cookie.domain}`);
    }
    if (cookie.path) {
      validateCookiePath(cookie.path);
      out.push(`Path=${cookie.path}`);
    }
    if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
      out.push(`Expires=${toIMFDate(cookie.expires)}`);
    }
    if (cookie.sameSite) {
      out.push(`SameSite=${cookie.sameSite}`);
    }
    for (const part of cookie.unparsed) {
      if (!part.includes("=")) {
        throw new Error("Invalid unparsed");
      }
      const [key, ...value] = part.split("=");
      out.push(`${key.trim()}=${value.join("=")}`);
    }
    return out.join("; ");
  };
  var getHeadersList = function(headers) {
    if (headers[kHeadersList]) {
      return headers[kHeadersList];
    }
    if (!kHeadersListNode) {
      kHeadersListNode = Object.getOwnPropertySymbols(headers).find((symbol) => symbol.description === "headers list");
      assert(kHeadersListNode, "Headers cannot be parsed");
    }
    const headersList = headers[kHeadersListNode];
    assert(headersList);
    return headersList;
  };
  var assert = __require("assert");
  var { kHeadersList } = require_symbols();
  var kHeadersListNode;
  module.exports = {
    isCTLExcludingHtab,
    stringify,
    getHeadersList
  };
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS((exports, module) => {
  var parseSetCookie = function(header) {
    if (isCTLExcludingHtab(header)) {
      return null;
    }
    let nameValuePair = "";
    let unparsedAttributes = "";
    let name = "";
    let value = "";
    if (header.includes(";")) {
      const position = { position: 0 };
      nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
      unparsedAttributes = header.slice(position.position);
    } else {
      nameValuePair = header;
    }
    if (!nameValuePair.includes("=")) {
      value = nameValuePair;
    } else {
      const position = { position: 0 };
      name = collectASequenceOfCodePointsFast("=", nameValuePair, position);
      value = nameValuePair.slice(position.position + 1);
    }
    name = name.trim();
    value = value.trim();
    if (name.length + value.length > maxNameValuePairSize) {
      return null;
    }
    return {
      name,
      value,
      ...parseUnparsedAttributes(unparsedAttributes)
    };
  };
  var parseUnparsedAttributes = function(unparsedAttributes, cookieAttributeList = {}) {
    if (unparsedAttributes.length === 0) {
      return cookieAttributeList;
    }
    assert(unparsedAttributes[0] === ";");
    unparsedAttributes = unparsedAttributes.slice(1);
    let cookieAv = "";
    if (unparsedAttributes.includes(";")) {
      cookieAv = collectASequenceOfCodePointsFast(";", unparsedAttributes, { position: 0 });
      unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
    } else {
      cookieAv = unparsedAttributes;
      unparsedAttributes = "";
    }
    let attributeName = "";
    let attributeValue = "";
    if (cookieAv.includes("=")) {
      const position = { position: 0 };
      attributeName = collectASequenceOfCodePointsFast("=", cookieAv, position);
      attributeValue = cookieAv.slice(position.position + 1);
    } else {
      attributeName = cookieAv;
    }
    attributeName = attributeName.trim();
    attributeValue = attributeValue.trim();
    if (attributeValue.length > maxAttributeValueSize) {
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    const attributeNameLowercase = attributeName.toLowerCase();
    if (attributeNameLowercase === "expires") {
      const expiryTime = new Date(attributeValue);
      cookieAttributeList.expires = expiryTime;
    } else if (attributeNameLowercase === "max-age") {
      const charCode = attributeValue.charCodeAt(0);
      if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      if (!/^\d+$/.test(attributeValue)) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const deltaSeconds = Number(attributeValue);
      cookieAttributeList.maxAge = deltaSeconds;
    } else if (attributeNameLowercase === "domain") {
      let cookieDomain = attributeValue;
      if (cookieDomain[0] === ".") {
        cookieDomain = cookieDomain.slice(1);
      }
      cookieDomain = cookieDomain.toLowerCase();
      cookieAttributeList.domain = cookieDomain;
    } else if (attributeNameLowercase === "path") {
      let cookiePath = "";
      if (attributeValue.length === 0 || attributeValue[0] !== "/") {
        cookiePath = "/";
      } else {
        cookiePath = attributeValue;
      }
      cookieAttributeList.path = cookiePath;
    } else if (attributeNameLowercase === "secure") {
      cookieAttributeList.secure = true;
    } else if (attributeNameLowercase === "httponly") {
      cookieAttributeList.httpOnly = true;
    } else if (attributeNameLowercase === "samesite") {
      let enforcement = "Default";
      const attributeValueLowercase = attributeValue.toLowerCase();
      if (attributeValueLowercase.includes("none")) {
        enforcement = "None";
      }
      if (attributeValueLowercase.includes("strict")) {
        enforcement = "Strict";
      }
      if (attributeValueLowercase.includes("lax")) {
        enforcement = "Lax";
      }
      cookieAttributeList.sameSite = enforcement;
    } else {
      cookieAttributeList.unparsed ??= [];
      cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
    }
    return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
  };
  var { maxNameValuePairSize, maxAttributeValueSize } = require_constants3();
  var { isCTLExcludingHtab } = require_util6();
  var { collectASequenceOfCodePointsFast } = require_dataURL();
  var assert = __require("assert");
  module.exports = {
    parseSetCookie,
    parseUnparsedAttributes
  };
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS((exports, module) => {
  var getCookies = function(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookie = headers.get("cookie");
    const out = {};
    if (!cookie) {
      return out;
    }
    for (const piece of cookie.split(";")) {
      const [name, ...value] = piece.split("=");
      out[name.trim()] = value.join("=");
    }
    return out;
  };
  var deleteCookie = function(headers, name, attributes) {
    webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    name = webidl.converters.DOMString(name);
    attributes = webidl.converters.DeleteCookieAttributes(attributes);
    setCookie(headers, {
      name,
      value: "",
      expires: new Date(0),
      ...attributes
    });
  };
  var getSetCookies = function(headers) {
    webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
    webidl.brandCheck(headers, Headers, { strict: false });
    const cookies = getHeadersList(headers).cookies;
    if (!cookies) {
      return [];
    }
    return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
  };
  var setCookie = function(headers, cookie) {
    webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
    webidl.brandCheck(headers, Headers, { strict: false });
    cookie = webidl.converters.Cookie(cookie);
    const str = stringify(cookie);
    if (str) {
      headers.append("Set-Cookie", stringify(cookie));
    }
  };
  var { parseSetCookie } = require_parse();
  var { stringify, getHeadersList } = require_util6();
  var { webidl } = require_webidl();
  var { Headers } = require_headers();
  webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]);
  webidl.converters.Cookie = webidl.dictionaryConverter([
    {
      converter: webidl.converters.DOMString,
      key: "name"
    },
    {
      converter: webidl.converters.DOMString,
      key: "value"
    },
    {
      converter: webidl.nullableConverter((value) => {
        if (typeof value === "number") {
          return webidl.converters["unsigned long long"](value);
        }
        return new Date(value);
      }),
      key: "expires",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: webidl.nullableConverter(webidl.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: webidl.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: webidl.sequenceConverter(webidl.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]);
  module.exports = {
    getCookies,
    deleteCookie,
    getSetCookies,
    setCookie
  };
});

// node_modules/undici/lib/websocket/constants.js
var require_constants4 = __commonJS((exports, module) => {
  var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  var staticPropertyDescriptors = {
    enumerable: true,
    writable: false,
    configurable: false
  };
  var states = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  };
  var opcodes = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  };
  var maxUnsigned16Bit = 2 ** 16 - 1;
  var parserStates = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  };
  var emptyBuffer = Buffer.allocUnsafe(0);
  module.exports = {
    uid,
    staticPropertyDescriptors,
    states,
    opcodes,
    maxUnsigned16Bit,
    parserStates,
    emptyBuffer
  };
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS((exports, module) => {
  module.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  };
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { kEnumerableProperty } = require_util();
  var { MessagePort } = __require("worker_threads");

  class MessageEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get data() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.data;
    }
    get origin() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.origin;
    }
    get lastEventId() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.lastEventId;
    }
    get source() {
      webidl.brandCheck(this, MessageEvent);
      return this.#eventInit.source;
    }
    get ports() {
      webidl.brandCheck(this, MessageEvent);
      if (!Object.isFrozen(this.#eventInit.ports)) {
        Object.freeze(this.#eventInit.ports);
      }
      return this.#eventInit.ports;
    }
    initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
      webidl.brandCheck(this, MessageEvent);
      webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
      return new MessageEvent(type, {
        bubbles,
        cancelable,
        data,
        origin,
        lastEventId,
        source,
        ports
      });
    }
  }

  class CloseEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
      super(type, eventInitDict);
      this.#eventInit = eventInitDict;
    }
    get wasClean() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.wasClean;
    }
    get code() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.code;
    }
    get reason() {
      webidl.brandCheck(this, CloseEvent);
      return this.#eventInit.reason;
    }
  }

  class ErrorEvent extends Event {
    #eventInit;
    constructor(type, eventInitDict) {
      webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(type, eventInitDict);
      type = webidl.converters.DOMString(type);
      eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
      this.#eventInit = eventInitDict;
    }
    get message() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.message;
    }
    get filename() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.filename;
    }
    get lineno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.lineno;
    }
    get colno() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.colno;
    }
    get error() {
      webidl.brandCheck(this, ErrorEvent);
      return this.#eventInit.error;
    }
  }
  Object.defineProperties(MessageEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: true
    },
    data: kEnumerableProperty,
    origin: kEnumerableProperty,
    lastEventId: kEnumerableProperty,
    source: kEnumerableProperty,
    ports: kEnumerableProperty,
    initMessageEvent: kEnumerableProperty
  });
  Object.defineProperties(CloseEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: true
    },
    reason: kEnumerableProperty,
    code: kEnumerableProperty,
    wasClean: kEnumerableProperty
  });
  Object.defineProperties(ErrorEvent.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: true
    },
    message: kEnumerableProperty,
    filename: kEnumerableProperty,
    lineno: kEnumerableProperty,
    colno: kEnumerableProperty,
    error: kEnumerableProperty
  });
  webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
  webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(webidl.converters.MessagePort);
  var eventInit = [
    {
      key: "bubbles",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "cancelable",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "composed",
      converter: webidl.converters.boolean,
      defaultValue: false
    }
  ];
  webidl.converters.MessageEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "data",
      converter: webidl.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      converter: webidl.nullableConverter(webidl.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: webidl.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]);
  webidl.converters.CloseEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "wasClean",
      converter: webidl.converters.boolean,
      defaultValue: false
    },
    {
      key: "code",
      converter: webidl.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: webidl.converters.USVString,
      defaultValue: ""
    }
  ]);
  webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
    ...eventInit,
    {
      key: "message",
      converter: webidl.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: webidl.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: webidl.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: webidl.converters.any
    }
  ]);
  module.exports = {
    MessageEvent,
    CloseEvent,
    ErrorEvent
  };
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS((exports, module) => {
  var isEstablished = function(ws) {
    return ws[kReadyState] === states.OPEN;
  };
  var isClosing = function(ws) {
    return ws[kReadyState] === states.CLOSING;
  };
  var isClosed = function(ws) {
    return ws[kReadyState] === states.CLOSED;
  };
  var fireEvent = function(e, target, eventConstructor = Event, eventInitDict) {
    const event = new eventConstructor(e, eventInitDict);
    target.dispatchEvent(event);
  };
  var websocketMessageReceived = function(ws, type, data) {
    if (ws[kReadyState] !== states.OPEN) {
      return;
    }
    let dataForEvent;
    if (type === opcodes.TEXT) {
      try {
        dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
      } catch {
        failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
        return;
      }
    } else if (type === opcodes.BINARY) {
      if (ws[kBinaryType] === "blob") {
        dataForEvent = new Blob([data]);
      } else {
        dataForEvent = new Uint8Array(data).buffer;
      }
    }
    fireEvent("message", ws, MessageEvent, {
      origin: ws[kWebSocketURL].origin,
      data: dataForEvent
    });
  };
  var isValidSubprotocol = function(protocol) {
    if (protocol.length === 0) {
      return false;
    }
    for (const char of protocol) {
      const code = char.charCodeAt(0);
      if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || code === 9) {
        return false;
      }
    }
    return true;
  };
  var isValidStatusCode = function(code) {
    if (code >= 1000 && code < 1015) {
      return code !== 1004 && code !== 1005 && code !== 1006;
    }
    return code >= 3000 && code <= 4999;
  };
  var failWebsocketConnection = function(ws, reason) {
    const { [kController]: controller, [kResponse]: response } = ws;
    controller.abort();
    if (response?.socket && !response.socket.destroyed) {
      response.socket.destroy();
    }
    if (reason) {
      fireEvent("error", ws, ErrorEvent, {
        error: new Error(reason)
      });
    }
  };
  var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
  var { states, opcodes } = require_constants4();
  var { MessageEvent, ErrorEvent } = require_events();
  module.exports = {
    isEstablished,
    isClosing,
    isClosed,
    fireEvent,
    isValidSubprotocol,
    isValidStatusCode,
    failWebsocketConnection,
    websocketMessageReceived
  };
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS((exports, module) => {
  var establishWebSocketConnection = function(url, protocols, ws, onEstablish, options) {
    const requestURL = url;
    requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
    const request = makeRequest({
      urlList: [requestURL],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (options.headers) {
      const headersList = new Headers(options.headers)[kHeadersList];
      request.headersList = headersList;
    }
    const keyValue = randomBytes(16).toString("base64");
    request.headersList.append("sec-websocket-key", keyValue);
    request.headersList.append("sec-websocket-version", "13");
    for (const protocol of protocols) {
      request.headersList.append("sec-websocket-protocol", protocol);
    }
    const permessageDeflate = "";
    const controller = fetching({
      request,
      useParallelQueue: true,
      dispatcher: options.dispatcher ?? getGlobalDispatcher(),
      processResponse(response) {
        if (response.type === "error" || response.status !== 101) {
          failWebsocketConnection(ws, "Received network error or non-101 status code.");
          return;
        }
        if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Server did not respond with sent protocols.");
          return;
        }
        if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
        const digest = createHash("sha1").update(keyValue + uid).digest("base64");
        if (secWSAccept !== digest) {
          failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
        if (secExtension !== null && secExtension !== permessageDeflate) {
          failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
          return;
        }
        const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
        if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
          failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
          return;
        }
        response.socket.on("data", onSocketData);
        response.socket.on("close", onSocketClose);
        response.socket.on("error", onSocketError);
        if (channels.open.hasSubscribers) {
          channels.open.publish({
            address: response.socket.address(),
            protocol: secProtocol,
            extensions: secExtension
          });
        }
        onEstablish(response);
      }
    });
    return controller;
  };
  var onSocketData = function(chunk) {
    if (!this.ws[kByteParser].write(chunk)) {
      this.pause();
    }
  };
  var onSocketClose = function() {
    const { ws } = this;
    const wasClean = ws[kSentClose] && ws[kReceivedClose];
    let code = 1005;
    let reason = "";
    const result = ws[kByteParser].closingInfo;
    if (result) {
      code = result.code ?? 1005;
      reason = result.reason;
    } else if (!ws[kSentClose]) {
      code = 1006;
    }
    ws[kReadyState] = states.CLOSED;
    fireEvent("close", ws, CloseEvent, {
      wasClean,
      code,
      reason
    });
    if (channels.close.hasSubscribers) {
      channels.close.publish({
        websocket: ws,
        code,
        reason
      });
    }
  };
  var onSocketError = function(error) {
    const { ws } = this;
    ws[kReadyState] = states.CLOSING;
    if (channels.socketError.hasSubscribers) {
      channels.socketError.publish(error);
    }
    this.destroy();
  };
  var { randomBytes, createHash } = __require("crypto");
  var diagnosticsChannel = __require("diagnostics_channel");
  var { uid, states } = require_constants4();
  var {
    kReadyState,
    kSentClose,
    kByteParser,
    kReceivedClose
  } = require_symbols5();
  var { fireEvent, failWebsocketConnection } = require_util7();
  var { CloseEvent } = require_events();
  var { makeRequest } = require_request2();
  var { fetching } = require_fetch();
  var { Headers } = require_headers();
  var { getGlobalDispatcher } = require_global2();
  var { kHeadersList } = require_symbols();
  var channels = {};
  channels.open = diagnosticsChannel.channel("undici:websocket:open");
  channels.close = diagnosticsChannel.channel("undici:websocket:close");
  channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
  module.exports = {
    establishWebSocketConnection
  };
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS((exports, module) => {
  var { randomBytes } = __require("crypto");
  var { maxUnsigned16Bit } = require_constants4();

  class WebsocketFrameSend {
    constructor(data) {
      this.frameData = data;
      this.maskKey = randomBytes(4);
    }
    createFrame(opcode) {
      const bodyLength = this.frameData?.byteLength ?? 0;
      let payloadLength = bodyLength;
      let offset = 6;
      if (bodyLength > maxUnsigned16Bit) {
        offset += 8;
        payloadLength = 127;
      } else if (bodyLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const buffer = Buffer.allocUnsafe(bodyLength + offset);
      buffer[0] = buffer[1] = 0;
      buffer[0] |= 128;
      buffer[0] = (buffer[0] & 240) + opcode;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      buffer[offset - 4] = this.maskKey[0];
      buffer[offset - 3] = this.maskKey[1];
      buffer[offset - 2] = this.maskKey[2];
      buffer[offset - 1] = this.maskKey[3];
      buffer[1] = payloadLength;
      if (payloadLength === 126) {
        buffer.writeUInt16BE(bodyLength, 2);
      } else if (payloadLength === 127) {
        buffer[2] = buffer[3] = 0;
        buffer.writeUIntBE(bodyLength, 4, 6);
      }
      buffer[1] |= 128;
      for (let i = 0;i < bodyLength; i++) {
        buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
      }
      return buffer;
    }
  }
  module.exports = {
    WebsocketFrameSend
  };
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS((exports, module) => {
  var { Writable } = __require("stream");
  var diagnosticsChannel = __require("diagnostics_channel");
  var { parserStates, opcodes, states, emptyBuffer } = require_constants4();
  var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
  var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
  var { WebsocketFrameSend } = require_frame();
  var channels = {};
  channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
  channels.pong = diagnosticsChannel.channel("undici:websocket:pong");

  class ByteParser extends Writable {
    #buffers = [];
    #byteOffset = 0;
    #state = parserStates.INFO;
    #info = {};
    #fragments = [];
    constructor(ws) {
      super();
      this.ws = ws;
    }
    _write(chunk, _, callback) {
      this.#buffers.push(chunk);
      this.#byteOffset += chunk.length;
      this.run(callback);
    }
    run(callback) {
      while (true) {
        if (this.#state === parserStates.INFO) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.fin = (buffer[0] & 128) !== 0;
          this.#info.opcode = buffer[0] & 15;
          this.#info.originalOpcode ??= this.#info.opcode;
          this.#info.fragmented = !this.#info.fin && this.#info.opcode !== opcodes.CONTINUATION;
          if (this.#info.fragmented && this.#info.opcode !== opcodes.BINARY && this.#info.opcode !== opcodes.TEXT) {
            failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const payloadLength = buffer[1] & 127;
          if (payloadLength <= 125) {
            this.#info.payloadLength = payloadLength;
            this.#state = parserStates.READ_DATA;
          } else if (payloadLength === 126) {
            this.#state = parserStates.PAYLOADLENGTH_16;
          } else if (payloadLength === 127) {
            this.#state = parserStates.PAYLOADLENGTH_64;
          }
          if (this.#info.fragmented && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((this.#info.opcode === opcodes.PING || this.#info.opcode === opcodes.PONG || this.#info.opcode === opcodes.CLOSE) && payloadLength > 125) {
            failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#info.opcode === opcodes.CLOSE) {
            if (payloadLength === 1) {
              failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const body = this.consume(payloadLength);
            this.#info.closeInfo = this.parseCloseBody(false, body);
            if (!this.ws[kSentClose]) {
              const body2 = Buffer.allocUnsafe(2);
              body2.writeUInt16BE(this.#info.closeInfo.code, 0);
              const closeFrame = new WebsocketFrameSend(body2);
              this.ws[kResponse].socket.write(closeFrame.createFrame(opcodes.CLOSE), (err) => {
                if (!err) {
                  this.ws[kSentClose] = true;
                }
              });
            }
            this.ws[kReadyState] = states.CLOSING;
            this.ws[kReceivedClose] = true;
            this.end();
            return;
          } else if (this.#info.opcode === opcodes.PING) {
            const body = this.consume(payloadLength);
            if (!this.ws[kReceivedClose]) {
              const frame = new WebsocketFrameSend(body);
              this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
              if (channels.ping.hasSubscribers) {
                channels.ping.publish({
                  payload: body
                });
              }
            }
            this.#state = parserStates.INFO;
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          } else if (this.#info.opcode === opcodes.PONG) {
            const body = this.consume(payloadLength);
            if (channels.pong.hasSubscribers) {
              channels.pong.publish({
                payload: body
              });
            }
            if (this.#byteOffset > 0) {
              continue;
            } else {
              callback();
              return;
            }
          }
        } else if (this.#state === parserStates.PAYLOADLENGTH_16) {
          if (this.#byteOffset < 2) {
            return callback();
          }
          const buffer = this.consume(2);
          this.#info.payloadLength = buffer.readUInt16BE(0);
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.PAYLOADLENGTH_64) {
          if (this.#byteOffset < 8) {
            return callback();
          }
          const buffer = this.consume(8);
          const upper = buffer.readUInt32BE(0);
          if (upper > 2 ** 31 - 1) {
            failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const lower = buffer.readUInt32BE(4);
          this.#info.payloadLength = (upper << 8) + lower;
          this.#state = parserStates.READ_DATA;
        } else if (this.#state === parserStates.READ_DATA) {
          if (this.#byteOffset < this.#info.payloadLength) {
            return callback();
          } else if (this.#byteOffset >= this.#info.payloadLength) {
            const body = this.consume(this.#info.payloadLength);
            this.#fragments.push(body);
            if (!this.#info.fragmented || this.#info.fin && this.#info.opcode === opcodes.CONTINUATION) {
              const fullMessage = Buffer.concat(this.#fragments);
              websocketMessageReceived(this.ws, this.#info.originalOpcode, fullMessage);
              this.#info = {};
              this.#fragments.length = 0;
            }
            this.#state = parserStates.INFO;
          }
        }
        if (this.#byteOffset > 0) {
          continue;
        } else {
          callback();
          break;
        }
      }
    }
    consume(n) {
      if (n > this.#byteOffset) {
        return null;
      } else if (n === 0) {
        return emptyBuffer;
      }
      if (this.#buffers[0].length === n) {
        this.#byteOffset -= this.#buffers[0].length;
        return this.#buffers.shift();
      }
      const buffer = Buffer.allocUnsafe(n);
      let offset = 0;
      while (offset !== n) {
        const next = this.#buffers[0];
        const { length } = next;
        if (length + offset === n) {
          buffer.set(this.#buffers.shift(), offset);
          break;
        } else if (length + offset > n) {
          buffer.set(next.subarray(0, n - offset), offset);
          this.#buffers[0] = next.subarray(n - offset);
          break;
        } else {
          buffer.set(this.#buffers.shift(), offset);
          offset += next.length;
        }
      }
      this.#byteOffset -= n;
      return buffer;
    }
    parseCloseBody(onlyCode, data) {
      let code;
      if (data.length >= 2) {
        code = data.readUInt16BE(0);
      }
      if (onlyCode) {
        if (!isValidStatusCode(code)) {
          return null;
        }
        return { code };
      }
      let reason = data.subarray(2);
      if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
        reason = reason.subarray(3);
      }
      if (code !== undefined && !isValidStatusCode(code)) {
        return null;
      }
      try {
        reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
      } catch {
        return null;
      }
      return { code, reason };
    }
    get closingInfo() {
      return this.#info.closeInfo;
    }
  }
  module.exports = {
    ByteParser
  };
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS((exports, module) => {
  var { webidl } = require_webidl();
  var { DOMException: DOMException2 } = require_constants();
  var { URLSerializer } = require_dataURL();
  var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants4();
  var {
    kWebSocketURL,
    kReadyState,
    kController,
    kBinaryType,
    kResponse,
    kSentClose,
    kByteParser
  } = require_symbols5();
  var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
  var { establishWebSocketConnection } = require_connection();
  var { WebsocketFrameSend } = require_frame();
  var { ByteParser } = require_receiver();
  var { kEnumerableProperty, isBlobLike } = require_util();
  var { getGlobalDispatcher } = require_global2();
  var { types } = __require("util");
  var experimentalWarned = false;

  class WebSocket extends EventTarget {
    #events = {
      open: null,
      error: null,
      close: null,
      message: null
    };
    #bufferedAmount = 0;
    #protocol = "";
    #extensions = "";
    constructor(url, protocols = []) {
      super();
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
      if (!experimentalWarned) {
        experimentalWarned = true;
        process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
          code: "UNDICI-WS"
        });
      }
      const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
      url = webidl.converters.USVString(url);
      protocols = options.protocols;
      let urlRecord;
      try {
        urlRecord = new URL(url);
      } catch (e) {
        throw new DOMException2(e, "SyntaxError");
      }
      if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
        throw new DOMException2(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, "SyntaxError");
      }
      if (urlRecord.hash) {
        throw new DOMException2("Got fragment", "SyntaxError");
      }
      if (typeof protocols === "string") {
        protocols = [protocols];
      }
      if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
        throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      }
      this[kWebSocketURL] = urlRecord;
      this[kController] = establishWebSocketConnection(urlRecord, protocols, this, (response) => this.#onConnectionEstablished(response), options);
      this[kReadyState] = WebSocket.CONNECTING;
      this[kBinaryType] = "blob";
    }
    close(code = undefined, reason = undefined) {
      webidl.brandCheck(this, WebSocket);
      if (code !== undefined) {
        code = webidl.converters["unsigned short"](code, { clamp: true });
      }
      if (reason !== undefined) {
        reason = webidl.converters.USVString(reason);
      }
      if (code !== undefined) {
        if (code !== 1000 && (code < 3000 || code > 4999)) {
          throw new DOMException2("invalid code", "InvalidAccessError");
        }
      }
      let reasonByteLength = 0;
      if (reason !== undefined) {
        reasonByteLength = Buffer.byteLength(reason);
        if (reasonByteLength > 123) {
          throw new DOMException2(`Reason must be less than 123 bytes; received ${reasonByteLength}`, "SyntaxError");
        }
      }
      if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {
      } else if (!isEstablished(this)) {
        failWebsocketConnection(this, "Connection was closed before it was established.");
        this[kReadyState] = WebSocket.CLOSING;
      } else if (!isClosing(this)) {
        const frame = new WebsocketFrameSend;
        if (code !== undefined && reason === undefined) {
          frame.frameData = Buffer.allocUnsafe(2);
          frame.frameData.writeUInt16BE(code, 0);
        } else if (code !== undefined && reason !== undefined) {
          frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
          frame.frameData.writeUInt16BE(code, 0);
          frame.frameData.write(reason, 2, "utf-8");
        } else {
          frame.frameData = emptyBuffer;
        }
        const socket = this[kResponse].socket;
        socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
          if (!err) {
            this[kSentClose] = true;
          }
        });
        this[kReadyState] = states.CLOSING;
      } else {
        this[kReadyState] = WebSocket.CLOSING;
      }
    }
    send(data) {
      webidl.brandCheck(this, WebSocket);
      webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
      data = webidl.converters.WebSocketSendData(data);
      if (this[kReadyState] === WebSocket.CONNECTING) {
        throw new DOMException2("Sent before connected.", "InvalidStateError");
      }
      if (!isEstablished(this) || isClosing(this)) {
        return;
      }
      const socket = this[kResponse].socket;
      if (typeof data === "string") {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.TEXT);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (types.isArrayBuffer(data)) {
        const value = Buffer.from(data);
        const frame = new WebsocketFrameSend(value);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += value.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= value.byteLength;
        });
      } else if (ArrayBuffer.isView(data)) {
        const ab = Buffer.from(data, data.byteOffset, data.byteLength);
        const frame = new WebsocketFrameSend(ab);
        const buffer = frame.createFrame(opcodes.BINARY);
        this.#bufferedAmount += ab.byteLength;
        socket.write(buffer, () => {
          this.#bufferedAmount -= ab.byteLength;
        });
      } else if (isBlobLike(data)) {
        const frame = new WebsocketFrameSend;
        data.arrayBuffer().then((ab) => {
          const value = Buffer.from(ab);
          frame.frameData = value;
          const buffer = frame.createFrame(opcodes.BINARY);
          this.#bufferedAmount += value.byteLength;
          socket.write(buffer, () => {
            this.#bufferedAmount -= value.byteLength;
          });
        });
      }
    }
    get readyState() {
      webidl.brandCheck(this, WebSocket);
      return this[kReadyState];
    }
    get bufferedAmount() {
      webidl.brandCheck(this, WebSocket);
      return this.#bufferedAmount;
    }
    get url() {
      webidl.brandCheck(this, WebSocket);
      return URLSerializer(this[kWebSocketURL]);
    }
    get extensions() {
      webidl.brandCheck(this, WebSocket);
      return this.#extensions;
    }
    get protocol() {
      webidl.brandCheck(this, WebSocket);
      return this.#protocol;
    }
    get onopen() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.open;
    }
    set onopen(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.open) {
        this.removeEventListener("open", this.#events.open);
      }
      if (typeof fn === "function") {
        this.#events.open = fn;
        this.addEventListener("open", fn);
      } else {
        this.#events.open = null;
      }
    }
    get onerror() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.error;
    }
    set onerror(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.error) {
        this.removeEventListener("error", this.#events.error);
      }
      if (typeof fn === "function") {
        this.#events.error = fn;
        this.addEventListener("error", fn);
      } else {
        this.#events.error = null;
      }
    }
    get onclose() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.close;
    }
    set onclose(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.close) {
        this.removeEventListener("close", this.#events.close);
      }
      if (typeof fn === "function") {
        this.#events.close = fn;
        this.addEventListener("close", fn);
      } else {
        this.#events.close = null;
      }
    }
    get onmessage() {
      webidl.brandCheck(this, WebSocket);
      return this.#events.message;
    }
    set onmessage(fn) {
      webidl.brandCheck(this, WebSocket);
      if (this.#events.message) {
        this.removeEventListener("message", this.#events.message);
      }
      if (typeof fn === "function") {
        this.#events.message = fn;
        this.addEventListener("message", fn);
      } else {
        this.#events.message = null;
      }
    }
    get binaryType() {
      webidl.brandCheck(this, WebSocket);
      return this[kBinaryType];
    }
    set binaryType(type) {
      webidl.brandCheck(this, WebSocket);
      if (type !== "blob" && type !== "arraybuffer") {
        this[kBinaryType] = "blob";
      } else {
        this[kBinaryType] = type;
      }
    }
    #onConnectionEstablished(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        this.#extensions = extensions;
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        this.#protocol = protocol;
      }
      fireEvent("open", this);
    }
  }
  WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
  WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
  WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
  WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
  Object.defineProperties(WebSocket.prototype, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors,
    url: kEnumerableProperty,
    readyState: kEnumerableProperty,
    bufferedAmount: kEnumerableProperty,
    onopen: kEnumerableProperty,
    onerror: kEnumerableProperty,
    onclose: kEnumerableProperty,
    close: kEnumerableProperty,
    onmessage: kEnumerableProperty,
    binaryType: kEnumerableProperty,
    send: kEnumerableProperty,
    extensions: kEnumerableProperty,
    protocol: kEnumerableProperty,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: false,
      enumerable: false,
      configurable: true
    }
  });
  Object.defineProperties(WebSocket, {
    CONNECTING: staticPropertyDescriptors,
    OPEN: staticPropertyDescriptors,
    CLOSING: staticPropertyDescriptors,
    CLOSED: staticPropertyDescriptors
  });
  webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(webidl.converters.DOMString);
  webidl.converters["DOMString or sequence<DOMString>"] = function(V) {
    if (webidl.util.Type(V) === "Object" && (Symbol.iterator in V)) {
      return webidl.converters["sequence<DOMString>"](V);
    }
    return webidl.converters.DOMString(V);
  };
  webidl.converters.WebSocketInit = webidl.dictionaryConverter([
    {
      key: "protocols",
      converter: webidl.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (V) => V,
      get defaultValue() {
        return getGlobalDispatcher();
      }
    },
    {
      key: "headers",
      converter: webidl.nullableConverter(webidl.converters.HeadersInit)
    }
  ]);
  webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V) {
    if (webidl.util.Type(V) === "Object" && !(Symbol.iterator in V)) {
      return webidl.converters.WebSocketInit(V);
    }
    return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V) };
  };
  webidl.converters.WebSocketSendData = function(V) {
    if (webidl.util.Type(V) === "Object") {
      if (isBlobLike(V)) {
        return webidl.converters.Blob(V, { strict: false });
      }
      if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {
        return webidl.converters.BufferSource(V);
      }
    }
    return webidl.converters.USVString(V);
  };
  module.exports = {
    WebSocket
  };
});

// node_modules/undici/index.js
var require_undici = __commonJS((exports, module) => {
  var makeDispatcher = function(fn) {
    return (url, opts, handler) => {
      if (typeof opts === "function") {
        handler = opts;
        opts = null;
      }
      if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
        throw new InvalidArgumentError("invalid url");
      }
      if (opts != null && typeof opts !== "object") {
        throw new InvalidArgumentError("invalid opts");
      }
      if (opts && opts.path != null) {
        if (typeof opts.path !== "string") {
          throw new InvalidArgumentError("invalid opts.path");
        }
        let path = opts.path;
        if (!opts.path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(util.parseOrigin(url).origin + path);
      } else {
        if (!opts) {
          opts = typeof url === "object" ? url : {};
        }
        url = util.parseURL(url);
      }
      const { agent, dispatcher = getGlobalDispatcher() } = opts;
      if (agent) {
        throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
      }
      return fn.call(dispatcher, {
        ...opts,
        origin: url.origin,
        path: url.search ? `${url.pathname}${url.search}` : url.pathname,
        method: opts.method || (opts.body ? "PUT" : "GET")
      }, handler);
    };
  };
  var Client = require_client();
  var Dispatcher = require_dispatcher();
  var errors = require_errors();
  var Pool = require_pool();
  var BalancedPool = require_balanced_pool();
  var Agent = require_agent();
  var util = require_util();
  var { InvalidArgumentError } = errors;
  var api = require_api();
  var buildConnector = require_connect();
  var MockClient = require_mock_client();
  var MockAgent = require_mock_agent();
  var MockPool = require_mock_pool();
  var mockErrors = require_mock_errors();
  var ProxyAgent = require_proxy_agent();
  var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
  var DecoratorHandler = require_DecoratorHandler();
  var RedirectHandler = require_RedirectHandler();
  var createRedirectInterceptor = require_redirectInterceptor();
  var hasCrypto;
  try {
    __require("crypto");
    hasCrypto = true;
  } catch {
    hasCrypto = false;
  }
  Object.assign(Dispatcher.prototype, api);
  exports.Dispatcher = Dispatcher;
  exports.Client = Client;
  exports.Pool = Pool;
  exports.BalancedPool = BalancedPool;
  exports.Agent = Agent;
  exports.ProxyAgent = ProxyAgent;
  exports.DecoratorHandler = DecoratorHandler;
  exports.RedirectHandler = RedirectHandler;
  exports.createRedirectInterceptor = createRedirectInterceptor;
  exports.buildConnector = buildConnector;
  exports.errors = errors;
  exports.setGlobalDispatcher = setGlobalDispatcher;
  exports.getGlobalDispatcher = getGlobalDispatcher;
  if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
    let fetchImpl = null;
    exports.fetch = async function fetch(resource) {
      if (!fetchImpl) {
        fetchImpl = require_fetch().fetch;
      }
      try {
        return await fetchImpl(...arguments);
      } catch (err) {
        Error.captureStackTrace(err, this);
        throw err;
      }
    };
    exports.Headers = require_headers().Headers;
    exports.Response = require_response().Response;
    exports.Request = require_request2().Request;
    exports.FormData = require_formdata().FormData;
    exports.File = require_file().File;
    exports.FileReader = require_filereader().FileReader;
    const { setGlobalOrigin, getGlobalOrigin } = require_global();
    exports.setGlobalOrigin = setGlobalOrigin;
    exports.getGlobalOrigin = getGlobalOrigin;
    const { CacheStorage } = require_cachestorage();
    const { kConstruct } = require_symbols4();
    exports.caches = new CacheStorage(kConstruct);
  }
  if (util.nodeMajor >= 16) {
    const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
    exports.deleteCookie = deleteCookie;
    exports.getCookies = getCookies;
    exports.getSetCookies = getSetCookies;
    exports.setCookie = setCookie;
    const { parseMIMEType, serializeAMimeType } = require_dataURL();
    exports.parseMIMEType = parseMIMEType;
    exports.serializeAMimeType = serializeAMimeType;
  }
  if (util.nodeMajor >= 18 && hasCrypto) {
    const { WebSocket } = require_websocket();
    exports.WebSocket = WebSocket;
  }
  exports.request = makeDispatcher(api.request);
  exports.stream = makeDispatcher(api.stream);
  exports.pipeline = makeDispatcher(api.pipeline);
  exports.connect = makeDispatcher(api.connect);
  exports.upgrade = makeDispatcher(api.upgrade);
  exports.MockClient = MockClient;
  exports.MockPool = MockPool;
  exports.MockAgent = MockAgent;
  exports.mockErrors = mockErrors;
});

// node_modules/discord-api-types/gateway/common.js
var require_common = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/gateway/v10.js
var require_v10 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GatewayDispatchEvents = exports.GatewayIntentBits = exports.GatewayCloseCodes = exports.GatewayOpcodes = exports.GatewayVersion = undefined;
  __exportStar(require_common(), exports);
  exports.GatewayVersion = "10";
  var GatewayOpcodes;
  (function(GatewayOpcodes2) {
    GatewayOpcodes2[GatewayOpcodes2["Dispatch"] = 0] = "Dispatch";
    GatewayOpcodes2[GatewayOpcodes2["Heartbeat"] = 1] = "Heartbeat";
    GatewayOpcodes2[GatewayOpcodes2["Identify"] = 2] = "Identify";
    GatewayOpcodes2[GatewayOpcodes2["PresenceUpdate"] = 3] = "PresenceUpdate";
    GatewayOpcodes2[GatewayOpcodes2["VoiceStateUpdate"] = 4] = "VoiceStateUpdate";
    GatewayOpcodes2[GatewayOpcodes2["Resume"] = 6] = "Resume";
    GatewayOpcodes2[GatewayOpcodes2["Reconnect"] = 7] = "Reconnect";
    GatewayOpcodes2[GatewayOpcodes2["RequestGuildMembers"] = 8] = "RequestGuildMembers";
    GatewayOpcodes2[GatewayOpcodes2["InvalidSession"] = 9] = "InvalidSession";
    GatewayOpcodes2[GatewayOpcodes2["Hello"] = 10] = "Hello";
    GatewayOpcodes2[GatewayOpcodes2["HeartbeatAck"] = 11] = "HeartbeatAck";
  })(GatewayOpcodes = exports.GatewayOpcodes || (exports.GatewayOpcodes = {}));
  var GatewayCloseCodes;
  (function(GatewayCloseCodes2) {
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownError"] = 4000] = "UnknownError";
    GatewayCloseCodes2[GatewayCloseCodes2["UnknownOpcode"] = 4001] = "UnknownOpcode";
    GatewayCloseCodes2[GatewayCloseCodes2["DecodeError"] = 4002] = "DecodeError";
    GatewayCloseCodes2[GatewayCloseCodes2["NotAuthenticated"] = 4003] = "NotAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["AuthenticationFailed"] = 4004] = "AuthenticationFailed";
    GatewayCloseCodes2[GatewayCloseCodes2["AlreadyAuthenticated"] = 4005] = "AlreadyAuthenticated";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidSeq"] = 4007] = "InvalidSeq";
    GatewayCloseCodes2[GatewayCloseCodes2["RateLimited"] = 4008] = "RateLimited";
    GatewayCloseCodes2[GatewayCloseCodes2["SessionTimedOut"] = 4009] = "SessionTimedOut";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidShard"] = 4010] = "InvalidShard";
    GatewayCloseCodes2[GatewayCloseCodes2["ShardingRequired"] = 4011] = "ShardingRequired";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidAPIVersion"] = 4012] = "InvalidAPIVersion";
    GatewayCloseCodes2[GatewayCloseCodes2["InvalidIntents"] = 4013] = "InvalidIntents";
    GatewayCloseCodes2[GatewayCloseCodes2["DisallowedIntents"] = 4014] = "DisallowedIntents";
  })(GatewayCloseCodes = exports.GatewayCloseCodes || (exports.GatewayCloseCodes = {}));
  var GatewayIntentBits;
  (function(GatewayIntentBits2) {
    GatewayIntentBits2[GatewayIntentBits2["Guilds"] = 1] = "Guilds";
    GatewayIntentBits2[GatewayIntentBits2["GuildMembers"] = 2] = "GuildMembers";
    GatewayIntentBits2[GatewayIntentBits2["GuildModeration"] = 4] = "GuildModeration";
    GatewayIntentBits2[GatewayIntentBits2["GuildBans"] = 4] = "GuildBans";
    GatewayIntentBits2[GatewayIntentBits2["GuildEmojisAndStickers"] = 8] = "GuildEmojisAndStickers";
    GatewayIntentBits2[GatewayIntentBits2["GuildIntegrations"] = 16] = "GuildIntegrations";
    GatewayIntentBits2[GatewayIntentBits2["GuildWebhooks"] = 32] = "GuildWebhooks";
    GatewayIntentBits2[GatewayIntentBits2["GuildInvites"] = 64] = "GuildInvites";
    GatewayIntentBits2[GatewayIntentBits2["GuildVoiceStates"] = 128] = "GuildVoiceStates";
    GatewayIntentBits2[GatewayIntentBits2["GuildPresences"] = 256] = "GuildPresences";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessages"] = 512] = "GuildMessages";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageReactions"] = 1024] = "GuildMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["GuildMessageTyping"] = 2048] = "GuildMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessages"] = 4096] = "DirectMessages";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageReactions"] = 8192] = "DirectMessageReactions";
    GatewayIntentBits2[GatewayIntentBits2["DirectMessageTyping"] = 16384] = "DirectMessageTyping";
    GatewayIntentBits2[GatewayIntentBits2["MessageContent"] = 32768] = "MessageContent";
    GatewayIntentBits2[GatewayIntentBits2["GuildScheduledEvents"] = 65536] = "GuildScheduledEvents";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationConfiguration"] = 1048576] = "AutoModerationConfiguration";
    GatewayIntentBits2[GatewayIntentBits2["AutoModerationExecution"] = 2097152] = "AutoModerationExecution";
  })(GatewayIntentBits = exports.GatewayIntentBits || (exports.GatewayIntentBits = {}));
  var GatewayDispatchEvents;
  (function(GatewayDispatchEvents2) {
    GatewayDispatchEvents2["ApplicationCommandPermissionsUpdate"] = "APPLICATION_COMMAND_PERMISSIONS_UPDATE";
    GatewayDispatchEvents2["ChannelCreate"] = "CHANNEL_CREATE";
    GatewayDispatchEvents2["ChannelDelete"] = "CHANNEL_DELETE";
    GatewayDispatchEvents2["ChannelPinsUpdate"] = "CHANNEL_PINS_UPDATE";
    GatewayDispatchEvents2["ChannelUpdate"] = "CHANNEL_UPDATE";
    GatewayDispatchEvents2["GuildBanAdd"] = "GUILD_BAN_ADD";
    GatewayDispatchEvents2["GuildBanRemove"] = "GUILD_BAN_REMOVE";
    GatewayDispatchEvents2["GuildCreate"] = "GUILD_CREATE";
    GatewayDispatchEvents2["GuildDelete"] = "GUILD_DELETE";
    GatewayDispatchEvents2["GuildEmojisUpdate"] = "GUILD_EMOJIS_UPDATE";
    GatewayDispatchEvents2["GuildIntegrationsUpdate"] = "GUILD_INTEGRATIONS_UPDATE";
    GatewayDispatchEvents2["GuildMemberAdd"] = "GUILD_MEMBER_ADD";
    GatewayDispatchEvents2["GuildMemberRemove"] = "GUILD_MEMBER_REMOVE";
    GatewayDispatchEvents2["GuildMembersChunk"] = "GUILD_MEMBERS_CHUNK";
    GatewayDispatchEvents2["GuildMemberUpdate"] = "GUILD_MEMBER_UPDATE";
    GatewayDispatchEvents2["GuildRoleCreate"] = "GUILD_ROLE_CREATE";
    GatewayDispatchEvents2["GuildRoleDelete"] = "GUILD_ROLE_DELETE";
    GatewayDispatchEvents2["GuildRoleUpdate"] = "GUILD_ROLE_UPDATE";
    GatewayDispatchEvents2["GuildStickersUpdate"] = "GUILD_STICKERS_UPDATE";
    GatewayDispatchEvents2["GuildUpdate"] = "GUILD_UPDATE";
    GatewayDispatchEvents2["IntegrationCreate"] = "INTEGRATION_CREATE";
    GatewayDispatchEvents2["IntegrationDelete"] = "INTEGRATION_DELETE";
    GatewayDispatchEvents2["IntegrationUpdate"] = "INTEGRATION_UPDATE";
    GatewayDispatchEvents2["InteractionCreate"] = "INTERACTION_CREATE";
    GatewayDispatchEvents2["InviteCreate"] = "INVITE_CREATE";
    GatewayDispatchEvents2["InviteDelete"] = "INVITE_DELETE";
    GatewayDispatchEvents2["MessageCreate"] = "MESSAGE_CREATE";
    GatewayDispatchEvents2["MessageDelete"] = "MESSAGE_DELETE";
    GatewayDispatchEvents2["MessageDeleteBulk"] = "MESSAGE_DELETE_BULK";
    GatewayDispatchEvents2["MessageReactionAdd"] = "MESSAGE_REACTION_ADD";
    GatewayDispatchEvents2["MessageReactionRemove"] = "MESSAGE_REACTION_REMOVE";
    GatewayDispatchEvents2["MessageReactionRemoveAll"] = "MESSAGE_REACTION_REMOVE_ALL";
    GatewayDispatchEvents2["MessageReactionRemoveEmoji"] = "MESSAGE_REACTION_REMOVE_EMOJI";
    GatewayDispatchEvents2["MessageUpdate"] = "MESSAGE_UPDATE";
    GatewayDispatchEvents2["PresenceUpdate"] = "PRESENCE_UPDATE";
    GatewayDispatchEvents2["StageInstanceCreate"] = "STAGE_INSTANCE_CREATE";
    GatewayDispatchEvents2["StageInstanceDelete"] = "STAGE_INSTANCE_DELETE";
    GatewayDispatchEvents2["StageInstanceUpdate"] = "STAGE_INSTANCE_UPDATE";
    GatewayDispatchEvents2["Ready"] = "READY";
    GatewayDispatchEvents2["Resumed"] = "RESUMED";
    GatewayDispatchEvents2["ThreadCreate"] = "THREAD_CREATE";
    GatewayDispatchEvents2["ThreadDelete"] = "THREAD_DELETE";
    GatewayDispatchEvents2["ThreadListSync"] = "THREAD_LIST_SYNC";
    GatewayDispatchEvents2["ThreadMembersUpdate"] = "THREAD_MEMBERS_UPDATE";
    GatewayDispatchEvents2["ThreadMemberUpdate"] = "THREAD_MEMBER_UPDATE";
    GatewayDispatchEvents2["ThreadUpdate"] = "THREAD_UPDATE";
    GatewayDispatchEvents2["TypingStart"] = "TYPING_START";
    GatewayDispatchEvents2["UserUpdate"] = "USER_UPDATE";
    GatewayDispatchEvents2["VoiceServerUpdate"] = "VOICE_SERVER_UPDATE";
    GatewayDispatchEvents2["VoiceStateUpdate"] = "VOICE_STATE_UPDATE";
    GatewayDispatchEvents2["WebhooksUpdate"] = "WEBHOOKS_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventCreate"] = "GUILD_SCHEDULED_EVENT_CREATE";
    GatewayDispatchEvents2["GuildScheduledEventUpdate"] = "GUILD_SCHEDULED_EVENT_UPDATE";
    GatewayDispatchEvents2["GuildScheduledEventDelete"] = "GUILD_SCHEDULED_EVENT_DELETE";
    GatewayDispatchEvents2["GuildScheduledEventUserAdd"] = "GUILD_SCHEDULED_EVENT_USER_ADD";
    GatewayDispatchEvents2["GuildScheduledEventUserRemove"] = "GUILD_SCHEDULED_EVENT_USER_REMOVE";
    GatewayDispatchEvents2["AutoModerationRuleCreate"] = "AUTO_MODERATION_RULE_CREATE";
    GatewayDispatchEvents2["AutoModerationRuleUpdate"] = "AUTO_MODERATION_RULE_UPDATE";
    GatewayDispatchEvents2["AutoModerationRuleDelete"] = "AUTO_MODERATION_RULE_DELETE";
    GatewayDispatchEvents2["AutoModerationActionExecution"] = "AUTO_MODERATION_ACTION_EXECUTION";
    GatewayDispatchEvents2["GuildAuditLogEntryCreate"] = "GUILD_AUDIT_LOG_ENTRY_CREATE";
  })(GatewayDispatchEvents = exports.GatewayDispatchEvents || (exports.GatewayDispatchEvents = {}));
});

// node_modules/discord-api-types/globals.js
var require_globals = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FormattingPatterns = undefined;
  exports.FormattingPatterns = {
    User: /<@(?<id>\d{17,20})>/,
    UserWithNickname: /<@!(?<id>\d{17,20})>/,
    UserWithOptionalNickname: /<@!?(?<id>\d{17,20})>/,
    Channel: /<#(?<id>\d{17,20})>/,
    Role: /<@&(?<id>\d{17,20})>/,
    SlashCommand: /<\/(?<fullName>(?<name>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32})(?: (?<subcommandOrGroup>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?(?: (?<subcommand>[-_\p{Letter}\p{Number}\p{sc=Deva}\p{sc=Thai}]{1,32}))?):(?<id>\d{17,20})>/u,
    Emoji: /<(?<animated>a)?:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    AnimatedEmoji: /<(?<animated>a):(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    StaticEmoji: /<:(?<name>\w{2,32}):(?<id>\d{17,20})>/,
    Timestamp: /<t:(?<timestamp>-?\d{1,13})(:(?<style>[DFRTdft]))?>/,
    DefaultStyledTimestamp: /<t:(?<timestamp>-?\d{1,13})>/,
    StyledTimestamp: /<t:(?<timestamp>-?\d{1,13}):(?<style>[DFRTdft])>/
  };
  Object.freeze(exports.FormattingPatterns);
});

// node_modules/discord-api-types/payloads/common.js
var require_common2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PermissionFlagsBits = undefined;
  exports.PermissionFlagsBits = {
    CreateInstantInvite: 1n << 0n,
    KickMembers: 1n << 1n,
    BanMembers: 1n << 2n,
    Administrator: 1n << 3n,
    ManageChannels: 1n << 4n,
    ManageGuild: 1n << 5n,
    AddReactions: 1n << 6n,
    ViewAuditLog: 1n << 7n,
    PrioritySpeaker: 1n << 8n,
    Stream: 1n << 9n,
    ViewChannel: 1n << 10n,
    SendMessages: 1n << 11n,
    SendTTSMessages: 1n << 12n,
    ManageMessages: 1n << 13n,
    EmbedLinks: 1n << 14n,
    AttachFiles: 1n << 15n,
    ReadMessageHistory: 1n << 16n,
    MentionEveryone: 1n << 17n,
    UseExternalEmojis: 1n << 18n,
    ViewGuildInsights: 1n << 19n,
    Connect: 1n << 20n,
    Speak: 1n << 21n,
    MuteMembers: 1n << 22n,
    DeafenMembers: 1n << 23n,
    MoveMembers: 1n << 24n,
    UseVAD: 1n << 25n,
    ChangeNickname: 1n << 26n,
    ManageNicknames: 1n << 27n,
    ManageRoles: 1n << 28n,
    ManageWebhooks: 1n << 29n,
    ManageEmojisAndStickers: 1n << 30n,
    ManageGuildExpressions: 1n << 30n,
    UseApplicationCommands: 1n << 31n,
    RequestToSpeak: 1n << 32n,
    ManageEvents: 1n << 33n,
    ManageThreads: 1n << 34n,
    CreatePublicThreads: 1n << 35n,
    CreatePrivateThreads: 1n << 36n,
    UseExternalStickers: 1n << 37n,
    SendMessagesInThreads: 1n << 38n,
    UseEmbeddedActivities: 1n << 39n,
    ModerateMembers: 1n << 40n,
    ViewCreatorMonetizationAnalytics: 1n << 41n,
    UseSoundboard: 1n << 42n,
    UseExternalSounds: 1n << 45n,
    SendVoiceMessages: 1n << 46n
  };
  Object.freeze(exports.PermissionFlagsBits);
});

// node_modules/discord-api-types/payloads/v10/application.js
var require_application = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationRoleConnectionMetadataType = exports.ApplicationFlags = undefined;
  var ApplicationFlags;
  (function(ApplicationFlags2) {
    ApplicationFlags2[ApplicationFlags2["EmbeddedReleased"] = 2] = "EmbeddedReleased";
    ApplicationFlags2[ApplicationFlags2["ManagedEmoji"] = 4] = "ManagedEmoji";
    ApplicationFlags2[ApplicationFlags2["EmbeddedIAP"] = 8] = "EmbeddedIAP";
    ApplicationFlags2[ApplicationFlags2["GroupDMCreate"] = 16] = "GroupDMCreate";
    ApplicationFlags2[ApplicationFlags2["ApplicationAutoModerationRuleCreateBadge"] = 64] = "ApplicationAutoModerationRuleCreateBadge";
    ApplicationFlags2[ApplicationFlags2["RPCHasConnected"] = 2048] = "RPCHasConnected";
    ApplicationFlags2[ApplicationFlags2["GatewayPresence"] = 4096] = "GatewayPresence";
    ApplicationFlags2[ApplicationFlags2["GatewayPresenceLimited"] = 8192] = "GatewayPresenceLimited";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembers"] = 16384] = "GatewayGuildMembers";
    ApplicationFlags2[ApplicationFlags2["GatewayGuildMembersLimited"] = 32768] = "GatewayGuildMembersLimited";
    ApplicationFlags2[ApplicationFlags2["VerificationPendingGuildLimit"] = 65536] = "VerificationPendingGuildLimit";
    ApplicationFlags2[ApplicationFlags2["Embedded"] = 131072] = "Embedded";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContent"] = 262144] = "GatewayMessageContent";
    ApplicationFlags2[ApplicationFlags2["GatewayMessageContentLimited"] = 524288] = "GatewayMessageContentLimited";
    ApplicationFlags2[ApplicationFlags2["EmbeddedFirstParty"] = 1048576] = "EmbeddedFirstParty";
    ApplicationFlags2[ApplicationFlags2["ApplicationCommandBadge"] = 8388608] = "ApplicationCommandBadge";
  })(ApplicationFlags = exports.ApplicationFlags || (exports.ApplicationFlags = {}));
  var ApplicationRoleConnectionMetadataType;
  (function(ApplicationRoleConnectionMetadataType2) {
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerLessThanOrEqual"] = 1] = "IntegerLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerGreaterThanOrEqual"] = 2] = "IntegerGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerEqual"] = 3] = "IntegerEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["IntegerNotEqual"] = 4] = "IntegerNotEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeLessThanOrEqual"] = 5] = "DatetimeLessThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["DatetimeGreaterThanOrEqual"] = 6] = "DatetimeGreaterThanOrEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanEqual"] = 7] = "BooleanEqual";
    ApplicationRoleConnectionMetadataType2[ApplicationRoleConnectionMetadataType2["BooleanNotEqual"] = 8] = "BooleanNotEqual";
  })(ApplicationRoleConnectionMetadataType = exports.ApplicationRoleConnectionMetadataType || (exports.ApplicationRoleConnectionMetadataType = {}));
});

// node_modules/discord-api-types/payloads/v10/auditLog.js
var require_auditLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AuditLogOptionsType = exports.AuditLogEvent = undefined;
  var AuditLogEvent;
  (function(AuditLogEvent2) {
    AuditLogEvent2[AuditLogEvent2["GuildUpdate"] = 1] = "GuildUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelCreate"] = 10] = "ChannelCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelUpdate"] = 11] = "ChannelUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelDelete"] = 12] = "ChannelDelete";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteCreate"] = 13] = "ChannelOverwriteCreate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteUpdate"] = 14] = "ChannelOverwriteUpdate";
    AuditLogEvent2[AuditLogEvent2["ChannelOverwriteDelete"] = 15] = "ChannelOverwriteDelete";
    AuditLogEvent2[AuditLogEvent2["MemberKick"] = 20] = "MemberKick";
    AuditLogEvent2[AuditLogEvent2["MemberPrune"] = 21] = "MemberPrune";
    AuditLogEvent2[AuditLogEvent2["MemberBanAdd"] = 22] = "MemberBanAdd";
    AuditLogEvent2[AuditLogEvent2["MemberBanRemove"] = 23] = "MemberBanRemove";
    AuditLogEvent2[AuditLogEvent2["MemberUpdate"] = 24] = "MemberUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberRoleUpdate"] = 25] = "MemberRoleUpdate";
    AuditLogEvent2[AuditLogEvent2["MemberMove"] = 26] = "MemberMove";
    AuditLogEvent2[AuditLogEvent2["MemberDisconnect"] = 27] = "MemberDisconnect";
    AuditLogEvent2[AuditLogEvent2["BotAdd"] = 28] = "BotAdd";
    AuditLogEvent2[AuditLogEvent2["RoleCreate"] = 30] = "RoleCreate";
    AuditLogEvent2[AuditLogEvent2["RoleUpdate"] = 31] = "RoleUpdate";
    AuditLogEvent2[AuditLogEvent2["RoleDelete"] = 32] = "RoleDelete";
    AuditLogEvent2[AuditLogEvent2["InviteCreate"] = 40] = "InviteCreate";
    AuditLogEvent2[AuditLogEvent2["InviteUpdate"] = 41] = "InviteUpdate";
    AuditLogEvent2[AuditLogEvent2["InviteDelete"] = 42] = "InviteDelete";
    AuditLogEvent2[AuditLogEvent2["WebhookCreate"] = 50] = "WebhookCreate";
    AuditLogEvent2[AuditLogEvent2["WebhookUpdate"] = 51] = "WebhookUpdate";
    AuditLogEvent2[AuditLogEvent2["WebhookDelete"] = 52] = "WebhookDelete";
    AuditLogEvent2[AuditLogEvent2["EmojiCreate"] = 60] = "EmojiCreate";
    AuditLogEvent2[AuditLogEvent2["EmojiUpdate"] = 61] = "EmojiUpdate";
    AuditLogEvent2[AuditLogEvent2["EmojiDelete"] = 62] = "EmojiDelete";
    AuditLogEvent2[AuditLogEvent2["MessageDelete"] = 72] = "MessageDelete";
    AuditLogEvent2[AuditLogEvent2["MessageBulkDelete"] = 73] = "MessageBulkDelete";
    AuditLogEvent2[AuditLogEvent2["MessagePin"] = 74] = "MessagePin";
    AuditLogEvent2[AuditLogEvent2["MessageUnpin"] = 75] = "MessageUnpin";
    AuditLogEvent2[AuditLogEvent2["IntegrationCreate"] = 80] = "IntegrationCreate";
    AuditLogEvent2[AuditLogEvent2["IntegrationUpdate"] = 81] = "IntegrationUpdate";
    AuditLogEvent2[AuditLogEvent2["IntegrationDelete"] = 82] = "IntegrationDelete";
    AuditLogEvent2[AuditLogEvent2["StageInstanceCreate"] = 83] = "StageInstanceCreate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceUpdate"] = 84] = "StageInstanceUpdate";
    AuditLogEvent2[AuditLogEvent2["StageInstanceDelete"] = 85] = "StageInstanceDelete";
    AuditLogEvent2[AuditLogEvent2["StickerCreate"] = 90] = "StickerCreate";
    AuditLogEvent2[AuditLogEvent2["StickerUpdate"] = 91] = "StickerUpdate";
    AuditLogEvent2[AuditLogEvent2["StickerDelete"] = 92] = "StickerDelete";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventCreate"] = 100] = "GuildScheduledEventCreate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventUpdate"] = 101] = "GuildScheduledEventUpdate";
    AuditLogEvent2[AuditLogEvent2["GuildScheduledEventDelete"] = 102] = "GuildScheduledEventDelete";
    AuditLogEvent2[AuditLogEvent2["ThreadCreate"] = 110] = "ThreadCreate";
    AuditLogEvent2[AuditLogEvent2["ThreadUpdate"] = 111] = "ThreadUpdate";
    AuditLogEvent2[AuditLogEvent2["ThreadDelete"] = 112] = "ThreadDelete";
    AuditLogEvent2[AuditLogEvent2["ApplicationCommandPermissionUpdate"] = 121] = "ApplicationCommandPermissionUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleCreate"] = 140] = "AutoModerationRuleCreate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleUpdate"] = 141] = "AutoModerationRuleUpdate";
    AuditLogEvent2[AuditLogEvent2["AutoModerationRuleDelete"] = 142] = "AutoModerationRuleDelete";
    AuditLogEvent2[AuditLogEvent2["AutoModerationBlockMessage"] = 143] = "AutoModerationBlockMessage";
    AuditLogEvent2[AuditLogEvent2["AutoModerationFlagToChannel"] = 144] = "AutoModerationFlagToChannel";
    AuditLogEvent2[AuditLogEvent2["AutoModerationUserCommunicationDisabled"] = 145] = "AutoModerationUserCommunicationDisabled";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationRequestCreated"] = 150] = "CreatorMonetizationRequestCreated";
    AuditLogEvent2[AuditLogEvent2["CreatorMonetizationTermsAccepted"] = 151] = "CreatorMonetizationTermsAccepted";
  })(AuditLogEvent = exports.AuditLogEvent || (exports.AuditLogEvent = {}));
  var AuditLogOptionsType;
  (function(AuditLogOptionsType2) {
    AuditLogOptionsType2["Role"] = "0";
    AuditLogOptionsType2["Member"] = "1";
  })(AuditLogOptionsType = exports.AuditLogOptionsType || (exports.AuditLogOptionsType = {}));
});

// node_modules/discord-api-types/payloads/v10/autoModeration.js
var require_autoModeration = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AutoModerationActionType = exports.AutoModerationRuleEventType = exports.AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleTriggerType = undefined;
  var AutoModerationRuleTriggerType;
  (function(AutoModerationRuleTriggerType2) {
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Keyword"] = 1] = "Keyword";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["Spam"] = 3] = "Spam";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["KeywordPreset"] = 4] = "KeywordPreset";
    AutoModerationRuleTriggerType2[AutoModerationRuleTriggerType2["MentionSpam"] = 5] = "MentionSpam";
  })(AutoModerationRuleTriggerType = exports.AutoModerationRuleTriggerType || (exports.AutoModerationRuleTriggerType = {}));
  var AutoModerationRuleKeywordPresetType;
  (function(AutoModerationRuleKeywordPresetType2) {
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Profanity"] = 1] = "Profanity";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["SexualContent"] = 2] = "SexualContent";
    AutoModerationRuleKeywordPresetType2[AutoModerationRuleKeywordPresetType2["Slurs"] = 3] = "Slurs";
  })(AutoModerationRuleKeywordPresetType = exports.AutoModerationRuleKeywordPresetType || (exports.AutoModerationRuleKeywordPresetType = {}));
  var AutoModerationRuleEventType;
  (function(AutoModerationRuleEventType2) {
    AutoModerationRuleEventType2[AutoModerationRuleEventType2["MessageSend"] = 1] = "MessageSend";
  })(AutoModerationRuleEventType = exports.AutoModerationRuleEventType || (exports.AutoModerationRuleEventType = {}));
  var AutoModerationActionType;
  (function(AutoModerationActionType2) {
    AutoModerationActionType2[AutoModerationActionType2["BlockMessage"] = 1] = "BlockMessage";
    AutoModerationActionType2[AutoModerationActionType2["SendAlertMessage"] = 2] = "SendAlertMessage";
    AutoModerationActionType2[AutoModerationActionType2["Timeout"] = 3] = "Timeout";
  })(AutoModerationActionType = exports.AutoModerationActionType || (exports.AutoModerationActionType = {}));
});

// node_modules/discord-api-types/payloads/v10/channel.js
var require_channel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ChannelFlags = exports.TextInputStyle = exports.ButtonStyle = exports.ComponentType = exports.AllowedMentionsTypes = exports.AttachmentFlags = exports.EmbedType = exports.ThreadMemberFlags = exports.ThreadAutoArchiveDuration = exports.OverwriteType = exports.MessageFlags = exports.MessageActivityType = exports.MessageType = exports.VideoQualityMode = exports.ChannelType = exports.ForumLayoutType = exports.SortOrderType = undefined;
  var SortOrderType;
  (function(SortOrderType2) {
    SortOrderType2[SortOrderType2["LatestActivity"] = 0] = "LatestActivity";
    SortOrderType2[SortOrderType2["CreationDate"] = 1] = "CreationDate";
  })(SortOrderType = exports.SortOrderType || (exports.SortOrderType = {}));
  var ForumLayoutType;
  (function(ForumLayoutType2) {
    ForumLayoutType2[ForumLayoutType2["NotSet"] = 0] = "NotSet";
    ForumLayoutType2[ForumLayoutType2["ListView"] = 1] = "ListView";
    ForumLayoutType2[ForumLayoutType2["GalleryView"] = 2] = "GalleryView";
  })(ForumLayoutType = exports.ForumLayoutType || (exports.ForumLayoutType = {}));
  var ChannelType;
  (function(ChannelType2) {
    ChannelType2[ChannelType2["GuildText"] = 0] = "GuildText";
    ChannelType2[ChannelType2["DM"] = 1] = "DM";
    ChannelType2[ChannelType2["GuildVoice"] = 2] = "GuildVoice";
    ChannelType2[ChannelType2["GroupDM"] = 3] = "GroupDM";
    ChannelType2[ChannelType2["GuildCategory"] = 4] = "GuildCategory";
    ChannelType2[ChannelType2["GuildAnnouncement"] = 5] = "GuildAnnouncement";
    ChannelType2[ChannelType2["AnnouncementThread"] = 10] = "AnnouncementThread";
    ChannelType2[ChannelType2["PublicThread"] = 11] = "PublicThread";
    ChannelType2[ChannelType2["PrivateThread"] = 12] = "PrivateThread";
    ChannelType2[ChannelType2["GuildStageVoice"] = 13] = "GuildStageVoice";
    ChannelType2[ChannelType2["GuildDirectory"] = 14] = "GuildDirectory";
    ChannelType2[ChannelType2["GuildForum"] = 15] = "GuildForum";
    ChannelType2[ChannelType2["GuildNews"] = 5] = "GuildNews";
    ChannelType2[ChannelType2["GuildNewsThread"] = 10] = "GuildNewsThread";
    ChannelType2[ChannelType2["GuildPublicThread"] = 11] = "GuildPublicThread";
    ChannelType2[ChannelType2["GuildPrivateThread"] = 12] = "GuildPrivateThread";
  })(ChannelType = exports.ChannelType || (exports.ChannelType = {}));
  var VideoQualityMode;
  (function(VideoQualityMode2) {
    VideoQualityMode2[VideoQualityMode2["Auto"] = 1] = "Auto";
    VideoQualityMode2[VideoQualityMode2["Full"] = 2] = "Full";
  })(VideoQualityMode = exports.VideoQualityMode || (exports.VideoQualityMode = {}));
  var MessageType;
  (function(MessageType2) {
    MessageType2[MessageType2["Default"] = 0] = "Default";
    MessageType2[MessageType2["RecipientAdd"] = 1] = "RecipientAdd";
    MessageType2[MessageType2["RecipientRemove"] = 2] = "RecipientRemove";
    MessageType2[MessageType2["Call"] = 3] = "Call";
    MessageType2[MessageType2["ChannelNameChange"] = 4] = "ChannelNameChange";
    MessageType2[MessageType2["ChannelIconChange"] = 5] = "ChannelIconChange";
    MessageType2[MessageType2["ChannelPinnedMessage"] = 6] = "ChannelPinnedMessage";
    MessageType2[MessageType2["UserJoin"] = 7] = "UserJoin";
    MessageType2[MessageType2["GuildBoost"] = 8] = "GuildBoost";
    MessageType2[MessageType2["GuildBoostTier1"] = 9] = "GuildBoostTier1";
    MessageType2[MessageType2["GuildBoostTier2"] = 10] = "GuildBoostTier2";
    MessageType2[MessageType2["GuildBoostTier3"] = 11] = "GuildBoostTier3";
    MessageType2[MessageType2["ChannelFollowAdd"] = 12] = "ChannelFollowAdd";
    MessageType2[MessageType2["GuildDiscoveryDisqualified"] = 14] = "GuildDiscoveryDisqualified";
    MessageType2[MessageType2["GuildDiscoveryRequalified"] = 15] = "GuildDiscoveryRequalified";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodInitialWarning"] = 16] = "GuildDiscoveryGracePeriodInitialWarning";
    MessageType2[MessageType2["GuildDiscoveryGracePeriodFinalWarning"] = 17] = "GuildDiscoveryGracePeriodFinalWarning";
    MessageType2[MessageType2["ThreadCreated"] = 18] = "ThreadCreated";
    MessageType2[MessageType2["Reply"] = 19] = "Reply";
    MessageType2[MessageType2["ChatInputCommand"] = 20] = "ChatInputCommand";
    MessageType2[MessageType2["ThreadStarterMessage"] = 21] = "ThreadStarterMessage";
    MessageType2[MessageType2["GuildInviteReminder"] = 22] = "GuildInviteReminder";
    MessageType2[MessageType2["ContextMenuCommand"] = 23] = "ContextMenuCommand";
    MessageType2[MessageType2["AutoModerationAction"] = 24] = "AutoModerationAction";
    MessageType2[MessageType2["RoleSubscriptionPurchase"] = 25] = "RoleSubscriptionPurchase";
    MessageType2[MessageType2["InteractionPremiumUpsell"] = 26] = "InteractionPremiumUpsell";
    MessageType2[MessageType2["StageStart"] = 27] = "StageStart";
    MessageType2[MessageType2["StageEnd"] = 28] = "StageEnd";
    MessageType2[MessageType2["StageSpeaker"] = 29] = "StageSpeaker";
    MessageType2[MessageType2["StageRaiseHand"] = 30] = "StageRaiseHand";
    MessageType2[MessageType2["StageTopic"] = 31] = "StageTopic";
    MessageType2[MessageType2["GuildApplicationPremiumSubscription"] = 32] = "GuildApplicationPremiumSubscription";
  })(MessageType = exports.MessageType || (exports.MessageType = {}));
  var MessageActivityType;
  (function(MessageActivityType2) {
    MessageActivityType2[MessageActivityType2["Join"] = 1] = "Join";
    MessageActivityType2[MessageActivityType2["Spectate"] = 2] = "Spectate";
    MessageActivityType2[MessageActivityType2["Listen"] = 3] = "Listen";
    MessageActivityType2[MessageActivityType2["JoinRequest"] = 5] = "JoinRequest";
  })(MessageActivityType = exports.MessageActivityType || (exports.MessageActivityType = {}));
  var MessageFlags;
  (function(MessageFlags2) {
    MessageFlags2[MessageFlags2["Crossposted"] = 1] = "Crossposted";
    MessageFlags2[MessageFlags2["IsCrosspost"] = 2] = "IsCrosspost";
    MessageFlags2[MessageFlags2["SuppressEmbeds"] = 4] = "SuppressEmbeds";
    MessageFlags2[MessageFlags2["SourceMessageDeleted"] = 8] = "SourceMessageDeleted";
    MessageFlags2[MessageFlags2["Urgent"] = 16] = "Urgent";
    MessageFlags2[MessageFlags2["HasThread"] = 32] = "HasThread";
    MessageFlags2[MessageFlags2["Ephemeral"] = 64] = "Ephemeral";
    MessageFlags2[MessageFlags2["Loading"] = 128] = "Loading";
    MessageFlags2[MessageFlags2["FailedToMentionSomeRolesInThread"] = 256] = "FailedToMentionSomeRolesInThread";
    MessageFlags2[MessageFlags2["ShouldShowLinkNotDiscordWarning"] = 1024] = "ShouldShowLinkNotDiscordWarning";
    MessageFlags2[MessageFlags2["SuppressNotifications"] = 4096] = "SuppressNotifications";
    MessageFlags2[MessageFlags2["IsVoiceMessage"] = 8192] = "IsVoiceMessage";
  })(MessageFlags = exports.MessageFlags || (exports.MessageFlags = {}));
  var OverwriteType;
  (function(OverwriteType2) {
    OverwriteType2[OverwriteType2["Role"] = 0] = "Role";
    OverwriteType2[OverwriteType2["Member"] = 1] = "Member";
  })(OverwriteType = exports.OverwriteType || (exports.OverwriteType = {}));
  var ThreadAutoArchiveDuration;
  (function(ThreadAutoArchiveDuration2) {
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneHour"] = 60] = "OneHour";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneDay"] = 1440] = "OneDay";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["ThreeDays"] = 4320] = "ThreeDays";
    ThreadAutoArchiveDuration2[ThreadAutoArchiveDuration2["OneWeek"] = 10080] = "OneWeek";
  })(ThreadAutoArchiveDuration = exports.ThreadAutoArchiveDuration || (exports.ThreadAutoArchiveDuration = {}));
  var ThreadMemberFlags;
  (function(ThreadMemberFlags2) {
    ThreadMemberFlags2[ThreadMemberFlags2["HasInteracted"] = 1] = "HasInteracted";
    ThreadMemberFlags2[ThreadMemberFlags2["AllMessages"] = 2] = "AllMessages";
    ThreadMemberFlags2[ThreadMemberFlags2["OnlyMentions"] = 4] = "OnlyMentions";
    ThreadMemberFlags2[ThreadMemberFlags2["NoMessages"] = 8] = "NoMessages";
  })(ThreadMemberFlags = exports.ThreadMemberFlags || (exports.ThreadMemberFlags = {}));
  var EmbedType;
  (function(EmbedType2) {
    EmbedType2["Rich"] = "rich";
    EmbedType2["Image"] = "image";
    EmbedType2["Video"] = "video";
    EmbedType2["GIFV"] = "gifv";
    EmbedType2["Article"] = "article";
    EmbedType2["Link"] = "link";
    EmbedType2["AutoModerationMessage"] = "auto_moderation_message";
  })(EmbedType = exports.EmbedType || (exports.EmbedType = {}));
  var AttachmentFlags;
  (function(AttachmentFlags2) {
    AttachmentFlags2[AttachmentFlags2["IsRemix"] = 4] = "IsRemix";
  })(AttachmentFlags = exports.AttachmentFlags || (exports.AttachmentFlags = {}));
  var AllowedMentionsTypes;
  (function(AllowedMentionsTypes2) {
    AllowedMentionsTypes2["Everyone"] = "everyone";
    AllowedMentionsTypes2["Role"] = "roles";
    AllowedMentionsTypes2["User"] = "users";
  })(AllowedMentionsTypes = exports.AllowedMentionsTypes || (exports.AllowedMentionsTypes = {}));
  var ComponentType;
  (function(ComponentType2) {
    ComponentType2[ComponentType2["ActionRow"] = 1] = "ActionRow";
    ComponentType2[ComponentType2["Button"] = 2] = "Button";
    ComponentType2[ComponentType2["StringSelect"] = 3] = "StringSelect";
    ComponentType2[ComponentType2["TextInput"] = 4] = "TextInput";
    ComponentType2[ComponentType2["UserSelect"] = 5] = "UserSelect";
    ComponentType2[ComponentType2["RoleSelect"] = 6] = "RoleSelect";
    ComponentType2[ComponentType2["MentionableSelect"] = 7] = "MentionableSelect";
    ComponentType2[ComponentType2["ChannelSelect"] = 8] = "ChannelSelect";
    ComponentType2[ComponentType2["SelectMenu"] = 3] = "SelectMenu";
  })(ComponentType = exports.ComponentType || (exports.ComponentType = {}));
  var ButtonStyle;
  (function(ButtonStyle2) {
    ButtonStyle2[ButtonStyle2["Primary"] = 1] = "Primary";
    ButtonStyle2[ButtonStyle2["Secondary"] = 2] = "Secondary";
    ButtonStyle2[ButtonStyle2["Success"] = 3] = "Success";
    ButtonStyle2[ButtonStyle2["Danger"] = 4] = "Danger";
    ButtonStyle2[ButtonStyle2["Link"] = 5] = "Link";
  })(ButtonStyle = exports.ButtonStyle || (exports.ButtonStyle = {}));
  var TextInputStyle;
  (function(TextInputStyle2) {
    TextInputStyle2[TextInputStyle2["Short"] = 1] = "Short";
    TextInputStyle2[TextInputStyle2["Paragraph"] = 2] = "Paragraph";
  })(TextInputStyle = exports.TextInputStyle || (exports.TextInputStyle = {}));
  var ChannelFlags;
  (function(ChannelFlags2) {
    ChannelFlags2[ChannelFlags2["GuildFeedRemoved"] = 1] = "GuildFeedRemoved";
    ChannelFlags2[ChannelFlags2["Pinned"] = 2] = "Pinned";
    ChannelFlags2[ChannelFlags2["ActiveChannelsRemoved"] = 4] = "ActiveChannelsRemoved";
    ChannelFlags2[ChannelFlags2["RequireTag"] = 16] = "RequireTag";
    ChannelFlags2[ChannelFlags2["IsSpam"] = 32] = "IsSpam";
    ChannelFlags2[ChannelFlags2["IsGuildResourceChannel"] = 128] = "IsGuildResourceChannel";
    ChannelFlags2[ChannelFlags2["ClydeAI"] = 256] = "ClydeAI";
    ChannelFlags2[ChannelFlags2["IsScheduledForDeletion"] = 512] = "IsScheduledForDeletion";
  })(ChannelFlags = exports.ChannelFlags || (exports.ChannelFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/emoji.js
var require_emoji = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/gateway.js
var require_gateway = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ActivityFlags = exports.ActivityType = exports.ActivityPlatform = exports.PresenceUpdateStatus = undefined;
  var PresenceUpdateStatus;
  (function(PresenceUpdateStatus2) {
    PresenceUpdateStatus2["Online"] = "online";
    PresenceUpdateStatus2["DoNotDisturb"] = "dnd";
    PresenceUpdateStatus2["Idle"] = "idle";
    PresenceUpdateStatus2["Invisible"] = "invisible";
    PresenceUpdateStatus2["Offline"] = "offline";
  })(PresenceUpdateStatus = exports.PresenceUpdateStatus || (exports.PresenceUpdateStatus = {}));
  var ActivityPlatform;
  (function(ActivityPlatform2) {
    ActivityPlatform2["Desktop"] = "desktop";
    ActivityPlatform2["Xbox"] = "xbox";
    ActivityPlatform2["Samsung"] = "samsung";
    ActivityPlatform2["IOS"] = "ios";
    ActivityPlatform2["Android"] = "android";
    ActivityPlatform2["Embedded"] = "embedded";
    ActivityPlatform2["PS4"] = "ps4";
    ActivityPlatform2["PS5"] = "ps5";
  })(ActivityPlatform = exports.ActivityPlatform || (exports.ActivityPlatform = {}));
  var ActivityType;
  (function(ActivityType2) {
    ActivityType2[ActivityType2["Playing"] = 0] = "Playing";
    ActivityType2[ActivityType2["Streaming"] = 1] = "Streaming";
    ActivityType2[ActivityType2["Listening"] = 2] = "Listening";
    ActivityType2[ActivityType2["Watching"] = 3] = "Watching";
    ActivityType2[ActivityType2["Custom"] = 4] = "Custom";
    ActivityType2[ActivityType2["Competing"] = 5] = "Competing";
  })(ActivityType = exports.ActivityType || (exports.ActivityType = {}));
  var ActivityFlags;
  (function(ActivityFlags2) {
    ActivityFlags2[ActivityFlags2["Instance"] = 1] = "Instance";
    ActivityFlags2[ActivityFlags2["Join"] = 2] = "Join";
    ActivityFlags2[ActivityFlags2["Spectate"] = 4] = "Spectate";
    ActivityFlags2[ActivityFlags2["JoinRequest"] = 8] = "JoinRequest";
    ActivityFlags2[ActivityFlags2["Sync"] = 16] = "Sync";
    ActivityFlags2[ActivityFlags2["Play"] = 32] = "Play";
    ActivityFlags2[ActivityFlags2["PartyPrivacyFriends"] = 64] = "PartyPrivacyFriends";
    ActivityFlags2[ActivityFlags2["PartyPrivacyVoiceChannel"] = 128] = "PartyPrivacyVoiceChannel";
    ActivityFlags2[ActivityFlags2["Embedded"] = 256] = "Embedded";
  })(ActivityFlags = exports.ActivityFlags || (exports.ActivityFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/guild.js
var require_guild = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildOnboardingPromptType = exports.GuildOnboardingMode = exports.MembershipScreeningFieldType = exports.GuildWidgetStyle = exports.IntegrationExpireBehavior = exports.GuildMemberFlags = exports.GuildFeature = exports.GuildSystemChannelFlags = exports.GuildHubType = exports.GuildPremiumTier = exports.GuildVerificationLevel = exports.GuildNSFWLevel = exports.GuildMFALevel = exports.GuildExplicitContentFilter = exports.GuildDefaultMessageNotifications = undefined;
  var GuildDefaultMessageNotifications;
  (function(GuildDefaultMessageNotifications2) {
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["AllMessages"] = 0] = "AllMessages";
    GuildDefaultMessageNotifications2[GuildDefaultMessageNotifications2["OnlyMentions"] = 1] = "OnlyMentions";
  })(GuildDefaultMessageNotifications = exports.GuildDefaultMessageNotifications || (exports.GuildDefaultMessageNotifications = {}));
  var GuildExplicitContentFilter;
  (function(GuildExplicitContentFilter2) {
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["Disabled"] = 0] = "Disabled";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["MembersWithoutRoles"] = 1] = "MembersWithoutRoles";
    GuildExplicitContentFilter2[GuildExplicitContentFilter2["AllMembers"] = 2] = "AllMembers";
  })(GuildExplicitContentFilter = exports.GuildExplicitContentFilter || (exports.GuildExplicitContentFilter = {}));
  var GuildMFALevel;
  (function(GuildMFALevel2) {
    GuildMFALevel2[GuildMFALevel2["None"] = 0] = "None";
    GuildMFALevel2[GuildMFALevel2["Elevated"] = 1] = "Elevated";
  })(GuildMFALevel = exports.GuildMFALevel || (exports.GuildMFALevel = {}));
  var GuildNSFWLevel;
  (function(GuildNSFWLevel2) {
    GuildNSFWLevel2[GuildNSFWLevel2["Default"] = 0] = "Default";
    GuildNSFWLevel2[GuildNSFWLevel2["Explicit"] = 1] = "Explicit";
    GuildNSFWLevel2[GuildNSFWLevel2["Safe"] = 2] = "Safe";
    GuildNSFWLevel2[GuildNSFWLevel2["AgeRestricted"] = 3] = "AgeRestricted";
  })(GuildNSFWLevel = exports.GuildNSFWLevel || (exports.GuildNSFWLevel = {}));
  var GuildVerificationLevel;
  (function(GuildVerificationLevel2) {
    GuildVerificationLevel2[GuildVerificationLevel2["None"] = 0] = "None";
    GuildVerificationLevel2[GuildVerificationLevel2["Low"] = 1] = "Low";
    GuildVerificationLevel2[GuildVerificationLevel2["Medium"] = 2] = "Medium";
    GuildVerificationLevel2[GuildVerificationLevel2["High"] = 3] = "High";
    GuildVerificationLevel2[GuildVerificationLevel2["VeryHigh"] = 4] = "VeryHigh";
  })(GuildVerificationLevel = exports.GuildVerificationLevel || (exports.GuildVerificationLevel = {}));
  var GuildPremiumTier;
  (function(GuildPremiumTier2) {
    GuildPremiumTier2[GuildPremiumTier2["None"] = 0] = "None";
    GuildPremiumTier2[GuildPremiumTier2["Tier1"] = 1] = "Tier1";
    GuildPremiumTier2[GuildPremiumTier2["Tier2"] = 2] = "Tier2";
    GuildPremiumTier2[GuildPremiumTier2["Tier3"] = 3] = "Tier3";
  })(GuildPremiumTier = exports.GuildPremiumTier || (exports.GuildPremiumTier = {}));
  var GuildHubType;
  (function(GuildHubType2) {
    GuildHubType2[GuildHubType2["Default"] = 0] = "Default";
    GuildHubType2[GuildHubType2["HighSchool"] = 1] = "HighSchool";
    GuildHubType2[GuildHubType2["College"] = 2] = "College";
  })(GuildHubType = exports.GuildHubType || (exports.GuildHubType = {}));
  var GuildSystemChannelFlags;
  (function(GuildSystemChannelFlags2) {
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotifications"] = 1] = "SuppressJoinNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressPremiumSubscriptions"] = 2] = "SuppressPremiumSubscriptions";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressGuildReminderNotifications"] = 4] = "SuppressGuildReminderNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressJoinNotificationReplies"] = 8] = "SuppressJoinNotificationReplies";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotifications"] = 16] = "SuppressRoleSubscriptionPurchaseNotifications";
    GuildSystemChannelFlags2[GuildSystemChannelFlags2["SuppressRoleSubscriptionPurchaseNotificationReplies"] = 32] = "SuppressRoleSubscriptionPurchaseNotificationReplies";
  })(GuildSystemChannelFlags = exports.GuildSystemChannelFlags || (exports.GuildSystemChannelFlags = {}));
  var GuildFeature;
  (function(GuildFeature2) {
    GuildFeature2["AnimatedBanner"] = "ANIMATED_BANNER";
    GuildFeature2["AnimatedIcon"] = "ANIMATED_ICON";
    GuildFeature2["ApplicationCommandPermissionsV2"] = "APPLICATION_COMMAND_PERMISSIONS_V2";
    GuildFeature2["AutoModeration"] = "AUTO_MODERATION";
    GuildFeature2["Banner"] = "BANNER";
    GuildFeature2["Community"] = "COMMUNITY";
    GuildFeature2["CreatorMonetizableProvisional"] = "CREATOR_MONETIZABLE_PROVISIONAL";
    GuildFeature2["CreatorStorePage"] = "CREATOR_STORE_PAGE";
    GuildFeature2["DeveloperSupportServer"] = "DEVELOPER_SUPPORT_SERVER";
    GuildFeature2["Discoverable"] = "DISCOVERABLE";
    GuildFeature2["Featurable"] = "FEATURABLE";
    GuildFeature2["HasDirectoryEntry"] = "HAS_DIRECTORY_ENTRY";
    GuildFeature2["Hub"] = "HUB";
    GuildFeature2["InvitesDisabled"] = "INVITES_DISABLED";
    GuildFeature2["InviteSplash"] = "INVITE_SPLASH";
    GuildFeature2["LinkedToHub"] = "LINKED_TO_HUB";
    GuildFeature2["MemberVerificationGateEnabled"] = "MEMBER_VERIFICATION_GATE_ENABLED";
    GuildFeature2["MonetizationEnabled"] = "MONETIZATION_ENABLED";
    GuildFeature2["MoreStickers"] = "MORE_STICKERS";
    GuildFeature2["News"] = "NEWS";
    GuildFeature2["Partnered"] = "PARTNERED";
    GuildFeature2["PreviewEnabled"] = "PREVIEW_ENABLED";
    GuildFeature2["PrivateThreads"] = "PRIVATE_THREADS";
    GuildFeature2["RaidAlertsDisabled"] = "RAID_ALERTS_DISABLED";
    GuildFeature2["RelayEnabled"] = "RELAY_ENABLED";
    GuildFeature2["RoleIcons"] = "ROLE_ICONS";
    GuildFeature2["RoleSubscriptionsAvailableForPurchase"] = "ROLE_SUBSCRIPTIONS_AVAILABLE_FOR_PURCHASE";
    GuildFeature2["RoleSubscriptionsEnabled"] = "ROLE_SUBSCRIPTIONS_ENABLED";
    GuildFeature2["TicketedEventsEnabled"] = "TICKETED_EVENTS_ENABLED";
    GuildFeature2["VanityURL"] = "VANITY_URL";
    GuildFeature2["Verified"] = "VERIFIED";
    GuildFeature2["VIPRegions"] = "VIP_REGIONS";
    GuildFeature2["WelcomeScreenEnabled"] = "WELCOME_SCREEN_ENABLED";
  })(GuildFeature = exports.GuildFeature || (exports.GuildFeature = {}));
  var GuildMemberFlags;
  (function(GuildMemberFlags2) {
    GuildMemberFlags2[GuildMemberFlags2["DidRejoin"] = 1] = "DidRejoin";
    GuildMemberFlags2[GuildMemberFlags2["CompletedOnboarding"] = 2] = "CompletedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["BypassesVerification"] = 4] = "BypassesVerification";
    GuildMemberFlags2[GuildMemberFlags2["StartedOnboarding"] = 8] = "StartedOnboarding";
    GuildMemberFlags2[GuildMemberFlags2["StartedHomeActions"] = 32] = "StartedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["CompletedHomeActions"] = 64] = "CompletedHomeActions";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedUsernameOrGuildNickname"] = 128] = "AutomodQuarantinedUsernameOrGuildNickname";
    GuildMemberFlags2[GuildMemberFlags2["AutomodQuarantinedBio"] = 256] = "AutomodQuarantinedBio";
  })(GuildMemberFlags = exports.GuildMemberFlags || (exports.GuildMemberFlags = {}));
  var IntegrationExpireBehavior;
  (function(IntegrationExpireBehavior2) {
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["RemoveRole"] = 0] = "RemoveRole";
    IntegrationExpireBehavior2[IntegrationExpireBehavior2["Kick"] = 1] = "Kick";
  })(IntegrationExpireBehavior = exports.IntegrationExpireBehavior || (exports.IntegrationExpireBehavior = {}));
  var GuildWidgetStyle;
  (function(GuildWidgetStyle2) {
    GuildWidgetStyle2["Shield"] = "shield";
    GuildWidgetStyle2["Banner1"] = "banner1";
    GuildWidgetStyle2["Banner2"] = "banner2";
    GuildWidgetStyle2["Banner3"] = "banner3";
    GuildWidgetStyle2["Banner4"] = "banner4";
  })(GuildWidgetStyle = exports.GuildWidgetStyle || (exports.GuildWidgetStyle = {}));
  var MembershipScreeningFieldType;
  (function(MembershipScreeningFieldType2) {
    MembershipScreeningFieldType2["Terms"] = "TERMS";
  })(MembershipScreeningFieldType = exports.MembershipScreeningFieldType || (exports.MembershipScreeningFieldType = {}));
  var GuildOnboardingMode;
  (function(GuildOnboardingMode2) {
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingDefault"] = 0] = "OnboardingDefault";
    GuildOnboardingMode2[GuildOnboardingMode2["OnboardingAdvanced"] = 1] = "OnboardingAdvanced";
  })(GuildOnboardingMode = exports.GuildOnboardingMode || (exports.GuildOnboardingMode = {}));
  var GuildOnboardingPromptType;
  (function(GuildOnboardingPromptType2) {
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["MultipleChoice"] = 0] = "MultipleChoice";
    GuildOnboardingPromptType2[GuildOnboardingPromptType2["Dropdown"] = 1] = "Dropdown";
  })(GuildOnboardingPromptType = exports.GuildOnboardingPromptType || (exports.GuildOnboardingPromptType = {}));
});

// node_modules/discord-api-types/payloads/v10/guildScheduledEvent.js
var require_guildScheduledEvent = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventStatus = exports.GuildScheduledEventEntityType = undefined;
  var GuildScheduledEventEntityType;
  (function(GuildScheduledEventEntityType2) {
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["StageInstance"] = 1] = "StageInstance";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["Voice"] = 2] = "Voice";
    GuildScheduledEventEntityType2[GuildScheduledEventEntityType2["External"] = 3] = "External";
  })(GuildScheduledEventEntityType = exports.GuildScheduledEventEntityType || (exports.GuildScheduledEventEntityType = {}));
  var GuildScheduledEventStatus;
  (function(GuildScheduledEventStatus2) {
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Scheduled"] = 1] = "Scheduled";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Active"] = 2] = "Active";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Completed"] = 3] = "Completed";
    GuildScheduledEventStatus2[GuildScheduledEventStatus2["Canceled"] = 4] = "Canceled";
  })(GuildScheduledEventStatus = exports.GuildScheduledEventStatus || (exports.GuildScheduledEventStatus = {}));
  var GuildScheduledEventPrivacyLevel;
  (function(GuildScheduledEventPrivacyLevel2) {
    GuildScheduledEventPrivacyLevel2[GuildScheduledEventPrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(GuildScheduledEventPrivacyLevel = exports.GuildScheduledEventPrivacyLevel || (exports.GuildScheduledEventPrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/attachment.js
var require_attachment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/base.js
var require_base = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/channel.js
var require_channel2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/mentionable.js
var require_mentionable = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/role.js
var require_role = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/shared.js
var require_shared = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandOptionType = undefined;
  var ApplicationCommandOptionType;
  (function(ApplicationCommandOptionType2) {
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Subcommand"] = 1] = "Subcommand";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["SubcommandGroup"] = 2] = "SubcommandGroup";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["String"] = 3] = "String";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Integer"] = 4] = "Integer";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Boolean"] = 5] = "Boolean";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["User"] = 6] = "User";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Channel"] = 7] = "Channel";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Role"] = 8] = "Role";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Mentionable"] = 9] = "Mentionable";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Number"] = 10] = "Number";
    ApplicationCommandOptionType2[ApplicationCommandOptionType2["Attachment"] = 11] = "Attachment";
  })(ApplicationCommandOptionType = exports.ApplicationCommandOptionType || (exports.ApplicationCommandOptionType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommand.js
var require_subcommand = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/subcommandGroup.js
var require_subcommandGroup = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/_chatInput/user.js
var require_user = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/chatInput.js
var require_chatInput = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_attachment(), exports);
  __exportStar(require_base(), exports);
  __exportStar(require_boolean(), exports);
  __exportStar(require_channel2(), exports);
  __exportStar(require_integer(), exports);
  __exportStar(require_mentionable(), exports);
  __exportStar(require_number(), exports);
  __exportStar(require_role(), exports);
  __exportStar(require_shared(), exports);
  __exportStar(require_string(), exports);
  __exportStar(require_subcommand(), exports);
  __exportStar(require_subcommandGroup(), exports);
  __exportStar(require_user(), exports);
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/contextMenu.js
var require_contextMenu = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/_applicationCommands/permissions.js
var require_permissions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.APIApplicationCommandPermissionsConstant = exports.ApplicationCommandPermissionType = undefined;
  var ApplicationCommandPermissionType;
  (function(ApplicationCommandPermissionType2) {
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Role"] = 1] = "Role";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["User"] = 2] = "User";
    ApplicationCommandPermissionType2[ApplicationCommandPermissionType2["Channel"] = 3] = "Channel";
  })(ApplicationCommandPermissionType = exports.ApplicationCommandPermissionType || (exports.ApplicationCommandPermissionType = {}));
  exports.APIApplicationCommandPermissionsConstant = {
    Everyone: (guildId) => String(guildId),
    AllChannels: (guildId) => String(BigInt(guildId) - 1n)
  };
});

// node_modules/discord-api-types/payloads/v10/_interactions/applicationCommands.js
var require_applicationCommands = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ApplicationCommandType = undefined;
  __exportStar(require_chatInput(), exports);
  __exportStar(require_contextMenu(), exports);
  __exportStar(require_permissions(), exports);
  var ApplicationCommandType;
  (function(ApplicationCommandType2) {
    ApplicationCommandType2[ApplicationCommandType2["ChatInput"] = 1] = "ChatInput";
    ApplicationCommandType2[ApplicationCommandType2["User"] = 2] = "User";
    ApplicationCommandType2[ApplicationCommandType2["Message"] = 3] = "Message";
  })(ApplicationCommandType = exports.ApplicationCommandType || (exports.ApplicationCommandType = {}));
});

// node_modules/discord-api-types/payloads/v10/_interactions/autocomplete.js
var require_autocomplete = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/base.js
var require_base2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/messageComponents.js
var require_messageComponents = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/modalSubmit.js
var require_modalSubmit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/ping.js
var require_ping = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/_interactions/responses.js
var require_responses = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InteractionResponseType = exports.InteractionType = undefined;
  var InteractionType;
  (function(InteractionType2) {
    InteractionType2[InteractionType2["Ping"] = 1] = "Ping";
    InteractionType2[InteractionType2["ApplicationCommand"] = 2] = "ApplicationCommand";
    InteractionType2[InteractionType2["MessageComponent"] = 3] = "MessageComponent";
    InteractionType2[InteractionType2["ApplicationCommandAutocomplete"] = 4] = "ApplicationCommandAutocomplete";
    InteractionType2[InteractionType2["ModalSubmit"] = 5] = "ModalSubmit";
  })(InteractionType = exports.InteractionType || (exports.InteractionType = {}));
  var InteractionResponseType;
  (function(InteractionResponseType2) {
    InteractionResponseType2[InteractionResponseType2["Pong"] = 1] = "Pong";
    InteractionResponseType2[InteractionResponseType2["ChannelMessageWithSource"] = 4] = "ChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredChannelMessageWithSource"] = 5] = "DeferredChannelMessageWithSource";
    InteractionResponseType2[InteractionResponseType2["DeferredMessageUpdate"] = 6] = "DeferredMessageUpdate";
    InteractionResponseType2[InteractionResponseType2["UpdateMessage"] = 7] = "UpdateMessage";
    InteractionResponseType2[InteractionResponseType2["ApplicationCommandAutocompleteResult"] = 8] = "ApplicationCommandAutocompleteResult";
    InteractionResponseType2[InteractionResponseType2["Modal"] = 9] = "Modal";
  })(InteractionResponseType = exports.InteractionResponseType || (exports.InteractionResponseType = {}));
});

// node_modules/discord-api-types/payloads/v10/interactions.js
var require_interactions = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_applicationCommands(), exports);
  __exportStar(require_autocomplete(), exports);
  __exportStar(require_base2(), exports);
  __exportStar(require_messageComponents(), exports);
  __exportStar(require_modalSubmit(), exports);
  __exportStar(require_ping(), exports);
  __exportStar(require_responses(), exports);
});

// node_modules/discord-api-types/payloads/v10/invite.js
var require_invite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InviteTargetType = undefined;
  var InviteTargetType;
  (function(InviteTargetType2) {
    InviteTargetType2[InviteTargetType2["Stream"] = 1] = "Stream";
    InviteTargetType2[InviteTargetType2["EmbeddedApplication"] = 2] = "EmbeddedApplication";
  })(InviteTargetType = exports.InviteTargetType || (exports.InviteTargetType = {}));
});

// node_modules/discord-api-types/payloads/v10/oauth2.js
var require_oauth2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Scopes = undefined;
  var OAuth2Scopes;
  (function(OAuth2Scopes2) {
    OAuth2Scopes2["Bot"] = "bot";
    OAuth2Scopes2["Connections"] = "connections";
    OAuth2Scopes2["DMChannelsRead"] = "dm_channels.read";
    OAuth2Scopes2["Email"] = "email";
    OAuth2Scopes2["Identify"] = "identify";
    OAuth2Scopes2["Guilds"] = "guilds";
    OAuth2Scopes2["GuildsJoin"] = "guilds.join";
    OAuth2Scopes2["GuildsMembersRead"] = "guilds.members.read";
    OAuth2Scopes2["GroupDMJoins"] = "gdm.join";
    OAuth2Scopes2["MessagesRead"] = "messages.read";
    OAuth2Scopes2["RoleConnectionsWrite"] = "role_connections.write";
    OAuth2Scopes2["RPC"] = "rpc";
    OAuth2Scopes2["RPCNotificationsRead"] = "rpc.notifications.read";
    OAuth2Scopes2["WebhookIncoming"] = "webhook.incoming";
    OAuth2Scopes2["Voice"] = "voice";
    OAuth2Scopes2["ApplicationsBuildsUpload"] = "applications.builds.upload";
    OAuth2Scopes2["ApplicationsBuildsRead"] = "applications.builds.read";
    OAuth2Scopes2["ApplicationsStoreUpdate"] = "applications.store.update";
    OAuth2Scopes2["ApplicationsEntitlements"] = "applications.entitlements";
    OAuth2Scopes2["RelationshipsRead"] = "relationships.read";
    OAuth2Scopes2["ActivitiesRead"] = "activities.read";
    OAuth2Scopes2["ActivitiesWrite"] = "activities.write";
    OAuth2Scopes2["ApplicationsCommands"] = "applications.commands";
    OAuth2Scopes2["ApplicationsCommandsUpdate"] = "applications.commands.update";
    OAuth2Scopes2["ApplicationCommandsPermissionsUpdate"] = "applications.commands.permissions.update";
  })(OAuth2Scopes = exports.OAuth2Scopes || (exports.OAuth2Scopes = {}));
});

// node_modules/discord-api-types/payloads/v10/permissions.js
var require_permissions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RoleFlags = undefined;
  var RoleFlags;
  (function(RoleFlags2) {
    RoleFlags2[RoleFlags2["InPrompt"] = 1] = "InPrompt";
  })(RoleFlags = exports.RoleFlags || (exports.RoleFlags = {}));
});

// node_modules/discord-api-types/payloads/v10/stageInstance.js
var require_stageInstance = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StageInstancePrivacyLevel = undefined;
  var StageInstancePrivacyLevel;
  (function(StageInstancePrivacyLevel2) {
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["Public"] = 1] = "Public";
    StageInstancePrivacyLevel2[StageInstancePrivacyLevel2["GuildOnly"] = 2] = "GuildOnly";
  })(StageInstancePrivacyLevel = exports.StageInstancePrivacyLevel || (exports.StageInstancePrivacyLevel = {}));
});

// node_modules/discord-api-types/payloads/v10/sticker.js
var require_sticker = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StickerFormatType = exports.StickerType = undefined;
  var StickerType;
  (function(StickerType2) {
    StickerType2[StickerType2["Standard"] = 1] = "Standard";
    StickerType2[StickerType2["Guild"] = 2] = "Guild";
  })(StickerType = exports.StickerType || (exports.StickerType = {}));
  var StickerFormatType;
  (function(StickerFormatType2) {
    StickerFormatType2[StickerFormatType2["PNG"] = 1] = "PNG";
    StickerFormatType2[StickerFormatType2["APNG"] = 2] = "APNG";
    StickerFormatType2[StickerFormatType2["Lottie"] = 3] = "Lottie";
    StickerFormatType2[StickerFormatType2["GIF"] = 4] = "GIF";
  })(StickerFormatType = exports.StickerFormatType || (exports.StickerFormatType = {}));
});

// node_modules/discord-api-types/payloads/v10/teams.js
var require_teams = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TeamMemberMembershipState = undefined;
  var TeamMemberMembershipState;
  (function(TeamMemberMembershipState2) {
    TeamMemberMembershipState2[TeamMemberMembershipState2["Invited"] = 1] = "Invited";
    TeamMemberMembershipState2[TeamMemberMembershipState2["Accepted"] = 2] = "Accepted";
  })(TeamMemberMembershipState = exports.TeamMemberMembershipState || (exports.TeamMemberMembershipState = {}));
});

// node_modules/discord-api-types/payloads/v10/template.js
var require_template = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/user.js
var require_user2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConnectionVisibility = exports.ConnectionService = exports.UserPremiumType = exports.UserFlags = undefined;
  var UserFlags;
  (function(UserFlags2) {
    UserFlags2[UserFlags2["Staff"] = 1] = "Staff";
    UserFlags2[UserFlags2["Partner"] = 2] = "Partner";
    UserFlags2[UserFlags2["Hypesquad"] = 4] = "Hypesquad";
    UserFlags2[UserFlags2["BugHunterLevel1"] = 8] = "BugHunterLevel1";
    UserFlags2[UserFlags2["MFASMS"] = 16] = "MFASMS";
    UserFlags2[UserFlags2["PremiumPromoDismissed"] = 32] = "PremiumPromoDismissed";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse1"] = 64] = "HypeSquadOnlineHouse1";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse2"] = 128] = "HypeSquadOnlineHouse2";
    UserFlags2[UserFlags2["HypeSquadOnlineHouse3"] = 256] = "HypeSquadOnlineHouse3";
    UserFlags2[UserFlags2["PremiumEarlySupporter"] = 512] = "PremiumEarlySupporter";
    UserFlags2[UserFlags2["TeamPseudoUser"] = 1024] = "TeamPseudoUser";
    UserFlags2[UserFlags2["HasUnreadUrgentMessages"] = 8192] = "HasUnreadUrgentMessages";
    UserFlags2[UserFlags2["BugHunterLevel2"] = 16384] = "BugHunterLevel2";
    UserFlags2[UserFlags2["VerifiedBot"] = 65536] = "VerifiedBot";
    UserFlags2[UserFlags2["VerifiedDeveloper"] = 131072] = "VerifiedDeveloper";
    UserFlags2[UserFlags2["CertifiedModerator"] = 262144] = "CertifiedModerator";
    UserFlags2[UserFlags2["BotHTTPInteractions"] = 524288] = "BotHTTPInteractions";
    UserFlags2[UserFlags2["Spammer"] = 1048576] = "Spammer";
    UserFlags2[UserFlags2["DisablePremium"] = 2097152] = "DisablePremium";
    UserFlags2[UserFlags2["ActiveDeveloper"] = 4194304] = "ActiveDeveloper";
    UserFlags2[UserFlags2["Quarantined"] = 17592186044416] = "Quarantined";
    UserFlags2[UserFlags2["Collaborator"] = 1125899906842624] = "Collaborator";
    UserFlags2[UserFlags2["RestrictedCollaborator"] = 2251799813685248] = "RestrictedCollaborator";
  })(UserFlags = exports.UserFlags || (exports.UserFlags = {}));
  var UserPremiumType;
  (function(UserPremiumType2) {
    UserPremiumType2[UserPremiumType2["None"] = 0] = "None";
    UserPremiumType2[UserPremiumType2["NitroClassic"] = 1] = "NitroClassic";
    UserPremiumType2[UserPremiumType2["Nitro"] = 2] = "Nitro";
    UserPremiumType2[UserPremiumType2["NitroBasic"] = 3] = "NitroBasic";
  })(UserPremiumType = exports.UserPremiumType || (exports.UserPremiumType = {}));
  var ConnectionService;
  (function(ConnectionService2) {
    ConnectionService2["BattleNet"] = "battlenet";
    ConnectionService2["eBay"] = "ebay";
    ConnectionService2["EpicGames"] = "epicgames";
    ConnectionService2["Facebook"] = "facebook";
    ConnectionService2["GitHub"] = "github";
    ConnectionService2["Instagram"] = "instagram";
    ConnectionService2["LeagueOfLegends"] = "leagueoflegends";
    ConnectionService2["PayPal"] = "paypal";
    ConnectionService2["PlayStationNetwork"] = "playstation";
    ConnectionService2["Reddit"] = "reddit";
    ConnectionService2["RiotGames"] = "riotgames";
    ConnectionService2["Spotify"] = "spotify";
    ConnectionService2["Skype"] = "skype";
    ConnectionService2["Steam"] = "steam";
    ConnectionService2["TikTok"] = "tiktok";
    ConnectionService2["Twitch"] = "twitch";
    ConnectionService2["Twitter"] = "twitter";
    ConnectionService2["Xbox"] = "xbox";
    ConnectionService2["YouTube"] = "youtube";
  })(ConnectionService = exports.ConnectionService || (exports.ConnectionService = {}));
  var ConnectionVisibility;
  (function(ConnectionVisibility2) {
    ConnectionVisibility2[ConnectionVisibility2["None"] = 0] = "None";
    ConnectionVisibility2[ConnectionVisibility2["Everyone"] = 1] = "Everyone";
  })(ConnectionVisibility = exports.ConnectionVisibility || (exports.ConnectionVisibility = {}));
});

// node_modules/discord-api-types/payloads/v10/voice.js
var require_voice = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/payloads/v10/webhook.js
var require_webhook = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebhookType = undefined;
  var WebhookType;
  (function(WebhookType2) {
    WebhookType2[WebhookType2["Incoming"] = 1] = "Incoming";
    WebhookType2[WebhookType2["ChannelFollower"] = 2] = "ChannelFollower";
    WebhookType2[WebhookType2["Application"] = 3] = "Application";
  })(WebhookType = exports.WebhookType || (exports.WebhookType = {}));
});

// node_modules/discord-api-types/payloads/v10/index.js
var require_v102 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common2(), exports);
  __exportStar(require_application(), exports);
  __exportStar(require_auditLog(), exports);
  __exportStar(require_autoModeration(), exports);
  __exportStar(require_channel(), exports);
  __exportStar(require_emoji(), exports);
  __exportStar(require_gateway(), exports);
  __exportStar(require_guild(), exports);
  __exportStar(require_guildScheduledEvent(), exports);
  __exportStar(require_interactions(), exports);
  __exportStar(require_invite(), exports);
  __exportStar(require_oauth2(), exports);
  __exportStar(require_permissions2(), exports);
  __exportStar(require_stageInstance(), exports);
  __exportStar(require_sticker(), exports);
  __exportStar(require_teams(), exports);
  __exportStar(require_template(), exports);
  __exportStar(require_user2(), exports);
  __exportStar(require_voice(), exports);
  __exportStar(require_webhook(), exports);
});

// node_modules/discord-api-types/rest/common.js
var require_common3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Locale = exports.RESTJSONErrorCodes = undefined;
  var RESTJSONErrorCodes;
  (function(RESTJSONErrorCodes2) {
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GeneralError"] = 0] = "GeneralError";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownAccount"] = 10001] = "UnknownAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplication"] = 10002] = "UnknownApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownChannel"] = 10003] = "UnknownChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuild"] = 10004] = "UnknownGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownIntegration"] = 10005] = "UnknownIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInvite"] = 10006] = "UnknownInvite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMember"] = 10007] = "UnknownMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownMessage"] = 10008] = "UnknownMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPermissionOverwrite"] = 10009] = "UnknownPermissionOverwrite";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownProvider"] = 10010] = "UnknownProvider";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRole"] = 10011] = "UnknownRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownToken"] = 10012] = "UnknownToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownUser"] = 10013] = "UnknownUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEmoji"] = 10014] = "UnknownEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhook"] = 10015] = "UnknownWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownWebhookService"] = 10016] = "UnknownWebhookService";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSession"] = 10020] = "UnknownSession";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBan"] = 10026] = "UnknownBan";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSKU"] = 10027] = "UnknownSKU";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreListing"] = 10028] = "UnknownStoreListing";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownEntitlement"] = 10029] = "UnknownEntitlement";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBuild"] = 10030] = "UnknownBuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownLobby"] = 10031] = "UnknownLobby";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownBranch"] = 10032] = "UnknownBranch";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStoreDirectoryLayout"] = 10033] = "UnknownStoreDirectoryLayout";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownRedistributable"] = 10036] = "UnknownRedistributable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGiftCode"] = 10038] = "UnknownGiftCode";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStream"] = 10049] = "UnknownStream";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownPremiumServerSubscribeCooldown"] = 10050] = "UnknownPremiumServerSubscribeCooldown";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildTemplate"] = 10057] = "UnknownGuildTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownDiscoverableServerCategory"] = 10059] = "UnknownDiscoverableServerCategory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownSticker"] = 10060] = "UnknownSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownInteraction"] = 10062] = "UnknownInteraction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommand"] = 10063] = "UnknownApplicationCommand";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownVoiceState"] = 10065] = "UnknownVoiceState";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownApplicationCommandPermissions"] = 10066] = "UnknownApplicationCommandPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownStageInstance"] = 10067] = "UnknownStageInstance";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildMemberVerificationForm"] = 10068] = "UnknownGuildMemberVerificationForm";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildWelcomeScreen"] = 10069] = "UnknownGuildWelcomeScreen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEvent"] = 10070] = "UnknownGuildScheduledEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownGuildScheduledEventUser"] = 10071] = "UnknownGuildScheduledEventUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnknownTag"] = 10087] = "UnknownTag";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BotsCannotUseThisEndpoint"] = 20001] = "BotsCannotUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyBotsCanUseThisEndpoint"] = 20002] = "OnlyBotsCanUseThisEndpoint";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ExplicitContentCannotBeSentToTheDesiredRecipient"] = 20009] = "ExplicitContentCannotBeSentToTheDesiredRecipient";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NotAuthorizedToPerformThisActionOnThisApplication"] = 20012] = "NotAuthorizedToPerformThisActionOnThisApplication";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ActionCannotBePerformedDueToSlowmodeRateLimit"] = 20016] = "ActionCannotBePerformedDueToSlowmodeRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheMazeIsntMeantForYou"] = 20017] = "TheMazeIsntMeantForYou";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OnlyTheOwnerOfThisAccountCanPerformThisAction"] = 20018] = "OnlyTheOwnerOfThisAccountCanPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["AnnouncementEditLimitExceeded"] = 20022] = "AnnouncementEditLimitExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UnderMinimumAge"] = 20024] = "UnderMinimumAge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelSendRateLimit"] = 20028] = "ChannelSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerSendRateLimit"] = 20029] = "ServerSendRateLimit";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords"] = 20031] = "StageTopicServerNameServerDescriptionOrChannelNamesContainDisallowedWords";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildPremiumSubscriptionLevelTooLow"] = 20035] = "GuildPremiumSubscriptionLevelTooLow";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildsReached"] = 30001] = "MaximumNumberOfGuildsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfFriendsReached"] = 30002] = "MaximumNumberOfFriendsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinsReachedForTheChannel"] = 30003] = "MaximumNumberOfPinsReachedForTheChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfRecipientsReached"] = 30004] = "MaximumNumberOfRecipientsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildRolesReached"] = 30005] = "MaximumNumberOfGuildRolesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksReached"] = 30007] = "MaximumNumberOfWebhooksReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEmojisReached"] = 30008] = "MaximumNumberOfEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfReactionsReached"] = 30010] = "MaximumNumberOfReactionsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGroupDMsReached"] = 30011] = "MaximumNumberOfGroupDMsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildChannelsReached"] = 30013] = "MaximumNumberOfGuildChannelsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAttachmentsInAMessageReached"] = 30015] = "MaximumNumberOfAttachmentsInAMessageReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfInvitesReached"] = 30016] = "MaximumNumberOfInvitesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfAnimatedEmojisReached"] = 30018] = "MaximumNumberOfAnimatedEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerMembersReached"] = 30019] = "MaximumNumberOfServerMembersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfServerCategoriesReached"] = 30030] = "MaximumNumberOfServerCategoriesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildAlreadyHasTemplate"] = 30031] = "GuildAlreadyHasTemplate";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfApplicationCommandsReached"] = 30032] = "MaximumNumberOfApplicationCommandsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumThreadParticipantsReached"] = 30033] = "MaximumThreadParticipantsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumDailyApplicationCommandCreatesReached"] = 30034] = "MaximumDailyApplicationCommandCreatesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfNonGuildMemberBansHasBeenExceeded"] = 30035] = "MaximumNumberOfNonGuildMemberBansHasBeenExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfBanFetchesHasBeenReached"] = 30037] = "MaximumNumberOfBanFetchesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfUncompletedGuildScheduledEventsReached"] = 30038] = "MaximumNumberOfUncompletedGuildScheduledEventsReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfStickersReached"] = 30039] = "MaximumNumberOfStickersReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPruneRequestsHasBeenReached"] = 30040] = "MaximumNumberOfPruneRequestsHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached"] = 30042] = "MaximumNumberOfGuildWidgetSettingsUpdatesHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfEditsToMessagesOlderThanOneHourReached"] = 30046] = "MaximumNumberOfEditsToMessagesOlderThanOneHourReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPinnedThreadsInForumHasBeenReached"] = 30047] = "MaximumNumberOfPinnedThreadsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfTagsInForumHasBeenReached"] = 30048] = "MaximumNumberOfTagsInForumHasBeenReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["BitrateIsTooHighForChannelOfThisType"] = 30052] = "BitrateIsTooHighForChannelOfThisType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfPremiumEmojisReached"] = 30056] = "MaximumNumberOfPremiumEmojisReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfWebhooksPerGuildReached"] = 30058] = "MaximumNumberOfWebhooksPerGuildReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumNumberOfChannelPermissionOverwritesReached"] = 30060] = "MaximumNumberOfChannelPermissionOverwritesReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheChannelsForThisGuildAreTooLarge"] = 30061] = "TheChannelsForThisGuildAreTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["Unauthorized"] = 40001] = "Unauthorized";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VerifyYourAccount"] = 40002] = "VerifyYourAccount";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OpeningDirectMessagesTooFast"] = 40003] = "OpeningDirectMessagesTooFast";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["SendMessagesHasBeenTemporarilyDisabled"] = 40004] = "SendMessagesHasBeenTemporarilyDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestEntityTooLarge"] = 40005] = "RequestEntityTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FeatureTemporarilyDisabledServerSide"] = 40006] = "FeatureTemporarilyDisabledServerSide";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UserBannedFromThisGuild"] = 40007] = "UserBannedFromThisGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ConnectionHasBeenRevoked"] = 40012] = "ConnectionHasBeenRevoked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TargetUserIsNotConnectedToVoice"] = 40032] = "TargetUserIsNotConnectedToVoice";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThisMessageWasAlreadyCrossposted"] = 40033] = "ThisMessageWasAlreadyCrossposted";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationCommandWithThatNameAlreadyExists"] = 40041] = "ApplicationCommandWithThatNameAlreadyExists";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationInteractionFailedToSend"] = 40043] = "ApplicationInteractionFailedToSend";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAMessageInAForumChannel"] = 40058] = "CannotSendAMessageInAForumChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InteractionHasAlreadyBeenAcknowledged"] = 40060] = "InteractionHasAlreadyBeenAcknowledged";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagNamesMustBeUnique"] = 40061] = "TagNamesMustBeUnique";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServiceResourceIsBeingRateLimited"] = 40062] = "ServiceResourceIsBeingRateLimited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThereAreNoTagsAvailableThatCanBeSetByNonModerators"] = 40066] = "ThereAreNoTagsAvailableThatCanBeSetByNonModerators";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TagRequiredToCreateAForumPostInThisChannel"] = 40067] = "TagRequiredToCreateAForumPostInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingAccess"] = 50001] = "MissingAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAccountType"] = 50002] = "InvalidAccountType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnDMChannel"] = 50003] = "CannotExecuteActionOnDMChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["GuildWidgetDisabled"] = 50004] = "GuildWidgetDisabled";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditMessageAuthoredByAnotherUser"] = 50005] = "CannotEditMessageAuthoredByAnotherUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendAnEmptyMessage"] = 50006] = "CannotSendAnEmptyMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesToThisUser"] = 50007] = "CannotSendMessagesToThisUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSendMessagesInNonTextChannel"] = 50008] = "CannotSendMessagesInNonTextChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ChannelVerificationLevelTooHighForYouToGainAccess"] = 50009] = "ChannelVerificationLevelTooHighForYouToGainAccess";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationDoesNotHaveBot"] = 50010] = "OAuth2ApplicationDoesNotHaveBot";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OAuth2ApplicationLimitReached"] = 50011] = "OAuth2ApplicationLimitReached";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2State"] = 50012] = "InvalidOAuth2State";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingPermissions"] = 50013] = "MissingPermissions";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidToken"] = 50014] = "InvalidToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoteWasTooLong"] = 50015] = "NoteWasTooLong";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ProvidedTooFewOrTooManyMessagesToDelete"] = 50016] = "ProvidedTooFewOrTooManyMessagesToDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMFALevel"] = 50017] = "InvalidMFALevel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageCanOnlyBePinnedInTheChannelItWasSentIn"] = 50019] = "MessageCanOnlyBePinnedInTheChannelItWasSentIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteCodeInvalidOrTaken"] = 50020] = "InviteCodeInvalidOrTaken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnSystemMessage"] = 50021] = "CannotExecuteActionOnSystemMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotExecuteActionOnThisChannelType"] = 50024] = "CannotExecuteActionOnThisChannelType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidOAuth2AccessToken"] = 50025] = "InvalidOAuth2AccessToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MissingRequiredOAuth2Scope"] = 50026] = "MissingRequiredOAuth2Scope";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidWebhookToken"] = 50027] = "InvalidWebhookToken";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRole"] = 50028] = "InvalidRole";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRecipients"] = 50033] = "InvalidRecipients";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OneOfTheMessagesProvidedWasTooOldForBulkDelete"] = 50034] = "OneOfTheMessagesProvidedWasTooOldForBulkDelete";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFormBodyOrContentType"] = 50035] = "InvalidFormBodyOrContentType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InviteAcceptedToGuildWithoutTheBotBeingIn"] = 50036] = "InviteAcceptedToGuildWithoutTheBotBeingIn";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActivityAction"] = 50039] = "InvalidActivityAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidAPIVersion"] = 50041] = "InvalidAPIVersion";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FileUploadedExceedsMaximumSize"] = 50045] = "FileUploadedExceedsMaximumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidFileUploaded"] = 50046] = "InvalidFileUploaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotSelfRedeemThisGift"] = 50054] = "CannotSelfRedeemThisGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidGuild"] = 50055] = "InvalidGuild";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidRequestOrigin"] = 50067] = "InvalidRequestOrigin";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidMessageType"] = 50068] = "InvalidMessageType";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["PaymentSourceRequiredToRedeemGift"] = 50070] = "PaymentSourceRequiredToRedeemGift";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotModifyASystemWebhook"] = 50073] = "CannotModifyASystemWebhook";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteChannelRequiredForCommunityGuilds"] = 50074] = "CannotDeleteChannelRequiredForCommunityGuilds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEditStickersWithinMessage"] = 50080] = "CannotEditStickersWithinMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidStickerSent"] = 50081] = "InvalidStickerSent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidActionOnArchivedThread"] = 50083] = "InvalidActionOnArchivedThread";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidThreadNotificationSettings"] = 50084] = "InvalidThreadNotificationSettings";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ParameterEarlierThanCreation"] = 50085] = "ParameterEarlierThanCreation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CommunityServerChannelsMustBeTextChannels"] = 50086] = "CommunityServerChannelsMustBeTextChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor"] = 50091] = "TheEntityTypeOfTheEventIsDifferentFromTheEntityYouAreTryingToStartTheEventFor";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNotAvailableInYourLocation"] = 50095] = "ServerNotAvailableInYourLocation";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMonetizationEnabledToPerformThisAction"] = 50097] = "ServerNeedsMonetizationEnabledToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ServerNeedsMoreBoostsToPerformThisAction"] = 50101] = "ServerNeedsMoreBoostsToPerformThisAction";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["RequestBodyContainsInvalidJSON"] = 50109] = "RequestBodyContainsInvalidJSON";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnerCannotBePendingMember"] = 50131] = "OwnerCannotBePendingMember";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["OwnershipCannotBeMovedToABotUser"] = 50132] = "OwnershipCannotBeMovedToABotUser";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToResizeAssetBelowTheMinimumSize"] = 50138] = "FailedToResizeAssetBelowTheMinimumSize";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji"] = 50144] = "CannotMixSubscriptionAndNonSubscriptionRolesForAnEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotConvertBetweenPremiumEmojiAndNormalEmoji"] = 50145] = "CannotConvertBetweenPremiumEmojiAndNormalEmoji";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedFileNotFound"] = 50146] = "UploadedFileNotFound";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesDoNotSupportAdditionalContent"] = 50159] = "VoiceMessagesDoNotSupportAdditionalContent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveASingleAudioAttachment"] = 50160] = "VoiceMessagesMustHaveASingleAudioAttachment";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesMustHaveSupportingMetadata"] = 50161] = "VoiceMessagesMustHaveSupportingMetadata";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["VoiceMessagesCannotBeEdited"] = 50162] = "VoiceMessagesCannotBeEdited";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotDeleteGuildSubscriptionIntegration"] = 50163] = "CannotDeleteGuildSubscriptionIntegration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouCannotSendVoiceMessagesInThisChannel"] = 50173] = "YouCannotSendVoiceMessagesInThisChannel";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheUserAccountMustFirstBeVerified"] = 50178] = "TheUserAccountMustFirstBeVerified";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["YouDoNotHavePermissionToSendThisSticker"] = 50600] = "YouDoNotHavePermissionToSendThisSticker";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TwoFactorAuthenticationIsRequired"] = 60003] = "TwoFactorAuthenticationIsRequired";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["NoUsersWithDiscordTagExist"] = 80004] = "NoUsersWithDiscordTagExist";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ReactionWasBlocked"] = 90001] = "ReactionWasBlocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ApplicationNotYetAvailable"] = 110001] = "ApplicationNotYetAvailable";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["APIResourceOverloaded"] = 130000] = "APIResourceOverloaded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TheStageIsAlreadyOpen"] = 150006] = "TheStageIsAlreadyOpen";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotReplyWithoutPermissionToReadMessageHistory"] = 160002] = "CannotReplyWithoutPermissionToReadMessageHistory";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadAlreadyCreatedForMessage"] = 160004] = "ThreadAlreadyCreatedForMessage";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["ThreadLocked"] = 160005] = "ThreadLocked";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveThreads"] = 160006] = "MaximumActiveThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MaximumActiveAnnouncementThreads"] = 160007] = "MaximumActiveAnnouncementThreads";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["InvalidJSONForUploadedLottieFile"] = 170001] = "InvalidJSONForUploadedLottieFile";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["UploadedLottiesCannotContainRasterizedImages"] = 170002] = "UploadedLottiesCannotContainRasterizedImages";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerMaximumFramerateExceeded"] = 170003] = "StickerMaximumFramerateExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFrameCountExceedsMaximumOf1000Frames"] = 170004] = "StickerFrameCountExceedsMaximumOf1000Frames";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["LottieAnimationMaximumDimensionsExceeded"] = 170005] = "LottieAnimationMaximumDimensionsExceeded";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerFramerateIsTooSmallOrTooLarge"] = 170006] = "StickerFramerateIsTooSmallOrTooLarge";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["StickerAnimationDurationExceedsMaximumOf5Seconds"] = 170007] = "StickerAnimationDurationExceedsMaximumOf5Seconds";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateAFinishedEvent"] = 180000] = "CannotUpdateAFinishedEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["FailedToCreateStageNeededForStageEvent"] = 180002] = "FailedToCreateStageNeededForStageEvent";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageWasBlockedByAutomaticModeration"] = 200000] = "MessageWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["TitleWasBlockedByAutomaticModeration"] = 200001] = "TitleWasBlockedByAutomaticModeration";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId"] = 220001] = "WebhooksPostedToForumChannelsMustHaveAThreadNameOrThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId"] = 220002] = "WebhooksPostedToForumChannelsCannotHaveBothAThreadNameAndThreadId";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhooksCanOnlyCreateThreadsInForumChannels"] = 220003] = "WebhooksCanOnlyCreateThreadsInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["WebhookServicesCannotBeUsedInForumChannels"] = 220004] = "WebhookServicesCannotBeUsedInForumChannels";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["MessageBlockedByHarmfulLinksFilter"] = 240000] = "MessageBlockedByHarmfulLinksFilter";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotEnableOnboardingRequirementsAreNotMet"] = 350000] = "CannotEnableOnboardingRequirementsAreNotMet";
    RESTJSONErrorCodes2[RESTJSONErrorCodes2["CannotUpdateOnboardingWhileBelowRequirements"] = 350001] = "CannotUpdateOnboardingWhileBelowRequirements";
  })(RESTJSONErrorCodes = exports.RESTJSONErrorCodes || (exports.RESTJSONErrorCodes = {}));
  var Locale;
  (function(Locale2) {
    Locale2["Indonesian"] = "id";
    Locale2["EnglishUS"] = "en-US";
    Locale2["EnglishGB"] = "en-GB";
    Locale2["Bulgarian"] = "bg";
    Locale2["ChineseCN"] = "zh-CN";
    Locale2["ChineseTW"] = "zh-TW";
    Locale2["Croatian"] = "hr";
    Locale2["Czech"] = "cs";
    Locale2["Danish"] = "da";
    Locale2["Dutch"] = "nl";
    Locale2["Finnish"] = "fi";
    Locale2["French"] = "fr";
    Locale2["German"] = "de";
    Locale2["Greek"] = "el";
    Locale2["Hindi"] = "hi";
    Locale2["Hungarian"] = "hu";
    Locale2["Italian"] = "it";
    Locale2["Japanese"] = "ja";
    Locale2["Korean"] = "ko";
    Locale2["Lithuanian"] = "lt";
    Locale2["Norwegian"] = "no";
    Locale2["Polish"] = "pl";
    Locale2["PortugueseBR"] = "pt-BR";
    Locale2["Romanian"] = "ro";
    Locale2["Russian"] = "ru";
    Locale2["SpanishES"] = "es-ES";
    Locale2["Swedish"] = "sv-SE";
    Locale2["Thai"] = "th";
    Locale2["Turkish"] = "tr";
    Locale2["Ukrainian"] = "uk";
    Locale2["Vietnamese"] = "vi";
  })(Locale = exports.Locale || (exports.Locale = {}));
});

// node_modules/discord-api-types/rest/v10/application.js
var require_application2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/auditLog.js
var require_auditLog2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/autoModeration.js
var require_autoModeration2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/channel.js
var require_channel3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/emoji.js
var require_emoji2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/gateway.js
var require_gateway2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guild.js
var require_guild2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/guildScheduledEvent.js
var require_guildScheduledEvent2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/interactions.js
var require_interactions2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/invite.js
var require_invite2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/oauth2.js
var require_oauth22 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/stageInstance.js
var require_stageInstance2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/sticker.js
var require_sticker2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/template.js
var require_template2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/user.js
var require_user3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/voice.js
var require_voice2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/webhook.js
var require_webhook2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/discord-api-types/rest/v10/index.js
var require_v103 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OAuth2Routes = exports.RouteBases = exports.ImageFormat = exports.CDNRoutes = exports.StickerPackApplicationId = exports.Routes = exports.APIVersion = undefined;
  __exportStar(require_common3(), exports);
  __exportStar(require_application2(), exports);
  __exportStar(require_auditLog2(), exports);
  __exportStar(require_autoModeration2(), exports);
  __exportStar(require_channel3(), exports);
  __exportStar(require_emoji2(), exports);
  __exportStar(require_gateway2(), exports);
  __exportStar(require_guild2(), exports);
  __exportStar(require_guildScheduledEvent2(), exports);
  __exportStar(require_interactions2(), exports);
  __exportStar(require_invite2(), exports);
  __exportStar(require_oauth22(), exports);
  __exportStar(require_stageInstance2(), exports);
  __exportStar(require_sticker2(), exports);
  __exportStar(require_template2(), exports);
  __exportStar(require_user3(), exports);
  __exportStar(require_voice2(), exports);
  __exportStar(require_webhook2(), exports);
  exports.APIVersion = "10";
  exports.Routes = {
    applicationRoleConnectionMetadata(applicationId) {
      return `/applications/${applicationId}/role-connections/metadata`;
    },
    guildAutoModerationRules(guildId) {
      return `/guilds/${guildId}/auto-moderation/rules`;
    },
    guildAutoModerationRule(guildId, ruleId) {
      return `/guilds/${guildId}/auto-moderation/rules/${ruleId}`;
    },
    guildAuditLog(guildId) {
      return `/guilds/${guildId}/audit-logs`;
    },
    channel(channelId) {
      return `/channels/${channelId}`;
    },
    channelMessages(channelId) {
      return `/channels/${channelId}/messages`;
    },
    channelMessage(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}`;
    },
    channelMessageCrosspost(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/crosspost`;
    },
    channelMessageOwnReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/@me`;
    },
    channelMessageUserReaction(channelId, messageId, emoji, userId) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}/${userId}`;
    },
    channelMessageReaction(channelId, messageId, emoji) {
      return `/channels/${channelId}/messages/${messageId}/reactions/${emoji}`;
    },
    channelMessageAllReactions(channelId, messageId) {
      return `/channels/${channelId}/messages/${messageId}/reactions`;
    },
    channelBulkDelete(channelId) {
      return `/channels/${channelId}/messages/bulk-delete`;
    },
    channelPermission(channelId, overwriteId) {
      return `/channels/${channelId}/permissions/${overwriteId}`;
    },
    channelInvites(channelId) {
      return `/channels/${channelId}/invites`;
    },
    channelFollowers(channelId) {
      return `/channels/${channelId}/followers`;
    },
    channelTyping(channelId) {
      return `/channels/${channelId}/typing`;
    },
    channelPins(channelId) {
      return `/channels/${channelId}/pins`;
    },
    channelPin(channelId, messageId) {
      return `/channels/${channelId}/pins/${messageId}`;
    },
    channelRecipient(channelId, userId) {
      return `/channels/${channelId}/recipients/${userId}`;
    },
    guildEmojis(guildId) {
      return `/guilds/${guildId}/emojis`;
    },
    guildEmoji(guildId, emojiId) {
      return `/guilds/${guildId}/emojis/${emojiId}`;
    },
    guilds() {
      return "/guilds";
    },
    guild(guildId) {
      return `/guilds/${guildId}`;
    },
    guildPreview(guildId) {
      return `/guilds/${guildId}/preview`;
    },
    guildChannels(guildId) {
      return `/guilds/${guildId}/channels`;
    },
    guildMember(guildId, userId = "@me") {
      return `/guilds/${guildId}/members/${userId}`;
    },
    guildMembers(guildId) {
      return `/guilds/${guildId}/members`;
    },
    guildMembersSearch(guildId) {
      return `/guilds/${guildId}/members/search`;
    },
    guildCurrentMemberNickname(guildId) {
      return `/guilds/${guildId}/members/@me/nick`;
    },
    guildMemberRole(guildId, memberId, roleId) {
      return `/guilds/${guildId}/members/${memberId}/roles/${roleId}`;
    },
    guildMFA(guildId) {
      return `/guilds/${guildId}/mfa`;
    },
    guildBans(guildId) {
      return `/guilds/${guildId}/bans`;
    },
    guildBan(guildId, userId) {
      return `/guilds/${guildId}/bans/${userId}`;
    },
    guildRoles(guildId) {
      return `/guilds/${guildId}/roles`;
    },
    guildRole(guildId, roleId) {
      return `/guilds/${guildId}/roles/${roleId}`;
    },
    guildPrune(guildId) {
      return `/guilds/${guildId}/prune`;
    },
    guildVoiceRegions(guildId) {
      return `/guilds/${guildId}/regions`;
    },
    guildInvites(guildId) {
      return `/guilds/${guildId}/invites`;
    },
    guildIntegrations(guildId) {
      return `/guilds/${guildId}/integrations`;
    },
    guildIntegration(guildId, integrationId) {
      return `/guilds/${guildId}/integrations/${integrationId}`;
    },
    guildWidgetSettings(guildId) {
      return `/guilds/${guildId}/widget`;
    },
    guildWidgetJSON(guildId) {
      return `/guilds/${guildId}/widget.json`;
    },
    guildVanityUrl(guildId) {
      return `/guilds/${guildId}/vanity-url`;
    },
    guildWidgetImage(guildId) {
      return `/guilds/${guildId}/widget.png`;
    },
    invite(code) {
      return `/invites/${code}`;
    },
    template(code) {
      return `/guilds/templates/${code}`;
    },
    guildTemplates(guildId) {
      return `/guilds/${guildId}/templates`;
    },
    guildTemplate(guildId, code) {
      return `/guilds/${guildId}/templates/${code}`;
    },
    threads(parentId, messageId) {
      const parts = ["", "channels", parentId];
      if (messageId)
        parts.push("messages", messageId);
      parts.push("threads");
      return parts.join("/");
    },
    guildActiveThreads(guildId) {
      return `/guilds/${guildId}/threads/active`;
    },
    channelThreads(channelId, archivedStatus) {
      return `/channels/${channelId}/threads/archived/${archivedStatus}`;
    },
    channelJoinedArchivedThreads(channelId) {
      return `/channels/${channelId}/users/@me/threads/archived/private`;
    },
    threadMembers(threadId, userId) {
      const parts = ["", "channels", threadId, "thread-members"];
      if (userId)
        parts.push(userId);
      return parts.join("/");
    },
    user(userId = "@me") {
      return `/users/${userId}`;
    },
    userApplicationRoleConnection(applicationId) {
      return `/users/@me/applications/${applicationId}/role-connection`;
    },
    userGuilds() {
      return `/users/@me/guilds`;
    },
    userGuildMember(guildId) {
      return `/users/@me/guilds/${guildId}/member`;
    },
    userGuild(guildId) {
      return `/users/@me/guilds/${guildId}`;
    },
    userChannels() {
      return `/users/@me/channels`;
    },
    userConnections() {
      return `/users/@me/connections`;
    },
    voiceRegions() {
      return `/voice/regions`;
    },
    channelWebhooks(channelId) {
      return `/channels/${channelId}/webhooks`;
    },
    guildWebhooks(guildId) {
      return `/guilds/${guildId}/webhooks`;
    },
    webhook(webhookId, webhookToken) {
      const parts = ["", "webhooks", webhookId];
      if (webhookToken)
        parts.push(webhookToken);
      return parts.join("/");
    },
    webhookMessage(webhookId, webhookToken, messageId = "@original") {
      return `/webhooks/${webhookId}/${webhookToken}/messages/${messageId}`;
    },
    webhookPlatform(webhookId, webhookToken, platform) {
      return `/webhooks/${webhookId}/${webhookToken}/${platform}`;
    },
    gateway() {
      return `/gateway`;
    },
    gatewayBot() {
      return `/gateway/bot`;
    },
    oauth2CurrentApplication() {
      return `/oauth2/applications/@me`;
    },
    oauth2CurrentAuthorization() {
      return `/oauth2/@me`;
    },
    oauth2Authorization() {
      return `/oauth2/authorize`;
    },
    oauth2TokenExchange() {
      return `/oauth2/token`;
    },
    oauth2TokenRevocation() {
      return `/oauth2/token/revoke`;
    },
    applicationCommands(applicationId) {
      return `/applications/${applicationId}/commands`;
    },
    applicationCommand(applicationId, commandId) {
      return `/applications/${applicationId}/commands/${commandId}`;
    },
    applicationGuildCommands(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands`;
    },
    applicationGuildCommand(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}`;
    },
    interactionCallback(interactionId, interactionToken) {
      return `/interactions/${interactionId}/${interactionToken}/callback`;
    },
    guildMemberVerification(guildId) {
      return `/guilds/${guildId}/member-verification`;
    },
    guildVoiceState(guildId, userId = "@me") {
      return `/guilds/${guildId}/voice-states/${userId}`;
    },
    guildApplicationCommandsPermissions(applicationId, guildId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/permissions`;
    },
    applicationCommandPermissions(applicationId, guildId, commandId) {
      return `/applications/${applicationId}/guilds/${guildId}/commands/${commandId}/permissions`;
    },
    guildWelcomeScreen(guildId) {
      return `/guilds/${guildId}/welcome-screen`;
    },
    stageInstances() {
      return `/stage-instances`;
    },
    stageInstance(channelId) {
      return `/stage-instances/${channelId}`;
    },
    sticker(stickerId) {
      return `/stickers/${stickerId}`;
    },
    nitroStickerPacks() {
      return "/sticker-packs";
    },
    guildStickers(guildId) {
      return `/guilds/${guildId}/stickers`;
    },
    guildSticker(guildId, stickerId) {
      return `/guilds/${guildId}/stickers/${stickerId}`;
    },
    guildScheduledEvents(guildId) {
      return `/guilds/${guildId}/scheduled-events`;
    },
    guildScheduledEvent(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}`;
    },
    guildScheduledEventUsers(guildId, guildScheduledEventId) {
      return `/guilds/${guildId}/scheduled-events/${guildScheduledEventId}/users`;
    },
    guildOnboarding(guildId) {
      return `/guilds/${guildId}/onboarding`;
    },
    currentApplication() {
      return "/applications/@me";
    }
  };
  exports.StickerPackApplicationId = "710982414301790216";
  exports.CDNRoutes = {
    emoji(emojiId, format) {
      return `/emojis/${emojiId}.${format}`;
    },
    guildIcon(guildId, guildIcon, format) {
      return `icons/${guildId}/${guildIcon}.${format}`;
    },
    guildSplash(guildId, guildSplash, format) {
      return `/splashes/${guildId}/${guildSplash}.${format}`;
    },
    guildDiscoverySplash(guildId, guildDiscoverySplash, format) {
      return `/discovery-splashes/${guildId}/${guildDiscoverySplash}.${format}`;
    },
    guildBanner(guildId, guildBanner, format) {
      return `/banners/${guildId}/${guildBanner}.${format}`;
    },
    userBanner(userId, userBanner, format) {
      return `/banners/${userId}/${userBanner}.${format}`;
    },
    defaultUserAvatar(index) {
      return `/embed/avatars/${index}.png`;
    },
    userAvatar(userId, userAvatar, format) {
      return `/avatars/${userId}/${userAvatar}.${format}`;
    },
    guildMemberAvatar(guildId, userId, memberAvatar, format) {
      return `/guilds/${guildId}/users/${userId}/avatars/${memberAvatar}.${format}`;
    },
    userAvatarDecoration(userId, userAvatarDecoration) {
      return `/avatar-decorations/${userId}/${userAvatarDecoration}.png`;
    },
    applicationIcon(applicationId, applicationIcon, format) {
      return `/app-icons/${applicationId}/${applicationIcon}.${format}`;
    },
    applicationCover(applicationId, applicationCoverImage, format) {
      return `/app-icons/${applicationId}/${applicationCoverImage}.${format}`;
    },
    applicationAsset(applicationId, applicationAssetId, format) {
      return `/app-assets/${applicationId}/${applicationAssetId}.${format}`;
    },
    achievementIcon(applicationId, achievementId, achievementIconHash, format) {
      return `/app-assets/${applicationId}/achievements/${achievementId}/icons/${achievementIconHash}.${format}`;
    },
    stickerPackBanner(stickerPackBannerAssetId, format) {
      return `/app-assets/${exports.StickerPackApplicationId}/store/${stickerPackBannerAssetId}.${format}`;
    },
    storePageAsset(applicationId, assetId) {
      return `/app-assets/${applicationId}/store/${assetId}.png`;
    },
    teamIcon(teamId, teamIcon, format) {
      return `/team-icons/${teamId}/${teamIcon}.${format}`;
    },
    sticker(stickerId, format) {
      return `/stickers/${stickerId}.${format}`;
    },
    roleIcon(roleId, roleIcon, format) {
      return `/role-icons/${roleId}/${roleIcon}.${format}`;
    },
    guildScheduledEventCover(guildScheduledEventId, guildScheduledEventCoverImage, format) {
      return `/guild-events/${guildScheduledEventId}/${guildScheduledEventCoverImage}.${format}`;
    },
    guildMemberBanner(guildId, userId, guildMemberBanner, format) {
      return `/guilds/${guildId}/users/${userId}/banners/${guildMemberBanner}.${format}`;
    }
  };
  var ImageFormat;
  (function(ImageFormat2) {
    ImageFormat2["JPEG"] = "jpeg";
    ImageFormat2["PNG"] = "png";
    ImageFormat2["WebP"] = "webp";
    ImageFormat2["GIF"] = "gif";
    ImageFormat2["Lottie"] = "json";
  })(ImageFormat = exports.ImageFormat || (exports.ImageFormat = {}));
  exports.RouteBases = {
    api: `https://discord.com/api/v${exports.APIVersion}`,
    cdn: "https://cdn.discordapp.com",
    invite: "https://discord.gg",
    template: "https://discord.new",
    gift: "https://discord.gift",
    scheduledEvent: "https://discord.com/events"
  };
  Object.freeze(exports.RouteBases);
  exports.OAuth2Routes = {
    authorizationURL: `${exports.RouteBases.api}${exports.Routes.oauth2Authorization()}`,
    tokenURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenExchange()}`,
    tokenRevocationURL: `${exports.RouteBases.api}${exports.Routes.oauth2TokenRevocation()}`
  };
  Object.freeze(exports.OAuth2Routes);
});

// node_modules/discord-api-types/rpc/common.js
var require_common4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RPCCloseEventCodes = exports.RPCErrorCodes = undefined;
  var RPCErrorCodes;
  (function(RPCErrorCodes2) {
    RPCErrorCodes2[RPCErrorCodes2["UnknownError"] = 1000] = "UnknownError";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPayload"] = 4000] = "InvalidPayload";
    RPCErrorCodes2[RPCErrorCodes2["InvalidCommand"] = 4002] = "InvalidCommand";
    RPCErrorCodes2[RPCErrorCodes2["InvalidGuild"] = 4003] = "InvalidGuild";
    RPCErrorCodes2[RPCErrorCodes2["InvalidEvent"] = 4004] = "InvalidEvent";
    RPCErrorCodes2[RPCErrorCodes2["InvalidChannel"] = 4005] = "InvalidChannel";
    RPCErrorCodes2[RPCErrorCodes2["InvalidPermissions"] = 4006] = "InvalidPermissions";
    RPCErrorCodes2[RPCErrorCodes2["InvalidClientId"] = 4007] = "InvalidClientId";
    RPCErrorCodes2[RPCErrorCodes2["InvalidOrigin"] = 4008] = "InvalidOrigin";
    RPCErrorCodes2[RPCErrorCodes2["InvalidToken"] = 4009] = "InvalidToken";
    RPCErrorCodes2[RPCErrorCodes2["InvalidUser"] = 4010] = "InvalidUser";
    RPCErrorCodes2[RPCErrorCodes2["OAuth2Error"] = 5000] = "OAuth2Error";
    RPCErrorCodes2[RPCErrorCodes2["SelectChannelTimedOut"] = 5001] = "SelectChannelTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["GetGuildTimedOut"] = 5002] = "GetGuildTimedOut";
    RPCErrorCodes2[RPCErrorCodes2["SelectVoiceForceRequired"] = 5003] = "SelectVoiceForceRequired";
    RPCErrorCodes2[RPCErrorCodes2["CaptureShortcutAlreadyListening"] = 5004] = "CaptureShortcutAlreadyListening";
  })(RPCErrorCodes = exports.RPCErrorCodes || (exports.RPCErrorCodes = {}));
  var RPCCloseEventCodes;
  (function(RPCCloseEventCodes2) {
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidClientId"] = 4000] = "InvalidClientId";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidOrigin"] = 4001] = "InvalidOrigin";
    RPCCloseEventCodes2[RPCCloseEventCodes2["RateLimited"] = 4002] = "RateLimited";
    RPCCloseEventCodes2[RPCCloseEventCodes2["TokenRevoked"] = 4003] = "TokenRevoked";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidVersion"] = 4004] = "InvalidVersion";
    RPCCloseEventCodes2[RPCCloseEventCodes2["InvalidEncoding"] = 4005] = "InvalidEncoding";
  })(RPCCloseEventCodes = exports.RPCCloseEventCodes || (exports.RPCCloseEventCodes = {}));
});

// node_modules/discord-api-types/rpc/v10.js
var require_v104 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_common4(), exports);
});

// node_modules/discord-api-types/utils/v10.js
var require_v105 = __commonJS((exports) => {
  var isDMInteraction = function(interaction) {
    return Reflect.has(interaction, "user");
  };
  var isGuildInteraction = function(interaction) {
    return Reflect.has(interaction, "guild_id");
  };
  var isApplicationCommandDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isApplicationCommandGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isMessageComponentDMInteraction = function(interaction) {
    return isDMInteraction(interaction);
  };
  var isMessageComponentGuildInteraction = function(interaction) {
    return isGuildInteraction(interaction);
  };
  var isLinkButton = function(component) {
    return component.style === index_1.ButtonStyle.Link;
  };
  var isInteractionButton = function(component) {
    return component.style !== index_1.ButtonStyle.Link;
  };
  var isMessageComponentInteraction = function(interaction) {
    return interaction.type === index_1.InteractionType.MessageComponent;
  };
  var isMessageComponentButtonInteraction = function(interaction) {
    return interaction.data.component_type === index_1.ComponentType.Button;
  };
  var isMessageComponentSelectMenuInteraction = function(interaction) {
    return [
      index_1.ComponentType.StringSelect,
      index_1.ComponentType.UserSelect,
      index_1.ComponentType.RoleSelect,
      index_1.ComponentType.MentionableSelect,
      index_1.ComponentType.ChannelSelect
    ].includes(interaction.data.component_type);
  };
  var isChatInputApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.ChatInput;
  };
  var isContextMenuApplicationCommandInteraction = function(interaction) {
    return interaction.data.type === index_1.ApplicationCommandType.Message || interaction.data.type === index_1.ApplicationCommandType.User;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isContextMenuApplicationCommandInteraction = exports.isChatInputApplicationCommandInteraction = exports.isMessageComponentSelectMenuInteraction = exports.isMessageComponentButtonInteraction = exports.isMessageComponentInteraction = exports.isInteractionButton = exports.isLinkButton = exports.isMessageComponentGuildInteraction = exports.isMessageComponentDMInteraction = exports.isApplicationCommandGuildInteraction = exports.isApplicationCommandDMInteraction = exports.isGuildInteraction = exports.isDMInteraction = undefined;
  var index_1 = require_v102();
  exports.isDMInteraction = isDMInteraction;
  exports.isGuildInteraction = isGuildInteraction;
  exports.isApplicationCommandDMInteraction = isApplicationCommandDMInteraction;
  exports.isApplicationCommandGuildInteraction = isApplicationCommandGuildInteraction;
  exports.isMessageComponentDMInteraction = isMessageComponentDMInteraction;
  exports.isMessageComponentGuildInteraction = isMessageComponentGuildInteraction;
  exports.isLinkButton = isLinkButton;
  exports.isInteractionButton = isInteractionButton;
  exports.isMessageComponentInteraction = isMessageComponentInteraction;
  exports.isMessageComponentButtonInteraction = isMessageComponentButtonInteraction;
  exports.isMessageComponentSelectMenuInteraction = isMessageComponentSelectMenuInteraction;
  exports.isChatInputApplicationCommandInteraction = isChatInputApplicationCommandInteraction;
  exports.isContextMenuApplicationCommandInteraction = isContextMenuApplicationCommandInteraction;
});

// node_modules/discord-api-types/v10.js
var require_v106 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Utils = undefined;
  __exportStar(require_v10(), exports);
  __exportStar(require_globals(), exports);
  __exportStar(require_v102(), exports);
  __exportStar(require_v103(), exports);
  __exportStar(require_v104(), exports);
  exports.Utils = require_v105();
});

// node_modules/@discordjs/collection/dist/index.js
var require_dist2 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Collection: () => Collection,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Collection = class _Collection extends Map {
    static {
      __name(this, "Collection");
    }
    ensure(key, defaultValueGenerator) {
      if (this.has(key))
        return this.get(key);
      if (typeof defaultValueGenerator !== "function")
        throw new TypeError(`${defaultValueGenerator} is not a function`);
      const defaultValue = defaultValueGenerator(key, this);
      this.set(key, defaultValue);
      return defaultValue;
    }
    hasAll(...keys) {
      return keys.every((key) => super.has(key));
    }
    hasAny(...keys) {
      return keys.some((key) => super.has(key));
    }
    first(amount) {
      if (amount === undefined)
        return this.values().next().value;
      if (amount < 0)
        return this.last(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.values();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    firstKey(amount) {
      if (amount === undefined)
        return this.keys().next().value;
      if (amount < 0)
        return this.lastKey(amount * -1);
      amount = Math.min(this.size, amount);
      const iter = this.keys();
      return Array.from({ length: amount }, () => iter.next().value);
    }
    last(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.first(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    lastKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[arr.length - 1];
      if (amount < 0)
        return this.firstKey(amount * -1);
      if (!amount)
        return [];
      return arr.slice(-amount);
    }
    at(index) {
      index = Math.floor(index);
      const arr = [...this.values()];
      return arr.at(index);
    }
    keyAt(index) {
      index = Math.floor(index);
      const arr = [...this.keys()];
      return arr.at(index);
    }
    random(amount) {
      const arr = [...this.values()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    randomKey(amount) {
      const arr = [...this.keys()];
      if (amount === undefined)
        return arr[Math.floor(Math.random() * arr.length)];
      if (!arr.length || !amount)
        return [];
      return Array.from({ length: Math.min(amount, arr.length) }, () => arr.splice(Math.floor(Math.random() * arr.length), 1)[0]);
    }
    reverse() {
      const entries = [...this.entries()].reverse();
      this.clear();
      for (const [key, value] of entries)
        this.set(key, value);
      return this;
    }
    find(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return val;
      }
      return;
    }
    findKey(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return key;
      }
      return;
    }
    sweep(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const previousSize = this.size;
      for (const [key, val] of this) {
        if (fn(val, key, this))
          this.delete(key);
      }
      return previousSize - this.size;
    }
    filter(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = new this.constructor[Symbol.species];
      for (const [key, val] of this) {
        if (fn(val, key, this))
          results.set(key, val);
      }
      return results;
    }
    partition(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const results = [
        new this.constructor[Symbol.species],
        new this.constructor[Symbol.species]
      ];
      for (const [key, val] of this) {
        if (fn(val, key, this)) {
          results[0].set(key, val);
        } else {
          results[1].set(key, val);
        }
      }
      return results;
    }
    flatMap(fn, thisArg) {
      const collections = this.map(fn, thisArg);
      return new this.constructor[Symbol.species]().concat(...collections);
    }
    map(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const iter = this.entries();
      return Array.from({ length: this.size }, () => {
        const [key, value] = iter.next().value;
        return fn(value, key, this);
      });
    }
    mapValues(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      const coll = new this.constructor[Symbol.species];
      for (const [key, val] of this)
        coll.set(key, fn(val, key, this));
      return coll;
    }
    some(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (fn(val, key, this))
          return true;
      }
      return false;
    }
    every(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, val] of this) {
        if (!fn(val, key, this))
          return false;
      }
      return true;
    }
    reduce(fn, initialValue) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      let accumulator;
      const iterator = this.entries();
      if (initialValue === undefined) {
        if (this.size === 0)
          throw new TypeError("Reduce of empty collection with no initial value");
        accumulator = iterator.next().value[1];
      } else {
        accumulator = initialValue;
      }
      for (const [key, value] of iterator) {
        accumulator = fn(accumulator, value, key, this);
      }
      return accumulator;
    }
    each(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      for (const [key, value] of this) {
        fn(value, key, this);
      }
      return this;
    }
    tap(fn, thisArg) {
      if (typeof fn !== "function")
        throw new TypeError(`${fn} is not a function`);
      if (thisArg !== undefined)
        fn = fn.bind(thisArg);
      fn(this);
      return this;
    }
    clone() {
      return new this.constructor[Symbol.species](this);
    }
    concat(...collections) {
      const newColl = this.clone();
      for (const coll of collections) {
        for (const [key, val] of coll)
          newColl.set(key, val);
      }
      return newColl;
    }
    equals(collection) {
      if (!collection)
        return false;
      if (this === collection)
        return true;
      if (this.size !== collection.size)
        return false;
      for (const [key, value] of this) {
        if (!collection.has(key) || value !== collection.get(key)) {
          return false;
        }
      }
      return true;
    }
    sort(compareFunction = _Collection.defaultSort) {
      const entries = [...this.entries()];
      entries.sort((a, b) => compareFunction(a[1], b[1], a[0], b[0]));
      super.clear();
      for (const [key, value] of entries) {
        super.set(key, value);
      }
      return this;
    }
    intersect(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (this.has(key) && Object.is(value, this.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    subtract(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of this) {
        if (!other.has(key) || !Object.is(value, other.get(key))) {
          coll.set(key, value);
        }
      }
      return coll;
    }
    difference(other) {
      const coll = new this.constructor[Symbol.species];
      for (const [key, value] of other) {
        if (!this.has(key))
          coll.set(key, value);
      }
      for (const [key, value] of this) {
        if (!other.has(key))
          coll.set(key, value);
      }
      return coll;
    }
    merge(other, whenInSelf, whenInOther, whenInBoth) {
      const coll = new this.constructor[Symbol.species];
      const keys = new Set([...this.keys(), ...other.keys()]);
      for (const key of keys) {
        const hasInSelf = this.has(key);
        const hasInOther = other.has(key);
        if (hasInSelf && hasInOther) {
          const result = whenInBoth(this.get(key), other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInSelf) {
          const result = whenInSelf(this.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        } else if (hasInOther) {
          const result = whenInOther(other.get(key), key);
          if (result.keep)
            coll.set(key, result.value);
        }
      }
      return coll;
    }
    sorted(compareFunction = _Collection.defaultSort) {
      return new this.constructor[Symbol.species](this).sort((av, bv, ak, bk) => compareFunction(av, bv, ak, bk));
    }
    toJSON() {
      return [...this.values()];
    }
    static defaultSort(firstValue, secondValue) {
      return Number(firstValue > secondValue) || Number(firstValue === secondValue) - 1;
    }
    static combineEntries(entries, combine) {
      const coll = new _Collection;
      for (const [key, value] of entries) {
        if (coll.has(key)) {
          coll.set(key, combine(coll.get(key), value, key));
        } else {
          coll.set(key, value);
        }
      }
      return coll;
    }
  };
  var version = "1.5.3";
});

// node_modules/@sapphire/snowflake/dist/index.js
var require_dist3 = __commonJS((exports) => {
  var cmpBigInt = function(a, b) {
    return a === b ? 0 : a < b ? -1 : 1;
  };
  var cmpString = function(a, b) {
    return a === b ? 0 : a.length < b.length ? -1 : a.length > b.length ? 1 : a < b ? -1 : 1;
  };
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var IncrementSymbol = Symbol("@sapphire/snowflake.increment");
  var EpochSymbol = Symbol("@sapphire/snowflake.epoch");
  var ProcessIdSymbol = Symbol("@sapphire/snowflake.processId");
  var WorkerIdSymbol = Symbol("@sapphire/snowflake.workerId");
  var MaximumWorkerId = 0b11111n;
  var MaximumProcessId = 0b11111n;
  var MaximumIncrement = 0b111111111111n;
  var _a;
  var _b;
  var _c;
  var _d;
  var Snowflake = class {
    constructor(epoch) {
      __publicField(this, "decode", this.deconstruct);
      __publicField(this, _a);
      __publicField(this, _b, 0n);
      __publicField(this, _c, 1n);
      __publicField(this, _d, 0n);
      this[EpochSymbol] = BigInt(epoch instanceof Date ? epoch.getTime() : epoch);
    }
    get epoch() {
      return this[EpochSymbol];
    }
    get processId() {
      return this[ProcessIdSymbol];
    }
    set processId(value) {
      this[ProcessIdSymbol] = BigInt(value) & MaximumProcessId;
    }
    get workerId() {
      return this[WorkerIdSymbol];
    }
    set workerId(value) {
      this[WorkerIdSymbol] = BigInt(value) & MaximumWorkerId;
    }
    generate({
      increment,
      timestamp = Date.now(),
      workerId = this[WorkerIdSymbol],
      processId = this[ProcessIdSymbol]
    } = {}) {
      if (timestamp instanceof Date)
        timestamp = BigInt(timestamp.getTime());
      else if (typeof timestamp === "number")
        timestamp = BigInt(timestamp);
      else if (typeof timestamp !== "bigint") {
        throw new TypeError(`"timestamp" argument must be a number, bigint, or Date (received ${typeof timestamp})`);
      }
      if (typeof increment !== "bigint") {
        increment = this[IncrementSymbol];
        this[IncrementSymbol] = increment + 1n & MaximumIncrement;
      }
      return timestamp - this[EpochSymbol] << 22n | (workerId & MaximumWorkerId) << 17n | (processId & MaximumProcessId) << 12n | increment & MaximumIncrement;
    }
    deconstruct(id) {
      const bigIntId = BigInt(id);
      const epoch = this[EpochSymbol];
      return {
        id: bigIntId,
        timestamp: (bigIntId >> 22n) + epoch,
        workerId: bigIntId >> 17n & MaximumWorkerId,
        processId: bigIntId >> 12n & MaximumProcessId,
        increment: bigIntId & MaximumIncrement,
        epoch
      };
    }
    timestampFrom(id) {
      return Number((BigInt(id) >> 22n) + this[EpochSymbol]);
    }
    static compare(a, b) {
      const typeA = typeof a;
      return typeA === typeof b ? typeA === "string" ? cmpString(a, b) : cmpBigInt(a, b) : cmpBigInt(BigInt(a), BigInt(b));
    }
  };
  __name(Snowflake, "Snowflake");
  _a = EpochSymbol, _b = IncrementSymbol, _c = ProcessIdSymbol, _d = WorkerIdSymbol;
  __name(cmpBigInt, "cmpBigInt");
  __name(cmpString, "cmpString");
  var DiscordSnowflake = new Snowflake(1420070400000n);
  var TwitterSnowflake = new Snowflake(1288834974657n);
  exports.DiscordSnowflake = DiscordSnowflake;
  exports.MaximumIncrement = MaximumIncrement;
  exports.MaximumProcessId = MaximumProcessId;
  exports.MaximumWorkerId = MaximumWorkerId;
  exports.Snowflake = Snowflake;
  exports.TwitterSnowflake = TwitterSnowflake;
});

// node_modules/@vladfrangu/async_event_emitter/dist/index.js
var require_dist4 = __commonJS((exports, module) => {
  var validateListener = function(input) {
    if (typeof input !== "function") {
      throw new TypeError(`The listener argument must be a function. Received ${typeof input}`);
    }
  };
  var validateAbortSignal = function(input) {
    if (input && !(input instanceof AbortSignal)) {
      throw new TypeError(`The signal option must be an AbortSignal. Received ${input}`);
    }
  };
  var spliceOne = function(list, index) {
    for (;index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }
    list.pop();
  };
  var arrayClone = function(arr) {
    switch (arr.length) {
      case 2:
        return [arr[0], arr[1]];
      case 3:
        return [arr[0], arr[1], arr[2]];
      case 4:
        return [arr[0], arr[1], arr[2], arr[3]];
      case 5:
        return [arr[0], arr[1], arr[2], arr[3], arr[4]];
      case 6:
        return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];
    }
    return arr.slice();
  };
  var identicalSequenceRange = function(a, b) {
    for (let i = 0;i < a.length - 3; i++) {
      const pos = b.indexOf(a[i]);
      if (pos !== -1) {
        const rest = b.length - pos;
        if (rest > 3) {
          let len = 1;
          const maxLen = Math.min(a.length - i, rest);
          while (maxLen > len && a[i + len] === b[pos + len]) {
            len++;
          }
          if (len > 3) {
            return [len, i];
          }
        }
      }
    }
    return [0, 0];
  };
  var enhanceStackTrace = function(err, own) {
    let ctorInfo = "";
    try {
      const { name } = this.constructor;
      if (name !== "AsyncEventEmitter")
        ctorInfo = ` on ${name} instance`;
    } catch {
    }
    const sep = `
Emitted 'error' event${ctorInfo} at:
`;
    const errStack = err.stack.split("\n").slice(1);
    const ownStack = own.stack.split("\n").slice(1);
    const { 0: len, 1: off } = identicalSequenceRange(ownStack, errStack);
    if (len > 0) {
      ownStack.splice(off + 1, len - 2, "    [... lines matching original stack trace ...]");
    }
    return err.stack + sep + ownStack.join("\n");
  };
  var onceWrapper = function() {
    if (!this.fired) {
      this.eventEmitter.removeListener(this.eventName, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) {
        return this.listener.call(this.eventEmitter);
      }
      return this.listener.apply(this.eventEmitter, arguments);
    }
  };
  var getReason = function(signal) {
    return signal?.reason;
  };
  var eventTargetAgnosticRemoveListener = function(emitter, name, listener, flags) {
    if (typeof emitter.off === "function") {
      emitter.off(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
      emitter.removeEventListener(name, listener, flags);
    }
  };
  var eventTargetAgnosticAddListener = function(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags?.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, listener, flags);
    }
  };
  var createIterResult = function(value, done) {
    return { value, done };
  };
  var handleMaybeAsync = function(emitter, result) {
    try {
      const fin = result.finally;
      if (typeof fin === "function") {
        const promiseId = String(++emitter["_wrapperId"]);
        emitter["_internalPromiseMap"].set(promiseId, result);
        fin.call(result, __name(function final() {
          emitter["_internalPromiseMap"].delete(promiseId);
        }, "final"));
      }
    } catch (err) {
      emitter.emit("error", err);
    }
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    AbortError: () => AbortError,
    AsyncEventEmitter: () => AsyncEventEmitter
  });
  module.exports = __toCommonJS(src_exports);
  __name(validateListener, "validateListener");
  __name(validateAbortSignal, "validateAbortSignal");
  __name(spliceOne, "spliceOne");
  __name(arrayClone, "arrayClone");
  __name(identicalSequenceRange, "identicalSequenceRange");
  __name(enhanceStackTrace, "enhanceStackTrace");
  var AsyncEventEmitter = class {
    constructor() {
      this._events = {
        __proto__: null
      };
      this._eventCount = 0;
      this._maxListeners = 10;
      this._internalPromiseMap = new Map;
      this._wrapperId = 0n;
    }
    addListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    on(eventName, listener) {
      return this.addListener(eventName, listener);
    }
    once(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, false);
      return this;
    }
    removeListener(eventName, listener) {
      validateListener(listener);
      const events = this._events;
      const eventList = events[eventName];
      if (eventList === undefined) {
        return this;
      }
      if (eventList === listener || eventList.listener === listener) {
        if (--this._eventCount === 0) {
          this._events = { __proto__: null };
        } else {
          delete events[eventName];
          if (events.removeListener) {
            this.emit("removeListener", eventName, eventList.listener ?? eventList);
          }
        }
      } else if (typeof eventList !== "function") {
        let position = -1;
        for (let i = eventList.length - 1;i >= 0; i--) {
          if (eventList[i] === listener || eventList[i].listener === listener) {
            position = i;
            break;
          }
        }
        if (position < 0) {
          return this;
        }
        if (position === 0) {
          eventList.shift();
        } else {
          spliceOne(eventList, position);
        }
        if (eventList.length === 0) {
          delete events[eventName];
          --this._eventCount;
        }
        if (events.removeListener !== undefined) {
          this.emit("removeListener", eventName, listener);
        }
      }
      return this;
    }
    off(eventName, listener) {
      return this.removeListener(eventName, listener);
    }
    removeAllListeners(event) {
      const events = this._events;
      if (events.removeListener === undefined) {
        if (!event) {
          this._events = { __proto__: null };
          this._eventCount = 0;
        } else if (events[event] !== undefined) {
          if (--this._eventCount === 0) {
            this._events = { __proto__: null };
          } else {
            delete events[event];
          }
        }
        return this;
      }
      if (!event) {
        for (const key of Reflect.ownKeys(events)) {
          if (key === "removeListener") {
            continue;
          }
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = { __proto__: null };
        this._eventCount = 0;
        return this;
      }
      const listeners = events[event];
      if (typeof listeners === "function") {
        this.removeListener(event, listeners);
      } else if (listeners !== undefined) {
        for (let i = listeners.length - 1;i >= 0; i--) {
          this.removeListener(event, listeners[i]);
        }
      }
      return this;
    }
    setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new RangeError(`Expected to get a non-negative number for "setMaxListeners", got ${n} instead`);
      }
      this._maxListeners = n;
      return this;
    }
    getMaxListeners() {
      return this._maxListeners;
    }
    listeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList.listener ?? eventList];
      }
      const ret = arrayClone(eventList);
      for (let i = 0;i < ret.length; ++i) {
        const orig = ret[i].listener;
        if (typeof orig === "function") {
          ret[i] = orig;
        }
      }
      return ret;
    }
    rawListeners(eventName) {
      const eventList = this._events[eventName];
      if (eventList === undefined) {
        return [];
      }
      if (typeof eventList === "function") {
        return [eventList];
      }
      return arrayClone(eventList);
    }
    emit(eventName, ...args) {
      let doError = eventName === "error";
      const events = this._events;
      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      }
      if (doError) {
        let er;
        if (args.length > 0) {
          er = args[0];
        }
        if (er instanceof Error) {
          try {
            const capture = {};
            Error.captureStackTrace(capture, AsyncEventEmitter.prototype.emit);
            Object.defineProperty(er, "stack", {
              value: enhanceStackTrace.call(this, er, capture),
              configurable: true
            });
          } catch {
          }
          throw er;
        }
        const stringifiedError = String(er);
        const err = new Error(`Unhandled 'error' event emitted, received ${stringifiedError}`);
        err.context = er;
        throw err;
      }
      const handlers = events[eventName];
      if (handlers === undefined) {
        return false;
      }
      if (typeof handlers === "function") {
        const result = handlers.apply(this, args);
        if (result !== undefined && result !== null) {
          handleMaybeAsync(this, result);
        }
      } else {
        const len = handlers.length;
        const listeners = arrayClone(handlers);
        for (let i = 0;i < len; ++i) {
          const result = listeners[i].apply(this, args);
          if (result !== undefined && result !== null) {
            handleMaybeAsync(this, result);
          }
        }
      }
      return true;
    }
    listenerCount(eventName) {
      const events = this._events;
      if (events === undefined) {
        return 0;
      }
      const eventListeners = events[eventName];
      if (typeof eventListeners === "function") {
        return 1;
      }
      return eventListeners?.length ?? 0;
    }
    prependListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, false);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    prependOnceListener(eventName, listener) {
      validateListener(listener);
      const wrapped = this._wrapListener(eventName, listener, true);
      this._addListener(eventName, wrapped, true);
      return this;
    }
    eventNames() {
      return this._eventCount > 0 ? Reflect.ownKeys(this._events) : [];
    }
    async waitForAllListenersToComplete() {
      const promises = [...this._internalPromiseMap.values()];
      if (promises.length === 0) {
        return false;
      }
      await Promise.all(promises);
      return true;
    }
    _addListener(eventName, wrappedListener, prepend) {
      if (this._events.newListener !== undefined) {
        this.emit("newListener", eventName, wrappedListener.listener ?? wrappedListener);
      }
      let existing = this._events[eventName];
      if (existing === undefined) {
        existing = this._events[eventName] = wrappedListener;
        ++this._eventCount;
      } else if (typeof existing === "function") {
        existing = this._events[eventName] = prepend ? [wrappedListener, existing] : [existing, wrappedListener];
      } else if (prepend) {
        existing.unshift(wrappedListener);
      } else {
        existing.push(wrappedListener);
      }
      if (this._maxListeners > 0 && existing.length > this._maxListeners && !existing._hasWarnedAboutMaxListeners) {
        existing._hasWarnedAboutMaxListeners = true;
        const warningMessage = [
          `Possible AsyncEventEmitter memory leak detected. ${existing.length} ${String(eventName)} listeners added to ${this.constructor.name}.`,
          `Use emitter.setMaxListeners() to increase the limit.`
        ].join(" ");
        console.warn(warningMessage);
      }
    }
    _wrapListener(eventName, listener, once) {
      if (!once) {
        return listener;
      }
      const state = {
        fired: false,
        wrapFn: undefined,
        eventEmitter: this,
        eventName,
        listener
      };
      const aliased = onceWrapper;
      const wrapped = aliased.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    static listenerCount(emitter, eventName) {
      return emitter.listenerCount(eventName);
    }
    static async once(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      return new Promise((resolve, reject) => {
        const errorListener = __name((err) => {
          emitter.removeListener(eventName, resolver);
          if (signal) {
            eventTargetAgnosticRemoveListener(emitter, eventName, abortListener);
          }
          reject(err);
        }, "errorListener");
        const resolver = __name((...args) => {
          emitter.removeListener("error", errorListener);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          resolve(args);
        }, "resolver");
        emitter.once(eventName, resolver);
        if (eventName !== "error") {
          emitter.once("error", errorListener);
        }
        const abortListener = __name(() => {
          eventTargetAgnosticRemoveListener(emitter, eventName, resolver);
          eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
          reject(new AbortError(undefined, { cause: getReason(signal) }));
        }, "abortListener");
        if (signal) {
          eventTargetAgnosticAddListener(signal, "abort", abortListener, { once: true });
        }
      });
    }
    static on(emitter, eventName, options = {}) {
      const signal = options?.signal;
      validateAbortSignal(signal);
      if (signal?.aborted) {
        throw new AbortError(undefined, { cause: getReason(signal) });
      }
      const unconsumedEvents = [];
      const unconsumedPromises = [];
      let error = null;
      let finished = false;
      const abortListener = __name(() => {
        errorHandler(new AbortError(undefined, { cause: getReason(signal) }));
      }, "abortListener");
      const eventHandler = __name((...args) => {
        const promise = unconsumedPromises.shift();
        if (promise) {
          promise.resolve(createIterResult(args, false));
        } else {
          unconsumedEvents.push(args);
        }
      }, "eventHandler");
      const errorHandler = __name((err) => {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
          toError.reject(err);
        } else {
          error = err;
        }
        iterator.return();
      }, "errorHandler");
      const iterator = Object.setPrototypeOf({
        next() {
          const value = unconsumedEvents.shift();
          if (value) {
            return Promise.resolve(createIterResult(value, false));
          }
          if (error) {
            const p = Promise.reject(error);
            error = null;
            return p;
          }
          if (finished) {
            return Promise.resolve(createIterResult(undefined, true));
          }
          return new Promise((resolve, reject) => {
            unconsumedPromises.push({ resolve, reject });
          });
        },
        return() {
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
          if (signal) {
            eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
          }
          finished = true;
          const doneResult = createIterResult(undefined, true);
          for (const promise of unconsumedPromises) {
            promise.resolve(doneResult);
          }
          return Promise.resolve(doneResult);
        },
        throw(err) {
          if (!err || !(err instanceof Error)) {
            throw new TypeError(`Expected Error instance to be thrown in AsyncEventEmitter.AsyncIterator. Got ${err}`);
          }
          error = err;
          emitter.off(eventName, eventHandler);
          emitter.off("error", errorHandler);
        },
        [Symbol.asyncIterator]() {
          return this;
        }
      }, AsyncIteratorPrototype);
      emitter.on(eventName, eventHandler);
      if (eventName !== "error") {
        emitter.on("error", errorHandler);
      }
      if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener);
      }
      return iterator;
    }
  };
  __name(AsyncEventEmitter, "AsyncEventEmitter");
  __name(onceWrapper, "onceWrapper");
  __name(getReason, "getReason");
  __name(eventTargetAgnosticRemoveListener, "eventTargetAgnosticRemoveListener");
  __name(eventTargetAgnosticAddListener, "eventTargetAgnosticAddListener");
  var AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {
  }).prototype);
  __name(createIterResult, "createIterResult");
  var AbortError = class extends Error {
    constructor(message = "The operation was aborted", options = undefined) {
      if (options !== undefined && typeof options !== "object") {
        throw new TypeError(`Failed to create AbortError: options is not an object or undefined`);
      }
      super(message, options);
      this.code = "ABORT_ERR";
      this.name = "AbortError";
    }
  };
  __name(AbortError, "AbortError");
  __name(handleMaybeAsync, "handleMaybeAsync");
});

// node_modules/magic-bytes.js/dist/model/toHex.js
var require_toHex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromHex = exports.toHex = undefined;
  var hex = (num) => new Number(num).toString(16).toLowerCase();
  var toHex = (num) => `0x${hex(num).length === 1 ? "0" + hex(num) : hex(num)}`;
  exports.toHex = toHex;
  var fromHex = (hex2) => new Number(hex2);
  exports.fromHex = fromHex;
});

// node_modules/magic-bytes.js/dist/model/tree.js
var require_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createComplexNode = exports.createNode = exports.merge = undefined;
  var createMatch = (leaf) => ({
    typename: leaf.typename,
    mime: leaf.info.mime,
    extension: leaf.info.extension
  });
  var isMatchingNode = (tree, path) => tree && path.length === 0;
  var head = (arr) => arr[0];
  var tail = (arr) => arr.slice(1, arr.length);
  var merge = (node, tree) => {
    if (node.bytes.length === 0)
      return tree;
    const currentByte = head(node.bytes);
    const path = tail(node.bytes);
    const currentTree = tree.bytes[currentByte];
    if (isMatchingNode(currentTree, path)) {
      const matchingNode = tree.bytes[currentByte];
      tree.bytes[currentByte] = {
        ...matchingNode,
        matches: [
          ...matchingNode.matches ? matchingNode.matches : [],
          createMatch(node)
        ]
      };
      return tree;
    }
    if (tree.bytes[currentByte]) {
      tree.bytes[currentByte] = exports.merge(exports.createNode(node.typename, path, node.info), tree.bytes[currentByte]);
      return tree;
    }
    if (!tree.bytes[currentByte]) {
      tree.bytes[currentByte] = {
        ...tree.bytes[currentByte],
        ...exports.createComplexNode(node.typename, path, node.info)
      };
    }
    return tree;
  };
  exports.merge = merge;
  var createNode = (typename, bytes, info) => {
    return { typename, bytes, info: info ? info : {} };
  };
  exports.createNode = createNode;
  var createComplexNode = (typename, bytes, info) => {
    let obj = {
      bytes: {},
      matches: undefined
    };
    const currentKey = head(bytes);
    const path = tail(bytes);
    if (bytes.length === 0) {
      return {
        matches: [
          createMatch({
            typename,
            info: info ? { extension: info.extension, mime: info.mime } : {}
          })
        ],
        bytes: {}
      };
    }
    obj.bytes[currentKey] = exports.createComplexNode(typename, path, info);
    return obj;
  };
  exports.createComplexNode = createComplexNode;
});

// node_modules/magic-bytes.js/dist/model/pattern-tree.js
var require_pattern_tree = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var toHex_1 = require_toHex();
  var tree_1 = require_tree();
  var fileType = new Map;
  var tree = {
    noOffset: null,
    offset: {}
  };
  var add = (typename, signature, additionalInfo, offset) => {
    fileType.set(typename, signature);
    if (offset) {
      const existing = tree.offset[toHex_1.toHex(offset)];
      if (!existing) {
        tree.offset[toHex_1.toHex(offset)] = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        const merged = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), { ...existing });
        tree.offset[toHex_1.toHex(offset)] = merged;
      }
    } else {
      if (tree.noOffset === null) {
        tree.noOffset = tree_1.createComplexNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo);
      } else {
        tree.noOffset = tree_1.merge(tree_1.createNode(typename, signature.map((e) => e.toLowerCase()), additionalInfo), tree.noOffset);
      }
    }
  };
  add("gif", ["0x47", "0x49", "0x46", "0x38", "0x37", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  add("gif", ["0x47", "0x49", "0x46", "0x38", "0x39", "0x61"], {
    mime: "image/gif",
    extension: "gif"
  });
  add("jpg", ["0xFF", "0xD8", "0xFF", "0xDB"], {
    mime: "image/jpeg",
    extension: "jpeg"
  });
  add("jpg", [
    "0xFF",
    "0xD8",
    "0xFF",
    "0xE0",
    "?",
    "?",
    "0x4A",
    "0x46",
    "0x49",
    "0x46",
    "0x00",
    "0x01"
  ], { mime: "image/jpeg", extension: "jpeg" });
  add("jpg", [
    "0xFF",
    "0xD8",
    "0xFF",
    "0xE1",
    "?",
    "?",
    "0x45",
    "0x78",
    "0x69",
    "0x66",
    "0x00",
    "0x00"
  ], { mime: "image/jpeg", extension: "jpeg" });
  add("webp", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x45",
    "0x42",
    "0x50"
  ], { mime: "image/webp", extension: "webp" });
  add("heif", ["0x66", "0x74", "0x79", "0x70", "0x6D", "0x69", "0x66", "0x31"], { mime: "image/heif", extension: "heif" }, 4);
  add("heif", ["0x66", "0x74", "0x79", "0x70", "0x68", "0x65", "0x69", "0x63"], { mime: "image/heif", extension: "heic" }, 4);
  add("rpm", ["0xed", "0xab", "0xee", "0xdb"]);
  add("bin", ["0x53", "0x50", "0x30", "0x31"], {
    mime: "application/octet-stream",
    extension: "bin"
  });
  add("pic", ["0x00"]);
  add("pif", ["0x00"]);
  add("sea", ["0x00"]);
  add("ytr", ["0x00"]);
  add("mp4", ["0x66", "0x74", "0x79", "0x70"], { mime: "video/mp4", extension: "mp4" }, 4);
  add("pdb", [
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00"
  ]);
  add("dba", ["0xBE", "0xBA", "0xFE", "0xCA"]);
  add("dba2", ["0x00", "0x01", "0x42", "0x44"]);
  add("tda", ["0x00", "0x01", "0x44", "0x54"]);
  add("tda2", ["0x00", "0x01", "0x00", "0x00"]);
  add("ico", ["0x00", "0x00", "0x01", "0x00"], {
    mime: "image/x-icon",
    extension: "ico"
  });
  add("3gp", ["0x66", "0x74", "0x79", "0x70", "0x33", "0x67"]);
  add("z", ["0x1F", "0x9D"]);
  add("tar.z", ["0x1F", "0xA0"]);
  add("bac", [
    "0x42",
    "0x41",
    "0x43",
    "0x4B",
    "0x4D",
    "0x49",
    "0x4B",
    "0x45",
    "0x44",
    "0x49",
    "0x53",
    "0x4B"
  ]);
  add("bz2", ["0x42", "0x5A", "0x68"], {
    mime: "application/x-bzip2",
    extension: "bz2"
  });
  add("tif", ["0x49", "0x49", "0x2A", "0x00"], {
    mime: "image/tiff",
    extension: "tif"
  });
  add("tiff", ["0x4D", "0x4D", "0x00", "0x2A"], {
    mime: "image/tiff",
    extension: "tiff"
  });
  add("cr2", [
    "0x49",
    "0x49",
    "0x2A",
    "0x00",
    "0x10",
    "0x00",
    "0x00",
    "0x00",
    "0x43",
    "0x52"
  ]);
  add("cin", ["0x80", "0x2A", "0x5F", "0xD7"]);
  add("cin1", ["0x52", "0x4E", "0x43", "0x01"]);
  add("cin2", ["0x52", "0x4E", "0x43", "0x02"]);
  add("dpx", ["0x53", "0x44", "0x50", "0x58"]);
  add("dpx2", ["0x58", "0x50", "0x44", "0x53"]);
  add("exr", ["0x76", "0x2F", "0x31", "0x01"]);
  add("bpg", ["0x42", "0x50", "0x47", "0xFB"]);
  add("ilbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x49",
    "0x4C",
    "0x42",
    "0x4D"
  ]);
  add("8svx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x38",
    "0x53",
    "0x56",
    "0x58"
  ]);
  add("acbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x43",
    "0x42",
    "0x4D"
  ]);
  add("anbm", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x42",
    "0x4D"
  ]);
  add("anim", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x4E",
    "0x49",
    "0x4D"
  ]);
  add("faxx", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x58",
    "0x58"
  ]);
  add("ftxt", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x54",
    "0x58",
    "0x54"
  ]);
  add("smus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x53",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  add("cmus", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x43",
    "0x4D",
    "0x55",
    "0x53"
  ]);
  add("yuvn", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x59",
    "0x55",
    "0x56",
    "0x4E"
  ]);
  add("iff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x46",
    "0x41",
    "0x4E",
    "0x54"
  ]);
  add("aiff", [
    "0x46",
    "0x4F",
    "0x52",
    "0x4D",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x49",
    "0x46",
    "0x46"
  ], { mime: "audio/x-aiff", extension: "aiff" });
  add("idx", ["0x49", "0x4E", "0x44", "0x58"]);
  add("lz", ["0x4C", "0x5A", "0x49", "0x50"]);
  add("exe", ["0x4D", "0x5A"]);
  add("zip", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("zip", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("zip", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/zip",
    extension: "zip"
  });
  add("jar", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("jar", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("jar", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/java-archive",
    extension: "jar"
  });
  add("odt", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("odt", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("odt", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.text",
    extension: "odt"
  });
  add("ods", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("ods", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("ods", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.spreadsheet",
    extension: "ods"
  });
  add("odp", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("odp", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("odp", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.oasis.opendocument.presentation",
    extension: "odp"
  });
  add("docx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("docx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("docx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    extension: "docx"
  });
  add("xlsx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("xlsx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("xlsx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  });
  add("pptx", ["0x50", "0x4B", "0x03", "0x04"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("pptx", ["0x50", "0x4B", "0x05", "0x06"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("pptx", ["0x50", "0x4B", "0x07", "0x08"], {
    mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    extension: "pptx"
  });
  add("vsdx", ["0x50", "0x4B", "0x03", "0x04"]);
  add("vsdx", ["0x50", "0x4B", "0x05", "0x06"]);
  add("vsdx", ["0x50", "0x4B", "0x07", "0x08"]);
  add("apk", ["0x50", "0x4B", "0x03", "0x04"]);
  add("apk", ["0x50", "0x4B", "0x05", "0x06"]);
  add("apk", ["0x50", "0x4B", "0x07", "0x08"]);
  add("aar", ["0x50", "0x4B", "0x03", "0x04"]);
  add("aar", ["0x50", "0x4B", "0x05", "0x06"]);
  add("aar", ["0x50", "0x4B", "0x07", "0x08"]);
  add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("rar", ["0x52", "0x61", "0x72", "0x21", "0x1A", "0x07", "0x01", "0x00"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("rar", ["0x7F", "0x45", "0x4C", "0x46"], {
    mime: "application/vnd.rar",
    extension: "rar"
  });
  add("png", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/png",
    extension: "png"
  });
  add("apng", ["0x89", "0x50", "0x4E", "0x47", "0x0D", "0x0A", "0x1A", "0x0A"], {
    mime: "image/apng",
    extension: "apng"
  });
  add("class", ["0xCA", "0xFE", "0xBA", "0xBE"]);
  add("class", ["0xEF", "0xBB", "0xBF"]);
  add("class", ["0xFE", "0xed", "0xFA", "0xCE"], undefined, 4096);
  add("class", ["0xFE", "0xed", "0xFA", "0xCF"], undefined, 4096);
  add("class", ["0xCE", "0xFA", "0xed", "0xFE"]);
  add("class", ["0xCF", "0xFA", "0xed", "0xFE"]);
  add("class", ["0xFF", "0xFE"]);
  add("class", ["0xFF", "0xFE"]);
  add("class", ["0xFF", "0xFE", "0x00", "0x00"]);
  add("ps", ["0x25", "0x21", "0x50", "0x53"]);
  add("pdf", ["0x25", "0x50", "0x44", "0x46"], {
    mime: "application/pdf",
    extension: "pdf"
  });
  add("asf", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("wma", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("wmv", [
    "0x30",
    "0x26",
    "0xB2",
    "0x75",
    "0x8E",
    "0x66",
    "0xCF",
    "0x11",
    "0xA6",
    "0xD9",
    "0x00",
    "0xAA",
    "0x00",
    "0x62",
    "0xCE",
    "0x6C"
  ]);
  add("deploymentimage", [
    "0x24",
    "0x53",
    "0x44",
    "0x49",
    "0x30",
    "0x30",
    "0x30",
    "0x31"
  ]);
  add("ogg", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "audio/ogg",
    extension: "ogg"
  });
  add("oga", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "audio/ogg",
    extension: "oga"
  });
  add("ogv", ["0x4F", "0x67", "0x67", "0x53"], {
    mime: "video/ogg",
    extension: "ogv"
  });
  add("psd", ["0x38", "0x42", "0x50", "0x53"], {
    mime: "application/x-photoshop",
    extension: "psd"
  });
  add("clip", ["0x43", "0x53", "0x46", "0x43", "0x48", "0x55", "0x4e", "0x4b"]);
  add("wav", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x57",
    "0x41",
    "0x56",
    "0x45"
  ], { mime: "audio/x-wav", extension: "wav" });
  add("avi", [
    "0x52",
    "0x49",
    "0x46",
    "0x46",
    "?",
    "?",
    "?",
    "?",
    "0x41",
    "0x56",
    "0x49",
    "0x20"
  ], { mime: "video/x-msvideo", extension: "avi" });
  add("mp3", ["0xFF", "0xFB"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0xFF", "0xF3"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0xFF", "0xF2"], { mime: "audio/mpeg", extension: "mp3" });
  add("mp3", ["0x49", "0x44", "0x33"], { mime: "audio/mpeg", extension: "mp3" });
  add("bmp", ["0x42", "0x4D"], { mime: "image/bmp", extension: "bmp" });
  add("iso", ["0x43", "0x44", "0x30", "0x30", "0x31"]);
  add("flac", ["0x66", "0x4C", "0x61", "0x43"]);
  add("mid", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "mid"
  });
  add("midi", ["0x4D", "0x54", "0x68", "0x64"], {
    mime: "audio/midi",
    extension: "midi"
  });
  add("doc", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/msword",
    extension: "doc"
  });
  add("xls", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-excel",
    extension: "xls"
  });
  add("ppt", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"], {
    mime: "application/vnd.ms-powerpoint",
    extension: "ppt"
  });
  add("msg", ["0xD0", "0xCF", "0x11", "0xE0", "0xA1", "0xB1", "0x1A", "0xE1"]);
  add("dex", ["0x64", "0x65", "0x78", "0x0A", "0x30", "0x33", "0x35", "0x00"]);
  add("vmdk", ["0x4B", "0x44", "0x4D"]);
  add("crx", ["0x43", "0x72", "0x32", "0x34"]);
  add("fh8", ["0x41", "0x47", "0x44", "0x33"]);
  add("cwk", [
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x05",
    "0x07",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  add("cwk", [
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x42",
    "0x4F",
    "0x42",
    "0x4F",
    "0x06",
    "0x07",
    "0xE1",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x00",
    "0x01"
  ]);
  add("toast", ["0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  add("toast", ["0x8B", "0x45", "0x52", "0x02", "0x00", "0x00", "0x00"]);
  add("dmg", ["0x78", "0x01", "0x73", "0x0D", "0x62", "0x62", "0x60"]);
  add("xar", ["0x78", "0x61", "0x72", "0x21"]);
  add("dat", ["0x50", "0x4D", "0x4F", "0x43", "0x43", "0x4D", "0x4F", "0x43"]);
  add("nes", ["0x4E", "0x45", "0x53", "0x1A"]);
  add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x00", "0x30", "0x30"], undefined, 257);
  add("tar", ["0x75", "0x73", "0x74", "0x61", "0x72", "0x20", "0x20", "0x00"], undefined, 257);
  add("tox", ["0x74", "0x6F", "0x78", "0x33"]);
  add("mlv", ["0x4D", "0x4C", "0x56", "0x49"]);
  add("windowsupdate", [
    "0x44",
    "0x43",
    "0x4D",
    "0x01",
    "0x50",
    "0x41",
    "0x33",
    "0x30"
  ]);
  add("7z", ["0x37", "0x7A", "0xBC", "0xAF", "0x27", "0x1C"], {
    mime: "application/x-7z-compressed",
    extension: "7z"
  });
  add("gz", ["0x1F", "0x8B"], { mime: "application/gzip", extension: "gz" });
  add("tar.gz", ["0x1F", "0x8B"], {
    mime: "application/gzip",
    extension: "tar.gz"
  });
  add("xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "xz"
  });
  add("tar.xz", ["0xFD", "0x37", "0x7A", "0x58", "0x5A", "0x00", "0x00"], {
    mime: "application/gzip",
    extension: "tar.xz"
  });
  add("lz2", ["0x04", "0x22", "0x4D", "0x18"]);
  add("cab", ["0x4D", "0x53", "0x43", "0x46"]);
  add("mkv", ["0x1A", "0x45", "0xDF", "0xA3"]);
  add("mka", ["0x1A", "0x45", "0xDF", "0xA3"]);
  add("mks", ["0x1A", "0x45", "0xDF", "0xA3"]);
  add("mk3d", ["0x1A", "0x45", "0xDF", "0xA3"]);
  add("webm", ["0x1A", "0x45", "0xDF", "0xA3"], {
    mime: "audio/webm",
    extension: "webm"
  });
  add("dcm", ["0x44", "0x49", "0x43", "0x4D"], undefined, 128);
  add("xml", ["0x3C", "0x3f", "0x78", "0x6d", "0x6C", "0x20"], {
    mime: "application/xml",
    extension: "xml"
  });
  add("wasm", ["0x00", "0x61", "0x73", "0x6d"]);
  add("lep", ["0xCF", "0x84", "0x01"]);
  add("swf", ["0x43", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  add("swf", ["0x46", "0x57", "0x53"], {
    mime: "application/x-shockwave-flash",
    extension: "swf"
  });
  add("deb", ["0x21", "0x3C", "0x61", "0x72", "0x63", "0x68", "0x3E"]);
  add("rtf", ["0x7B", "0x5C", "0x72", "0x74", "0x66", "0x31"], {
    mime: "application/rtf",
    extension: "rtf"
  });
  add("m2p", ["0x00", "0x00", "0x01", "0xBA"]);
  add("vob", ["0x00", "0x00", "0x01", "0xBA"]);
  add("mpg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpg"
  });
  add("mpeg", ["0x00", "0x00", "0x01", "0xBA"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  add("mpeg", ["0x47"], { mime: "video/mpeg", extension: "mpeg" });
  add("mpeg", ["0x00", "0x00", "0x01", "0xB3"], {
    mime: "video/mpeg",
    extension: "mpeg"
  });
  add("hl2demo", ["48", "4C", "32", "44", "45", "4D", "4F"]);
  exports.default = () => tree;
});

// node_modules/magic-bytes.js/dist/index.js
var require_dist5 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filetypeextension = exports.filetypemime = exports.filetypename = exports.filetypeinfo = undefined;
  var pattern_tree_1 = __importDefault(require_pattern_tree());
  var toHex_1 = require_toHex();
  var patternTree = pattern_tree_1.default();
  var filetypeinfo = (bytes) => {
    let tree = patternTree;
    for (const k of Object.keys(tree.offset)) {
      const offset = toHex_1.fromHex(k);
      const offsetExceedsFile = offset >= bytes.length;
      if (offsetExceedsFile) {
        continue;
      }
      const node = patternTree.offset[k];
      const guessed = walkTree(offset, bytes, node);
      if (guessed.length > 0) {
        return guessed;
      }
    }
    if (tree.noOffset === null) {
      return [];
    }
    return walkTree(0, bytes, tree.noOffset);
  };
  exports.filetypeinfo = filetypeinfo;
  var walkTree = (index, bytes, node) => {
    let step = node;
    let guessFile = [];
    while (true) {
      const currentByte = toHex_1.toHex(bytes[index]);
      if (step.bytes["?"] && !step.bytes[currentByte]) {
        step = step.bytes["?"];
      } else {
        step = step.bytes[currentByte];
      }
      if (!step) {
        return guessFile;
      }
      if (step && step.matches) {
        guessFile = step.matches.slice(0);
      }
      index += 1;
    }
  };
  exports.default = exports.filetypeinfo;
  var filetypename = (bytes) => exports.filetypeinfo(bytes).map((e) => e.typename);
  exports.filetypename = filetypename;
  var filetypemime = (bytes) => exports.filetypeinfo(bytes).map((e) => e.mime ? e.mime : "");
  exports.filetypemime = filetypemime;
  var filetypeextension = (bytes) => exports.filetypeinfo(bytes).map((e) => e.extension ? e.extension : "");
  exports.filetypeextension = filetypeextension;
});

// node_modules/@sapphire/async-queue/dist/index.js
var require_dist6 = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var src_exports = {};
  __export2(src_exports, {
    AsyncQueue: () => AsyncQueue
  });
  module.exports = __toCommonJS(src_exports);
  var AsyncQueueEntry = class {
    constructor(queue) {
      __publicField(this, "promise");
      __publicField(this, "resolve");
      __publicField(this, "reject");
      __publicField(this, "queue");
      __publicField(this, "signal", null);
      __publicField(this, "signalListener", null);
      this.queue = queue;
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
    }
    setSignal(signal) {
      if (signal.aborted)
        return this;
      this.signal = signal;
      this.signalListener = () => {
        const index = this.queue["promises"].indexOf(this);
        if (index !== -1)
          this.queue["promises"].splice(index, 1);
        this.reject(new Error("Request aborted manually"));
      };
      this.signal.addEventListener("abort", this.signalListener);
      return this;
    }
    use() {
      this.dispose();
      this.resolve();
      return this;
    }
    abort() {
      this.dispose();
      this.reject(new Error("Request aborted manually"));
      return this;
    }
    dispose() {
      if (this.signal) {
        this.signal.removeEventListener("abort", this.signalListener);
        this.signal = null;
        this.signalListener = null;
      }
    }
  };
  __name(AsyncQueueEntry, "AsyncQueueEntry");
  var AsyncQueue = class {
    constructor() {
      __publicField(this, "promises", []);
    }
    get remaining() {
      return this.promises.length;
    }
    get queued() {
      return this.remaining === 0 ? 0 : this.remaining - 1;
    }
    wait(options) {
      const entry = new AsyncQueueEntry(this);
      if (this.promises.length === 0) {
        this.promises.push(entry);
        return Promise.resolve();
      }
      this.promises.push(entry);
      if (options?.signal)
        entry.setSignal(options.signal);
      return entry.promise;
    }
    shift() {
      if (this.promises.length === 0)
        return;
      if (this.promises.length === 1) {
        this.promises.shift();
        return;
      }
      this.promises.shift();
      this.promises[0].use();
    }
    abortAll() {
      if (this.queued === 0)
        return;
      for (let i = 1;i < this.promises.length; ++i) {
        this.promises[i].abort();
      }
      this.promises.length = 1;
    }
  };
  __name(AsyncQueue, "AsyncQueue");
});

// node_modules/@discordjs/rest/dist/index.js
var require_dist7 = __commonJS((exports, module) => {
  var setDefaultStrategy = function(newStrategy) {
    defaultStrategy = newStrategy;
  };
  var getDefaultStrategy = function() {
    return defaultStrategy;
  };
  async function makeRequest(url, init) {
    const options = {
      ...init,
      body: await resolveBody(init.body)
    };
    const res = await (0, import_undici.request)(url, options);
    return {
      body: res.body,
      async arrayBuffer() {
        return res.body.arrayBuffer();
      },
      async json() {
        return res.body.json();
      },
      async text() {
        return res.body.text();
      },
      get bodyUsed() {
        return res.body.bodyUsed;
      },
      headers: new import_undici.Headers(res.headers),
      status: res.statusCode,
      statusText: import_node_http.STATUS_CODES[res.statusCode],
      ok: res.statusCode >= 200 && res.statusCode < 300
    };
  }
  async function resolveBody(body) {
    if (body == null) {
      return null;
    } else if (typeof body === "string") {
      return body;
    } else if (import_node_util.types.isUint8Array(body)) {
      return body;
    } else if (import_node_util.types.isArrayBuffer(body)) {
      return new Uint8Array(body);
    } else if (body instanceof import_node_url.URLSearchParams) {
      return body.toString();
    } else if (body instanceof DataView) {
      return new Uint8Array(body.buffer);
    } else if (body instanceof Blob) {
      return new Uint8Array(await body.arrayBuffer());
    } else if (body instanceof FormData) {
      return body;
    } else if (body[Symbol.iterator]) {
      const chunks = [...body];
      return Buffer.concat(chunks);
    } else if (body[Symbol.asyncIterator]) {
      const chunks = [];
      for await (const chunk of body) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    }
    throw new TypeError(`Unable to resolve body.`);
  }
  var isErrorGroupWrapper = function(error) {
    return Reflect.has(error, "_errors");
  };
  var isErrorResponse = function(error) {
    return typeof Reflect.get(error, "message") === "string";
  };
  var serializeSearchParam = function(value) {
    switch (typeof value) {
      case "string":
        return value;
      case "number":
      case "bigint":
      case "boolean":
        return value.toString();
      case "object":
        if (value === null)
          return null;
        if (value instanceof Date) {
          return Number.isNaN(value.getTime()) ? null : value.toISOString();
        }
        if (typeof value.toString === "function" && value.toString !== Object.prototype.toString)
          return value.toString();
        return null;
      default:
        return null;
    }
  };
  var makeURLSearchParams = function(options) {
    const params = new URLSearchParams;
    if (!options)
      return params;
    for (const [key, value] of Object.entries(options)) {
      const serialized = serializeSearchParam(value);
      if (serialized !== null)
        params.append(key, serialized);
    }
    return params;
  };
  async function parseResponse(res) {
    if (res.headers.get("Content-Type")?.startsWith("application/json")) {
      return res.json();
    }
    return res.arrayBuffer();
  }
  var hasSublimit = function(bucketRoute, body, method) {
    if (bucketRoute === "/channels/:id") {
      if (typeof body !== "object" || body === null)
        return false;
      if (method !== "PATCH")
        return false;
      const castedBody = body;
      return ["name", "topic"].some((key) => Reflect.has(castedBody, key));
    }
    return true;
  };
  var shouldRetry = function(error) {
    if (error.name === "AbortError")
      return true;
    return ("code" in error) && error.code === "ECONNRESET" || error.message.includes("ECONNRESET");
  };
  async function onRateLimit(manager, rateLimitData) {
    const { options } = manager;
    if (!options.rejectOnRateLimit)
      return;
    const shouldThrow = typeof options.rejectOnRateLimit === "function" ? await options.rejectOnRateLimit(rateLimitData) : options.rejectOnRateLimit.some((route) => rateLimitData.route.startsWith(route.toLowerCase()));
    if (shouldThrow) {
      throw new RateLimitError(rateLimitData);
    }
  }
  var calculateUserDefaultAvatarIndex = function(userId) {
    return Number(BigInt(userId) >> 22n) % 6;
  };
  async function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(() => resolve(), ms);
    });
  }
  var isBufferLike = function(value) {
    return value instanceof ArrayBuffer || value instanceof Uint8Array || value instanceof Uint8ClampedArray;
  };
  var incrementInvalidCount = function(manager) {
    if (!invalidCountResetTime || invalidCountResetTime < Date.now()) {
      invalidCountResetTime = Date.now() + 1000 * 60 * 10;
      invalidCount = 0;
    }
    invalidCount++;
    const emitInvalid = manager.options.invalidRequestWarningInterval > 0 && invalidCount % manager.options.invalidRequestWarningInterval === 0;
    if (emitInvalid) {
      manager.emit("invalidRequestWarning", {
        count: invalidCount,
        remainingTime: invalidCountResetTime - Date.now()
      });
    }
  };
  async function makeNetworkRequest(manager, routeId, url, options, requestData, retries) {
    const controller = new AbortController;
    const timeout = setTimeout(() => controller.abort(), manager.options.timeout);
    if (requestData.signal) {
      if (requestData.signal.aborted)
        controller.abort();
      else
        requestData.signal.addEventListener("abort", () => controller.abort());
    }
    let res;
    try {
      res = await manager.options.makeRequest(url, { ...options, signal: controller.signal });
    } catch (error) {
      if (!(error instanceof Error))
        throw error;
      if (shouldRetry(error) && retries !== manager.options.retries) {
        return null;
      }
      throw error;
    } finally {
      clearTimeout(timeout);
    }
    if (manager.listenerCount("response")) {
      manager.emit("response", {
        method: options.method ?? "get",
        path: routeId.original,
        route: routeId.bucketRoute,
        options,
        data: requestData,
        retries
      }, res instanceof Response ? res.clone() : { ...res });
    }
    return res;
  }
  async function handleErrors(manager, res, method, url, requestData, retries) {
    const status = res.status;
    if (status >= 500 && status < 600) {
      if (retries !== manager.options.retries) {
        return null;
      }
      throw new HTTPError(status, res.statusText, method, url, requestData);
    } else {
      if (status >= 400 && status < 500) {
        if (status === 401 && requestData.auth) {
          manager.setToken(null);
        }
        const data = await parseResponse(res);
        throw new DiscordAPIError(data, "code" in data ? data.code : data.error, status, method, url, requestData);
      }
      return res;
    }
  }
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    ALLOWED_EXTENSIONS: () => ALLOWED_EXTENSIONS,
    ALLOWED_SIZES: () => ALLOWED_SIZES,
    ALLOWED_STICKER_EXTENSIONS: () => ALLOWED_STICKER_EXTENSIONS,
    BurstHandlerMajorIdKey: () => BurstHandlerMajorIdKey,
    CDN: () => CDN,
    DefaultRestOptions: () => DefaultRestOptions,
    DefaultUserAgent: () => DefaultUserAgent,
    DefaultUserAgentAppendix: () => DefaultUserAgentAppendix,
    DiscordAPIError: () => DiscordAPIError,
    HTTPError: () => HTTPError,
    OverwrittenMimeTypes: () => OverwrittenMimeTypes,
    REST: () => REST,
    RESTEvents: () => RESTEvents,
    RateLimitError: () => RateLimitError,
    RequestMethod: () => RequestMethod,
    calculateUserDefaultAvatarIndex: () => calculateUserDefaultAvatarIndex,
    makeURLSearchParams: () => makeURLSearchParams,
    parseResponse: () => parseResponse,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var import_node_buffer = __require("buffer");
  var import_util2 = require_dist();
  var import_undici2 = require_undici();
  var defaultStrategy;
  __name(setDefaultStrategy, "setDefaultStrategy");
  __name(getDefaultStrategy, "getDefaultStrategy");
  var import_node_http = __require("http");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_undici = require_undici();
  __name(makeRequest, "makeRequest");
  __name(resolveBody, "resolveBody");
  var import_util = require_dist();
  var import_v10 = require_v106();
  var DefaultUserAgent = `DiscordBot (https://discord.js.org, 2.0.1)`;
  var DefaultUserAgentAppendix = (0, import_util.getUserAgentAppendix)();
  var DefaultRestOptions = {
    agent: null,
    api: "https://discord.com/api",
    authPrefix: "Bot",
    cdn: "https://cdn.discordapp.com",
    headers: {},
    invalidRequestWarningInterval: 0,
    globalRequestsPerSecond: 50,
    offset: 50,
    rejectOnRateLimit: null,
    retries: 3,
    timeout: 15000,
    userAgentAppendix: DefaultUserAgentAppendix,
    version: import_v10.APIVersion,
    hashSweepInterval: 14400000,
    hashLifetime: 86400000,
    handlerSweepInterval: 3600000,
    async makeRequest(...args) {
      return getDefaultStrategy()(...args);
    }
  };
  var RESTEvents = ((RESTEvents2) => {
    RESTEvents2["Debug"] = "restDebug";
    RESTEvents2["HandlerSweep"] = "handlerSweep";
    RESTEvents2["HashSweep"] = "hashSweep";
    RESTEvents2["InvalidRequestWarning"] = "invalidRequestWarning";
    RESTEvents2["RateLimited"] = "rateLimited";
    RESTEvents2["Response"] = "response";
    return RESTEvents2;
  })(RESTEvents || {});
  var ALLOWED_EXTENSIONS = ["webp", "png", "jpg", "jpeg", "gif"];
  var ALLOWED_STICKER_EXTENSIONS = ["png", "json", "gif"];
  var ALLOWED_SIZES = [16, 32, 64, 128, 256, 512, 1024, 2048, 4096];
  var OverwrittenMimeTypes = {
    "image/apng": "image/png"
  };
  var BurstHandlerMajorIdKey = "burst";
  var CDN = class {
    constructor(base = DefaultRestOptions.cdn) {
      this.base = base;
    }
    static {
      __name(this, "CDN");
    }
    appAsset(clientId, assetHash, options) {
      return this.makeURL(`/app-assets/${clientId}/${assetHash}`, options);
    }
    appIcon(clientId, iconHash, options) {
      return this.makeURL(`/app-icons/${clientId}/${iconHash}`, options);
    }
    avatar(id, avatarHash, options) {
      return this.dynamicMakeURL(`/avatars/${id}/${avatarHash}`, avatarHash, options);
    }
    avatarDecoration(userId, userAvatarDecoration, options) {
      return this.makeURL(`/avatar-decorations/${userId}/${userAvatarDecoration}`, options);
    }
    banner(id, bannerHash, options) {
      return this.dynamicMakeURL(`/banners/${id}/${bannerHash}`, bannerHash, options);
    }
    channelIcon(channelId, iconHash, options) {
      return this.makeURL(`/channel-icons/${channelId}/${iconHash}`, options);
    }
    defaultAvatar(index) {
      return this.makeURL(`/embed/avatars/${index}`, { extension: "png" });
    }
    discoverySplash(guildId, splashHash, options) {
      return this.makeURL(`/discovery-splashes/${guildId}/${splashHash}`, options);
    }
    emoji(emojiId, extension) {
      return this.makeURL(`/emojis/${emojiId}`, { extension });
    }
    guildMemberAvatar(guildId, userId, avatarHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/avatars/${avatarHash}`, avatarHash, options);
    }
    guildMemberBanner(guildId, userId, bannerHash, options) {
      return this.dynamicMakeURL(`/guilds/${guildId}/users/${userId}/banner`, bannerHash, options);
    }
    icon(id, iconHash, options) {
      return this.dynamicMakeURL(`/icons/${id}/${iconHash}`, iconHash, options);
    }
    roleIcon(roleId, roleIconHash, options) {
      return this.makeURL(`/role-icons/${roleId}/${roleIconHash}`, options);
    }
    splash(guildId, splashHash, options) {
      return this.makeURL(`/splashes/${guildId}/${splashHash}`, options);
    }
    sticker(stickerId, extension = "png") {
      return this.makeURL(`/stickers/${stickerId}`, { allowedExtensions: ALLOWED_STICKER_EXTENSIONS, extension });
    }
    stickerPackBanner(bannerId, options) {
      return this.makeURL(`/app-assets/710982414301790216/store/${bannerId}`, options);
    }
    teamIcon(teamId, iconHash, options) {
      return this.makeURL(`/team-icons/${teamId}/${iconHash}`, options);
    }
    guildScheduledEventCover(scheduledEventId, coverHash, options) {
      return this.makeURL(`/guild-events/${scheduledEventId}/${coverHash}`, options);
    }
    dynamicMakeURL(route, hash, { forceStatic = false, ...options } = {}) {
      return this.makeURL(route, !forceStatic && hash.startsWith("a_") ? { ...options, extension: "gif" } : options);
    }
    makeURL(route, { allowedExtensions = ALLOWED_EXTENSIONS, extension = "webp", size } = {}) {
      extension = String(extension).toLowerCase();
      if (!allowedExtensions.includes(extension)) {
        throw new RangeError(`Invalid extension provided: ${extension}
Must be one of: ${allowedExtensions.join(", ")}`);
      }
      if (size && !ALLOWED_SIZES.includes(size)) {
        throw new RangeError(`Invalid size provided: ${size}
Must be one of: ${ALLOWED_SIZES.join(", ")}`);
      }
      const url = new URL(`${this.base}${route}.${extension}`);
      if (size) {
        url.searchParams.set("size", String(size));
      }
      return url.toString();
    }
  };
  __name(isErrorGroupWrapper, "isErrorGroupWrapper");
  __name(isErrorResponse, "isErrorResponse");
  var DiscordAPIError = class _DiscordAPIError extends Error {
    constructor(rawError, code, status, method, url, bodyData) {
      super(_DiscordAPIError.getMessage(rawError));
      this.rawError = rawError;
      this.code = code;
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "DiscordAPIError");
    }
    requestBody;
    get name() {
      return `${_DiscordAPIError.name}[${this.code}]`;
    }
    static getMessage(error) {
      let flattened = "";
      if ("code" in error) {
        if (error.errors) {
          flattened = [...this.flattenDiscordError(error.errors)].join("\n");
        }
        return error.message && flattened ? `${error.message}
${flattened}` : error.message || flattened || "Unknown Error";
      }
      return error.error_description ?? "No Description";
    }
    static *flattenDiscordError(obj, key = "") {
      if (isErrorResponse(obj)) {
        return yield `${key.length ? `${key}[${obj.code}]` : `${obj.code}`}: ${obj.message}`.trim();
      }
      for (const [otherKey, val] of Object.entries(obj)) {
        const nextKey = otherKey.startsWith("_") ? key : key ? Number.isNaN(Number(otherKey)) ? `${key}.${otherKey}` : `${key}[${otherKey}]` : otherKey;
        if (typeof val === "string") {
          yield val;
        } else if (isErrorGroupWrapper(val)) {
          for (const error of val._errors) {
            yield* this.flattenDiscordError(error, nextKey);
          }
        } else {
          yield* this.flattenDiscordError(val, nextKey);
        }
      }
    }
  };
  var HTTPError = class _HTTPError extends Error {
    constructor(status, statusText, method, url, bodyData) {
      super(statusText);
      this.status = status;
      this.method = method;
      this.url = url;
      this.requestBody = { files: bodyData.files, json: bodyData.body };
    }
    static {
      __name(this, "HTTPError");
    }
    requestBody;
    name = _HTTPError.name;
  };
  var RateLimitError = class _RateLimitError extends Error {
    static {
      __name(this, "RateLimitError");
    }
    timeToReset;
    limit;
    method;
    hash;
    url;
    route;
    majorParameter;
    global;
    constructor({ timeToReset, limit, method, hash, url, route, majorParameter, global: global2 }) {
      super();
      this.timeToReset = timeToReset;
      this.limit = limit;
      this.method = method;
      this.hash = hash;
      this.url = url;
      this.route = route;
      this.majorParameter = majorParameter;
      this.global = global2;
    }
    get name() {
      return `${_RateLimitError.name}[${this.route}]`;
    }
  };
  var import_collection = require_dist2();
  var import_snowflake = require_dist3();
  var import_async_event_emitter = require_dist4();
  var import_magic_bytes = require_dist5();
  var RequestMethod = ((RequestMethod2) => {
    RequestMethod2["Delete"] = "DELETE";
    RequestMethod2["Get"] = "GET";
    RequestMethod2["Patch"] = "PATCH";
    RequestMethod2["Post"] = "POST";
    RequestMethod2["Put"] = "PUT";
    return RequestMethod2;
  })(RequestMethod || {});
  __name(serializeSearchParam, "serializeSearchParam");
  __name(makeURLSearchParams, "makeURLSearchParams");
  __name(parseResponse, "parseResponse");
  __name(hasSublimit, "hasSublimit");
  __name(shouldRetry, "shouldRetry");
  __name(onRateLimit, "onRateLimit");
  __name(calculateUserDefaultAvatarIndex, "calculateUserDefaultAvatarIndex");
  __name(sleep, "sleep");
  __name(isBufferLike, "isBufferLike");
  var invalidCount = 0;
  var invalidCountResetTime = null;
  __name(incrementInvalidCount, "incrementInvalidCount");
  __name(makeNetworkRequest, "makeNetworkRequest");
  __name(handleErrors, "handleErrors");
  var BurstHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "BurstHandler");
    }
    id;
    inactive = false;
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async queueRequest(routeId, url, options, requestData) {
      return this.runRequest(routeId, url, options, requestData);
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const retry = res.headers.get("Retry-After");
      if (retry)
        retryAfter = Number(retry) * 1000 + this.manager.options.offset;
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (status >= 200 && status < 300) {
        return res;
      } else if (status === 429) {
        const isGlobal = res.headers.has("X-RateLimit-Global");
        await onRateLimit(this.manager, {
          timeToReset: retryAfter,
          limit: Number.POSITIVE_INFINITY,
          method,
          hash: this.hash,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          global: isGlobal
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${Number.POSITIVE_INFINITY}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : None`
        ].join("\n"));
        await sleep(retryAfter);
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var import_async_queue = require_dist6();
  var SequentialHandler = class {
    constructor(manager, hash, majorParameter) {
      this.manager = manager;
      this.hash = hash;
      this.majorParameter = majorParameter;
      this.id = `${hash}:${majorParameter}`;
    }
    static {
      __name(this, "SequentialHandler");
    }
    id;
    reset = -1;
    remaining = 1;
    limit = Number.POSITIVE_INFINITY;
    #asyncQueue = new import_async_queue.AsyncQueue;
    #sublimitedQueue = null;
    #sublimitPromise = null;
    #shiftSublimit = false;
    get inactive() {
      return this.#asyncQueue.remaining === 0 && (this.#sublimitedQueue === null || this.#sublimitedQueue.remaining === 0) && !this.limited;
    }
    get globalLimited() {
      return this.manager.globalRemaining <= 0 && Date.now() < this.manager.globalReset;
    }
    get localLimited() {
      return this.remaining <= 0 && Date.now() < this.reset;
    }
    get limited() {
      return this.globalLimited || this.localLimited;
    }
    get timeToReset() {
      return this.reset + this.manager.options.offset - Date.now();
    }
    debug(message) {
      this.manager.emit("restDebug", `[REST ${this.id}] ${message}`);
    }
    async globalDelayFor(time) {
      await sleep(time);
      this.manager.globalDelay = null;
    }
    async queueRequest(routeId, url, options, requestData) {
      let queue = this.#asyncQueue;
      let queueType = 0;
      if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
        queue = this.#sublimitedQueue;
        queueType = 1;
      }
      await queue.wait({ signal: requestData.signal });
      if (queueType === 0) {
        if (this.#sublimitedQueue && hasSublimit(routeId.bucketRoute, requestData.body, options.method)) {
          queue = this.#sublimitedQueue;
          const wait = queue.wait();
          this.#asyncQueue.shift();
          await wait;
        } else if (this.#sublimitPromise) {
          await this.#sublimitPromise.promise;
        }
      }
      try {
        return await this.runRequest(routeId, url, options, requestData);
      } finally {
        queue.shift();
        if (this.#shiftSublimit) {
          this.#shiftSublimit = false;
          this.#sublimitedQueue?.shift();
        }
        if (this.#sublimitedQueue?.remaining === 0) {
          this.#sublimitPromise?.resolve();
          this.#sublimitedQueue = null;
        }
      }
    }
    async runRequest(routeId, url, options, requestData, retries = 0) {
      while (this.limited) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        let delay;
        if (isGlobal) {
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
          if (!this.manager.globalDelay) {
            this.manager.globalDelay = this.globalDelayFor(timeout);
          }
          delay = this.manager.globalDelay;
        } else {
          limit2 = this.limit;
          timeout = this.timeToReset;
          delay = sleep(timeout);
        }
        const rateLimitData = {
          timeToReset: timeout,
          limit: limit2,
          method: options.method ?? "get",
          hash: this.hash,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          global: isGlobal
        };
        this.manager.emit("rateLimited", rateLimitData);
        await onRateLimit(this.manager, rateLimitData);
        if (isGlobal) {
          this.debug(`Global rate limit hit, blocking all requests for ${timeout}ms`);
        } else {
          this.debug(`Waiting ${timeout}ms for rate limit to pass`);
        }
        await delay;
      }
      if (!this.manager.globalReset || this.manager.globalReset < Date.now()) {
        this.manager.globalReset = Date.now() + 1000;
        this.manager.globalRemaining = this.manager.options.globalRequestsPerSecond;
      }
      this.manager.globalRemaining--;
      const method = options.method ?? "get";
      const res = await makeNetworkRequest(this.manager, routeId, url, options, requestData, retries);
      if (res === null) {
        return this.runRequest(routeId, url, options, requestData, ++retries);
      }
      const status = res.status;
      let retryAfter = 0;
      const limit = res.headers.get("X-RateLimit-Limit");
      const remaining = res.headers.get("X-RateLimit-Remaining");
      const reset = res.headers.get("X-RateLimit-Reset-After");
      const hash = res.headers.get("X-RateLimit-Bucket");
      const retry = res.headers.get("Retry-After");
      this.limit = limit ? Number(limit) : Number.POSITIVE_INFINITY;
      this.remaining = remaining ? Number(remaining) : 1;
      this.reset = reset ? Number(reset) * 1000 + Date.now() + this.manager.options.offset : Date.now();
      if (retry)
        retryAfter = Number(retry) * 1000 + this.manager.options.offset;
      if (hash && hash !== this.hash) {
        this.debug(["Received bucket hash update", `  Old Hash  : ${this.hash}`, `  New Hash  : ${hash}`].join("\n"));
        this.manager.hashes.set(`${method}:${routeId.bucketRoute}`, { value: hash, lastAccess: Date.now() });
      } else if (hash) {
        const hashData = this.manager.hashes.get(`${method}:${routeId.bucketRoute}`);
        if (hashData) {
          hashData.lastAccess = Date.now();
        }
      }
      let sublimitTimeout = null;
      if (retryAfter > 0) {
        if (res.headers.has("X-RateLimit-Global")) {
          this.manager.globalRemaining = 0;
          this.manager.globalReset = Date.now() + retryAfter;
        } else if (!this.localLimited) {
          sublimitTimeout = retryAfter;
        }
      }
      if (status === 401 || status === 403 || status === 429) {
        incrementInvalidCount(this.manager);
      }
      if (res.ok) {
        return res;
      } else if (status === 429) {
        const isGlobal = this.globalLimited;
        let limit2;
        let timeout;
        if (isGlobal) {
          limit2 = this.manager.options.globalRequestsPerSecond;
          timeout = this.manager.globalReset + this.manager.options.offset - Date.now();
        } else {
          limit2 = this.limit;
          timeout = this.timeToReset;
        }
        await onRateLimit(this.manager, {
          timeToReset: timeout,
          limit: limit2,
          method,
          hash: this.hash,
          url,
          route: routeId.bucketRoute,
          majorParameter: this.majorParameter,
          global: isGlobal
        });
        this.debug([
          "Encountered unexpected 429 rate limit",
          `  Global         : ${isGlobal.toString()}`,
          `  Method         : ${method}`,
          `  URL            : ${url}`,
          `  Bucket         : ${routeId.bucketRoute}`,
          `  Major parameter: ${routeId.majorParameter}`,
          `  Hash           : ${this.hash}`,
          `  Limit          : ${limit2}`,
          `  Retry After    : ${retryAfter}ms`,
          `  Sublimit       : ${sublimitTimeout ? `${sublimitTimeout}ms` : "None"}`
        ].join("\n"));
        if (sublimitTimeout) {
          const firstSublimit = !this.#sublimitedQueue;
          if (firstSublimit) {
            this.#sublimitedQueue = new import_async_queue.AsyncQueue;
            this.#sublimitedQueue.wait();
            this.#asyncQueue.shift();
          }
          this.#sublimitPromise?.resolve();
          this.#sublimitPromise = null;
          await sleep(sublimitTimeout);
          let resolve;
          const promise = new Promise((res2) => resolve = res2);
          this.#sublimitPromise = { promise, resolve };
          if (firstSublimit) {
            await this.#asyncQueue.wait();
            this.#shiftSublimit = true;
          }
        }
        return this.runRequest(routeId, url, options, requestData, retries);
      } else {
        const handled = await handleErrors(this.manager, res, method, url, requestData, retries);
        if (handled === null) {
          return this.runRequest(routeId, url, options, requestData, ++retries);
        }
        return handled;
      }
    }
  };
  var REST = class _REST extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "REST");
    }
    agent = null;
    cdn;
    globalRemaining;
    globalDelay = null;
    globalReset = -1;
    hashes = new import_collection.Collection;
    handlers = new import_collection.Collection;
    #token = null;
    hashTimer;
    handlerTimer;
    options;
    constructor(options = {}) {
      super();
      this.cdn = new CDN(options.cdn ?? DefaultRestOptions.cdn);
      this.options = { ...DefaultRestOptions, ...options };
      this.options.offset = Math.max(0, this.options.offset);
      this.globalRemaining = Math.max(1, this.options.globalRequestsPerSecond);
      this.agent = options.agent ?? null;
      this.setupSweepers();
    }
    setupSweepers() {
      const validateMaxInterval = __name((interval) => {
        if (interval > 14400000) {
          throw new Error("Cannot set an interval greater than 4 hours");
        }
      }, "validateMaxInterval");
      if (this.options.hashSweepInterval !== 0 && this.options.hashSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.hashSweepInterval);
        this.hashTimer = setInterval(() => {
          const sweptHashes = new import_collection.Collection;
          const currentDate = Date.now();
          this.hashes.sweep((val, key) => {
            if (val.lastAccess === -1)
              return false;
            const shouldSweep = Math.floor(currentDate - val.lastAccess) > this.options.hashLifetime;
            if (shouldSweep) {
              sweptHashes.set(key, val);
              this.emit("restDebug", `Hash ${val.value} for ${key} swept due to lifetime being exceeded`);
            }
            return shouldSweep;
          });
          this.emit("hashSweep", sweptHashes);
        }, this.options.hashSweepInterval);
        this.hashTimer.unref?.();
      }
      if (this.options.handlerSweepInterval !== 0 && this.options.handlerSweepInterval !== Number.POSITIVE_INFINITY) {
        validateMaxInterval(this.options.handlerSweepInterval);
        this.handlerTimer = setInterval(() => {
          const sweptHandlers = new import_collection.Collection;
          this.handlers.sweep((val, key) => {
            const { inactive } = val;
            if (inactive) {
              sweptHandlers.set(key, val);
              this.emit("restDebug", `Handler ${val.id} for ${key} swept due to being inactive`);
            }
            return inactive;
          });
          this.emit("handlerSweep", sweptHandlers);
        }, this.options.handlerSweepInterval);
        this.handlerTimer.unref?.();
      }
    }
    async get(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "GET" });
    }
    async delete(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "DELETE" });
    }
    async post(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "POST" });
    }
    async put(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PUT" });
    }
    async patch(fullRoute, options = {}) {
      return this.request({ ...options, fullRoute, method: "PATCH" });
    }
    async request(options) {
      const response = await this.queueRequest(options);
      return parseResponse(response);
    }
    setAgent(agent) {
      this.agent = agent;
      return this;
    }
    setToken(token) {
      this.#token = token;
      return this;
    }
    async queueRequest(request2) {
      const routeId = _REST.generateRouteData(request2.fullRoute, request2.method);
      const hash = this.hashes.get(`${request2.method}:${routeId.bucketRoute}`) ?? {
        value: `Global(${request2.method}:${routeId.bucketRoute})`,
        lastAccess: -1
      };
      const handler = this.handlers.get(`${hash.value}:${routeId.majorParameter}`) ?? this.createHandler(hash.value, routeId.majorParameter);
      const { url, fetchOptions } = await this.resolveRequest(request2);
      return handler.queueRequest(routeId, url, fetchOptions, {
        body: request2.body,
        files: request2.files,
        auth: request2.auth !== false,
        signal: request2.signal
      });
    }
    createHandler(hash, majorParameter) {
      const queue = majorParameter === BurstHandlerMajorIdKey ? new BurstHandler(this, hash, majorParameter) : new SequentialHandler(this, hash, majorParameter);
      this.handlers.set(queue.id, queue);
      return queue;
    }
    async resolveRequest(request2) {
      const { options } = this;
      let query = "";
      if (request2.query) {
        const resolvedQuery = request2.query.toString();
        if (resolvedQuery !== "") {
          query = `?${resolvedQuery}`;
        }
      }
      const headers = {
        ...this.options.headers,
        "User-Agent": `${DefaultUserAgent} ${options.userAgentAppendix}`.trim()
      };
      if (request2.auth !== false) {
        if (!this.#token) {
          throw new Error("Expected token to be set for this request, but none was present");
        }
        headers.Authorization = `${request2.authPrefix ?? this.options.authPrefix} ${this.#token}`;
      }
      if (request2.reason?.length) {
        headers["X-Audit-Log-Reason"] = encodeURIComponent(request2.reason);
      }
      const url = `${options.api}${request2.versioned === false ? "" : `/v${options.version}`}${request2.fullRoute}${query}`;
      let finalBody;
      let additionalHeaders = {};
      if (request2.files?.length) {
        const formData = new FormData;
        for (const [index, file] of request2.files.entries()) {
          const fileKey = file.key ?? `files[${index}]`;
          if (isBufferLike(file.data)) {
            let contentType = file.contentType;
            if (!contentType) {
              const [parsedType] = (0, import_magic_bytes.filetypeinfo)(file.data);
              if (parsedType) {
                contentType = OverwrittenMimeTypes[parsedType.mime] ?? parsedType.mime ?? "application/octet-stream";
              }
            }
            formData.append(fileKey, new Blob([file.data], { type: contentType }), file.name);
          } else {
            formData.append(fileKey, new Blob([`${file.data}`], { type: file.contentType }), file.name);
          }
        }
        if (request2.body != null) {
          if (request2.appendToFormData) {
            for (const [key, value] of Object.entries(request2.body)) {
              formData.append(key, value);
            }
          } else {
            formData.append("payload_json", JSON.stringify(request2.body));
          }
        }
        finalBody = formData;
      } else if (request2.body != null) {
        if (request2.passThroughBody) {
          finalBody = request2.body;
        } else {
          finalBody = JSON.stringify(request2.body);
          additionalHeaders = { "Content-Type": "application/json" };
        }
      }
      const method = request2.method.toUpperCase();
      const fetchOptions = {
        body: ["GET", "HEAD"].includes(method) ? null : finalBody,
        headers: { ...request2.headers, ...additionalHeaders, ...headers },
        method,
        dispatcher: request2.dispatcher ?? this.agent ?? undefined
      };
      return { url, fetchOptions };
    }
    clearHashSweeper() {
      clearInterval(this.hashTimer);
    }
    clearHandlerSweeper() {
      clearInterval(this.handlerTimer);
    }
    static generateRouteData(endpoint, method) {
      if (endpoint.startsWith("/interactions/") && endpoint.endsWith("/callback")) {
        return {
          majorParameter: BurstHandlerMajorIdKey,
          bucketRoute: "/interactions/:id/:token/callback",
          original: endpoint
        };
      }
      const majorIdMatch = /^\/(?:channels|guilds|webhooks)\/(\d{17,19})/.exec(endpoint);
      const majorId = majorIdMatch?.[1] ?? "global";
      const baseRoute = endpoint.replaceAll(/\d{17,19}/g, ":id").replace(/\/reactions\/(.*)/, "/reactions/:reaction");
      let exceptions = "";
      if (method === "DELETE" && baseRoute === "/channels/:id/messages/:id") {
        const id = /\d{17,19}$/.exec(endpoint)[0];
        const timestamp = import_snowflake.DiscordSnowflake.timestampFrom(id);
        if (Date.now() - timestamp > 1000 * 60 * 60 * 24 * 14) {
          exceptions += "/Delete Old Message";
        }
      }
      return {
        majorParameter: majorId,
        bucketRoute: baseRoute + exceptions,
        original: endpoint
      };
    }
  };
  var version = "2.0.1";
  globalThis.FormData ??= import_undici2.FormData;
  globalThis.Blob ??= import_node_buffer.Blob;
  setDefaultStrategy((0, import_util2.shouldUseGlobalFetchAndWebSocket)() ? fetch : makeRequest);
});

// node_modules/discord.js/src/errors/ErrorCodes.js
var require_ErrorCodes = __commonJS((exports, module) => {
  var keys = [
    "ClientInvalidOption",
    "ClientInvalidProvidedShards",
    "ClientMissingIntents",
    "ClientNotReady",
    "TokenInvalid",
    "TokenMissing",
    "ApplicationCommandPermissionsTokenMissing",
    "WSCloseRequested",
    "WSConnectionExists",
    "WSNotOpen",
    "ManagerDestroyed",
    "BitFieldInvalid",
    "ShardingInvalid",
    "ShardingRequired",
    "InvalidIntents",
    "DisallowedIntents",
    "ShardingNoShards",
    "ShardingInProcess",
    "ShardingInvalidEvalBroadcast",
    "ShardingShardNotFound",
    "ShardingAlreadySpawned",
    "ShardingProcessExists",
    "ShardingWorkerExists",
    "ShardingReadyTimeout",
    "ShardingReadyDisconnected",
    "ShardingReadyDied",
    "ShardingNoChildExists",
    "ShardingShardMiscalculation",
    "ColorRange",
    "ColorConvert",
    "InviteOptionsMissingChannel",
    "ButtonLabel",
    "ButtonURL",
    "ButtonCustomId",
    "SelectMenuCustomId",
    "SelectMenuPlaceholder",
    "SelectOptionLabel",
    "SelectOptionValue",
    "SelectOptionDescription",
    "InteractionCollectorError",
    "FileNotFound",
    "UserBannerNotFetched",
    "UserNoDMChannel",
    "VoiceNotStageChannel",
    "VoiceStateNotOwn",
    "VoiceStateInvalidType",
    "ReqResourceType",
    "ImageFormat",
    "ImageSize",
    "MessageBulkDeleteType",
    "MessageNonceType",
    "MessageContentType",
    "SplitMaxLen",
    "BanResolveId",
    "FetchBanResolveId",
    "PruneDaysType",
    "GuildChannelResolve",
    "GuildVoiceChannelResolve",
    "GuildChannelOrphan",
    "GuildChannelUnowned",
    "GuildOwned",
    "GuildMembersTimeout",
    "GuildUncachedMe",
    "ChannelNotCached",
    "StageChannelResolve",
    "GuildScheduledEventResolve",
    "FetchOwnerId",
    "InvalidType",
    "InvalidElement",
    "MessageThreadParent",
    "MessageExistingThread",
    "ThreadInvitableType",
    "WebhookMessage",
    "WebhookTokenUnavailable",
    "WebhookURLInvalid",
    "WebhookApplication",
    "MessageReferenceMissing",
    "EmojiType",
    "EmojiManaged",
    "MissingManageGuildExpressionsPermission",
    "MissingManageEmojisAndStickersPermission",
    "NotGuildSticker",
    "ReactionResolveUser",
    "VanityURL",
    "InviteResolveCode",
    "InviteNotFound",
    "DeleteGroupDMChannel",
    "FetchGroupDMChannel",
    "MemberFetchNonceLength",
    "GlobalCommandPermissions",
    "GuildUncachedEntityResolve",
    "InteractionAlreadyReplied",
    "InteractionNotReplied",
    "InteractionEphemeralReplied",
    "CommandInteractionOptionNotFound",
    "CommandInteractionOptionType",
    "CommandInteractionOptionEmpty",
    "CommandInteractionOptionNoSubcommand",
    "CommandInteractionOptionNoSubcommandGroup",
    "CommandInteractionOptionInvalidChannelType",
    "AutocompleteInteractionOptionNoFocusedOption",
    "ModalSubmitInteractionFieldNotFound",
    "ModalSubmitInteractionFieldType",
    "InvalidMissingScopes",
    "InvalidScopesWithPermissions",
    "NotImplemented",
    "SweepFilterReturn",
    "GuildForumMessageRequired"
  ];
  module.exports = Object.fromEntries(keys.map((key) => [key, key]));
});

// node_modules/discord.js/src/errors/Messages.js
var require_Messages = __commonJS((exports, module) => {
  var DjsErrorCodes = require_ErrorCodes();
  var Messages = {
    [DjsErrorCodes.ClientInvalidOption]: (prop, must) => `The ${prop} option must be ${must}`,
    [DjsErrorCodes.ClientInvalidProvidedShards]: "None of the provided shards were valid.",
    [DjsErrorCodes.ClientMissingIntents]: "Valid intents must be provided for the Client.",
    [DjsErrorCodes.ClientNotReady]: (action) => `The client needs to be logged in to ${action}.`,
    [DjsErrorCodes.TokenInvalid]: "An invalid token was provided.",
    [DjsErrorCodes.TokenMissing]: "Request to use token, but token was unavailable to the client.",
    [DjsErrorCodes.ApplicationCommandPermissionsTokenMissing]: "Editing application command permissions requires an OAuth2 bearer token, but none was provided.",
    [DjsErrorCodes.WSCloseRequested]: "WebSocket closed due to user request.",
    [DjsErrorCodes.WSConnectionExists]: "There is already an existing WebSocket connection.",
    [DjsErrorCodes.WSNotOpen]: (data = "data") => `WebSocket not open to send ${data}`,
    [DjsErrorCodes.ManagerDestroyed]: "Manager was destroyed.",
    [DjsErrorCodes.BitFieldInvalid]: (bit) => `Invalid bitfield flag or number: ${bit}.`,
    [DjsErrorCodes.ShardingInvalid]: "Invalid shard settings were provided.",
    [DjsErrorCodes.ShardingRequired]: "This session would have handled too many guilds - Sharding is required.",
    [DjsErrorCodes.InvalidIntents]: "Invalid intent provided for WebSocket intents.",
    [DjsErrorCodes.DisallowedIntents]: "Privileged intent provided is not enabled or whitelisted.",
    [DjsErrorCodes.ShardingNoShards]: "No shards have been spawned.",
    [DjsErrorCodes.ShardingInProcess]: "Shards are still being spawned.",
    [DjsErrorCodes.ShardingInvalidEvalBroadcast]: "Script to evaluate must be a function",
    [DjsErrorCodes.ShardingShardNotFound]: (id) => `Shard ${id} could not be found.`,
    [DjsErrorCodes.ShardingAlreadySpawned]: (count) => `Already spawned ${count} shards.`,
    [DjsErrorCodes.ShardingProcessExists]: (id) => `Shard ${id} already has an active process.`,
    [DjsErrorCodes.ShardingWorkerExists]: (id) => `Shard ${id} already has an active worker.`,
    [DjsErrorCodes.ShardingReadyTimeout]: (id) => `Shard ${id}'s Client took too long to become ready.`,
    [DjsErrorCodes.ShardingReadyDisconnected]: (id) => `Shard ${id}'s Client disconnected before becoming ready.`,
    [DjsErrorCodes.ShardingReadyDied]: (id) => `Shard ${id}'s process exited before its Client became ready.`,
    [DjsErrorCodes.ShardingNoChildExists]: (id) => `Shard ${id} has no active process or worker.`,
    [DjsErrorCodes.ShardingShardMiscalculation]: (shard, guild, count) => `Calculated invalid shard ${shard} for guild ${guild} with ${count} shards.`,
    [DjsErrorCodes.ColorRange]: "Color must be within the range 0 - 16777215 (0xFFFFFF).",
    [DjsErrorCodes.ColorConvert]: "Unable to convert color to a number.",
    [DjsErrorCodes.InviteOptionsMissingChannel]: "A valid guild channel must be provided when GuildScheduledEvent is EXTERNAL.",
    [DjsErrorCodes.ButtonLabel]: "MessageButton label must be a string",
    [DjsErrorCodes.ButtonURL]: "MessageButton URL must be a string",
    [DjsErrorCodes.ButtonCustomId]: "MessageButton customId must be a string",
    [DjsErrorCodes.SelectMenuCustomId]: "MessageSelectMenu customId must be a string",
    [DjsErrorCodes.SelectMenuPlaceholder]: "MessageSelectMenu placeholder must be a string",
    [DjsErrorCodes.SelectOptionLabel]: "MessageSelectOption label must be a string",
    [DjsErrorCodes.SelectOptionValue]: "MessageSelectOption value must be a string",
    [DjsErrorCodes.SelectOptionDescription]: "MessageSelectOption description must be a string",
    [DjsErrorCodes.InteractionCollectorError]: (reason) => `Collector received no interactions before ending with reason: ${reason}`,
    [DjsErrorCodes.FileNotFound]: (file) => `File could not be found: ${file}`,
    [DjsErrorCodes.UserBannerNotFetched]: "You must fetch this user's banner before trying to generate its URL!",
    [DjsErrorCodes.UserNoDMChannel]: "No DM Channel exists!",
    [DjsErrorCodes.VoiceNotStageChannel]: "You are only allowed to do this in stage channels.",
    [DjsErrorCodes.VoiceStateNotOwn]: "You cannot self-deafen/mute/request to speak on VoiceStates that do not belong to the ClientUser.",
    [DjsErrorCodes.VoiceStateInvalidType]: (name) => `${name} must be a boolean.`,
    [DjsErrorCodes.ReqResourceType]: "The resource must be a string, Buffer or a valid file stream.",
    [DjsErrorCodes.ImageFormat]: (format) => `Invalid image format: ${format}`,
    [DjsErrorCodes.ImageSize]: (size) => `Invalid image size: ${size}`,
    [DjsErrorCodes.MessageBulkDeleteType]: "The messages must be an Array, Collection, or number.",
    [DjsErrorCodes.MessageNonceType]: "Message nonce must be an integer or a string.",
    [DjsErrorCodes.MessageContentType]: "Message content must be a string.",
    [DjsErrorCodes.SplitMaxLen]: "Chunk exceeds the max length and contains no split characters.",
    [DjsErrorCodes.BanResolveId]: (ban = false) => `Couldn't resolve the user id to ${ban ? "ban" : "unban"}.`,
    [DjsErrorCodes.FetchBanResolveId]: "Couldn't resolve the user id to fetch the ban.",
    [DjsErrorCodes.PruneDaysType]: "Days must be a number",
    [DjsErrorCodes.GuildChannelResolve]: "Could not resolve channel to a guild channel.",
    [DjsErrorCodes.GuildVoiceChannelResolve]: "Could not resolve channel to a guild voice channel.",
    [DjsErrorCodes.GuildChannelOrphan]: "Could not find a parent to this guild channel.",
    [DjsErrorCodes.GuildChannelUnowned]: "The fetched channel does not belong to this manager's guild.",
    [DjsErrorCodes.GuildOwned]: "Guild is owned by the client.",
    [DjsErrorCodes.GuildMembersTimeout]: "Members didn't arrive in time.",
    [DjsErrorCodes.GuildUncachedMe]: "The client user as a member of this guild is uncached.",
    [DjsErrorCodes.ChannelNotCached]: "Could not find the channel where this message came from in the cache!",
    [DjsErrorCodes.StageChannelResolve]: "Could not resolve channel to a stage channel.",
    [DjsErrorCodes.GuildScheduledEventResolve]: "Could not resolve the guild scheduled event.",
    [DjsErrorCodes.FetchOwnerId]: "Couldn't resolve the guild ownerId to fetch the member.",
    [DjsErrorCodes.InvalidType]: (name, expected, an = false) => `Supplied ${name} is not a${an ? "n" : ""} ${expected}.`,
    [DjsErrorCodes.InvalidElement]: (type, name, elem) => `Supplied ${type} ${name} includes an invalid element: ${elem}`,
    [DjsErrorCodes.MessageThreadParent]: "The message was not sent in a guild text or news channel",
    [DjsErrorCodes.MessageExistingThread]: "The message already has a thread",
    [DjsErrorCodes.ThreadInvitableType]: (type) => `Invitable cannot be edited on ${type}`,
    [DjsErrorCodes.WebhookMessage]: "The message was not sent by a webhook.",
    [DjsErrorCodes.WebhookTokenUnavailable]: "This action requires a webhook token, but none is available.",
    [DjsErrorCodes.WebhookURLInvalid]: "The provided webhook URL is not valid.",
    [DjsErrorCodes.WebhookApplication]: "This message webhook belongs to an application and cannot be fetched.",
    [DjsErrorCodes.MessageReferenceMissing]: "The message does not reference another message",
    [DjsErrorCodes.EmojiType]: "Emoji must be a string or GuildEmoji/ReactionEmoji",
    [DjsErrorCodes.EmojiManaged]: "Emoji is managed and has no Author.",
    [DjsErrorCodes.MissingManageGuildExpressionsPermission]: (guild) => `Client must have Manage Guild Expressions permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.MissingManageEmojisAndStickersPermission]: (guild) => `Client must have Manage Emojis and Stickers permission in guild ${guild} to see emoji authors.`,
    [DjsErrorCodes.NotGuildSticker]: "Sticker is a standard (non-guild) sticker and has no author.",
    [DjsErrorCodes.ReactionResolveUser]: "Couldn't resolve the user id to remove from the reaction.",
    [DjsErrorCodes.VanityURL]: "This guild does not have the vanity URL feature enabled.",
    [DjsErrorCodes.InviteResolveCode]: "Could not resolve the code to fetch the invite.",
    [DjsErrorCodes.InviteNotFound]: "Could not find the requested invite.",
    [DjsErrorCodes.DeleteGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot delete them",
    [DjsErrorCodes.FetchGroupDMChannel]: "Bots don't have access to Group DM Channels and cannot fetch them",
    [DjsErrorCodes.MemberFetchNonceLength]: "Nonce length must not exceed 32 characters.",
    [DjsErrorCodes.GlobalCommandPermissions]: "Permissions for global commands may only be fetched or modified by providing a GuildResolvable or from a guild's application command manager.",
    [DjsErrorCodes.GuildUncachedEntityResolve]: (type) => `Cannot resolve ${type} from an arbitrary guild, provide an id instead`,
    [DjsErrorCodes.InteractionAlreadyReplied]: "The reply to this interaction has already been sent or deferred.",
    [DjsErrorCodes.InteractionNotReplied]: "The reply to this interaction has not been sent or deferred.",
    [DjsErrorCodes.InteractionEphemeralReplied]: "Ephemeral responses cannot be deleted.",
    [DjsErrorCodes.CommandInteractionOptionNotFound]: (name) => `Required option "${name}" not found.`,
    [DjsErrorCodes.CommandInteractionOptionType]: (name, type, expected) => `Option "${name}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.CommandInteractionOptionEmpty]: (name, type) => `Required option "${name}" is of type: ${type}; expected a non-empty value.`,
    [DjsErrorCodes.CommandInteractionOptionNoSubcommand]: "No subcommand specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionNoSubcommandGroup]: "No subcommand group specified for interaction.",
    [DjsErrorCodes.CommandInteractionOptionInvalidChannelType]: (name, type, expected) => `The type of channel of the option "${name}" is: ${type}; expected ${expected}.`,
    [DjsErrorCodes.AutocompleteInteractionOptionNoFocusedOption]: "No focused option for autocomplete interaction.",
    [DjsErrorCodes.ModalSubmitInteractionFieldNotFound]: (customId) => `Required field with custom id "${customId}" not found.`,
    [DjsErrorCodes.ModalSubmitInteractionFieldType]: (customId, type, expected) => `Field with custom id "${customId}" is of type: ${type}; expected ${expected}.`,
    [DjsErrorCodes.InvalidMissingScopes]: "At least one valid scope must be provided for the invite",
    [DjsErrorCodes.InvalidScopesWithPermissions]: "Permissions cannot be set without the bot scope.",
    [DjsErrorCodes.NotImplemented]: (what, name) => `Method ${what} not implemented on ${name}.`,
    [DjsErrorCodes.SweepFilterReturn]: "The return value of the sweepFilter function was not false or a Function",
    [DjsErrorCodes.GuildForumMessageRequired]: "You must provide a message to create a guild forum thread"
  };
  module.exports = Messages;
});

// node_modules/discord.js/src/errors/DJSError.js
var require_DJSError = __commonJS((exports, module) => {
  var makeDiscordjsError = function(Base) {
    return class DiscordjsError extends Base {
      constructor(code, ...args) {
        super(message(code, args));
        this.code = code;
        Error.captureStackTrace?.(this, DiscordjsError);
      }
      get name() {
        return `${super.name} [${this.code}]`;
      }
    };
  };
  var message = function(code, args) {
    if (!(code in ErrorCodes))
      throw new Error("Error code must be a valid DiscordjsErrorCodes");
    const msg = Messages[code];
    if (!msg)
      throw new Error(`No message associated with error code: ${code}.`);
    if (typeof msg === "function")
      return msg(...args);
    if (!args?.length)
      return msg;
    args.unshift(msg);
    return String(...args);
  };
  var ErrorCodes = require_ErrorCodes();
  var Messages = require_Messages();
  module.exports = {
    DiscordjsError: makeDiscordjsError(Error),
    DiscordjsTypeError: makeDiscordjsError(TypeError),
    DiscordjsRangeError: makeDiscordjsError(RangeError)
  };
});

// node_modules/discord.js/src/errors/index.js
var require_errors2 = __commonJS((exports, module) => {
  module.exports = require_DJSError();
  module.exports.ErrorCodes = require_ErrorCodes();
  module.exports.Messages = require_Messages();
});

// node_modules/lodash.snakecase/index.js
var require_lodash = __commonJS((exports, module) => {
  var arrayReduce = function(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  };
  var asciiWords = function(string) {
    return string.match(reAsciiWord) || [];
  };
  var basePropertyOf = function(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  };
  var hasUnicodeWord = function(string) {
    return reHasUnicodeWord.test(string);
  };
  var unicodeWords = function(string) {
    return string.match(reUnicodeWord) || [];
  };
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var createCompounder = function(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
    };
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  };
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var deburr = function(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
  };
  var words = function(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  };
  var INFINITY = 1 / 0;
  var symbolTag = "[object Symbol]";
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsDingbatRange = "\\u2700-\\u27bf";
  var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
  var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
  var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
  var rsPunctuationRange = "\\u2000-\\u206f";
  var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
  var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
  var rsApos = "['\u2019]";
  var rsBreak = "[" + rsBreakRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsDigits = "\\d+";
  var rsDingbat = "[" + rsDingbatRange + "]";
  var rsLower = "[" + rsLowerRange + "]";
  var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsUpper = "[" + rsUpperRange + "]";
  var rsZWJ = "\\u200d";
  var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
  var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
  var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
  var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
  var reApos = RegExp(rsApos, "g");
  var reComboMark = RegExp(rsCombo, "g");
  var reUnicodeWord = RegExp([
    rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
    rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
    rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
    rsUpper + "+" + rsOptUpperContr,
    rsDigits,
    rsEmoji
  ].join("|"), "g");
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
  var deburredLetters = {
    "\xC0": "A",
    "\xC1": "A",
    "\xC2": "A",
    "\xC3": "A",
    "\xC4": "A",
    "\xC5": "A",
    "\xE0": "a",
    "\xE1": "a",
    "\xE2": "a",
    "\xE3": "a",
    "\xE4": "a",
    "\xE5": "a",
    "\xC7": "C",
    "\xE7": "c",
    "\xD0": "D",
    "\xF0": "d",
    "\xC8": "E",
    "\xC9": "E",
    "\xCA": "E",
    "\xCB": "E",
    "\xE8": "e",
    "\xE9": "e",
    "\xEA": "e",
    "\xEB": "e",
    "\xCC": "I",
    "\xCD": "I",
    "\xCE": "I",
    "\xCF": "I",
    "\xEC": "i",
    "\xED": "i",
    "\xEE": "i",
    "\xEF": "i",
    "\xD1": "N",
    "\xF1": "n",
    "\xD2": "O",
    "\xD3": "O",
    "\xD4": "O",
    "\xD5": "O",
    "\xD6": "O",
    "\xD8": "O",
    "\xF2": "o",
    "\xF3": "o",
    "\xF4": "o",
    "\xF5": "o",
    "\xF6": "o",
    "\xF8": "o",
    "\xD9": "U",
    "\xDA": "U",
    "\xDB": "U",
    "\xDC": "U",
    "\xF9": "u",
    "\xFA": "u",
    "\xFB": "u",
    "\xFC": "u",
    "\xDD": "Y",
    "\xFD": "y",
    "\xFF": "y",
    "\xC6": "Ae",
    "\xE6": "ae",
    "\xDE": "Th",
    "\xFE": "th",
    "\xDF": "ss",
    "\u0100": "A",
    "\u0102": "A",
    "\u0104": "A",
    "\u0101": "a",
    "\u0103": "a",
    "\u0105": "a",
    "\u0106": "C",
    "\u0108": "C",
    "\u010A": "C",
    "\u010C": "C",
    "\u0107": "c",
    "\u0109": "c",
    "\u010B": "c",
    "\u010D": "c",
    "\u010E": "D",
    "\u0110": "D",
    "\u010F": "d",
    "\u0111": "d",
    "\u0112": "E",
    "\u0114": "E",
    "\u0116": "E",
    "\u0118": "E",
    "\u011A": "E",
    "\u0113": "e",
    "\u0115": "e",
    "\u0117": "e",
    "\u0119": "e",
    "\u011B": "e",
    "\u011C": "G",
    "\u011E": "G",
    "\u0120": "G",
    "\u0122": "G",
    "\u011D": "g",
    "\u011F": "g",
    "\u0121": "g",
    "\u0123": "g",
    "\u0124": "H",
    "\u0126": "H",
    "\u0125": "h",
    "\u0127": "h",
    "\u0128": "I",
    "\u012A": "I",
    "\u012C": "I",
    "\u012E": "I",
    "\u0130": "I",
    "\u0129": "i",
    "\u012B": "i",
    "\u012D": "i",
    "\u012F": "i",
    "\u0131": "i",
    "\u0134": "J",
    "\u0135": "j",
    "\u0136": "K",
    "\u0137": "k",
    "\u0138": "k",
    "\u0139": "L",
    "\u013B": "L",
    "\u013D": "L",
    "\u013F": "L",
    "\u0141": "L",
    "\u013A": "l",
    "\u013C": "l",
    "\u013E": "l",
    "\u0140": "l",
    "\u0142": "l",
    "\u0143": "N",
    "\u0145": "N",
    "\u0147": "N",
    "\u014A": "N",
    "\u0144": "n",
    "\u0146": "n",
    "\u0148": "n",
    "\u014B": "n",
    "\u014C": "O",
    "\u014E": "O",
    "\u0150": "O",
    "\u014D": "o",
    "\u014F": "o",
    "\u0151": "o",
    "\u0154": "R",
    "\u0156": "R",
    "\u0158": "R",
    "\u0155": "r",
    "\u0157": "r",
    "\u0159": "r",
    "\u015A": "S",
    "\u015C": "S",
    "\u015E": "S",
    "\u0160": "S",
    "\u015B": "s",
    "\u015D": "s",
    "\u015F": "s",
    "\u0161": "s",
    "\u0162": "T",
    "\u0164": "T",
    "\u0166": "T",
    "\u0163": "t",
    "\u0165": "t",
    "\u0167": "t",
    "\u0168": "U",
    "\u016A": "U",
    "\u016C": "U",
    "\u016E": "U",
    "\u0170": "U",
    "\u0172": "U",
    "\u0169": "u",
    "\u016B": "u",
    "\u016D": "u",
    "\u016F": "u",
    "\u0171": "u",
    "\u0173": "u",
    "\u0174": "W",
    "\u0175": "w",
    "\u0176": "Y",
    "\u0177": "y",
    "\u0178": "Y",
    "\u0179": "Z",
    "\u017B": "Z",
    "\u017D": "Z",
    "\u017A": "z",
    "\u017C": "z",
    "\u017E": "z",
    "\u0132": "IJ",
    "\u0133": "ij",
    "\u0152": "Oe",
    "\u0153": "oe",
    "\u0149": "'n",
    "\u017F": "ss"
  };
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var deburrLetter = basePropertyOf(deburredLetters);
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  var snakeCase = createCompounder(function(result, word, index) {
    return result + (index ? "_" : "") + word.toLowerCase();
  });
  module.exports = snakeCase;
});

// node_modules/discord.js/src/util/Transformers.js
var require_Transformers = __commonJS((exports, module) => {
  var toSnakeCase = function(obj) {
    if (typeof obj !== "object" || !obj)
      return obj;
    if (obj instanceof Date)
      return obj;
    if (isJSONEncodable(obj))
      return toSnakeCase(obj.toJSON());
    if (Array.isArray(obj))
      return obj.map(toSnakeCase);
    return Object.fromEntries(Object.entries(obj).map(([key, value]) => [snakeCase(key), toSnakeCase(value)]));
  };
  var _transformAPIAutoModerationAction = function(autoModerationAction) {
    return {
      type: autoModerationAction.type,
      metadata: {
        durationSeconds: autoModerationAction.metadata.duration_seconds ?? null,
        channelId: autoModerationAction.metadata.channel_id ?? null,
        customMessage: autoModerationAction.metadata.custom_message ?? null
      }
    };
  };
  var { isJSONEncodable } = require_dist();
  var snakeCase = require_lodash();
  module.exports = { toSnakeCase, _transformAPIAutoModerationAction };
});

// node_modules/discord.js/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "discord.js",
    version: "14.13.0",
    description: "A powerful library for interacting with the Discord API",
    scripts: {
      test: "yarn docs:test && yarn test:typescript",
      "test:typescript": "tsc --noEmit && tsd",
      lint: "prettier --check . && tslint typings/index.d.ts && eslint src --format=pretty",
      format: "prettier --write . && eslint src --fix --format=pretty",
      fmt: "yarn format",
      docs: "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../ -o ./docs/docs.json",
      "docs:test": "docgen -i './src/*.js' './src/**/*.js' -c ./docs/index.json -r ../../",
      prepack: "yarn lint && yarn test",
      changelog: "git cliff --prepend ./CHANGELOG.md -u -c ./cliff.toml -r ../../ --include-path 'packages/discord.js/*'",
      release: "cliff-jumper"
    },
    main: "./src/index.js",
    types: "./typings/index.d.ts",
    directories: {
      lib: "src",
      test: "test"
    },
    files: [
      "src",
      "typings"
    ],
    contributors: [
      "Crawl <icrawltogo@gmail.com>",
      "Amish Shah <amishshah.2k@gmail.com>",
      "Vlad Frangu <kingdgrizzle@gmail.com>",
      "SpaceEEC <spaceeec@yahoo.com>",
      "Aura Rom\xE1n <kyradiscord@gmail.com>"
    ],
    license: "Apache-2.0",
    keywords: [
      "discord",
      "api",
      "bot",
      "client",
      "node",
      "discordapp"
    ],
    repository: {
      type: "git",
      url: "https://github.com/discordjs/discord.js.git",
      directory: "packages/discord.js"
    },
    bugs: {
      url: "https://github.com/discordjs/discord.js/issues"
    },
    homepage: "https://discord.js.org",
    dependencies: {
      "@discordjs/builders": "^1.6.5",
      "@discordjs/collection": "^1.5.3",
      "@discordjs/formatters": "^0.3.2",
      "@discordjs/rest": "^2.0.1",
      "@discordjs/util": "^1.0.1",
      "@discordjs/ws": "^1.0.1",
      "@sapphire/snowflake": "^3.5.1",
      "@types/ws": "^8.5.5",
      "discord-api-types": "0.37.50",
      "fast-deep-equal": "^3.1.3",
      "lodash.snakecase": "^4.1.1",
      tslib: "^2.6.1",
      undici: "5.22.1",
      ws: "^8.13.0"
    },
    devDependencies: {
      "@discordjs/docgen": "^0.12.1",
      "@favware/cliff-jumper": "^2.1.1",
      "@types/node": "16.18.40",
      dtslint: "^4.2.1",
      eslint: "^8.47.0",
      "eslint-formatter-pretty": "^5.0.0",
      jest: "^29.6.2",
      prettier: "^2.8.8",
      tsd: "^0.28.1",
      tslint: "^6.1.3",
      turbo: "^1.10.12",
      typescript: "^5.1.6"
    },
    engines: {
      node: ">=16.11.0"
    }
  };
});

// node_modules/discord.js/src/util/LimitedCollection.js
var require_LimitedCollection = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class LimitedCollection extends Collection {
    constructor(options = {}, iterable) {
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      const { maxSize = Infinity, keepOverLimit = null } = options;
      if (typeof maxSize !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "maxSize", "number");
      }
      if (keepOverLimit !== null && typeof keepOverLimit !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "keepOverLimit", "function");
      }
      super(iterable);
      this.maxSize = maxSize;
      this.keepOverLimit = keepOverLimit;
    }
    set(key, value) {
      if (this.maxSize === 0 && !this.keepOverLimit?.(value, key, this))
        return this;
      if (this.size >= this.maxSize && !this.has(key)) {
        for (const [k, v] of this.entries()) {
          const keep = this.keepOverLimit?.(v, k, this) ?? false;
          if (!keep) {
            this.delete(k);
            break;
          }
        }
      }
      return super.set(key, value);
    }
    static get [Symbol.species]() {
      return Collection;
    }
  }
  module.exports = LimitedCollection;
});

// node_modules/discord.js/src/util/Options.js
var require_Options = __commonJS((exports, module) => {
  var { DefaultRestOptions, DefaultUserAgentAppendix } = require_dist7();
  var { toSnakeCase } = require_Transformers();
  var { version } = require_package();

  class Options extends null {
    static userAgentAppendix = `discord.js/${version} ${DefaultUserAgentAppendix}`.trimEnd();
    static createDefault() {
      return {
        closeTimeout: 5000,
        waitGuildTimeout: 15000,
        shardCount: 1,
        makeCache: this.cacheWithLimits(this.DefaultMakeCacheSettings),
        partials: [],
        failIfNotExists: true,
        presence: {},
        sweepers: this.DefaultSweeperSettings,
        ws: {
          large_threshold: 50,
          version: 10
        },
        rest: {
          ...DefaultRestOptions,
          userAgentAppendix: this.userAgentAppendix
        },
        jsonTransformer: toSnakeCase
      };
    }
    static cacheWithLimits(settings = {}) {
      const { Collection } = require_dist2();
      const LimitedCollection = require_LimitedCollection();
      return (managerType, _, manager) => {
        const setting = settings[manager.name] ?? settings[managerType.name];
        if (setting == null) {
          return new Collection;
        }
        if (typeof setting === "number") {
          if (setting === Infinity) {
            return new Collection;
          }
          return new LimitedCollection({ maxSize: setting });
        }
        const noLimit = setting.maxSize == null || setting.maxSize === Infinity;
        if (noLimit) {
          return new Collection;
        }
        return new LimitedCollection(setting);
      };
    }
    static cacheEverything() {
      const { Collection } = require_dist2();
      return () => new Collection;
    }
    static get DefaultMakeCacheSettings() {
      return {
        MessageManager: 200
      };
    }
    static get DefaultSweeperSettings() {
      return {
        threads: {
          interval: 3600,
          lifetime: 14400
        }
      };
    }
  }
  module.exports = Options;
});

// node_modules/discord.js/src/util/Colors.js
var require_Colors = __commonJS((exports, module) => {
  module.exports = {
    Default: 0,
    White: 16777215,
    Aqua: 1752220,
    Green: 5763719,
    Blue: 3447003,
    Yellow: 16705372,
    Purple: 10181046,
    LuminousVividPink: 15277667,
    Fuchsia: 15418782,
    Gold: 15844367,
    Orange: 15105570,
    Red: 15548997,
    Grey: 9807270,
    Navy: 3426654,
    DarkAqua: 1146986,
    DarkGreen: 2067276,
    DarkBlue: 2123412,
    DarkPurple: 7419530,
    DarkVividPink: 11342935,
    DarkGold: 12745742,
    DarkOrange: 11027200,
    DarkRed: 10038562,
    DarkGrey: 9936031,
    DarkerGrey: 8359053,
    LightGrey: 12370112,
    DarkNavy: 2899536,
    Blurple: 5793266,
    Greyple: 10070709,
    DarkButNotBlack: 2895667,
    NotQuiteBlack: 2303786
  };
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports, module) => {
  var isArray = Array.isArray;
  module.exports = isArray;
});

// node_modules/lodash/_freeGlobal.js
var require__freeGlobal = __commonJS((exports, module) => {
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  module.exports = freeGlobal;
});

// node_modules/lodash/_root.js
var require__root = __commonJS((exports, module) => {
  var freeGlobal = require__freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  module.exports = root;
});

// node_modules/lodash/_Symbol.js
var require__Symbol = __commonJS((exports, module) => {
  var root = require__root();
  var Symbol2 = root.Symbol;
  module.exports = Symbol2;
});

// node_modules/lodash/_getRawTag.js
var require__getRawTag = __commonJS((exports, module) => {
  var getRawTag = function(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = undefined;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  };
  var Symbol2 = require__Symbol();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = getRawTag;
});

// node_modules/lodash/_objectToString.js
var require__objectToString = __commonJS((exports, module) => {
  var objectToString = function(value) {
    return nativeObjectToString.call(value);
  };
  var objectProto = Object.prototype;
  var nativeObjectToString = objectProto.toString;
  module.exports = objectToString;
});

// node_modules/lodash/_baseGetTag.js
var require__baseGetTag = __commonJS((exports, module) => {
  var baseGetTag = function(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && (symToStringTag in Object(value)) ? getRawTag(value) : objectToString(value);
  };
  var Symbol2 = require__Symbol();
  var getRawTag = require__getRawTag();
  var objectToString = require__objectToString();
  var nullTag = "[object Null]";
  var undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined;
  module.exports = baseGetTag;
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS((exports, module) => {
  var isObjectLike = function(value) {
    return value != null && typeof value == "object";
  };
  module.exports = isObjectLike;
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS((exports, module) => {
  var isSymbol = function(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObjectLike = require_isObjectLike();
  var symbolTag = "[object Symbol]";
  module.exports = isSymbol;
});

// node_modules/lodash/_isKey.js
var require__isKey = __commonJS((exports, module) => {
  var isKey = function(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && (value in Object(object));
  };
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  module.exports = isKey;
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports, module) => {
  var isObject = function(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  };
  module.exports = isObject;
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS((exports, module) => {
  var isFunction = function(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  };
  var baseGetTag = require__baseGetTag();
  var isObject = require_isObject();
  var asyncTag = "[object AsyncFunction]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var proxyTag = "[object Proxy]";
  module.exports = isFunction;
});

// node_modules/lodash/_coreJsData.js
var require__coreJsData = __commonJS((exports, module) => {
  var root = require__root();
  var coreJsData = root["__core-js_shared__"];
  module.exports = coreJsData;
});

// node_modules/lodash/_isMasked.js
var require__isMasked = __commonJS((exports, module) => {
  var isMasked = function(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  };
  var coreJsData = require__coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  module.exports = isMasked;
});

// node_modules/lodash/_toSource.js
var require__toSource = __commonJS((exports, module) => {
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  };
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  module.exports = toSource;
});

// node_modules/lodash/_baseIsNative.js
var require__baseIsNative = __commonJS((exports, module) => {
  var baseIsNative = function(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  };
  var isFunction = require_isFunction();
  var isMasked = require__isMasked();
  var isObject = require_isObject();
  var toSource = require__toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  module.exports = baseIsNative;
});

// node_modules/lodash/_getValue.js
var require__getValue = __commonJS((exports, module) => {
  var getValue = function(object, key) {
    return object == null ? undefined : object[key];
  };
  module.exports = getValue;
});

// node_modules/lodash/_getNative.js
var require__getNative = __commonJS((exports, module) => {
  var getNative = function(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  };
  var baseIsNative = require__baseIsNative();
  var getValue = require__getValue();
  module.exports = getNative;
});

// node_modules/lodash/_nativeCreate.js
var require__nativeCreate = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var nativeCreate = getNative(Object, "create");
  module.exports = nativeCreate;
});

// node_modules/lodash/_hashClear.js
var require__hashClear = __commonJS((exports, module) => {
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  };
  var nativeCreate = require__nativeCreate();
  module.exports = hashClear;
});

// node_modules/lodash/_hashDelete.js
var require__hashDelete = __commonJS((exports, module) => {
  var hashDelete = function(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  };
  module.exports = hashDelete;
});

// node_modules/lodash/_hashGet.js
var require__hashGet = __commonJS((exports, module) => {
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashGet;
});

// node_modules/lodash/_hashHas.js
var require__hashHas = __commonJS((exports, module) => {
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  };
  var nativeCreate = require__nativeCreate();
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  module.exports = hashHas;
});

// node_modules/lodash/_hashSet.js
var require__hashSet = __commonJS((exports, module) => {
  var hashSet = function(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  };
  var nativeCreate = require__nativeCreate();
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = hashSet;
});

// node_modules/lodash/_Hash.js
var require__Hash = __commonJS((exports, module) => {
  var Hash = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = require__hashClear();
  var hashDelete = require__hashDelete();
  var hashGet = require__hashGet();
  var hashHas = require__hashHas();
  var hashSet = require__hashSet();
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  module.exports = Hash;
});

// node_modules/lodash/_listCacheClear.js
var require__listCacheClear = __commonJS((exports, module) => {
  var listCacheClear = function() {
    this.__data__ = [];
    this.size = 0;
  };
  module.exports = listCacheClear;
});

// node_modules/lodash/eq.js
var require_eq = __commonJS((exports, module) => {
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  module.exports = eq;
});

// node_modules/lodash/_assocIndexOf.js
var require__assocIndexOf = __commonJS((exports, module) => {
  var assocIndexOf = function(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var eq = require_eq();
  module.exports = assocIndexOf;
});

// node_modules/lodash/_listCacheDelete.js
var require__listCacheDelete = __commonJS((exports, module) => {
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  };
  var assocIndexOf = require__assocIndexOf();
  var arrayProto = Array.prototype;
  var splice = arrayProto.splice;
  module.exports = listCacheDelete;
});

// node_modules/lodash/_listCacheGet.js
var require__listCacheGet = __commonJS((exports, module) => {
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheGet;
});

// node_modules/lodash/_listCacheHas.js
var require__listCacheHas = __commonJS((exports, module) => {
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheHas;
});

// node_modules/lodash/_listCacheSet.js
var require__listCacheSet = __commonJS((exports, module) => {
  var listCacheSet = function(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  };
  var assocIndexOf = require__assocIndexOf();
  module.exports = listCacheSet;
});

// node_modules/lodash/_ListCache.js
var require__ListCache = __commonJS((exports, module) => {
  var ListCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = require__listCacheClear();
  var listCacheDelete = require__listCacheDelete();
  var listCacheGet = require__listCacheGet();
  var listCacheHas = require__listCacheHas();
  var listCacheSet = require__listCacheSet();
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  module.exports = ListCache;
});

// node_modules/lodash/_Map.js
var require__Map = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Map2 = getNative(root, "Map");
  module.exports = Map2;
});

// node_modules/lodash/_mapCacheClear.js
var require__mapCacheClear = __commonJS((exports, module) => {
  var mapCacheClear = function() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  };
  var Hash = require__Hash();
  var ListCache = require__ListCache();
  var Map2 = require__Map();
  module.exports = mapCacheClear;
});

// node_modules/lodash/_isKeyable.js
var require__isKeyable = __commonJS((exports, module) => {
  var isKeyable = function(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  };
  module.exports = isKeyable;
});

// node_modules/lodash/_getMapData.js
var require__getMapData = __commonJS((exports, module) => {
  var getMapData = function(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var isKeyable = require__isKeyable();
  module.exports = getMapData;
});

// node_modules/lodash/_mapCacheDelete.js
var require__mapCacheDelete = __commonJS((exports, module) => {
  var mapCacheDelete = function(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheDelete;
});

// node_modules/lodash/_mapCacheGet.js
var require__mapCacheGet = __commonJS((exports, module) => {
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheGet;
});

// node_modules/lodash/_mapCacheHas.js
var require__mapCacheHas = __commonJS((exports, module) => {
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheHas;
});

// node_modules/lodash/_mapCacheSet.js
var require__mapCacheSet = __commonJS((exports, module) => {
  var mapCacheSet = function(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  };
  var getMapData = require__getMapData();
  module.exports = mapCacheSet;
});

// node_modules/lodash/_MapCache.js
var require__MapCache = __commonJS((exports, module) => {
  var MapCache = function(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = require__mapCacheClear();
  var mapCacheDelete = require__mapCacheDelete();
  var mapCacheGet = require__mapCacheGet();
  var mapCacheHas = require__mapCacheHas();
  var mapCacheSet = require__mapCacheSet();
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  module.exports = MapCache;
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS((exports, module) => {
  var memoize = function(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  };
  var MapCache = require__MapCache();
  var FUNC_ERROR_TEXT = "Expected a function";
  memoize.Cache = MapCache;
  module.exports = memoize;
});

// node_modules/lodash/_memoizeCapped.js
var require__memoizeCapped = __commonJS((exports, module) => {
  var memoizeCapped = function(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  };
  var memoize = require_memoize();
  var MAX_MEMOIZE_SIZE = 500;
  module.exports = memoizeCapped;
});

// node_modules/lodash/_stringToPath.js
var require__stringToPath = __commonJS((exports, module) => {
  var memoizeCapped = require__memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  module.exports = stringToPath;
});

// node_modules/lodash/_arrayMap.js
var require__arrayMap = __commonJS((exports, module) => {
  var arrayMap = function(array, iteratee) {
    var index = -1, length = array == null ? 0 : array.length, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  };
  module.exports = arrayMap;
});

// node_modules/lodash/_baseToString.js
var require__baseToString = __commonJS((exports, module) => {
  var baseToString = function(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var Symbol2 = require__Symbol();
  var arrayMap = require__arrayMap();
  var isArray = require_isArray();
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolToString = symbolProto ? symbolProto.toString : undefined;
  module.exports = baseToString;
});

// node_modules/lodash/toString.js
var require_toString = __commonJS((exports, module) => {
  var toString = function(value) {
    return value == null ? "" : baseToString(value);
  };
  var baseToString = require__baseToString();
  module.exports = toString;
});

// node_modules/lodash/_castPath.js
var require__castPath = __commonJS((exports, module) => {
  var castPath = function(value, object) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath(toString(value));
  };
  var isArray = require_isArray();
  var isKey = require__isKey();
  var stringToPath = require__stringToPath();
  var toString = require_toString();
  module.exports = castPath;
});

// node_modules/lodash/_toKey.js
var require__toKey = __commonJS((exports, module) => {
  var toKey = function(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  };
  var isSymbol = require_isSymbol();
  var INFINITY = 1 / 0;
  module.exports = toKey;
});

// node_modules/lodash/_baseGet.js
var require__baseGet = __commonJS((exports, module) => {
  var baseGet = function(object, path) {
    path = castPath(path, object);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : undefined;
  };
  var castPath = require__castPath();
  var toKey = require__toKey();
  module.exports = baseGet;
});

// node_modules/lodash/get.js
var require_get = __commonJS((exports, module) => {
  var get = function(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  };
  var baseGet = require__baseGet();
  module.exports = get;
});

// node_modules/fast-deep-equal/es6/index.js
var require_es6 = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a instanceof Map && b instanceof Map) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        for (i of a.entries())
          if (!equal(i[1], b.get(i[0])))
            return false;
        return true;
      }
      if (a instanceof Set && b instanceof Set) {
        if (a.size !== b.size)
          return false;
        for (i of a.entries())
          if (!b.has(i[0]))
            return false;
        return true;
      }
      if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (a[i] !== b[i])
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/lodash/_setCacheAdd.js
var require__setCacheAdd = __commonJS((exports, module) => {
  var setCacheAdd = function(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  };
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  module.exports = setCacheAdd;
});

// node_modules/lodash/_setCacheHas.js
var require__setCacheHas = __commonJS((exports, module) => {
  var setCacheHas = function(value) {
    return this.__data__.has(value);
  };
  module.exports = setCacheHas;
});

// node_modules/lodash/_SetCache.js
var require__SetCache = __commonJS((exports, module) => {
  var SetCache = function(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  };
  var MapCache = require__MapCache();
  var setCacheAdd = require__setCacheAdd();
  var setCacheHas = require__setCacheHas();
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  module.exports = SetCache;
});

// node_modules/lodash/_baseFindIndex.js
var require__baseFindIndex = __commonJS((exports, module) => {
  var baseFindIndex = function(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  };
  module.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require__baseIsNaN = __commonJS((exports, module) => {
  var baseIsNaN = function(value) {
    return value !== value;
  };
  module.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require__strictIndexOf = __commonJS((exports, module) => {
  var strictIndexOf = function(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  };
  module.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require__baseIndexOf = __commonJS((exports, module) => {
  var baseIndexOf = function(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  };
  var baseFindIndex = require__baseFindIndex();
  var baseIsNaN = require__baseIsNaN();
  var strictIndexOf = require__strictIndexOf();
  module.exports = baseIndexOf;
});

// node_modules/lodash/_arrayIncludes.js
var require__arrayIncludes = __commonJS((exports, module) => {
  var arrayIncludes = function(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  };
  var baseIndexOf = require__baseIndexOf();
  module.exports = arrayIncludes;
});

// node_modules/lodash/_arrayIncludesWith.js
var require__arrayIncludesWith = __commonJS((exports, module) => {
  var arrayIncludesWith = function(array, value, comparator) {
    var index = -1, length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  };
  module.exports = arrayIncludesWith;
});

// node_modules/lodash/_cacheHas.js
var require__cacheHas = __commonJS((exports, module) => {
  var cacheHas = function(cache, key) {
    return cache.has(key);
  };
  module.exports = cacheHas;
});

// node_modules/lodash/_Set.js
var require__Set = __commonJS((exports, module) => {
  var getNative = require__getNative();
  var root = require__root();
  var Set2 = getNative(root, "Set");
  module.exports = Set2;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports, module) => {
  var noop = function() {
  };
  module.exports = noop;
});

// node_modules/lodash/_setToArray.js
var require__setToArray = __commonJS((exports, module) => {
  var setToArray = function(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  };
  module.exports = setToArray;
});

// node_modules/lodash/_createSet.js
var require__createSet = __commonJS((exports, module) => {
  var Set2 = require__Set();
  var noop = require_noop();
  var setToArray = require__setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
    return new Set2(values);
  };
  module.exports = createSet;
});

// node_modules/lodash/_baseUniq.js
var require__baseUniq = __commonJS((exports, module) => {
  var baseUniq = function(array, iteratee, comparator) {
    var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes = arrayIncludesWith;
    } else if (length >= LARGE_ARRAY_SIZE) {
      var set = iteratee ? null : createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache;
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index < length) {
        var value = array[index], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  };
  var SetCache = require__SetCache();
  var arrayIncludes = require__arrayIncludes();
  var arrayIncludesWith = require__arrayIncludesWith();
  var cacheHas = require__cacheHas();
  var createSet = require__createSet();
  var setToArray = require__setToArray();
  var LARGE_ARRAY_SIZE = 200;
  module.exports = baseUniq;
});

// node_modules/lodash/uniqWith.js
var require_uniqWith = __commonJS((exports, module) => {
  var uniqWith = function(array, comparator) {
    comparator = typeof comparator == "function" ? comparator : undefined;
    return array && array.length ? baseUniq(array, undefined, comparator) : [];
  };
  var baseUniq = require__baseUniq();
  module.exports = uniqWith;
});

// node_modules/@sapphire/shapeshift/dist/index.js
var require_dist8 = __commonJS((exports) => {
  var _interopDefault = function(e) {
    return e && e.__esModule ? e : { default: e };
  };
  var setGlobalValidationEnabled = function(enabled) {
    validationEnabled = enabled;
  };
  var getGlobalValidationEnabled = function() {
    return validationEnabled;
  };
  var getValue = function(valueOrFn) {
    return typeof valueOrFn === "function" ? valueOrFn() : valueOrFn;
  };
  var whenConstraint = function(key, options, validator) {
    return {
      run(input, parent) {
        if (!parent) {
          return Result.err(new ExpectedConstraintError("s.object(T.when)", "Validator has no parent", parent, "Validator to have a parent"));
        }
        const isKeyArray = Array.isArray(key);
        const value = isKeyArray ? key.map((k) => get__default.default(parent, k)) : get__default.default(parent, key);
        const predicate = resolveBooleanIs(options, value, isKeyArray) ? options.then : options.otherwise;
        if (predicate) {
          return predicate(validator).run(input);
        }
        return Result.ok(input);
      }
    };
  };
  var resolveBooleanIs = function(options, value, isKeyArray) {
    if (options.is === undefined) {
      return isKeyArray ? !value.some((val) => !val) : Boolean(value);
    }
    if (typeof options.is === "function") {
      return options.is(value);
    }
    return value === options.is;
  };
  var isUnique = function(input) {
    if (input.length < 2)
      return true;
    const uniqueArray2 = uniqWith__default.default(input, fastDeepEqual__default.default);
    return uniqueArray2.length === input.length;
  };
  var lessThan = function(a, b) {
    return a < b;
  };
  var lessThanOrEqual = function(a, b) {
    return a <= b;
  };
  var greaterThan = function(a, b) {
    return a > b;
  };
  var greaterThanOrEqual = function(a, b) {
    return a >= b;
  };
  var equal = function(a, b) {
    return a === b;
  };
  var notEqual = function(a, b) {
    return a !== b;
  };
  var arrayLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthLessThan = function(value) {
    const expected = `expected.length < ${value}`;
    return arrayLengthComparator(lessThan, "s.array(T).lengthLessThan", expected, value);
  };
  var arrayLengthLessThanOrEqual = function(value) {
    const expected = `expected.length <= ${value}`;
    return arrayLengthComparator(lessThanOrEqual, "s.array(T).lengthLessThanOrEqual", expected, value);
  };
  var arrayLengthGreaterThan = function(value) {
    const expected = `expected.length > ${value}`;
    return arrayLengthComparator(greaterThan, "s.array(T).lengthGreaterThan", expected, value);
  };
  var arrayLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.length >= ${value}`;
    return arrayLengthComparator(greaterThanOrEqual, "s.array(T).lengthGreaterThanOrEqual", expected, value);
  };
  var arrayLengthEqual = function(value) {
    const expected = `expected.length === ${value}`;
    return arrayLengthComparator(equal, "s.array(T).lengthEqual", expected, value);
  };
  var arrayLengthNotEqual = function(value) {
    const expected = `expected.length !== ${value}`;
    return arrayLengthComparator(notEqual, "s.array(T).lengthNotEqual", expected, value);
  };
  var arrayLengthRange = function(start, endBefore) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRange", "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeInclusive = function(start, end) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeInclusive", "Invalid Array length", input, expected));
      }
    };
  };
  var arrayLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).lengthRangeExclusive", "Invalid Array length", input, expected));
      }
    };
  };
  var bigintComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid bigint value", input, expected));
      }
    };
  };
  var bigintLessThan = function(value) {
    const expected = `expected < ${value}n`;
    return bigintComparator(lessThan, "s.bigint.lessThan", expected, value);
  };
  var bigintLessThanOrEqual = function(value) {
    const expected = `expected <= ${value}n`;
    return bigintComparator(lessThanOrEqual, "s.bigint.lessThanOrEqual", expected, value);
  };
  var bigintGreaterThan = function(value) {
    const expected = `expected > ${value}n`;
    return bigintComparator(greaterThan, "s.bigint.greaterThan", expected, value);
  };
  var bigintGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value}n`;
    return bigintComparator(greaterThanOrEqual, "s.bigint.greaterThanOrEqual", expected, value);
  };
  var bigintEqual = function(value) {
    const expected = `expected === ${value}n`;
    return bigintComparator(equal, "s.bigint.equal", expected, value);
  };
  var bigintNotEqual = function(value) {
    const expected = `expected !== ${value}n`;
    return bigintComparator(notEqual, "s.bigint.notEqual", expected, value);
  };
  var bigintDivisibleBy = function(divider) {
    const expected = `expected % ${divider}n === 0n`;
    return {
      run(input) {
        return input % divider === 0n ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.bigint.divisibleBy", "BigInt is not divisible", input, expected));
      }
    };
  };
  var dateComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input.getTime(), number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Date value", input, expected));
      }
    };
  };
  var dateLessThan = function(value) {
    const expected = `expected < ${value.toISOString()}`;
    return dateComparator(lessThan, "s.date.lessThan", expected, value.getTime());
  };
  var dateLessThanOrEqual = function(value) {
    const expected = `expected <= ${value.toISOString()}`;
    return dateComparator(lessThanOrEqual, "s.date.lessThanOrEqual", expected, value.getTime());
  };
  var dateGreaterThan = function(value) {
    const expected = `expected > ${value.toISOString()}`;
    return dateComparator(greaterThan, "s.date.greaterThan", expected, value.getTime());
  };
  var dateGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value.toISOString()}`;
    return dateComparator(greaterThanOrEqual, "s.date.greaterThanOrEqual", expected, value.getTime());
  };
  var dateEqual = function(value) {
    const expected = `expected === ${value.toISOString()}`;
    return dateComparator(equal, "s.date.equal", expected, value.getTime());
  };
  var dateNotEqual = function(value) {
    const expected = `expected !== ${value.toISOString()}`;
    return dateComparator(notEqual, "s.date.notEqual", expected, value.getTime());
  };
  var numberComparator = function(comparator, name, expected, number) {
    return {
      run(input) {
        return comparator(input, number) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid number value", input, expected));
      }
    };
  };
  var numberLessThan = function(value) {
    const expected = `expected < ${value}`;
    return numberComparator(lessThan, "s.number.lessThan", expected, value);
  };
  var numberLessThanOrEqual = function(value) {
    const expected = `expected <= ${value}`;
    return numberComparator(lessThanOrEqual, "s.number.lessThanOrEqual", expected, value);
  };
  var numberGreaterThan = function(value) {
    const expected = `expected > ${value}`;
    return numberComparator(greaterThan, "s.number.greaterThan", expected, value);
  };
  var numberGreaterThanOrEqual = function(value) {
    const expected = `expected >= ${value}`;
    return numberComparator(greaterThanOrEqual, "s.number.greaterThanOrEqual", expected, value);
  };
  var numberEqual = function(value) {
    const expected = `expected === ${value}`;
    return numberComparator(equal, "s.number.equal", expected, value);
  };
  var numberNotEqual = function(value) {
    const expected = `expected !== ${value}`;
    return numberComparator(notEqual, "s.number.notEqual", expected, value);
  };
  var numberDivisibleBy = function(divider) {
    const expected = `expected % ${divider} === 0`;
    return {
      run(input) {
        return input % divider === 0 ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.divisibleBy", "Number is not divisible", input, expected));
      }
    };
  };
  var validateEmail = function(email) {
    if (!email)
      return false;
    const atIndex = email.indexOf("@");
    if (atIndex === -1)
      return false;
    if (atIndex > 64)
      return false;
    const domainIndex = atIndex + 1;
    if (email.includes("@", domainIndex))
      return false;
    if (email.length - domainIndex > 255)
      return false;
    let dotIndex = email.indexOf(".", domainIndex);
    if (dotIndex === -1)
      return false;
    let lastDotIndex = domainIndex;
    do {
      if (dotIndex - lastDotIndex > 63)
        return false;
      lastDotIndex = dotIndex + 1;
    } while ((dotIndex = email.indexOf(".", lastDotIndex)) !== -1);
    if (email.length - lastDotIndex > 63)
      return false;
    return accountRegex.test(email.slice(0, atIndex)) && validateEmailDomain(email.slice(domainIndex));
  };
  var validateEmailDomain = function(domain) {
    try {
      return new URL(`http://${domain}`).hostname === domain;
    } catch {
      return false;
    }
  };
  var isIPv4 = function(s2) {
    return IPv4Reg.test(s2);
  };
  var isIPv6 = function(s2) {
    return IPv6Reg.test(s2);
  };
  var isIP = function(s2) {
    if (isIPv4(s2))
      return 4;
    if (isIPv6(s2))
      return 6;
    return 0;
  };
  var validatePhoneNumber = function(input) {
    return phoneNumberRegex.test(input);
  };
  var combinedErrorFn = function(...fns) {
    switch (fns.length) {
      case 0:
        return () => null;
      case 1:
        return fns[0];
      case 2: {
        const [fn0, fn1] = fns;
        return (...params) => fn0(...params) || fn1(...params);
      }
      default: {
        return (...params) => {
          for (const fn of fns) {
            const result = fn(...params);
            if (result)
              return result;
          }
          return null;
        };
      }
    }
  };
  var createUrlValidators = function(options) {
    const fns = [];
    if (options?.allowedProtocols?.length)
      fns.push(allowedProtocolsFn(options.allowedProtocols));
    if (options?.allowedDomains?.length)
      fns.push(allowedDomainsFn(options.allowedDomains));
    return combinedErrorFn(...fns);
  };
  var allowedProtocolsFn = function(allowedProtocols) {
    return (input, url) => allowedProtocols.includes(url.protocol) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL protocol", input, allowedProtocols);
  };
  var allowedDomainsFn = function(allowedDomains) {
    return (input, url) => allowedDomains.includes(url.hostname) ? null : new MultiplePossibilitiesConstraintError("s.string.url", "Invalid URL domain", input, allowedDomains);
  };
  var stringLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid string length", input, expected));
      }
    };
  };
  var stringLengthLessThan = function(length) {
    const expected = `expected.length < ${length}`;
    return stringLengthComparator(lessThan, "s.string.lengthLessThan", expected, length);
  };
  var stringLengthLessThanOrEqual = function(length) {
    const expected = `expected.length <= ${length}`;
    return stringLengthComparator(lessThanOrEqual, "s.string.lengthLessThanOrEqual", expected, length);
  };
  var stringLengthGreaterThan = function(length) {
    const expected = `expected.length > ${length}`;
    return stringLengthComparator(greaterThan, "s.string.lengthGreaterThan", expected, length);
  };
  var stringLengthGreaterThanOrEqual = function(length) {
    const expected = `expected.length >= ${length}`;
    return stringLengthComparator(greaterThanOrEqual, "s.string.lengthGreaterThanOrEqual", expected, length);
  };
  var stringLengthEqual = function(length) {
    const expected = `expected.length === ${length}`;
    return stringLengthComparator(equal, "s.string.lengthEqual", expected, length);
  };
  var stringLengthNotEqual = function(length) {
    const expected = `expected.length !== ${length}`;
    return stringLengthComparator(notEqual, "s.string.lengthNotEqual", expected, length);
  };
  var stringEmail = function() {
    return {
      run(input) {
        return validateEmail(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.email", "Invalid email address", input, "expected to be an email address"));
      }
    };
  };
  var stringRegexValidator = function(type, expected, regex) {
    return {
      run(input) {
        return regex.test(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(type, "Invalid string format", input, expected));
      }
    };
  };
  var stringUrl = function(options) {
    const validatorFn = createUrlValidators(options);
    return {
      run(input) {
        let url;
        try {
          url = new URL(input);
        } catch {
          return Result.err(new ExpectedConstraintError("s.string.url", "Invalid URL", input, "expected to match a URL"));
        }
        const validatorFnResult = validatorFn(input, url);
        if (validatorFnResult === null)
          return Result.ok(input);
        return Result.err(validatorFnResult);
      }
    };
  };
  var stringIp = function(version) {
    const ipVersion = version ? `v${version}` : "";
    const validatorFn = version === 4 ? isIPv4 : version === 6 ? isIPv6 : isIP;
    const name = `s.string.ip${ipVersion}`;
    const message = `Invalid IP${ipVersion} address`;
    const expected = `expected to be an IP${ipVersion} address`;
    return {
      run(input) {
        return validatorFn(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, message, input, expected));
      }
    };
  };
  var stringRegex = function(regex) {
    return stringRegexValidator("s.string.regex", `expected ${regex}.test(expected) to be true`, regex);
  };
  var stringUuid = function({ version = 4, nullable = false } = {}) {
    version ?? (version = "1-5");
    const regex = new RegExp(`^(?:[0-9A-F]{8}-[0-9A-F]{4}-[${version}][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}${nullable ? "|00000000-0000-0000-0000-000000000000" : ""})\$`, "i");
    const expected = `expected to match UUID${typeof version === "number" ? `v${version}` : ` in range of ${version}`}`;
    return stringRegexValidator("s.string.uuid", expected, regex);
  };
  var stringDate = function() {
    return {
      run(input) {
        const time = Date.parse(input);
        return Number.isNaN(time) ? Result.err(new ExpectedConstraintError("s.string.date", "Invalid date string", input, "expected to be a valid date string (in the ISO 8601 or ECMA-262 format)")) : Result.ok(input);
      }
    };
  };
  var stringPhone = function() {
    return {
      run(input) {
        return validatePhoneNumber(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.string.phone", "Invalid phone number", input, "expected to be a phone number"));
      }
    };
  };
  var typedArrayByteLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.byteLength, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthLessThan = function(value) {
    const expected = `expected.byteLength < ${value}`;
    return typedArrayByteLengthComparator(lessThan, "s.typedArray(T).byteLengthLessThan", expected, value);
  };
  var typedArrayByteLengthLessThanOrEqual = function(value) {
    const expected = `expected.byteLength <= ${value}`;
    return typedArrayByteLengthComparator(lessThanOrEqual, "s.typedArray(T).byteLengthLessThanOrEqual", expected, value);
  };
  var typedArrayByteLengthGreaterThan = function(value) {
    const expected = `expected.byteLength > ${value}`;
    return typedArrayByteLengthComparator(greaterThan, "s.typedArray(T).byteLengthGreaterThan", expected, value);
  };
  var typedArrayByteLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.byteLength >= ${value}`;
    return typedArrayByteLengthComparator(greaterThanOrEqual, "s.typedArray(T).byteLengthGreaterThanOrEqual", expected, value);
  };
  var typedArrayByteLengthEqual = function(value) {
    const expected = `expected.byteLength === ${value}`;
    return typedArrayByteLengthComparator(equal, "s.typedArray(T).byteLengthEqual", expected, value);
  };
  var typedArrayByteLengthNotEqual = function(value) {
    const expected = `expected.byteLength !== ${value}`;
    return typedArrayByteLengthComparator(notEqual, "s.typedArray(T).byteLengthNotEqual", expected, value);
  };
  var typedArrayByteLengthRange = function(start, endBefore) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRange", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeInclusive = function(start, end) {
    const expected = `expected.byteLength >= ${start} && expected.byteLength <= ${end}`;
    return {
      run(input) {
        return input.byteLength >= start && input.byteLength <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeInclusive", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayByteLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.byteLength > ${startAfter} && expected.byteLength < ${endBefore}`;
    return {
      run(input) {
        return input.byteLength > startAfter && input.byteLength < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).byteLengthRangeExclusive", "Invalid Typed Array byte length", input, expected));
      }
    };
  };
  var typedArrayLengthComparator = function(comparator, name, expected, length) {
    return {
      run(input) {
        return comparator(input.length, length) ? Result.ok(input) : Result.err(new ExpectedConstraintError(name, "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthLessThan = function(value) {
    const expected = `expected.length < ${value}`;
    return typedArrayLengthComparator(lessThan, "s.typedArray(T).lengthLessThan", expected, value);
  };
  var typedArrayLengthLessThanOrEqual = function(value) {
    const expected = `expected.length <= ${value}`;
    return typedArrayLengthComparator(lessThanOrEqual, "s.typedArray(T).lengthLessThanOrEqual", expected, value);
  };
  var typedArrayLengthGreaterThan = function(value) {
    const expected = `expected.length > ${value}`;
    return typedArrayLengthComparator(greaterThan, "s.typedArray(T).lengthGreaterThan", expected, value);
  };
  var typedArrayLengthGreaterThanOrEqual = function(value) {
    const expected = `expected.length >= ${value}`;
    return typedArrayLengthComparator(greaterThanOrEqual, "s.typedArray(T).lengthGreaterThanOrEqual", expected, value);
  };
  var typedArrayLengthEqual = function(value) {
    const expected = `expected.length === ${value}`;
    return typedArrayLengthComparator(equal, "s.typedArray(T).lengthEqual", expected, value);
  };
  var typedArrayLengthNotEqual = function(value) {
    const expected = `expected.length !== ${value}`;
    return typedArrayLengthComparator(notEqual, "s.typedArray(T).lengthNotEqual", expected, value);
  };
  var typedArrayLengthRange = function(start, endBefore) {
    const expected = `expected.length >= ${start} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length >= start && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRange", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeInclusive = function(start, end) {
    const expected = `expected.length >= ${start} && expected.length <= ${end}`;
    return {
      run(input) {
        return input.length >= start && input.length <= end ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeInclusive", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var typedArrayLengthRangeExclusive = function(startAfter, endBefore) {
    const expected = `expected.length > ${startAfter} && expected.length < ${endBefore}`;
    return {
      run(input) {
        return input.length > startAfter && input.length < endBefore ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.typedArray(T).lengthRangeExclusive", "Invalid Typed Array length", input, expected));
      }
    };
  };
  var get = require_get();
  var util = __require("util");
  var fastDeepEqual = require_es6();
  var uniqWith = require_uniqWith();
  var get__default = _interopDefault(get);
  var fastDeepEqual__default = _interopDefault(fastDeepEqual);
  var uniqWith__default = _interopDefault(uniqWith);
  var __defProp2 = Object.defineProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var validationEnabled = true;
  __name(setGlobalValidationEnabled, "setGlobalValidationEnabled");
  __name(getGlobalValidationEnabled, "getGlobalValidationEnabled");
  var Result = class {
    constructor(success, value, error) {
      this.success = success;
      if (success) {
        this.value = value;
      } else {
        this.error = error;
      }
    }
    isOk() {
      return this.success;
    }
    isErr() {
      return !this.success;
    }
    unwrap() {
      if (this.isOk())
        return this.value;
      throw this.error;
    }
    static ok(value) {
      return new Result(true, value);
    }
    static err(error) {
      return new Result(false, undefined, error);
    }
  };
  __name(Result, "Result");
  __name(getValue, "getValue");
  var customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
  var customInspectSymbolStackLess = Symbol.for("nodejs.util.inspect.custom.stack-less");
  var BaseError = class extends Error {
    [customInspectSymbol](depth, options) {
      return `${this[customInspectSymbolStackLess](depth, options)}
${this.stack.slice(this.stack.indexOf("\n"))}`;
    }
  };
  __name(BaseError, "BaseError");
  var BaseConstraintError = class extends BaseError {
    constructor(constraint, message, given) {
      super(message);
      this.constraint = constraint;
      this.given = given;
    }
  };
  __name(BaseConstraintError, "BaseConstraintError");
  var ExpectedConstraintError = class extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected: ", "string")}${options.stylize(this.expected, "boolean")}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(ExpectedConstraintError, "ExpectedConstraintError");
  __name(whenConstraint, "whenConstraint");
  __name(resolveBooleanIs, "resolveBooleanIs");
  var BaseValidator = class {
    constructor(constraints = []) {
      this.constraints = [];
      this.isValidationEnabled = null;
      this.constraints = constraints;
    }
    setParent(parent) {
      this.parent = parent;
      return this;
    }
    get optional() {
      return new UnionValidator([new LiteralValidator(undefined), this.clone()]);
    }
    get nullable() {
      return new UnionValidator([new LiteralValidator(null), this.clone()]);
    }
    get nullish() {
      return new UnionValidator([new NullishValidator, this.clone()]);
    }
    get array() {
      return new ArrayValidator(this.clone());
    }
    get set() {
      return new SetValidator(this.clone());
    }
    or(...predicates) {
      return new UnionValidator([this.clone(), ...predicates]);
    }
    transform(cb) {
      return this.addConstraint({ run: (input) => Result.ok(cb(input)) });
    }
    reshape(cb) {
      return this.addConstraint({ run: cb });
    }
    default(value) {
      return new DefaultValidator(this.clone(), value);
    }
    when(key, options) {
      return this.addConstraint(whenConstraint(key, options, this));
    }
    describe(description) {
      const clone = this.clone();
      clone.description = description;
      return clone;
    }
    run(value) {
      let result = this.handle(value);
      if (result.isErr())
        return result;
      for (const constraint of this.constraints) {
        result = constraint.run(result.value, this.parent);
        if (result.isErr())
          break;
      }
      return result;
    }
    parse(value) {
      if (!this.shouldRunConstraints) {
        return this.handle(value).unwrap();
      }
      return this.constraints.reduce((v, constraint) => constraint.run(v).unwrap(), this.handle(value).unwrap());
    }
    is(value) {
      return this.run(value).isOk();
    }
    setValidationEnabled(isValidationEnabled) {
      const clone = this.clone();
      clone.isValidationEnabled = isValidationEnabled;
      return clone;
    }
    getValidationEnabled() {
      return getValue(this.isValidationEnabled);
    }
    get shouldRunConstraints() {
      return getValue(this.isValidationEnabled) ?? getGlobalValidationEnabled();
    }
    clone() {
      const clone = Reflect.construct(this.constructor, [this.constraints]);
      clone.isValidationEnabled = this.isValidationEnabled;
      return clone;
    }
    addConstraint(constraint) {
      const clone = this.clone();
      clone.constraints = clone.constraints.concat(constraint);
      return clone;
    }
  };
  __name(BaseValidator, "BaseValidator");
  __name(isUnique, "isUnique");
  __name(lessThan, "lessThan");
  __name(lessThanOrEqual, "lessThanOrEqual");
  __name(greaterThan, "greaterThan");
  __name(greaterThanOrEqual, "greaterThanOrEqual");
  __name(equal, "equal");
  __name(notEqual, "notEqual");
  __name(arrayLengthComparator, "arrayLengthComparator");
  __name(arrayLengthLessThan, "arrayLengthLessThan");
  __name(arrayLengthLessThanOrEqual, "arrayLengthLessThanOrEqual");
  __name(arrayLengthGreaterThan, "arrayLengthGreaterThan");
  __name(arrayLengthGreaterThanOrEqual, "arrayLengthGreaterThanOrEqual");
  __name(arrayLengthEqual, "arrayLengthEqual");
  __name(arrayLengthNotEqual, "arrayLengthNotEqual");
  __name(arrayLengthRange, "arrayLengthRange");
  __name(arrayLengthRangeInclusive, "arrayLengthRangeInclusive");
  __name(arrayLengthRangeExclusive, "arrayLengthRangeExclusive");
  var uniqueArray = {
    run(input) {
      return isUnique(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.array(T).unique", "Array values are not unique", input, "Expected all values to be unique"));
    }
  };
  var CombinedPropertyError = class extends BaseError {
    constructor(errors) {
      super("Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedPropertyError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedPropertyError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map(([key, error]) => {
        const property = CombinedPropertyError.formatProperty(key, options);
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  input${property}${padding}${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
    static formatProperty(key, options) {
      if (typeof key === "string")
        return options.stylize(`.${key}`, "symbol");
      if (typeof key === "number")
        return `[${options.stylize(key.toString(), "number")}]`;
      return `[${options.stylize("Symbol", "symbol")}(${key.description})]`;
    }
  };
  __name(CombinedPropertyError, "CombinedPropertyError");
  var ValidationError = class extends BaseError {
    constructor(validator, message, given) {
      super(message);
      this.validator = validator;
      this.given = given;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(ValidationError, "ValidationError");
  var ArrayValidator = class extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    lengthLessThan(length) {
      return this.addConstraint(arrayLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(arrayLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(arrayLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(arrayLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(arrayLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(arrayLengthNotEqual(length));
    }
    lengthRange(start, endBefore) {
      return this.addConstraint(arrayLengthRange(start, endBefore));
    }
    lengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(arrayLengthRangeInclusive(startAt, endAt));
    }
    lengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(arrayLengthRangeExclusive(startAfter, endBefore));
    }
    get unique() {
      return this.addConstraint(uniqueArray);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.array(T)", "Expected an array", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i = 0;i < values.length; i++) {
        const result = this.validator.run(values[i]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(ArrayValidator, "ArrayValidator");
  __name(bigintComparator, "bigintComparator");
  __name(bigintLessThan, "bigintLessThan");
  __name(bigintLessThanOrEqual, "bigintLessThanOrEqual");
  __name(bigintGreaterThan, "bigintGreaterThan");
  __name(bigintGreaterThanOrEqual, "bigintGreaterThanOrEqual");
  __name(bigintEqual, "bigintEqual");
  __name(bigintNotEqual, "bigintNotEqual");
  __name(bigintDivisibleBy, "bigintDivisibleBy");
  var BigIntValidator = class extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(bigintLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(bigintLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(bigintGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(bigintGreaterThanOrEqual(number));
    }
    equal(number) {
      return this.addConstraint(bigintEqual(number));
    }
    notEqual(number) {
      return this.addConstraint(bigintNotEqual(number));
    }
    get positive() {
      return this.greaterThanOrEqual(0n);
    }
    get negative() {
      return this.lessThan(0n);
    }
    divisibleBy(number) {
      return this.addConstraint(bigintDivisibleBy(number));
    }
    get abs() {
      return this.transform((value) => value < 0 ? -value : value);
    }
    intN(bits) {
      return this.transform((value) => BigInt.asIntN(bits, value));
    }
    uintN(bits) {
      return this.transform((value) => BigInt.asUintN(bits, value));
    }
    handle(value) {
      return typeof value === "bigint" ? Result.ok(value) : Result.err(new ValidationError("s.bigint", "Expected a bigint primitive", value));
    }
  };
  __name(BigIntValidator, "BigIntValidator");
  var booleanTrue = {
    run(input) {
      return input ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.boolean.true", "Invalid boolean value", input, "true"));
    }
  };
  var booleanFalse = {
    run(input) {
      return input ? Result.err(new ExpectedConstraintError("s.boolean.false", "Invalid boolean value", input, "false")) : Result.ok(input);
    }
  };
  var BooleanValidator = class extends BaseValidator {
    get true() {
      return this.addConstraint(booleanTrue);
    }
    get false() {
      return this.addConstraint(booleanFalse);
    }
    equal(value) {
      return value ? this.true : this.false;
    }
    notEqual(value) {
      return value ? this.false : this.true;
    }
    handle(value) {
      return typeof value === "boolean" ? Result.ok(value) : Result.err(new ValidationError("s.boolean", "Expected a boolean primitive", value));
    }
  };
  __name(BooleanValidator, "BooleanValidator");
  __name(dateComparator, "dateComparator");
  __name(dateLessThan, "dateLessThan");
  __name(dateLessThanOrEqual, "dateLessThanOrEqual");
  __name(dateGreaterThan, "dateGreaterThan");
  __name(dateGreaterThanOrEqual, "dateGreaterThanOrEqual");
  __name(dateEqual, "dateEqual");
  __name(dateNotEqual, "dateNotEqual");
  var dateInvalid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.date.invalid", "Invalid Date value", input, "expected === NaN"));
    }
  };
  var dateValid = {
    run(input) {
      return Number.isNaN(input.getTime()) ? Result.err(new ExpectedConstraintError("s.date.valid", "Invalid Date value", input, "expected !== NaN")) : Result.ok(input);
    }
  };
  var DateValidator = class extends BaseValidator {
    lessThan(date) {
      return this.addConstraint(dateLessThan(new Date(date)));
    }
    lessThanOrEqual(date) {
      return this.addConstraint(dateLessThanOrEqual(new Date(date)));
    }
    greaterThan(date) {
      return this.addConstraint(dateGreaterThan(new Date(date)));
    }
    greaterThanOrEqual(date) {
      return this.addConstraint(dateGreaterThanOrEqual(new Date(date)));
    }
    equal(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.invalid : this.addConstraint(dateEqual(resolved));
    }
    notEqual(date) {
      const resolved = new Date(date);
      return Number.isNaN(resolved.getTime()) ? this.valid : this.addConstraint(dateNotEqual(resolved));
    }
    get valid() {
      return this.addConstraint(dateValid);
    }
    get invalid() {
      return this.addConstraint(dateInvalid);
    }
    handle(value) {
      return value instanceof Date ? Result.ok(value) : Result.err(new ValidationError("s.date", "Expected a Date", value));
    }
  };
  __name(DateValidator, "DateValidator");
  var ExpectedValidationError = class extends ValidationError {
    constructor(validator, message, given, expected) {
      super(validator, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        validator: this.validator,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const validator = options.stylize(this.validator, "string");
      if (depth < 0) {
        return options.stylize(`[ExpectedValidationError: ${validator}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const expected = util.inspect(this.expected, newOptions).replace(/\n/g, padding);
      const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("ExpectedValidationError", "special")} > ${validator}`;
      const message = options.stylize(this.message, "regexp");
      const expectedBlock = `
  ${options.stylize("Expected:", "string")}${padding}${expected}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(ExpectedValidationError, "ExpectedValidationError");
  var InstanceValidator = class extends BaseValidator {
    constructor(expected, constraints = []) {
      super(constraints);
      this.expected = expected;
    }
    handle(value) {
      return value instanceof this.expected ? Result.ok(value) : Result.err(new ExpectedValidationError("s.instance(V)", "Expected", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(InstanceValidator, "InstanceValidator");
  var LiteralValidator = class extends BaseValidator {
    constructor(literal, constraints = []) {
      super(constraints);
      this.expected = literal;
    }
    handle(value) {
      return Object.is(value, this.expected) ? Result.ok(value) : Result.err(new ExpectedValidationError("s.literal(V)", "Expected values to be equals", value, this.expected));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.expected, this.constraints]);
    }
  };
  __name(LiteralValidator, "LiteralValidator");
  var NeverValidator = class extends BaseValidator {
    handle(value) {
      return Result.err(new ValidationError("s.never", "Expected a value to not be passed", value));
    }
  };
  __name(NeverValidator, "NeverValidator");
  var NullishValidator = class extends BaseValidator {
    handle(value) {
      return value === undefined || value === null ? Result.ok(value) : Result.err(new ValidationError("s.nullish", "Expected undefined or null", value));
    }
  };
  __name(NullishValidator, "NullishValidator");
  __name(numberComparator, "numberComparator");
  __name(numberLessThan, "numberLessThan");
  __name(numberLessThanOrEqual, "numberLessThanOrEqual");
  __name(numberGreaterThan, "numberGreaterThan");
  __name(numberGreaterThanOrEqual, "numberGreaterThanOrEqual");
  __name(numberEqual, "numberEqual");
  __name(numberNotEqual, "numberNotEqual");
  var numberInt = {
    run(input) {
      return Number.isInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.int", "Given value is not an integer", input, "Number.isInteger(expected) to be true"));
    }
  };
  var numberSafeInt = {
    run(input) {
      return Number.isSafeInteger(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.safeInt", "Given value is not a safe integer", input, "Number.isSafeInteger(expected) to be true"));
    }
  };
  var numberFinite = {
    run(input) {
      return Number.isFinite(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.finite", "Given value is not finite", input, "Number.isFinite(expected) to be true"));
    }
  };
  var numberNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.ok(input) : Result.err(new ExpectedConstraintError("s.number.equal(NaN)", "Invalid number value", input, "expected === NaN"));
    }
  };
  var numberNotNaN = {
    run(input) {
      return Number.isNaN(input) ? Result.err(new ExpectedConstraintError("s.number.notEqual(NaN)", "Invalid number value", input, "expected !== NaN")) : Result.ok(input);
    }
  };
  __name(numberDivisibleBy, "numberDivisibleBy");
  var NumberValidator = class extends BaseValidator {
    lessThan(number) {
      return this.addConstraint(numberLessThan(number));
    }
    lessThanOrEqual(number) {
      return this.addConstraint(numberLessThanOrEqual(number));
    }
    greaterThan(number) {
      return this.addConstraint(numberGreaterThan(number));
    }
    greaterThanOrEqual(number) {
      return this.addConstraint(numberGreaterThanOrEqual(number));
    }
    equal(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNaN) : this.addConstraint(numberEqual(number));
    }
    notEqual(number) {
      return Number.isNaN(number) ? this.addConstraint(numberNotNaN) : this.addConstraint(numberNotEqual(number));
    }
    get int() {
      return this.addConstraint(numberInt);
    }
    get safeInt() {
      return this.addConstraint(numberSafeInt);
    }
    get finite() {
      return this.addConstraint(numberFinite);
    }
    get positive() {
      return this.greaterThanOrEqual(0);
    }
    get negative() {
      return this.lessThan(0);
    }
    divisibleBy(divider) {
      return this.addConstraint(numberDivisibleBy(divider));
    }
    get abs() {
      return this.transform(Math.abs);
    }
    get sign() {
      return this.transform(Math.sign);
    }
    get trunc() {
      return this.transform(Math.trunc);
    }
    get floor() {
      return this.transform(Math.floor);
    }
    get fround() {
      return this.transform(Math.fround);
    }
    get round() {
      return this.transform(Math.round);
    }
    get ceil() {
      return this.transform(Math.ceil);
    }
    handle(value) {
      return typeof value === "number" ? Result.ok(value) : Result.err(new ValidationError("s.number", "Expected a number primitive", value));
    }
  };
  __name(NumberValidator, "NumberValidator");
  var MissingPropertyError = class extends BaseError {
    constructor(property) {
      super("A required property is missing");
      this.property = property;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[MissingPropertyError: ${property}]`, "special");
      }
      const header = `${options.stylize("MissingPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      return `${header}
  ${message}`;
    }
  };
  __name(MissingPropertyError, "MissingPropertyError");
  var UnknownPropertyError = class extends BaseError {
    constructor(property, value) {
      super("Received unexpected property");
      this.property = property;
      this.value = value;
    }
    toJSON() {
      return {
        name: this.name,
        property: this.property,
        value: this.value
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const property = options.stylize(this.property.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownPropertyError: ${property}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const given = util.inspect(this.value, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("UnknownPropertyError", "special")} > ${property}`;
      const message = options.stylize(this.message, "regexp");
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${givenBlock}`;
    }
  };
  __name(UnknownPropertyError, "UnknownPropertyError");
  var DefaultValidator = class extends BaseValidator {
    constructor(validator, value, constraints = []) {
      super(constraints);
      this.validator = validator;
      this.defaultValue = value;
    }
    default(value) {
      const clone = this.clone();
      clone.defaultValue = value;
      return clone;
    }
    handle(value) {
      return typeof value === "undefined" ? Result.ok(getValue(this.defaultValue)) : this.validator["handle"](value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.defaultValue, this.constraints]);
    }
  };
  __name(DefaultValidator, "DefaultValidator");
  var CombinedError = class extends BaseError {
    constructor(errors) {
      super("Received one or more errors");
      this.errors = errors;
    }
    [customInspectSymbolStackLess](depth, options) {
      if (depth < 0) {
        return options.stylize("[CombinedError]", "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1, compact: true };
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const header = `${options.stylize("CombinedError", "special")} (${options.stylize(this.errors.length.toString(), "number")})`;
      const message = options.stylize(this.message, "regexp");
      const errors = this.errors.map((error, i) => {
        const index = options.stylize((i + 1).toString(), "number");
        const body = error[customInspectSymbolStackLess](depth - 1, newOptions).replace(/\n/g, padding);
        return `  ${index} ${body}`;
      }).join("\n\n");
      return `${header}
  ${message}

${errors}`;
    }
  };
  __name(CombinedError, "CombinedError");
  var UnionValidator = class extends BaseValidator {
    constructor(validators, constraints = []) {
      super(constraints);
      this.validators = validators;
    }
    get optional() {
      if (this.validators.length === 0)
        return new UnionValidator([new LiteralValidator(undefined)], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return this.clone();
        if (validator.expected === null) {
          return new UnionValidator([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new UnionValidator([new LiteralValidator(undefined), ...this.validators]);
    }
    get required() {
      if (this.validators.length === 0)
        return this.clone();
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === undefined)
          return new UnionValidator(this.validators.slice(1), this.constraints);
      } else if (validator instanceof NullishValidator) {
        return new UnionValidator([new LiteralValidator(null), ...this.validators.slice(1)], this.constraints);
      }
      return this.clone();
    }
    get nullable() {
      if (this.validators.length === 0)
        return new UnionValidator([new LiteralValidator(null)], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null)
          return this.clone();
        if (validator.expected === undefined) {
          return new UnionValidator([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new UnionValidator([new LiteralValidator(null), ...this.validators]);
    }
    get nullish() {
      if (this.validators.length === 0)
        return new UnionValidator([new NullishValidator], this.constraints);
      const [validator] = this.validators;
      if (validator instanceof LiteralValidator) {
        if (validator.expected === null || validator.expected === undefined) {
          return new UnionValidator([new NullishValidator, ...this.validators.slice(1)], this.constraints);
        }
      } else if (validator instanceof NullishValidator) {
        return this.clone();
      }
      return new UnionValidator([new NullishValidator, ...this.validators]);
    }
    or(...predicates) {
      return new UnionValidator([...this.validators, ...predicates]);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.constraints]);
    }
    handle(value) {
      const errors = [];
      for (const validator of this.validators) {
        const result = validator.run(value);
        if (result.isOk())
          return result;
        errors.push(result.error);
      }
      return Result.err(new CombinedError(errors));
    }
  };
  __name(UnionValidator, "UnionValidator");
  var ObjectValidator = class extends BaseValidator {
    constructor(shape, strategy = 0, constraints = []) {
      super(constraints);
      this.keys = [];
      this.requiredKeys = new Map;
      this.possiblyUndefinedKeys = new Map;
      this.possiblyUndefinedKeysWithDefaults = new Map;
      this.shape = shape;
      this.strategy = strategy;
      switch (this.strategy) {
        case 0:
          this.handleStrategy = (value) => this.handleIgnoreStrategy(value);
          break;
        case 1: {
          this.handleStrategy = (value) => this.handleStrictStrategy(value);
          break;
        }
        case 2:
          this.handleStrategy = (value) => this.handlePassthroughStrategy(value);
          break;
      }
      const shapeEntries = Object.entries(shape);
      this.keys = shapeEntries.map(([key]) => key);
      for (const [key, validator] of shapeEntries) {
        if (validator instanceof UnionValidator) {
          const [possiblyLiteralOrNullishPredicate] = validator["validators"];
          if (possiblyLiteralOrNullishPredicate instanceof NullishValidator) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else if (possiblyLiteralOrNullishPredicate instanceof LiteralValidator) {
            if (possiblyLiteralOrNullishPredicate.expected === undefined) {
              this.possiblyUndefinedKeys.set(key, validator);
            } else {
              this.requiredKeys.set(key, validator);
            }
          } else if (validator instanceof DefaultValidator) {
            this.possiblyUndefinedKeysWithDefaults.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof NullishValidator) {
          this.possiblyUndefinedKeys.set(key, validator);
        } else if (validator instanceof LiteralValidator) {
          if (validator.expected === undefined) {
            this.possiblyUndefinedKeys.set(key, validator);
          } else {
            this.requiredKeys.set(key, validator);
          }
        } else if (validator instanceof DefaultValidator) {
          this.possiblyUndefinedKeysWithDefaults.set(key, validator);
        } else {
          this.requiredKeys.set(key, validator);
        }
      }
    }
    get strict() {
      return Reflect.construct(this.constructor, [this.shape, 1, this.constraints]);
    }
    get ignore() {
      return Reflect.construct(this.constructor, [this.shape, 0, this.constraints]);
    }
    get passthrough() {
      return Reflect.construct(this.constructor, [this.shape, 2, this.constraints]);
    }
    get partial() {
      const shape = Object.fromEntries(this.keys.map((key) => [key, this.shape[key].optional]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    get required() {
      const shape = Object.fromEntries(this.keys.map((key) => {
        let validator = this.shape[key];
        if (validator instanceof UnionValidator)
          validator = validator.required;
        return [key, validator];
      }));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    extend(schema) {
      const shape = { ...this.shape, ...schema instanceof ObjectValidator ? schema.shape : schema };
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    pick(keys) {
      const shape = Object.fromEntries(keys.filter((key) => this.keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    omit(keys) {
      const shape = Object.fromEntries(this.keys.filter((key) => !keys.includes(key)).map((key) => [key, this.shape[key]]));
      return Reflect.construct(this.constructor, [shape, this.strategy, this.constraints]);
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue !== "object") {
        return Result.err(new ValidationError("s.object(T)", `Expected the value to be an object, but received ${typeOfValue} instead`, value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.object(T)", "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.object(T)", "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      for (const predicate of Object.values(this.shape)) {
        predicate.setParent(this.parent ?? value);
      }
      return this.handleStrategy(value);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.shape, this.strategy, this.constraints]);
    }
    handleIgnoreStrategy(value) {
      const errors = [];
      const finalObject = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalObject[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      if (inputEntries.size === 0) {
        return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
      }
      const checkInputEntriesInsteadOfSchemaKeys = this.possiblyUndefinedKeys.size > inputEntries.size;
      if (checkInputEntriesInsteadOfSchemaKeys) {
        for (const [key] of inputEntries) {
          const predicate = this.possiblyUndefinedKeys.get(key);
          if (predicate) {
            runPredicate(key, predicate);
          }
        }
      } else {
        for (const [key, predicate] of this.possiblyUndefinedKeys) {
          if (inputEntries.delete(key)) {
            runPredicate(key, predicate);
          }
        }
      }
      return errors.length === 0 ? Result.ok(finalObject) : Result.err(new CombinedPropertyError(errors));
    }
    handleStrictStrategy(value) {
      const errors = [];
      const finalResult = {};
      const inputEntries = new Map(Object.entries(value));
      const runPredicate = __name((key, predicate) => {
        const result = predicate.run(value[key]);
        if (result.isOk()) {
          finalResult[key] = result.value;
        } else {
          const error = result.error;
          errors.push([key, error]);
        }
      }, "runPredicate");
      for (const [key, predicate] of this.requiredKeys) {
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        } else {
          errors.push([key, new MissingPropertyError(key)]);
        }
      }
      for (const [key, validator] of this.possiblyUndefinedKeysWithDefaults) {
        inputEntries.delete(key);
        runPredicate(key, validator);
      }
      for (const [key, predicate] of this.possiblyUndefinedKeys) {
        if (inputEntries.size === 0) {
          break;
        }
        if (inputEntries.delete(key)) {
          runPredicate(key, predicate);
        }
      }
      if (inputEntries.size !== 0) {
        for (const [key, value2] of inputEntries.entries()) {
          errors.push([key, new UnknownPropertyError(key, value2)]);
        }
      }
      return errors.length === 0 ? Result.ok(finalResult) : Result.err(new CombinedPropertyError(errors));
    }
    handlePassthroughStrategy(value) {
      const result = this.handleIgnoreStrategy(value);
      return result.isErr() ? result : Result.ok({ ...value, ...result.value });
    }
  };
  __name(ObjectValidator, "ObjectValidator");
  var PassthroughValidator = class extends BaseValidator {
    handle(value) {
      return Result.ok(value);
    }
  };
  __name(PassthroughValidator, "PassthroughValidator");
  var RecordValidator = class extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(value) {
      if (typeof value !== "object") {
        return Result.err(new ValidationError("s.record(T)", "Expected an object", value));
      }
      if (value === null) {
        return Result.err(new ValidationError("s.record(T)", "Expected the value to not be null", value));
      }
      if (Array.isArray(value)) {
        return Result.err(new ValidationError("s.record(T)", "Expected the value to not be an array", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = {};
      for (const [key, val] of Object.entries(value)) {
        const result = this.validator.run(val);
        if (result.isOk())
          transformed[key] = result.value;
        else
          errors.push([key, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(RecordValidator, "RecordValidator");
  var SetValidator = class extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      if (!(values instanceof Set)) {
        return Result.err(new ValidationError("s.set(T)", "Expected a set", values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = new Set;
      for (const value of values) {
        const result = this.validator.run(value);
        if (result.isOk())
          transformed.add(result.value);
        else
          errors.push(result.error);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedError(errors));
    }
  };
  __name(SetValidator, "SetValidator");
  var accountRegex = /^(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")$/;
  __name(validateEmail, "validateEmail");
  __name(validateEmailDomain, "validateEmailDomain");
  var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
  var IPv4Reg = new RegExp(`^${v4Str}\$`);
  var v6Seg = "(?:[0-9a-fA-F]{1,4})";
  var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?\$`);
  __name(isIPv4, "isIPv4");
  __name(isIPv6, "isIPv6");
  __name(isIP, "isIP");
  var phoneNumberRegex = /^((?:\+|0{0,2})\d{1,2}\s?)?\(?\d{3}\)?[\s.-]?\d{3}[\s.-]?\d{4}$/;
  __name(validatePhoneNumber, "validatePhoneNumber");
  var MultiplePossibilitiesConstraintError = class extends BaseConstraintError {
    constructor(constraint, message, given, expected) {
      super(constraint, message, given);
      this.expected = expected;
    }
    toJSON() {
      return {
        name: this.name,
        constraint: this.constraint,
        given: this.given,
        expected: this.expected
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const constraint = options.stylize(this.constraint, "string");
      if (depth < 0) {
        return options.stylize(`[MultiplePossibilitiesConstraintError: ${constraint}]`, "special");
      }
      const newOptions = { ...options, depth: options.depth === null ? null : options.depth - 1 };
      const verticalLine = options.stylize("|", "undefined");
      const padding = `
  ${verticalLine} `;
      const given = util.inspect(this.given, newOptions).replace(/\n/g, padding);
      const header = `${options.stylize("MultiplePossibilitiesConstraintError", "special")} > ${constraint}`;
      const message = options.stylize(this.message, "regexp");
      const expectedPadding = `
  ${verticalLine} - `;
      const expectedBlock = `
  ${options.stylize("Expected any of the following:", "string")}${expectedPadding}${this.expected.map((possible) => options.stylize(possible, "boolean")).join(expectedPadding)}`;
      const givenBlock = `
  ${options.stylize("Received:", "regexp")}${padding}${given}`;
      return `${header}
  ${message}
${expectedBlock}
${givenBlock}`;
    }
  };
  __name(MultiplePossibilitiesConstraintError, "MultiplePossibilitiesConstraintError");
  __name(combinedErrorFn, "combinedErrorFn");
  __name(createUrlValidators, "createUrlValidators");
  __name(allowedProtocolsFn, "allowedProtocolsFn");
  __name(allowedDomainsFn, "allowedDomainsFn");
  __name(stringLengthComparator, "stringLengthComparator");
  __name(stringLengthLessThan, "stringLengthLessThan");
  __name(stringLengthLessThanOrEqual, "stringLengthLessThanOrEqual");
  __name(stringLengthGreaterThan, "stringLengthGreaterThan");
  __name(stringLengthGreaterThanOrEqual, "stringLengthGreaterThanOrEqual");
  __name(stringLengthEqual, "stringLengthEqual");
  __name(stringLengthNotEqual, "stringLengthNotEqual");
  __name(stringEmail, "stringEmail");
  __name(stringRegexValidator, "stringRegexValidator");
  __name(stringUrl, "stringUrl");
  __name(stringIp, "stringIp");
  __name(stringRegex, "stringRegex");
  __name(stringUuid, "stringUuid");
  __name(stringDate, "stringDate");
  __name(stringPhone, "stringPhone");
  var StringValidator = class extends BaseValidator {
    lengthLessThan(length) {
      return this.addConstraint(stringLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(stringLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(stringLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(stringLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(stringLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(stringLengthNotEqual(length));
    }
    get email() {
      return this.addConstraint(stringEmail());
    }
    url(options) {
      return this.addConstraint(stringUrl(options));
    }
    uuid(options) {
      return this.addConstraint(stringUuid(options));
    }
    regex(regex) {
      return this.addConstraint(stringRegex(regex));
    }
    get date() {
      return this.addConstraint(stringDate());
    }
    get ipv4() {
      return this.ip(4);
    }
    get ipv6() {
      return this.ip(6);
    }
    ip(version) {
      return this.addConstraint(stringIp(version));
    }
    phone() {
      return this.addConstraint(stringPhone());
    }
    handle(value) {
      return typeof value === "string" ? Result.ok(value) : Result.err(new ValidationError("s.string", "Expected a string primitive", value));
    }
  };
  __name(StringValidator, "StringValidator");
  var TupleValidator = class extends BaseValidator {
    constructor(validators, constraints = []) {
      super(constraints);
      this.validators = [];
      this.validators = validators;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validators, this.constraints]);
    }
    handle(values) {
      if (!Array.isArray(values)) {
        return Result.err(new ValidationError("s.tuple(T)", "Expected an array", values));
      }
      if (values.length !== this.validators.length) {
        return Result.err(new ValidationError("s.tuple(T)", `Expected an array of length ${this.validators.length}`, values));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(values);
      }
      const errors = [];
      const transformed = [];
      for (let i = 0;i < values.length; i++) {
        const result = this.validators[i].run(values[i]);
        if (result.isOk())
          transformed.push(result.value);
        else
          errors.push([i, result.error]);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(TupleValidator, "TupleValidator");
  var MapValidator = class extends BaseValidator {
    constructor(keyValidator, valueValidator, constraints = []) {
      super(constraints);
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.keyValidator, this.valueValidator, this.constraints]);
    }
    handle(value) {
      if (!(value instanceof Map)) {
        return Result.err(new ValidationError("s.map(K, V)", "Expected a map", value));
      }
      if (!this.shouldRunConstraints) {
        return Result.ok(value);
      }
      const errors = [];
      const transformed = new Map;
      for (const [key, val] of value.entries()) {
        const keyResult = this.keyValidator.run(key);
        const valueResult = this.valueValidator.run(val);
        const { length } = errors;
        if (keyResult.isErr())
          errors.push([key, keyResult.error]);
        if (valueResult.isErr())
          errors.push([key, valueResult.error]);
        if (errors.length === length)
          transformed.set(keyResult.value, valueResult.value);
      }
      return errors.length === 0 ? Result.ok(transformed) : Result.err(new CombinedPropertyError(errors));
    }
  };
  __name(MapValidator, "MapValidator");
  var LazyValidator = class extends BaseValidator {
    constructor(validator, constraints = []) {
      super(constraints);
      this.validator = validator;
    }
    clone() {
      return Reflect.construct(this.constructor, [this.validator, this.constraints]);
    }
    handle(values) {
      return this.validator(values).run(values);
    }
  };
  __name(LazyValidator, "LazyValidator");
  var UnknownEnumValueError = class extends BaseError {
    constructor(value, keys, enumMappings) {
      super("Expected the value to be one of the following enum values:");
      this.value = value;
      this.enumKeys = keys;
      this.enumMappings = enumMappings;
    }
    toJSON() {
      return {
        name: this.name,
        value: this.value,
        enumKeys: this.enumKeys,
        enumMappings: [...this.enumMappings.entries()]
      };
    }
    [customInspectSymbolStackLess](depth, options) {
      const value = options.stylize(this.value.toString(), "string");
      if (depth < 0) {
        return options.stylize(`[UnknownEnumValueError: ${value}]`, "special");
      }
      const padding = `
  ${options.stylize("|", "undefined")} `;
      const pairs = this.enumKeys.map((key) => {
        const enumValue = this.enumMappings.get(key);
        return `${options.stylize(key, "string")} or ${options.stylize(enumValue.toString(), typeof enumValue === "number" ? "number" : "string")}`;
      }).join(padding);
      const header = `${options.stylize("UnknownEnumValueError", "special")} > ${value}`;
      const message = options.stylize(this.message, "regexp");
      const pairsBlock = `${padding}${pairs}`;
      return `${header}
  ${message}
${pairsBlock}`;
    }
  };
  __name(UnknownEnumValueError, "UnknownEnumValueError");
  var NativeEnumValidator = class extends BaseValidator {
    constructor(enumShape) {
      super();
      this.hasNumericElements = false;
      this.enumMapping = new Map;
      this.enumShape = enumShape;
      this.enumKeys = Object.keys(enumShape).filter((key) => {
        return typeof enumShape[enumShape[key]] !== "number";
      });
      for (const key of this.enumKeys) {
        const enumValue = enumShape[key];
        this.enumMapping.set(key, enumValue);
        this.enumMapping.set(enumValue, enumValue);
        if (typeof enumValue === "number") {
          this.hasNumericElements = true;
          this.enumMapping.set(`${enumValue}`, enumValue);
        }
      }
    }
    handle(value) {
      const typeOfValue = typeof value;
      if (typeOfValue === "number") {
        if (!this.hasNumericElements) {
          return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string", value));
        }
      } else if (typeOfValue !== "string") {
        return Result.err(new ValidationError("s.nativeEnum(T)", "Expected the value to be a string or number", value));
      }
      const casted = value;
      const possibleEnumValue = this.enumMapping.get(casted);
      return typeof possibleEnumValue === "undefined" ? Result.err(new UnknownEnumValueError(casted, this.enumKeys, this.enumMapping)) : Result.ok(possibleEnumValue);
    }
    clone() {
      return Reflect.construct(this.constructor, [this.enumShape]);
    }
  };
  __name(NativeEnumValidator, "NativeEnumValidator");
  __name(typedArrayByteLengthComparator, "typedArrayByteLengthComparator");
  __name(typedArrayByteLengthLessThan, "typedArrayByteLengthLessThan");
  __name(typedArrayByteLengthLessThanOrEqual, "typedArrayByteLengthLessThanOrEqual");
  __name(typedArrayByteLengthGreaterThan, "typedArrayByteLengthGreaterThan");
  __name(typedArrayByteLengthGreaterThanOrEqual, "typedArrayByteLengthGreaterThanOrEqual");
  __name(typedArrayByteLengthEqual, "typedArrayByteLengthEqual");
  __name(typedArrayByteLengthNotEqual, "typedArrayByteLengthNotEqual");
  __name(typedArrayByteLengthRange, "typedArrayByteLengthRange");
  __name(typedArrayByteLengthRangeInclusive, "typedArrayByteLengthRangeInclusive");
  __name(typedArrayByteLengthRangeExclusive, "typedArrayByteLengthRangeExclusive");
  __name(typedArrayLengthComparator, "typedArrayLengthComparator");
  __name(typedArrayLengthLessThan, "typedArrayLengthLessThan");
  __name(typedArrayLengthLessThanOrEqual, "typedArrayLengthLessThanOrEqual");
  __name(typedArrayLengthGreaterThan, "typedArrayLengthGreaterThan");
  __name(typedArrayLengthGreaterThanOrEqual, "typedArrayLengthGreaterThanOrEqual");
  __name(typedArrayLengthEqual, "typedArrayLengthEqual");
  __name(typedArrayLengthNotEqual, "typedArrayLengthNotEqual");
  __name(typedArrayLengthRange, "typedArrayLengthRange");
  __name(typedArrayLengthRangeInclusive, "typedArrayLengthRangeInclusive");
  __name(typedArrayLengthRangeExclusive, "typedArrayLengthRangeExclusive");
  var vowels = ["a", "e", "i", "o", "u"];
  var aOrAn = __name((word) => {
    return `${vowels.includes(word[0].toLowerCase()) ? "an" : "a"} ${word}`;
  }, "aOrAn");
  var TypedArrays = {
    Int8Array: (x) => x instanceof Int8Array,
    Uint8Array: (x) => x instanceof Uint8Array,
    Uint8ClampedArray: (x) => x instanceof Uint8ClampedArray,
    Int16Array: (x) => x instanceof Int16Array,
    Uint16Array: (x) => x instanceof Uint16Array,
    Int32Array: (x) => x instanceof Int32Array,
    Uint32Array: (x) => x instanceof Uint32Array,
    Float32Array: (x) => x instanceof Float32Array,
    Float64Array: (x) => x instanceof Float64Array,
    BigInt64Array: (x) => x instanceof BigInt64Array,
    BigUint64Array: (x) => x instanceof BigUint64Array,
    TypedArray: (x) => ArrayBuffer.isView(x) && !(x instanceof DataView)
  };
  var TypedArrayValidator = class extends BaseValidator {
    constructor(type, constraints = []) {
      super(constraints);
      this.type = type;
    }
    byteLengthLessThan(length) {
      return this.addConstraint(typedArrayByteLengthLessThan(length));
    }
    byteLengthLessThanOrEqual(length) {
      return this.addConstraint(typedArrayByteLengthLessThanOrEqual(length));
    }
    byteLengthGreaterThan(length) {
      return this.addConstraint(typedArrayByteLengthGreaterThan(length));
    }
    byteLengthGreaterThanOrEqual(length) {
      return this.addConstraint(typedArrayByteLengthGreaterThanOrEqual(length));
    }
    byteLengthEqual(length) {
      return this.addConstraint(typedArrayByteLengthEqual(length));
    }
    byteLengthNotEqual(length) {
      return this.addConstraint(typedArrayByteLengthNotEqual(length));
    }
    byteLengthRange(start, endBefore) {
      return this.addConstraint(typedArrayByteLengthRange(start, endBefore));
    }
    byteLengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(typedArrayByteLengthRangeInclusive(startAt, endAt));
    }
    byteLengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(typedArrayByteLengthRangeExclusive(startAfter, endBefore));
    }
    lengthLessThan(length) {
      return this.addConstraint(typedArrayLengthLessThan(length));
    }
    lengthLessThanOrEqual(length) {
      return this.addConstraint(typedArrayLengthLessThanOrEqual(length));
    }
    lengthGreaterThan(length) {
      return this.addConstraint(typedArrayLengthGreaterThan(length));
    }
    lengthGreaterThanOrEqual(length) {
      return this.addConstraint(typedArrayLengthGreaterThanOrEqual(length));
    }
    lengthEqual(length) {
      return this.addConstraint(typedArrayLengthEqual(length));
    }
    lengthNotEqual(length) {
      return this.addConstraint(typedArrayLengthNotEqual(length));
    }
    lengthRange(start, endBefore) {
      return this.addConstraint(typedArrayLengthRange(start, endBefore));
    }
    lengthRangeInclusive(startAt, endAt) {
      return this.addConstraint(typedArrayLengthRangeInclusive(startAt, endAt));
    }
    lengthRangeExclusive(startAfter, endBefore) {
      return this.addConstraint(typedArrayLengthRangeExclusive(startAfter, endBefore));
    }
    clone() {
      return Reflect.construct(this.constructor, [this.type, this.constraints]);
    }
    handle(value) {
      return TypedArrays[this.type](value) ? Result.ok(value) : Result.err(new ValidationError("s.typedArray", `Expected ${aOrAn(this.type)}`, value));
    }
  };
  __name(TypedArrayValidator, "TypedArrayValidator");
  var Shapes = class {
    get string() {
      return new StringValidator;
    }
    get number() {
      return new NumberValidator;
    }
    get bigint() {
      return new BigIntValidator;
    }
    get boolean() {
      return new BooleanValidator;
    }
    get date() {
      return new DateValidator;
    }
    object(shape) {
      return new ObjectValidator(shape);
    }
    get undefined() {
      return this.literal(undefined);
    }
    get null() {
      return this.literal(null);
    }
    get nullish() {
      return new NullishValidator;
    }
    get any() {
      return new PassthroughValidator;
    }
    get unknown() {
      return new PassthroughValidator;
    }
    get never() {
      return new NeverValidator;
    }
    enum(...values) {
      return this.union(...values.map((value) => this.literal(value)));
    }
    nativeEnum(enumShape) {
      return new NativeEnumValidator(enumShape);
    }
    literal(value) {
      if (value instanceof Date)
        return this.date.equal(value);
      return new LiteralValidator(value);
    }
    instance(expected) {
      return new InstanceValidator(expected);
    }
    union(...validators) {
      return new UnionValidator(validators);
    }
    array(validator) {
      return new ArrayValidator(validator);
    }
    typedArray(type = "TypedArray") {
      return new TypedArrayValidator(type);
    }
    get int8Array() {
      return this.typedArray("Int8Array");
    }
    get uint8Array() {
      return this.typedArray("Uint8Array");
    }
    get uint8ClampedArray() {
      return this.typedArray("Uint8ClampedArray");
    }
    get int16Array() {
      return this.typedArray("Int16Array");
    }
    get uint16Array() {
      return this.typedArray("Uint16Array");
    }
    get int32Array() {
      return this.typedArray("Int32Array");
    }
    get uint32Array() {
      return this.typedArray("Uint32Array");
    }
    get float32Array() {
      return this.typedArray("Float32Array");
    }
    get float64Array() {
      return this.typedArray("Float64Array");
    }
    get bigInt64Array() {
      return this.typedArray("BigInt64Array");
    }
    get bigUint64Array() {
      return this.typedArray("BigUint64Array");
    }
    tuple(validators) {
      return new TupleValidator(validators);
    }
    set(validator) {
      return new SetValidator(validator);
    }
    record(validator) {
      return new RecordValidator(validator);
    }
    map(keyValidator, valueValidator) {
      return new MapValidator(keyValidator, valueValidator);
    }
    lazy(validator) {
      return new LazyValidator(validator);
    }
  };
  __name(Shapes, "Shapes");
  var s = new Shapes;
  exports.BaseError = BaseError;
  exports.CombinedError = CombinedError;
  exports.CombinedPropertyError = CombinedPropertyError;
  exports.ExpectedConstraintError = ExpectedConstraintError;
  exports.ExpectedValidationError = ExpectedValidationError;
  exports.MissingPropertyError = MissingPropertyError;
  exports.MultiplePossibilitiesConstraintError = MultiplePossibilitiesConstraintError;
  exports.Result = Result;
  exports.UnknownEnumValueError = UnknownEnumValueError;
  exports.UnknownPropertyError = UnknownPropertyError;
  exports.ValidationError = ValidationError;
  exports.customInspectSymbol = customInspectSymbol;
  exports.customInspectSymbolStackLess = customInspectSymbolStackLess;
  exports.getGlobalValidationEnabled = getGlobalValidationEnabled;
  exports.s = s;
  exports.setGlobalValidationEnabled = setGlobalValidationEnabled;
});

// node_modules/@discordjs/formatters/dist/index.js
var require_dist9 = __commonJS((exports, module) => {
  var escapeMarkdown = function(text, options = {}) {
    const {
      codeBlock: codeBlock2 = true,
      inlineCode: inlineCode2 = true,
      bold: bold2 = true,
      italic: italic2 = true,
      underline = true,
      strikethrough: strikethrough2 = true,
      spoiler: spoiler2 = true,
      codeBlockContent = true,
      inlineCodeContent = true,
      escape = true,
      heading = false,
      bulletedList = false,
      numberedList = false,
      maskedLink = false
    } = options;
    if (!codeBlockContent) {
      return text.split("```").map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          inlineCode: inlineCode2,
          bold: bold2,
          italic: italic2,
          underline,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          inlineCodeContent,
          escape,
          heading,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(codeBlock2 ? "\\`\\`\\`" : "```");
    }
    if (!inlineCodeContent) {
      return text.split(/(?<=^|[^`])`(?=[^`]|$)/g).map((subString, index, array) => {
        if (index % 2 && index !== array.length - 1)
          return subString;
        return escapeMarkdown(subString, {
          codeBlock: codeBlock2,
          bold: bold2,
          italic: italic2,
          underline,
          strikethrough: strikethrough2,
          spoiler: spoiler2,
          escape,
          heading,
          bulletedList,
          numberedList,
          maskedLink
        });
      }).join(inlineCode2 ? "\\`" : "`");
    }
    let res = text;
    if (escape)
      res = escapeEscape(res);
    if (inlineCode2)
      res = escapeInlineCode(res);
    if (codeBlock2)
      res = escapeCodeBlock(res);
    if (italic2)
      res = escapeItalic(res);
    if (bold2)
      res = escapeBold(res);
    if (underline)
      res = escapeUnderline(res);
    if (strikethrough2)
      res = escapeStrikethrough(res);
    if (spoiler2)
      res = escapeSpoiler(res);
    if (heading)
      res = escapeHeading(res);
    if (bulletedList)
      res = escapeBulletedList(res);
    if (numberedList)
      res = escapeNumberedList(res);
    if (maskedLink)
      res = escapeMaskedLink(res);
    return res;
  };
  var escapeCodeBlock = function(text) {
    return text.replaceAll("```", "\\`\\`\\`");
  };
  var escapeInlineCode = function(text) {
    return text.replaceAll(/(?<=^|[^`])``?(?=[^`]|$)/g, (match) => match.length === 2 ? "\\`\\`" : "\\`");
  };
  var escapeItalic = function(text) {
    let idx = 0;
    const newText = text.replaceAll(/(?<=^|[^*])\*([^*]|\*\*|$)/g, (_, match) => {
      if (match === "**")
        return ++idx % 2 ? `\\*${match}` : `${match}\\*`;
      return `\\*${match}`;
    });
    idx = 0;
    return newText.replaceAll(/(?<=^|[^_])(?<!<a?:.+)_(?!:\d+>)([^_]|__|$)/g, (_, match) => {
      if (match === "__")
        return ++idx % 2 ? `\\_${match}` : `${match}\\_`;
      return `\\_${match}`;
    });
  };
  var escapeBold = function(text) {
    let idx = 0;
    return text.replaceAll(/\*\*(\*)?/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\*\\*` : `\\*\\*${match}`;
      return "\\*\\*";
    });
  };
  var escapeUnderline = function(text) {
    let idx = 0;
    return text.replaceAll(/(?<!<a?:.+)__(_)?(?!:\d+>)/g, (_, match) => {
      if (match)
        return ++idx % 2 ? `${match}\\_\\_` : `\\_\\_${match}`;
      return "\\_\\_";
    });
  };
  var escapeStrikethrough = function(text) {
    return text.replaceAll("~~", "\\~\\~");
  };
  var escapeSpoiler = function(text) {
    return text.replaceAll("||", "\\|\\|");
  };
  var escapeEscape = function(text) {
    return text.replaceAll("\\", "\\\\");
  };
  var escapeHeading = function(text) {
    return text.replaceAll(/^( {0,2})([*-] )?( *)(#{1,3} )/gm, "$1$2$3\\$4");
  };
  var escapeBulletedList = function(text) {
    return text.replaceAll(/^( *)([*-])( +)/gm, "$1\\$2$3");
  };
  var escapeNumberedList = function(text) {
    return text.replaceAll(/^( *\d+)\./gm, "$1\\.");
  };
  var escapeMaskedLink = function(text) {
    return text.replaceAll(/\[.+]\(.+\)/gm, "\\$&");
  };
  var codeBlock = function(language, content) {
    return content === undefined ? `\`\`\`
${language}
\`\`\`` : `\`\`\`${language}
${content}
\`\`\``;
  };
  var inlineCode = function(content) {
    return `\`${content}\``;
  };
  var italic = function(content) {
    return `_${content}_`;
  };
  var bold = function(content) {
    return `**${content}**`;
  };
  var underscore = function(content) {
    return `__${content}__`;
  };
  var strikethrough = function(content) {
    return `~~${content}~~`;
  };
  var quote = function(content) {
    return `> ${content}`;
  };
  var blockQuote = function(content) {
    return `>>> ${content}`;
  };
  var hideLinkEmbed = function(url) {
    return `<${url}>`;
  };
  var hyperlink = function(content, url, title) {
    return title ? `[${content}](${url} "${title}")` : `[${content}](${url})`;
  };
  var spoiler = function(content) {
    return `||${content}||`;
  };
  var userMention = function(userId) {
    return `<@${userId}>`;
  };
  var channelMention = function(channelId) {
    return `<#${channelId}>`;
  };
  var roleMention = function(roleId) {
    return `<@&${roleId}>`;
  };
  var chatInputApplicationCommandMention = function(commandName, subcommandGroupName, subcommandName, commandId) {
    if (commandId !== undefined) {
      return `</${commandName} ${subcommandGroupName} ${subcommandName}:${commandId}>`;
    }
    if (subcommandName !== undefined) {
      return `</${commandName} ${subcommandGroupName}:${subcommandName}>`;
    }
    return `</${commandName}:${subcommandGroupName}>`;
  };
  var formatEmoji = function(emojiId, animated = false) {
    return `<${animated ? "a" : ""}:_:${emojiId}>`;
  };
  var channelLink = function(channelId, guildId) {
    return `https://discord.com/channels/${guildId ?? "@me"}/${channelId}`;
  };
  var messageLink = function(channelId, messageId, guildId) {
    return `${guildId === undefined ? channelLink(channelId) : channelLink(channelId, guildId)}/${messageId}`;
  };
  var time = function(timeOrSeconds, style) {
    if (typeof timeOrSeconds !== "number") {
      timeOrSeconds = Math.floor((timeOrSeconds?.getTime() ?? Date.now()) / 1000);
    }
    return typeof style === "string" ? `<t:${timeOrSeconds}:${style}>` : `<t:${timeOrSeconds}>`;
  };
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Faces: () => Faces,
    TimestampStyles: () => TimestampStyles,
    blockQuote: () => blockQuote,
    bold: () => bold,
    channelLink: () => channelLink,
    channelMention: () => channelMention,
    chatInputApplicationCommandMention: () => chatInputApplicationCommandMention,
    codeBlock: () => codeBlock,
    escapeBold: () => escapeBold,
    escapeBulletedList: () => escapeBulletedList,
    escapeCodeBlock: () => escapeCodeBlock,
    escapeEscape: () => escapeEscape,
    escapeHeading: () => escapeHeading,
    escapeInlineCode: () => escapeInlineCode,
    escapeItalic: () => escapeItalic,
    escapeMarkdown: () => escapeMarkdown,
    escapeMaskedLink: () => escapeMaskedLink,
    escapeNumberedList: () => escapeNumberedList,
    escapeSpoiler: () => escapeSpoiler,
    escapeStrikethrough: () => escapeStrikethrough,
    escapeUnderline: () => escapeUnderline,
    formatEmoji: () => formatEmoji,
    hideLinkEmbed: () => hideLinkEmbed,
    hyperlink: () => hyperlink,
    inlineCode: () => inlineCode,
    italic: () => italic,
    messageLink: () => messageLink,
    quote: () => quote,
    roleMention: () => roleMention,
    spoiler: () => spoiler,
    strikethrough: () => strikethrough,
    time: () => time,
    underscore: () => underscore,
    userMention: () => userMention
  });
  module.exports = __toCommonJS(src_exports);
  __name(escapeMarkdown, "escapeMarkdown");
  __name(escapeCodeBlock, "escapeCodeBlock");
  __name(escapeInlineCode, "escapeInlineCode");
  __name(escapeItalic, "escapeItalic");
  __name(escapeBold, "escapeBold");
  __name(escapeUnderline, "escapeUnderline");
  __name(escapeStrikethrough, "escapeStrikethrough");
  __name(escapeSpoiler, "escapeSpoiler");
  __name(escapeEscape, "escapeEscape");
  __name(escapeHeading, "escapeHeading");
  __name(escapeBulletedList, "escapeBulletedList");
  __name(escapeNumberedList, "escapeNumberedList");
  __name(escapeMaskedLink, "escapeMaskedLink");
  __name(codeBlock, "codeBlock");
  __name(inlineCode, "inlineCode");
  __name(italic, "italic");
  __name(bold, "bold");
  __name(underscore, "underscore");
  __name(strikethrough, "strikethrough");
  __name(quote, "quote");
  __name(blockQuote, "blockQuote");
  __name(hideLinkEmbed, "hideLinkEmbed");
  __name(hyperlink, "hyperlink");
  __name(spoiler, "spoiler");
  __name(userMention, "userMention");
  __name(channelMention, "channelMention");
  __name(roleMention, "roleMention");
  __name(chatInputApplicationCommandMention, "chatInputApplicationCommandMention");
  __name(formatEmoji, "formatEmoji");
  __name(channelLink, "channelLink");
  __name(messageLink, "messageLink");
  __name(time, "time");
  var TimestampStyles = {
    ShortTime: "t",
    LongTime: "T",
    ShortDate: "d",
    LongDate: "D",
    ShortDateTime: "f",
    LongDateTime: "F",
    RelativeTime: "R"
  };
  var Faces = ((Faces2) => {
    Faces2["Shrug"] = "\xAF_(\u30C4)_/\xAF";
    Faces2["Tableflip"] = "(\u256F\xB0\u25A1\xB0)\u256F\uFE35 \u253B\u2501\u253B";
    Faces2["Unflip"] = "\u252C\u2500\u252C\u30CE( \xBA _ \xBA\u30CE)";
    return Faces2;
  })(Faces || {});
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports, module) => {
  module.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length;i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length;i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length;i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ts-mixer/dist/cjs/util.js
var require_util8 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.flatten = exports.unique = exports.hardMixProtos = exports.nearestCommonProto = exports.protoChain = exports.copyProps = undefined;
  var copyProps = (dest, src, exclude = []) => {
    const props = Object.getOwnPropertyDescriptors(src);
    for (let prop of exclude)
      delete props[prop];
    Object.defineProperties(dest, props);
  };
  exports.copyProps = copyProps;
  var protoChain = (obj, currentChain = [obj]) => {
    const proto = Object.getPrototypeOf(obj);
    if (proto === null)
      return currentChain;
    return (0, exports.protoChain)(proto, [...currentChain, proto]);
  };
  exports.protoChain = protoChain;
  var nearestCommonProto = (...objs) => {
    if (objs.length === 0)
      return;
    let commonProto = undefined;
    const protoChains = objs.map((obj) => (0, exports.protoChain)(obj));
    while (protoChains.every((protoChain2) => protoChain2.length > 0)) {
      const protos = protoChains.map((protoChain2) => protoChain2.pop());
      const potentialCommonProto = protos[0];
      if (protos.every((proto) => proto === potentialCommonProto))
        commonProto = potentialCommonProto;
      else
        break;
    }
    return commonProto;
  };
  exports.nearestCommonProto = nearestCommonProto;
  var hardMixProtos = (ingredients, constructor, exclude = []) => {
    var _a;
    const base = (_a = (0, exports.nearestCommonProto)(...ingredients)) !== null && _a !== undefined ? _a : Object.prototype;
    const mixedProto = Object.create(base);
    const visitedProtos = (0, exports.protoChain)(base);
    for (let prototype of ingredients) {
      let protos = (0, exports.protoChain)(prototype);
      for (let i = protos.length - 1;i >= 0; i--) {
        let newProto = protos[i];
        if (visitedProtos.indexOf(newProto) === -1) {
          (0, exports.copyProps)(mixedProto, newProto, ["constructor", ...exclude]);
          visitedProtos.push(newProto);
        }
      }
    }
    mixedProto.constructor = constructor;
    return mixedProto;
  };
  exports.hardMixProtos = hardMixProtos;
  var unique = (arr) => arr.filter((e, i) => arr.indexOf(e) == i);
  exports.unique = unique;
  var flatten = (arr) => arr.length === 0 ? [] : arr.length === 1 ? arr[0] : arr.reduce((a1, a2) => [...a1, ...a2]);
  exports.flatten = flatten;
});

// node_modules/ts-mixer/dist/cjs/proxy.js
var require_proxy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.softMixProtos = exports.proxyMix = exports.getIngredientWithProp = undefined;
  var util_1 = require_util8();
  var getIngredientWithProp = (prop, ingredients) => {
    const protoChains = ingredients.map((ingredient) => (0, util_1.protoChain)(ingredient));
    let protoDepth = 0;
    let protosAreLeftToSearch = true;
    while (protosAreLeftToSearch) {
      protosAreLeftToSearch = false;
      for (let i = ingredients.length - 1;i >= 0; i--) {
        const searchTarget = protoChains[i][protoDepth];
        if (searchTarget !== undefined && searchTarget !== null) {
          protosAreLeftToSearch = true;
          if (Object.getOwnPropertyDescriptor(searchTarget, prop) != null) {
            return protoChains[i][0];
          }
        }
      }
      protoDepth++;
    }
    return;
  };
  exports.getIngredientWithProp = getIngredientWithProp;
  var proxyMix = (ingredients, prototype = Object.prototype) => new Proxy({}, {
    getPrototypeOf() {
      return prototype;
    },
    setPrototypeOf() {
      throw Error("Cannot set prototype of Proxies created by ts-mixer");
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor((0, exports.getIngredientWithProp)(prop, ingredients) || {}, prop);
    },
    defineProperty() {
      throw new Error("Cannot define new properties on Proxies created by ts-mixer");
    },
    has(_, prop) {
      return (0, exports.getIngredientWithProp)(prop, ingredients) !== undefined || prototype[prop] !== undefined;
    },
    get(_, prop) {
      return ((0, exports.getIngredientWithProp)(prop, ingredients) || prototype)[prop];
    },
    set(_, prop, val) {
      const ingredientWithProp = (0, exports.getIngredientWithProp)(prop, ingredients);
      if (ingredientWithProp === undefined)
        throw new Error("Cannot set new properties on Proxies created by ts-mixer");
      ingredientWithProp[prop] = val;
      return true;
    },
    deleteProperty() {
      throw new Error("Cannot delete properties on Proxies created by ts-mixer");
    },
    ownKeys() {
      return ingredients.map(Object.getOwnPropertyNames).reduce((prev, curr) => curr.concat(prev.filter((key) => curr.indexOf(key) < 0)));
    }
  });
  exports.proxyMix = proxyMix;
  var softMixProtos = (ingredients, constructor) => (0, exports.proxyMix)([...ingredients, { constructor }]);
  exports.softMixProtos = softMixProtos;
});

// node_modules/ts-mixer/dist/cjs/settings.js
var require_settings = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.settings = undefined;
  exports.settings = {
    initFunction: null,
    staticsStrategy: "copy",
    prototypeStrategy: "copy",
    decoratorInheritance: "deep"
  };
});

// node_modules/ts-mixer/dist/cjs/mixin-tracking.js
var require_mixin_tracking = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.registerMixins = exports.getMixinsForClass = undefined;
  var util_1 = require_util8();
  var mixins = new Map;
  var getMixinsForClass = (clazz) => mixins.get(clazz);
  exports.getMixinsForClass = getMixinsForClass;
  var registerMixins = (mixedClass, constituents) => mixins.set(mixedClass, constituents);
  exports.registerMixins = registerMixins;
  var hasMixin = (instance, mixin) => {
    if (instance instanceof mixin)
      return true;
    const constructor = instance.constructor;
    const visited = new Set;
    let frontier = new Set;
    frontier.add(constructor);
    while (frontier.size > 0) {
      if (frontier.has(mixin))
        return true;
      frontier.forEach((item) => visited.add(item));
      const newFrontier = new Set;
      frontier.forEach((item) => {
        var _a;
        const itemConstituents = (_a = mixins.get(item)) !== null && _a !== undefined ? _a : (0, util_1.protoChain)(item.prototype).map((proto) => proto.constructor).filter((item2) => item2 !== null);
        if (itemConstituents)
          itemConstituents.forEach((constituent) => {
            if (!visited.has(constituent) && !frontier.has(constituent))
              newFrontier.add(constituent);
          });
      });
      frontier = newFrontier;
    }
    return false;
  };
  exports.hasMixin = hasMixin;
});

// node_modules/ts-mixer/dist/cjs/decorator.js
var require_decorator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.decorate = exports.getDecoratorsForClass = exports.directDecoratorSearch = exports.deepDecoratorSearch = undefined;
  var util_1 = require_util8();
  var mixin_tracking_1 = require_mixin_tracking();
  var mergeObjectsOfDecorators = (o1, o2) => {
    var _a, _b;
    const allKeys = (0, util_1.unique)([...Object.getOwnPropertyNames(o1), ...Object.getOwnPropertyNames(o2)]);
    const mergedObject = {};
    for (let key of allKeys)
      mergedObject[key] = (0, util_1.unique)([...(_a = o1 === null || o1 === undefined ? undefined : o1[key]) !== null && _a !== undefined ? _a : [], ...(_b = o2 === null || o2 === undefined ? undefined : o2[key]) !== null && _b !== undefined ? _b : []]);
    return mergedObject;
  };
  var mergePropertyAndMethodDecorators = (d1, d2) => {
    var _a, _b, _c, _d;
    return {
      property: mergeObjectsOfDecorators((_a = d1 === null || d1 === undefined ? undefined : d1.property) !== null && _a !== undefined ? _a : {}, (_b = d2 === null || d2 === undefined ? undefined : d2.property) !== null && _b !== undefined ? _b : {}),
      method: mergeObjectsOfDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.method) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.method) !== null && _d !== undefined ? _d : {})
    };
  };
  var mergeDecorators = (d1, d2) => {
    var _a, _b, _c, _d, _e, _f;
    return {
      class: (0, util_1.unique)([...(_a = d1 === null || d1 === undefined ? undefined : d1.class) !== null && _a !== undefined ? _a : [], ...(_b = d2 === null || d2 === undefined ? undefined : d2.class) !== null && _b !== undefined ? _b : []]),
      static: mergePropertyAndMethodDecorators((_c = d1 === null || d1 === undefined ? undefined : d1.static) !== null && _c !== undefined ? _c : {}, (_d = d2 === null || d2 === undefined ? undefined : d2.static) !== null && _d !== undefined ? _d : {}),
      instance: mergePropertyAndMethodDecorators((_e = d1 === null || d1 === undefined ? undefined : d1.instance) !== null && _e !== undefined ? _e : {}, (_f = d2 === null || d2 === undefined ? undefined : d2.instance) !== null && _f !== undefined ? _f : {})
    };
  };
  var decorators = new Map;
  var findAllConstituentClasses = (...classes) => {
    var _a;
    const allClasses = new Set;
    const frontier = new Set([...classes]);
    while (frontier.size > 0) {
      for (let clazz of frontier) {
        const protoChainClasses = (0, util_1.protoChain)(clazz.prototype).map((proto) => proto.constructor);
        const mixinClasses = (_a = (0, mixin_tracking_1.getMixinsForClass)(clazz)) !== null && _a !== undefined ? _a : [];
        const potentiallyNewClasses = [...protoChainClasses, ...mixinClasses];
        const newClasses = potentiallyNewClasses.filter((c) => !allClasses.has(c));
        for (let newClass of newClasses)
          frontier.add(newClass);
        allClasses.add(clazz);
        frontier.delete(clazz);
      }
    }
    return [...allClasses];
  };
  var deepDecoratorSearch = (...classes) => {
    const decoratorsForClassChain = findAllConstituentClasses(...classes).map((clazz) => decorators.get(clazz)).filter((decorators2) => !!decorators2);
    if (decoratorsForClassChain.length == 0)
      return {};
    if (decoratorsForClassChain.length == 1)
      return decoratorsForClassChain[0];
    return decoratorsForClassChain.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.deepDecoratorSearch = deepDecoratorSearch;
  var directDecoratorSearch = (...classes) => {
    const classDecorators = classes.map((clazz) => (0, exports.getDecoratorsForClass)(clazz));
    if (classDecorators.length === 0)
      return {};
    if (classDecorators.length === 1)
      return classDecorators[0];
    return classDecorators.reduce((d1, d2) => mergeDecorators(d1, d2));
  };
  exports.directDecoratorSearch = directDecoratorSearch;
  var getDecoratorsForClass = (clazz) => {
    let decoratorsForClass = decorators.get(clazz);
    if (!decoratorsForClass) {
      decoratorsForClass = {};
      decorators.set(clazz, decoratorsForClass);
    }
    return decoratorsForClass;
  };
  exports.getDecoratorsForClass = getDecoratorsForClass;
  var decorateClass = (decorator) => (clazz) => {
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    let classDecorators = decoratorsForClass.class;
    if (!classDecorators) {
      classDecorators = [];
      decoratorsForClass.class = classDecorators;
    }
    classDecorators.push(decorator);
    return decorator(clazz);
  };
  var decorateMember = (decorator) => (object, key, ...otherArgs) => {
    var _a, _b, _c;
    const decoratorTargetType = typeof object === "function" ? "static" : "instance";
    const decoratorType = typeof object[key] === "function" ? "method" : "property";
    const clazz = decoratorTargetType === "static" ? object : object.constructor;
    const decoratorsForClass = (0, exports.getDecoratorsForClass)(clazz);
    const decoratorsForTargetType = (_a = decoratorsForClass === null || decoratorsForClass === undefined ? undefined : decoratorsForClass[decoratorTargetType]) !== null && _a !== undefined ? _a : {};
    decoratorsForClass[decoratorTargetType] = decoratorsForTargetType;
    let decoratorsForType = (_b = decoratorsForTargetType === null || decoratorsForTargetType === undefined ? undefined : decoratorsForTargetType[decoratorType]) !== null && _b !== undefined ? _b : {};
    decoratorsForTargetType[decoratorType] = decoratorsForType;
    let decoratorsForKey = (_c = decoratorsForType === null || decoratorsForType === undefined ? undefined : decoratorsForType[key]) !== null && _c !== undefined ? _c : [];
    decoratorsForType[key] = decoratorsForKey;
    decoratorsForKey.push(decorator);
    return decorator(object, key, ...otherArgs);
  };
  var decorate = (decorator) => (...args) => {
    if (args.length === 1)
      return decorateClass(decorator)(args[0]);
    return decorateMember(decorator)(...args);
  };
  exports.decorate = decorate;
});

// node_modules/ts-mixer/dist/cjs/mixins.js
var require_mixins = __commonJS((exports) => {
  var Mixin = function(...constructors) {
    var _a, _b, _c;
    const prototypes = constructors.map((constructor) => constructor.prototype);
    const initFunctionName = settings_1.settings.initFunction;
    if (initFunctionName !== null) {
      const initFunctions = prototypes.map((proto) => proto[initFunctionName]).filter((func) => typeof func === "function");
      const combinedInitFunction = function(...args) {
        for (let initFunction of initFunctions)
          initFunction.apply(this, args);
      };
      const extraProto = { [initFunctionName]: combinedInitFunction };
      prototypes.push(extraProto);
    }
    function MixedClass(...args) {
      for (const constructor of constructors)
        (0, util_1.copyProps)(this, new constructor(...args));
      if (initFunctionName !== null && typeof this[initFunctionName] === "function")
        this[initFunctionName].apply(this, args);
    }
    MixedClass.prototype = settings_1.settings.prototypeStrategy === "copy" ? (0, util_1.hardMixProtos)(prototypes, MixedClass) : (0, proxy_1.softMixProtos)(prototypes, MixedClass);
    Object.setPrototypeOf(MixedClass, settings_1.settings.staticsStrategy === "copy" ? (0, util_1.hardMixProtos)(constructors, null, ["prototype"]) : (0, proxy_1.proxyMix)(constructors, Function.prototype));
    let DecoratedMixedClass = MixedClass;
    if (settings_1.settings.decoratorInheritance !== "none") {
      const classDecorators = settings_1.settings.decoratorInheritance === "deep" ? (0, decorator_1.deepDecoratorSearch)(...constructors) : (0, decorator_1.directDecoratorSearch)(...constructors);
      for (let decorator of (_a = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.class) !== null && _a !== undefined ? _a : []) {
        const result = decorator(DecoratedMixedClass);
        if (result) {
          DecoratedMixedClass = result;
        }
      }
      applyPropAndMethodDecorators((_b = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.static) !== null && _b !== undefined ? _b : {}, DecoratedMixedClass);
      applyPropAndMethodDecorators((_c = classDecorators === null || classDecorators === undefined ? undefined : classDecorators.instance) !== null && _c !== undefined ? _c : {}, DecoratedMixedClass.prototype);
    }
    (0, mixin_tracking_1.registerMixins)(DecoratedMixedClass, constructors);
    return DecoratedMixedClass;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mix = exports.Mixin = undefined;
  var proxy_1 = require_proxy();
  var settings_1 = require_settings();
  var util_1 = require_util8();
  var decorator_1 = require_decorator();
  var mixin_tracking_1 = require_mixin_tracking();
  exports.Mixin = Mixin;
  var applyPropAndMethodDecorators = (propAndMethodDecorators, target) => {
    const propDecorators = propAndMethodDecorators.property;
    const methodDecorators = propAndMethodDecorators.method;
    if (propDecorators)
      for (let key in propDecorators)
        for (let decorator of propDecorators[key])
          decorator(target, key);
    if (methodDecorators)
      for (let key in methodDecorators)
        for (let decorator of methodDecorators[key])
          decorator(target, key, Object.getOwnPropertyDescriptor(target, key));
  };
  var mix = (...ingredients) => (decoratedClass) => {
    const mixedClass = Mixin(...ingredients.concat([decoratedClass]));
    Object.defineProperty(mixedClass, "name", {
      value: decoratedClass.name,
      writable: false
    });
    return mixedClass;
  };
  exports.mix = mix;
});

// node_modules/ts-mixer/dist/cjs/index.js
var require_cjs = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.hasMixin = exports.decorate = exports.settings = exports.mix = exports.Mixin = undefined;
  var mixins_1 = require_mixins();
  Object.defineProperty(exports, "Mixin", { enumerable: true, get: function() {
    return mixins_1.Mixin;
  } });
  Object.defineProperty(exports, "mix", { enumerable: true, get: function() {
    return mixins_1.mix;
  } });
  var settings_1 = require_settings();
  Object.defineProperty(exports, "settings", { enumerable: true, get: function() {
    return settings_1.settings;
  } });
  var decorator_1 = require_decorator();
  Object.defineProperty(exports, "decorate", { enumerable: true, get: function() {
    return decorator_1.decorate;
  } });
  var mixin_tracking_1 = require_mixin_tracking();
  Object.defineProperty(exports, "hasMixin", { enumerable: true, get: function() {
    return mixin_tracking_1.hasMixin;
  } });
});

// node_modules/@discordjs/builders/dist/index.js
var require_dist10 = __commonJS((exports, module) => {
  var enableValidators = function() {
    return validate = true;
  };
  var disableValidators = function() {
    return validate = false;
  };
  var isValidationEnabled = function() {
    return validate;
  };
  var validateFieldLength = function(amountAdding, fields) {
    fieldLengthPredicate.parse((fields?.length ?? 0) + amountAdding);
  };
  var normalizeArray = function(arr) {
    if (Array.isArray(arr[0]))
      return arr[0];
    return arr;
  };
  var validateRequiredSelectMenuParameters = function(options, customId) {
    customIdValidator.parse(customId);
    optionsValidator.parse(options);
  };
  var validateRequiredSelectMenuOptionParameters = function(label, value) {
    labelValueDescriptionValidator.parse(label);
    labelValueDescriptionValidator.parse(value);
  };
  var validateRequiredButtonParameters = function(style, label, emoji, customId, url) {
    if (url && customId) {
      throw new RangeError("URL and custom id are mutually exclusive");
    }
    if (!label && !emoji) {
      throw new RangeError("Buttons must have a label and/or an emoji");
    }
    if (style === import_v10.ButtonStyle.Link) {
      if (!url) {
        throw new RangeError("Link buttons must have a url");
      }
    } else if (url) {
      throw new RangeError("Non-link buttons cannot have a url");
    }
  };
  var validateRequiredParameters = function(customId, style, label) {
    customIdValidator.parse(customId);
    textInputStyleValidator.parse(style);
    labelValidator.parse(label);
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case import_v1010.ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case import_v1010.ComponentType.Button:
        return new ButtonBuilder(data);
      case import_v1010.ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case import_v1010.ComponentType.TextInput:
        return new TextInputBuilder(data);
      case import_v1010.ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case import_v1010.ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case import_v1010.ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case import_v1010.ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      default:
        throw new Error(`Cannot properly serialize component type: ${data.type}`);
    }
  };
  var validateRequiredParameters2 = function(customId, title, components) {
    customIdValidator.parse(customId);
    titleValidator.parse(title);
    componentsValidator.parse(components);
  };
  var validateName = function(name) {
    namePredicate.parse(name);
  };
  var validateDescription = function(description) {
    descriptionPredicate2.parse(description);
  };
  var validateLocale = function(locale) {
    return localePredicate.parse(locale);
  };
  var validateMaxOptionsLength = function(options) {
    maxArrayLengthPredicate.parse(options);
  };
  var validateRequiredParameters3 = function(name, description, options) {
    validateName(name);
    validateDescription(description);
    validateMaxOptionsLength(options);
  };
  var validateDefaultPermission = function(value) {
    booleanPredicate.parse(value);
  };
  var validateRequired = function(required) {
    booleanPredicate.parse(required);
  };
  var validateChoicesLength = function(amountAdding, choices) {
    choicesLengthPredicate.parse((choices?.length ?? 0) + amountAdding);
  };
  var assertReturnOfBuilder = function(input, ExpectedInstanceOf) {
    import_shapeshift5.s.instance(ExpectedInstanceOf).parse(input);
  };
  var validateLocalizationMap = function(value) {
    localizationMapPredicate.parse(value);
  };
  var validateDMPermission = function(value) {
    dmPermissionPredicate.parse(value);
  };
  var validateDefaultMemberPermissions = function(permissions) {
    return memberPermissionPredicate.parse(permissions);
  };
  var validateNSFW = function(value) {
    booleanPredicate.parse(value);
  };
  var validateDefaultPermission2 = function(value) {
    booleanPredicate3.parse(value);
  };
  var validateName2 = function(name) {
    namePredicate2.parse(name);
  };
  var validateType = function(type) {
    typePredicate.parse(type);
  };
  var validateRequiredParameters4 = function(name, type) {
    validateName2(name);
    validateType(type);
  };
  var validateDMPermission2 = function(value) {
    dmPermissionPredicate2.parse(value);
  };
  var validateDefaultMemberPermissions2 = function(permissions) {
    return memberPermissionPredicate2.parse(permissions);
  };
  var embedLength = function(data) {
    return (data.title?.length ?? 0) + (data.description?.length ?? 0) + (data.fields?.reduce((prev, curr) => prev + curr.name.length + curr.value.length, 0) ?? 0) + (data.footer?.text.length ?? 0) + (data.author?.name.length ?? 0);
  };
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? undefined : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator;i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp2(target, key, result);
    return result;
  };
  var src_exports = {};
  __export2(src_exports, {
    ActionRowBuilder: () => ActionRowBuilder,
    ApplicationCommandNumericOptionMinMaxValueMixin: () => ApplicationCommandNumericOptionMinMaxValueMixin,
    ApplicationCommandOptionBase: () => ApplicationCommandOptionBase,
    ApplicationCommandOptionChannelTypesMixin: () => ApplicationCommandOptionChannelTypesMixin,
    ApplicationCommandOptionWithChoicesAndAutocompleteMixin: () => ApplicationCommandOptionWithChoicesAndAutocompleteMixin,
    BaseSelectMenuBuilder: () => BaseSelectMenuBuilder,
    ButtonBuilder: () => ButtonBuilder,
    ChannelSelectMenuBuilder: () => ChannelSelectMenuBuilder,
    ComponentAssertions: () => Assertions_exports2,
    ComponentBuilder: () => ComponentBuilder,
    ContextMenuCommandAssertions: () => Assertions_exports6,
    ContextMenuCommandBuilder: () => ContextMenuCommandBuilder,
    EmbedAssertions: () => Assertions_exports,
    EmbedBuilder: () => EmbedBuilder,
    MentionableSelectMenuBuilder: () => MentionableSelectMenuBuilder,
    ModalAssertions: () => Assertions_exports4,
    ModalBuilder: () => ModalBuilder,
    RoleSelectMenuBuilder: () => RoleSelectMenuBuilder,
    SelectMenuBuilder: () => StringSelectMenuBuilder,
    SelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    SharedNameAndDescription: () => SharedNameAndDescription,
    SharedSlashCommandOptions: () => SharedSlashCommandOptions,
    SlashCommandAssertions: () => Assertions_exports5,
    SlashCommandAttachmentOption: () => SlashCommandAttachmentOption,
    SlashCommandBooleanOption: () => SlashCommandBooleanOption,
    SlashCommandBuilder: () => SlashCommandBuilder,
    SlashCommandChannelOption: () => SlashCommandChannelOption,
    SlashCommandIntegerOption: () => SlashCommandIntegerOption,
    SlashCommandMentionableOption: () => SlashCommandMentionableOption,
    SlashCommandNumberOption: () => SlashCommandNumberOption,
    SlashCommandRoleOption: () => SlashCommandRoleOption,
    SlashCommandStringOption: () => SlashCommandStringOption,
    SlashCommandSubcommandBuilder: () => SlashCommandSubcommandBuilder,
    SlashCommandSubcommandGroupBuilder: () => SlashCommandSubcommandGroupBuilder,
    SlashCommandUserOption: () => SlashCommandUserOption,
    StringSelectMenuBuilder: () => StringSelectMenuBuilder,
    StringSelectMenuOptionBuilder: () => StringSelectMenuOptionBuilder,
    TextInputAssertions: () => Assertions_exports3,
    TextInputBuilder: () => TextInputBuilder,
    UserSelectMenuBuilder: () => UserSelectMenuBuilder,
    createComponentBuilder: () => createComponentBuilder,
    disableValidators: () => disableValidators,
    embedLength: () => embedLength,
    enableValidators: () => enableValidators,
    isValidationEnabled: () => isValidationEnabled,
    normalizeArray: () => normalizeArray,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  var Assertions_exports = {};
  __export2(Assertions_exports, {
    RGBPredicate: () => RGBPredicate,
    authorNamePredicate: () => authorNamePredicate,
    colorPredicate: () => colorPredicate,
    descriptionPredicate: () => descriptionPredicate,
    embedAuthorPredicate: () => embedAuthorPredicate,
    embedFieldPredicate: () => embedFieldPredicate,
    embedFieldsArrayPredicate: () => embedFieldsArrayPredicate,
    embedFooterPredicate: () => embedFooterPredicate,
    fieldInlinePredicate: () => fieldInlinePredicate,
    fieldLengthPredicate: () => fieldLengthPredicate,
    fieldNamePredicate: () => fieldNamePredicate,
    fieldValuePredicate: () => fieldValuePredicate,
    footerTextPredicate: () => footerTextPredicate,
    imageURLPredicate: () => imageURLPredicate,
    timestampPredicate: () => timestampPredicate,
    titlePredicate: () => titlePredicate,
    urlPredicate: () => urlPredicate,
    validateFieldLength: () => validateFieldLength
  });
  var import_shapeshift = require_dist8();
  var validate = true;
  __name(enableValidators, "enableValidators");
  __name(disableValidators, "disableValidators");
  __name(isValidationEnabled, "isValidationEnabled");
  var fieldNamePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(256).setValidationEnabled(isValidationEnabled);
  var fieldValuePredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(1024).setValidationEnabled(isValidationEnabled);
  var fieldInlinePredicate = import_shapeshift.s.boolean.optional;
  var embedFieldPredicate = import_shapeshift.s.object({
    name: fieldNamePredicate,
    value: fieldValuePredicate,
    inline: fieldInlinePredicate
  }).setValidationEnabled(isValidationEnabled);
  var embedFieldsArrayPredicate = embedFieldPredicate.array.setValidationEnabled(isValidationEnabled);
  var fieldLengthPredicate = import_shapeshift.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateFieldLength, "validateFieldLength");
  var authorNamePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
  var imageURLPredicate = import_shapeshift.s.string.url({
    allowedProtocols: ["http:", "https:", "attachment:"]
  }).nullish.setValidationEnabled(isValidationEnabled);
  var urlPredicate = import_shapeshift.s.string.url({
    allowedProtocols: ["http:", "https:"]
  }).nullish.setValidationEnabled(isValidationEnabled);
  var embedAuthorPredicate = import_shapeshift.s.object({
    name: authorNamePredicate,
    iconURL: imageURLPredicate,
    url: urlPredicate
  }).setValidationEnabled(isValidationEnabled);
  var RGBPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(255).setValidationEnabled(isValidationEnabled);
  var colorPredicate = import_shapeshift.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(16777215).or(import_shapeshift.s.tuple([RGBPredicate, RGBPredicate, RGBPredicate])).nullable.setValidationEnabled(isValidationEnabled);
  var descriptionPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(4096).nullable.setValidationEnabled(isValidationEnabled);
  var footerTextPredicate = import_shapeshift.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(2048).nullable.setValidationEnabled(isValidationEnabled);
  var embedFooterPredicate = import_shapeshift.s.object({
    text: footerTextPredicate,
    iconURL: imageURLPredicate
  }).setValidationEnabled(isValidationEnabled);
  var timestampPredicate = import_shapeshift.s.union(import_shapeshift.s.number, import_shapeshift.s.date).nullable.setValidationEnabled(isValidationEnabled);
  var titlePredicate = fieldNamePredicate.nullable.setValidationEnabled(isValidationEnabled);
  __name(normalizeArray, "normalizeArray");
  var EmbedBuilder = class {
    static {
      __name(this, "EmbedBuilder");
    }
    data;
    constructor(data = {}) {
      this.data = { ...data };
      if (data.timestamp)
        this.data.timestamp = new Date(data.timestamp).toISOString();
    }
    addFields(...fields) {
      const normalizedFields = normalizeArray(fields);
      validateFieldLength(normalizedFields.length, this.data.fields);
      embedFieldsArrayPredicate.parse(normalizedFields);
      if (this.data.fields)
        this.data.fields.push(...normalizedFields);
      else
        this.data.fields = normalizedFields;
      return this;
    }
    spliceFields(index, deleteCount, ...fields) {
      validateFieldLength(fields.length - deleteCount, this.data.fields);
      embedFieldsArrayPredicate.parse(fields);
      if (this.data.fields)
        this.data.fields.splice(index, deleteCount, ...fields);
      else
        this.data.fields = fields;
      return this;
    }
    setFields(...fields) {
      this.spliceFields(0, this.data.fields?.length ?? 0, ...normalizeArray(fields));
      return this;
    }
    setAuthor(options) {
      if (options === null) {
        this.data.author = undefined;
        return this;
      }
      embedAuthorPredicate.parse(options);
      this.data.author = { name: options.name, url: options.url, icon_url: options.iconURL };
      return this;
    }
    setColor(color) {
      colorPredicate.parse(color);
      if (Array.isArray(color)) {
        const [red, green, blue] = color;
        this.data.color = (red << 16) + (green << 8) + blue;
        return this;
      }
      this.data.color = color ?? undefined;
      return this;
    }
    setDescription(description) {
      descriptionPredicate.parse(description);
      this.data.description = description ?? undefined;
      return this;
    }
    setFooter(options) {
      if (options === null) {
        this.data.footer = undefined;
        return this;
      }
      embedFooterPredicate.parse(options);
      this.data.footer = { text: options.text, icon_url: options.iconURL };
      return this;
    }
    setImage(url) {
      imageURLPredicate.parse(url);
      this.data.image = url ? { url } : undefined;
      return this;
    }
    setThumbnail(url) {
      imageURLPredicate.parse(url);
      this.data.thumbnail = url ? { url } : undefined;
      return this;
    }
    setTimestamp(timestamp = Date.now()) {
      timestampPredicate.parse(timestamp);
      this.data.timestamp = timestamp ? new Date(timestamp).toISOString() : undefined;
      return this;
    }
    setTitle(title) {
      titlePredicate.parse(title);
      this.data.title = title ?? undefined;
      return this;
    }
    setURL(url) {
      urlPredicate.parse(url);
      this.data.url = url ?? undefined;
      return this;
    }
    toJSON() {
      return { ...this.data };
    }
  };
  __reExport(src_exports, require_dist9(), module.exports);
  var Assertions_exports2 = {};
  __export2(Assertions_exports2, {
    buttonLabelValidator: () => buttonLabelValidator,
    buttonStyleValidator: () => buttonStyleValidator,
    channelTypesValidator: () => channelTypesValidator,
    customIdValidator: () => customIdValidator,
    defaultValidator: () => defaultValidator,
    disabledValidator: () => disabledValidator,
    emojiValidator: () => emojiValidator,
    jsonOptionValidator: () => jsonOptionValidator,
    labelValueDescriptionValidator: () => labelValueDescriptionValidator,
    minMaxValidator: () => minMaxValidator,
    optionValidator: () => optionValidator,
    optionsLengthValidator: () => optionsLengthValidator,
    optionsValidator: () => optionsValidator,
    placeholderValidator: () => placeholderValidator,
    urlValidator: () => urlValidator,
    validateRequiredButtonParameters: () => validateRequiredButtonParameters,
    validateRequiredSelectMenuOptionParameters: () => validateRequiredSelectMenuOptionParameters,
    validateRequiredSelectMenuParameters: () => validateRequiredSelectMenuParameters
  });
  var import_shapeshift2 = require_dist8();
  var import_v10 = require_v106();
  var StringSelectMenuOptionBuilder = class {
    constructor(data = {}) {
      this.data = data;
    }
    static {
      __name(this, "StringSelectMenuOptionBuilder");
    }
    setLabel(label) {
      this.data.label = labelValueDescriptionValidator.parse(label);
      return this;
    }
    setValue(value) {
      this.data.value = labelValueDescriptionValidator.parse(value);
      return this;
    }
    setDescription(description) {
      this.data.description = labelValueDescriptionValidator.parse(description);
      return this;
    }
    setDefault(isDefault = true) {
      this.data.default = defaultValidator.parse(isDefault);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuOptionParameters(this.data.label, this.data.value);
      return {
        ...this.data
      };
    }
  };
  var customIdValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var emojiValidator = import_shapeshift2.s.object({
    id: import_shapeshift2.s.string,
    name: import_shapeshift2.s.string,
    animated: import_shapeshift2.s.boolean
  }).partial.strict.setValidationEnabled(isValidationEnabled);
  var disabledValidator = import_shapeshift2.s.boolean;
  var buttonLabelValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(80).setValidationEnabled(isValidationEnabled);
  var buttonStyleValidator = import_shapeshift2.s.nativeEnum(import_v10.ButtonStyle);
  var placeholderValidator = import_shapeshift2.s.string.lengthLessThanOrEqual(150).setValidationEnabled(isValidationEnabled);
  var minMaxValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  var labelValueDescriptionValidator = import_shapeshift2.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var jsonOptionValidator = import_shapeshift2.s.object({
    label: labelValueDescriptionValidator,
    value: labelValueDescriptionValidator,
    description: labelValueDescriptionValidator.optional,
    emoji: emojiValidator.optional,
    default: import_shapeshift2.s.boolean.optional
  }).setValidationEnabled(isValidationEnabled);
  var optionValidator = import_shapeshift2.s.instance(StringSelectMenuOptionBuilder).setValidationEnabled(isValidationEnabled);
  var optionsValidator = optionValidator.array.lengthGreaterThanOrEqual(0).setValidationEnabled(isValidationEnabled);
  var optionsLengthValidator = import_shapeshift2.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredSelectMenuParameters, "validateRequiredSelectMenuParameters");
  var defaultValidator = import_shapeshift2.s.boolean;
  __name(validateRequiredSelectMenuOptionParameters, "validateRequiredSelectMenuOptionParameters");
  var channelTypesValidator = import_shapeshift2.s.nativeEnum(import_v10.ChannelType).array.setValidationEnabled(isValidationEnabled);
  var urlValidator = import_shapeshift2.s.string.url({
    allowedProtocols: ["http:", "https:", "discord:"]
  }).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredButtonParameters, "validateRequiredButtonParameters");
  var import_v1011 = require_v106();
  var ComponentBuilder = class {
    static {
      __name(this, "ComponentBuilder");
    }
    data;
    constructor(data) {
      this.data = data;
    }
  };
  var import_v1010 = require_v106();
  var import_v102 = require_v106();
  var ButtonBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ButtonBuilder");
    }
    constructor(data) {
      super({ type: import_v102.ComponentType.Button, ...data });
    }
    setStyle(style) {
      this.data.style = buttonStyleValidator.parse(style);
      return this;
    }
    setURL(url) {
      this.data.url = urlValidator.parse(url);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setEmoji(emoji) {
      this.data.emoji = emojiValidator.parse(emoji);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    setLabel(label) {
      this.data.label = buttonLabelValidator.parse(label);
      return this;
    }
    toJSON() {
      validateRequiredButtonParameters(this.data.style, this.data.label, this.data.emoji, this.data.custom_id, this.data.url);
      return {
        ...this.data
      };
    }
  };
  var import_v103 = require_v106();
  var BaseSelectMenuBuilder = class extends ComponentBuilder {
    static {
      __name(this, "BaseSelectMenuBuilder");
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator.parse(placeholder);
      return this;
    }
    setMinValues(minValues) {
      this.data.min_values = minMaxValidator.parse(minValues);
      return this;
    }
    setMaxValues(maxValues) {
      this.data.max_values = minMaxValidator.parse(maxValues);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setDisabled(disabled = true) {
      this.data.disabled = disabledValidator.parse(disabled);
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var ChannelSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "ChannelSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v103.ComponentType.ChannelSelect });
    }
    addChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.push(...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    setChannelTypes(...types) {
      const normalizedTypes = normalizeArray(types);
      this.data.channel_types ??= [];
      this.data.channel_types.splice(0, this.data.channel_types.length, ...channelTypesValidator.parse(normalizedTypes));
      return this;
    }
    toJSON() {
      customIdValidator.parse(this.data.custom_id);
      return {
        ...this.data
      };
    }
  };
  var import_v104 = require_v106();
  var MentionableSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "MentionableSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v104.ComponentType.MentionableSelect });
    }
  };
  var import_v105 = require_v106();
  var RoleSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "RoleSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v105.ComponentType.RoleSelect });
    }
  };
  var import_v106 = require_v106();
  var StringSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "StringSelectMenuBuilder");
    }
    options;
    constructor(data) {
      const { options, ...initData } = data ?? {};
      super({ ...initData, type: import_v106.ComponentType.StringSelect });
      this.options = options?.map((option) => new StringSelectMenuOptionBuilder(option)) ?? [];
    }
    addOptions(...options) {
      const normalizedOptions = normalizeArray(options);
      optionsLengthValidator.parse(this.options.length + normalizedOptions.length);
      this.options.push(...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      return this;
    }
    setOptions(...options) {
      return this.spliceOptions(0, this.options.length, ...options);
    }
    spliceOptions(index, deleteCount, ...options) {
      const normalizedOptions = normalizeArray(options);
      const clone = [...this.options];
      clone.splice(index, deleteCount, ...normalizedOptions.map((normalizedOption) => normalizedOption instanceof StringSelectMenuOptionBuilder ? normalizedOption : new StringSelectMenuOptionBuilder(jsonOptionValidator.parse(normalizedOption))));
      optionsLengthValidator.parse(clone.length);
      this.options.splice(0, this.options.length, ...clone);
      return this;
    }
    toJSON() {
      validateRequiredSelectMenuParameters(this.options, this.data.custom_id);
      return {
        ...this.data,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  var import_v107 = require_v106();
  var UserSelectMenuBuilder = class extends BaseSelectMenuBuilder {
    static {
      __name(this, "UserSelectMenuBuilder");
    }
    constructor(data) {
      super({ ...data, type: import_v107.ComponentType.UserSelect });
    }
  };
  var import_util = require_dist();
  var import_v109 = require_v106();
  var import_fast_deep_equal = __toESM2(require_fast_deep_equal());
  var Assertions_exports3 = {};
  __export2(Assertions_exports3, {
    labelValidator: () => labelValidator,
    maxLengthValidator: () => maxLengthValidator,
    minLengthValidator: () => minLengthValidator,
    placeholderValidator: () => placeholderValidator2,
    requiredValidator: () => requiredValidator,
    textInputStyleValidator: () => textInputStyleValidator,
    validateRequiredParameters: () => validateRequiredParameters,
    valueValidator: () => valueValidator
  });
  var import_shapeshift3 = require_dist8();
  var import_v108 = require_v106();
  var textInputStyleValidator = import_shapeshift3.s.nativeEnum(import_v108.TextInputStyle);
  var minLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(0).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var maxLengthValidator = import_shapeshift3.s.number.int.greaterThanOrEqual(1).lessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var requiredValidator = import_shapeshift3.s.boolean;
  var valueValidator = import_shapeshift3.s.string.lengthLessThanOrEqual(4000).setValidationEnabled(isValidationEnabled);
  var placeholderValidator2 = import_shapeshift3.s.string.lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var labelValidator = import_shapeshift3.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters, "validateRequiredParameters");
  var TextInputBuilder = class extends ComponentBuilder {
    static {
      __name(this, "TextInputBuilder");
    }
    constructor(data) {
      super({ type: import_v109.ComponentType.TextInput, ...data });
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    setLabel(label) {
      this.data.label = labelValidator.parse(label);
      return this;
    }
    setStyle(style) {
      this.data.style = textInputStyleValidator.parse(style);
      return this;
    }
    setMinLength(minLength) {
      this.data.min_length = minLengthValidator.parse(minLength);
      return this;
    }
    setMaxLength(maxLength) {
      this.data.max_length = maxLengthValidator.parse(maxLength);
      return this;
    }
    setPlaceholder(placeholder) {
      this.data.placeholder = placeholderValidator2.parse(placeholder);
      return this;
    }
    setValue(value) {
      this.data.value = valueValidator.parse(value);
      return this;
    }
    setRequired(required = true) {
      this.data.required = requiredValidator.parse(required);
      return this;
    }
    toJSON() {
      validateRequiredParameters(this.data.custom_id, this.data.style, this.data.label);
      return {
        ...this.data
      };
    }
    equals(other) {
      if ((0, import_util.isJSONEncodable)(other)) {
        return (0, import_fast_deep_equal.default)(other.toJSON(), this.data);
      }
      return (0, import_fast_deep_equal.default)(other, this.data);
    }
  };
  __name(createComponentBuilder, "createComponentBuilder");
  var ActionRowBuilder = class extends ComponentBuilder {
    static {
      __name(this, "ActionRowBuilder");
    }
    components;
    constructor({ components, ...data } = {}) {
      super({ type: import_v1011.ComponentType.ActionRow, ...data });
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports4 = {};
  __export2(Assertions_exports4, {
    componentsValidator: () => componentsValidator,
    titleValidator: () => titleValidator,
    validateRequiredParameters: () => validateRequiredParameters2
  });
  var import_shapeshift4 = require_dist8();
  var titleValidator = import_shapeshift4.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(45).setValidationEnabled(isValidationEnabled);
  var componentsValidator = import_shapeshift4.s.instance(ActionRowBuilder).array.lengthGreaterThanOrEqual(1).setValidationEnabled(isValidationEnabled);
  __name(validateRequiredParameters2, "validateRequiredParameters");
  var ModalBuilder = class {
    static {
      __name(this, "ModalBuilder");
    }
    data;
    components = [];
    constructor({ components, ...data } = {}) {
      this.data = { ...data };
      this.components = components?.map((component) => createComponentBuilder(component)) ?? [];
    }
    setTitle(title) {
      this.data.title = titleValidator.parse(title);
      return this;
    }
    setCustomId(customId) {
      this.data.custom_id = customIdValidator.parse(customId);
      return this;
    }
    addComponents(...components) {
      this.components.push(...normalizeArray(components).map((component) => component instanceof ActionRowBuilder ? component : new ActionRowBuilder(component)));
      return this;
    }
    setComponents(...components) {
      this.components.splice(0, this.components.length, ...normalizeArray(components));
      return this;
    }
    toJSON() {
      validateRequiredParameters2(this.data.custom_id, this.data.title, this.components);
      return {
        ...this.data,
        components: this.components.map((component) => component.toJSON())
      };
    }
  };
  var Assertions_exports5 = {};
  __export2(Assertions_exports5, {
    assertReturnOfBuilder: () => assertReturnOfBuilder,
    localizationMapPredicate: () => localizationMapPredicate,
    validateChoicesLength: () => validateChoicesLength,
    validateDMPermission: () => validateDMPermission,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions,
    validateDefaultPermission: () => validateDefaultPermission,
    validateDescription: () => validateDescription,
    validateLocale: () => validateLocale,
    validateLocalizationMap: () => validateLocalizationMap,
    validateMaxOptionsLength: () => validateMaxOptionsLength,
    validateNSFW: () => validateNSFW,
    validateName: () => validateName,
    validateRequired: () => validateRequired,
    validateRequiredParameters: () => validateRequiredParameters3
  });
  var import_shapeshift5 = require_dist8();
  var import_v1012 = require_v106();
  var namePredicate = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^[\p{Ll}\p{Lm}\p{Lo}\p{N}\p{sc=Devanagari}\p{sc=Thai}_-]+$/u).setValidationEnabled(isValidationEnabled);
  __name(validateName, "validateName");
  var descriptionPredicate2 = import_shapeshift5.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100).setValidationEnabled(isValidationEnabled);
  var localePredicate = import_shapeshift5.s.nativeEnum(import_v1012.Locale);
  __name(validateDescription, "validateDescription");
  var maxArrayLengthPredicate = import_shapeshift5.s.unknown.array.lengthLessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateLocale, "validateLocale");
  __name(validateMaxOptionsLength, "validateMaxOptionsLength");
  __name(validateRequiredParameters3, "validateRequiredParameters");
  var booleanPredicate = import_shapeshift5.s.boolean;
  __name(validateDefaultPermission, "validateDefaultPermission");
  __name(validateRequired, "validateRequired");
  var choicesLengthPredicate = import_shapeshift5.s.number.lessThanOrEqual(25).setValidationEnabled(isValidationEnabled);
  __name(validateChoicesLength, "validateChoicesLength");
  __name(assertReturnOfBuilder, "assertReturnOfBuilder");
  var localizationMapPredicate = import_shapeshift5.s.object(Object.fromEntries(Object.values(import_v1012.Locale).map((locale) => [locale, import_shapeshift5.s.string.nullish]))).strict.nullish.setValidationEnabled(isValidationEnabled);
  __name(validateLocalizationMap, "validateLocalizationMap");
  var dmPermissionPredicate = import_shapeshift5.s.boolean.nullish;
  __name(validateDMPermission, "validateDMPermission");
  var memberPermissionPredicate = import_shapeshift5.s.union(import_shapeshift5.s.bigint.transform((value) => value.toString()), import_shapeshift5.s.number.safeInt.transform((value) => value.toString()), import_shapeshift5.s.string.regex(/^\d+$/)).nullish;
  __name(validateDefaultMemberPermissions, "validateDefaultMemberPermissions");
  __name(validateNSFW, "validateNSFW");
  var import_ts_mixer6 = require_cjs();
  var import_v1024 = require_v106();
  var import_ts_mixer5 = require_cjs();
  var SharedNameAndDescription = class {
    static {
      __name(this, "SharedNameAndDescription");
    }
    name;
    name_localizations;
    description;
    description_localizations;
    setName(name) {
      validateName(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setDescription(description) {
      validateDescription(description);
      Reflect.set(this, "description", description);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames)) {
        this.setNameLocalization(...args);
      }
      return this;
    }
    setDescriptionLocalization(locale, localizedDescription) {
      if (!this.description_localizations) {
        Reflect.set(this, "description_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedDescription === null) {
        this.description_localizations[parsedLocale] = null;
        return this;
      }
      validateDescription(localizedDescription);
      this.description_localizations[parsedLocale] = localizedDescription;
      return this;
    }
    setDescriptionLocalizations(localizedDescriptions) {
      if (localizedDescriptions === null) {
        Reflect.set(this, "description_localizations", null);
        return this;
      }
      Reflect.set(this, "description_localizations", {});
      for (const args of Object.entries(localizedDescriptions)) {
        this.setDescriptionLocalization(...args);
      }
      return this;
    }
  };
  var import_v1013 = require_v106();
  var ApplicationCommandOptionBase = class extends SharedNameAndDescription {
    static {
      __name(this, "ApplicationCommandOptionBase");
    }
    required = false;
    setRequired(required) {
      validateRequired(required);
      Reflect.set(this, "required", required);
      return this;
    }
    runRequiredValidations() {
      validateRequiredParameters3(this.name, this.description, []);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      validateRequired(this.required);
    }
  };
  var SlashCommandAttachmentOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandAttachmentOption");
    }
    type = import_v1013.ApplicationCommandOptionType.Attachment;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1014 = require_v106();
  var SlashCommandBooleanOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandBooleanOption");
    }
    type = import_v1014.ApplicationCommandOptionType.Boolean;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_v1016 = require_v106();
  var import_ts_mixer = require_cjs();
  var import_shapeshift6 = require_dist8();
  var import_v1015 = require_v106();
  var allowedChannelTypes = [
    import_v1015.ChannelType.GuildText,
    import_v1015.ChannelType.GuildVoice,
    import_v1015.ChannelType.GuildCategory,
    import_v1015.ChannelType.GuildAnnouncement,
    import_v1015.ChannelType.AnnouncementThread,
    import_v1015.ChannelType.PublicThread,
    import_v1015.ChannelType.PrivateThread,
    import_v1015.ChannelType.GuildStageVoice,
    import_v1015.ChannelType.GuildForum
  ];
  var channelTypesPredicate = import_shapeshift6.s.array(import_shapeshift6.s.union(...allowedChannelTypes.map((type) => import_shapeshift6.s.literal(type))));
  var ApplicationCommandOptionChannelTypesMixin = class {
    static {
      __name(this, "ApplicationCommandOptionChannelTypesMixin");
    }
    channel_types;
    addChannelTypes(...channelTypes) {
      if (this.channel_types === undefined) {
        Reflect.set(this, "channel_types", []);
      }
      this.channel_types.push(...channelTypesPredicate.parse(channelTypes));
      return this;
    }
  };
  var SlashCommandChannelOption = class extends ApplicationCommandOptionBase {
    type = import_v1016.ApplicationCommandOptionType.Channel;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  __name(SlashCommandChannelOption, "SlashCommandChannelOption");
  SlashCommandChannelOption = __decorateClass([
    (0, import_ts_mixer.mix)(ApplicationCommandOptionChannelTypesMixin)
  ], SlashCommandChannelOption);
  var import_shapeshift8 = require_dist8();
  var import_v1018 = require_v106();
  var import_ts_mixer2 = require_cjs();
  var ApplicationCommandNumericOptionMinMaxValueMixin = class {
    static {
      __name(this, "ApplicationCommandNumericOptionMinMaxValueMixin");
    }
    max_value;
    min_value;
  };
  var import_shapeshift7 = require_dist8();
  var import_v1017 = require_v106();
  var stringPredicate = import_shapeshift7.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(100);
  var numberPredicate = import_shapeshift7.s.number.greaterThan(Number.NEGATIVE_INFINITY).lessThan(Number.POSITIVE_INFINITY);
  var choicesPredicate = import_shapeshift7.s.object({
    name: stringPredicate,
    name_localizations: localizationMapPredicate,
    value: import_shapeshift7.s.union(stringPredicate, numberPredicate)
  }).array;
  var booleanPredicate2 = import_shapeshift7.s.boolean;
  var ApplicationCommandOptionWithChoicesAndAutocompleteMixin = class {
    static {
      __name(this, "ApplicationCommandOptionWithChoicesAndAutocompleteMixin");
    }
    choices;
    autocomplete;
    type;
    addChoices(...choices) {
      if (choices.length > 0 && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(choices);
      if (this.choices === undefined) {
        Reflect.set(this, "choices", []);
      }
      validateChoicesLength(choices.length, this.choices);
      for (const { name, name_localizations, value } of choices) {
        if (this.type === import_v1017.ApplicationCommandOptionType.String) {
          stringPredicate.parse(value);
        } else {
          numberPredicate.parse(value);
        }
        this.choices.push({ name, name_localizations, value });
      }
      return this;
    }
    setChoices(...choices) {
      if (choices.length > 0 && this.autocomplete) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      choicesPredicate.parse(choices);
      Reflect.set(this, "choices", []);
      this.addChoices(...choices);
      return this;
    }
    setAutocomplete(autocomplete) {
      booleanPredicate2.parse(autocomplete);
      if (autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      Reflect.set(this, "autocomplete", autocomplete);
      return this;
    }
  };
  var numberValidator = import_shapeshift8.s.number.int;
  var SlashCommandIntegerOption = class extends ApplicationCommandOptionBase {
    type = import_v1018.ApplicationCommandOptionType.Integer;
    setMaxValue(max) {
      numberValidator.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandIntegerOption, "SlashCommandIntegerOption");
  SlashCommandIntegerOption = __decorateClass([
    (0, import_ts_mixer2.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandIntegerOption);
  var import_v1019 = require_v106();
  var SlashCommandMentionableOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandMentionableOption");
    }
    type = import_v1019.ApplicationCommandOptionType.Mentionable;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift9 = require_dist8();
  var import_v1020 = require_v106();
  var import_ts_mixer3 = require_cjs();
  var numberValidator2 = import_shapeshift9.s.number;
  var SlashCommandNumberOption = class extends ApplicationCommandOptionBase {
    type = import_v1020.ApplicationCommandOptionType.Number;
    setMaxValue(max) {
      numberValidator2.parse(max);
      Reflect.set(this, "max_value", max);
      return this;
    }
    setMinValue(min) {
      numberValidator2.parse(min);
      Reflect.set(this, "min_value", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandNumberOption, "SlashCommandNumberOption");
  SlashCommandNumberOption = __decorateClass([
    (0, import_ts_mixer3.mix)(ApplicationCommandNumericOptionMinMaxValueMixin, ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandNumberOption);
  var import_v1021 = require_v106();
  var SlashCommandRoleOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandRoleOption");
    }
    type = import_v1021.ApplicationCommandOptionType.Role;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var import_shapeshift10 = require_dist8();
  var import_v1022 = require_v106();
  var import_ts_mixer4 = require_cjs();
  var minLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(0).lessThanOrEqual(6000);
  var maxLengthValidator2 = import_shapeshift10.s.number.greaterThanOrEqual(1).lessThanOrEqual(6000);
  var SlashCommandStringOption = class extends ApplicationCommandOptionBase {
    type = import_v1022.ApplicationCommandOptionType.String;
    max_length;
    min_length;
    setMaxLength(max) {
      maxLengthValidator2.parse(max);
      Reflect.set(this, "max_length", max);
      return this;
    }
    setMinLength(min) {
      minLengthValidator2.parse(min);
      Reflect.set(this, "min_length", min);
      return this;
    }
    toJSON() {
      this.runRequiredValidations();
      if (this.autocomplete && Array.isArray(this.choices) && this.choices.length > 0) {
        throw new RangeError("Autocomplete and choices are mutually exclusive to each other.");
      }
      return { ...this };
    }
  };
  __name(SlashCommandStringOption, "SlashCommandStringOption");
  SlashCommandStringOption = __decorateClass([
    (0, import_ts_mixer4.mix)(ApplicationCommandOptionWithChoicesAndAutocompleteMixin)
  ], SlashCommandStringOption);
  var import_v1023 = require_v106();
  var SlashCommandUserOption = class extends ApplicationCommandOptionBase {
    static {
      __name(this, "SlashCommandUserOption");
    }
    type = import_v1023.ApplicationCommandOptionType.User;
    toJSON() {
      this.runRequiredValidations();
      return { ...this };
    }
  };
  var SharedSlashCommandOptions = class {
    static {
      __name(this, "SharedSlashCommandOptions");
    }
    options;
    addBooleanOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandBooleanOption);
    }
    addUserOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandUserOption);
    }
    addChannelOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandChannelOption);
    }
    addRoleOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandRoleOption);
    }
    addAttachmentOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandAttachmentOption);
    }
    addMentionableOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandMentionableOption);
    }
    addStringOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandStringOption);
    }
    addIntegerOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandIntegerOption);
    }
    addNumberOption(input) {
      return this._sharedAddOptionMethod(input, SlashCommandNumberOption);
    }
    _sharedAddOptionMethod(input, Instance) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new Instance) : input;
      assertReturnOfBuilder(result, Instance);
      options.push(result);
      return this;
    }
  };
  var SlashCommandSubcommandGroupBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1024.ApplicationCommandOptionType.SubcommandGroup,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandGroupBuilder, "SlashCommandSubcommandGroupBuilder");
  SlashCommandSubcommandGroupBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription)
  ], SlashCommandSubcommandGroupBuilder);
  var SlashCommandSubcommandBuilder = class {
    name = undefined;
    description = undefined;
    options = [];
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      return {
        type: import_v1024.ApplicationCommandOptionType.Subcommand,
        name: this.name,
        name_localizations: this.name_localizations,
        description: this.description,
        description_localizations: this.description_localizations,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandSubcommandBuilder, "SlashCommandSubcommandBuilder");
  SlashCommandSubcommandBuilder = __decorateClass([
    (0, import_ts_mixer5.mix)(SharedNameAndDescription, SharedSlashCommandOptions)
  ], SlashCommandSubcommandBuilder);
  var SlashCommandBuilder = class {
    name = undefined;
    name_localizations;
    description = undefined;
    description_localizations;
    options = [];
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    nsfw = undefined;
    setDefaultPermission(value) {
      validateDefaultPermission(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNSFW(nsfw = true) {
      validateNSFW(nsfw);
      Reflect.set(this, "nsfw", nsfw);
      return this;
    }
    addSubcommandGroup(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandGroupBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandGroupBuilder);
      options.push(result);
      return this;
    }
    addSubcommand(input) {
      const { options } = this;
      validateMaxOptionsLength(options);
      const result = typeof input === "function" ? input(new SlashCommandSubcommandBuilder) : input;
      assertReturnOfBuilder(result, SlashCommandSubcommandBuilder);
      options.push(result);
      return this;
    }
    toJSON() {
      validateRequiredParameters3(this.name, this.description, this.options);
      validateLocalizationMap(this.name_localizations);
      validateLocalizationMap(this.description_localizations);
      return {
        ...this,
        options: this.options.map((option) => option.toJSON())
      };
    }
  };
  __name(SlashCommandBuilder, "SlashCommandBuilder");
  SlashCommandBuilder = __decorateClass([
    (0, import_ts_mixer6.mix)(SharedSlashCommandOptions, SharedNameAndDescription)
  ], SlashCommandBuilder);
  var Assertions_exports6 = {};
  __export2(Assertions_exports6, {
    validateDMPermission: () => validateDMPermission2,
    validateDefaultMemberPermissions: () => validateDefaultMemberPermissions2,
    validateDefaultPermission: () => validateDefaultPermission2,
    validateName: () => validateName2,
    validateRequiredParameters: () => validateRequiredParameters4,
    validateType: () => validateType
  });
  var import_shapeshift11 = require_dist8();
  var import_v1025 = require_v106();
  var namePredicate2 = import_shapeshift11.s.string.lengthGreaterThanOrEqual(1).lengthLessThanOrEqual(32).regex(/^( *[\p{P}\p{L}\p{N}\p{sc=Devanagari}\p{sc=Thai}]+ *)+$/u).setValidationEnabled(isValidationEnabled);
  var typePredicate = import_shapeshift11.s.union(import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.User), import_shapeshift11.s.literal(import_v1025.ApplicationCommandType.Message)).setValidationEnabled(isValidationEnabled);
  var booleanPredicate3 = import_shapeshift11.s.boolean;
  __name(validateDefaultPermission2, "validateDefaultPermission");
  __name(validateName2, "validateName");
  __name(validateType, "validateType");
  __name(validateRequiredParameters4, "validateRequiredParameters");
  var dmPermissionPredicate2 = import_shapeshift11.s.boolean.nullish;
  __name(validateDMPermission2, "validateDMPermission");
  var memberPermissionPredicate2 = import_shapeshift11.s.union(import_shapeshift11.s.bigint.transform((value) => value.toString()), import_shapeshift11.s.number.safeInt.transform((value) => value.toString()), import_shapeshift11.s.string.regex(/^\d+$/)).nullish;
  __name(validateDefaultMemberPermissions2, "validateDefaultMemberPermissions");
  var ContextMenuCommandBuilder = class {
    static {
      __name(this, "ContextMenuCommandBuilder");
    }
    name = undefined;
    name_localizations;
    type = undefined;
    default_permission = undefined;
    default_member_permissions = undefined;
    dm_permission = undefined;
    setName(name) {
      validateName2(name);
      Reflect.set(this, "name", name);
      return this;
    }
    setType(type) {
      validateType(type);
      Reflect.set(this, "type", type);
      return this;
    }
    setDefaultPermission(value) {
      validateDefaultPermission2(value);
      Reflect.set(this, "default_permission", value);
      return this;
    }
    setDefaultMemberPermissions(permissions) {
      const permissionValue = validateDefaultMemberPermissions2(permissions);
      Reflect.set(this, "default_member_permissions", permissionValue);
      return this;
    }
    setDMPermission(enabled) {
      validateDMPermission2(enabled);
      Reflect.set(this, "dm_permission", enabled);
      return this;
    }
    setNameLocalization(locale, localizedName) {
      if (!this.name_localizations) {
        Reflect.set(this, "name_localizations", {});
      }
      const parsedLocale = validateLocale(locale);
      if (localizedName === null) {
        this.name_localizations[parsedLocale] = null;
        return this;
      }
      validateName2(localizedName);
      this.name_localizations[parsedLocale] = localizedName;
      return this;
    }
    setNameLocalizations(localizedNames) {
      if (localizedNames === null) {
        Reflect.set(this, "name_localizations", null);
        return this;
      }
      Reflect.set(this, "name_localizations", {});
      for (const args of Object.entries(localizedNames))
        this.setNameLocalization(...args);
      return this;
    }
    toJSON() {
      validateRequiredParameters4(this.name, this.type);
      validateLocalizationMap(this.name_localizations);
      return { ...this };
    }
  };
  __name(embedLength, "embedLength");
  var version = "1.6.5";
});

// node_modules/discord.js/src/structures/Base.js
var require_Base = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class Base {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
    _patch(data) {
      return data;
    }
    _update(data) {
      const clone = this._clone();
      this._patch(data);
      return clone;
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = Base;
});

// node_modules/discord.js/src/util/BitField.js
var require_BitField = __commonJS((exports, module) => {
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();

  class BitField {
    static Flags = {};
    static DefaultBit = 0;
    constructor(bits = this.constructor.DefaultBit) {
      this.bitfield = this.constructor.resolve(bits);
    }
    any(bit) {
      return (this.bitfield & this.constructor.resolve(bit)) !== this.constructor.DefaultBit;
    }
    equals(bit) {
      return this.bitfield === this.constructor.resolve(bit);
    }
    has(bit) {
      bit = this.constructor.resolve(bit);
      return (this.bitfield & bit) === bit;
    }
    missing(bits, ...hasParams) {
      return new this.constructor(bits).remove(this).toArray(...hasParams);
    }
    freeze() {
      return Object.freeze(this);
    }
    add(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield | total);
      this.bitfield |= total;
      return this;
    }
    remove(...bits) {
      let total = this.constructor.DefaultBit;
      for (const bit of bits) {
        total |= this.constructor.resolve(bit);
      }
      if (Object.isFrozen(this))
        return new this.constructor(this.bitfield & ~total);
      this.bitfield &= ~total;
      return this;
    }
    serialize(...hasParams) {
      const serialized = {};
      for (const [flag, bit] of Object.entries(this.constructor.Flags)) {
        if (isNaN(flag))
          serialized[flag] = this.has(bit, ...hasParams);
      }
      return serialized;
    }
    toArray(...hasParams) {
      return [...this[Symbol.iterator](...hasParams)];
    }
    toJSON() {
      return typeof this.bitfield === "number" ? this.bitfield : this.bitfield.toString();
    }
    valueOf() {
      return this.bitfield;
    }
    *[Symbol.iterator](...hasParams) {
      for (const bitName of Object.keys(this.constructor.Flags)) {
        if (isNaN(bitName) && this.has(bitName, ...hasParams))
          yield bitName;
      }
    }
    static resolve(bit) {
      const { DefaultBit } = this;
      if (typeof DefaultBit === typeof bit && bit >= DefaultBit)
        return bit;
      if (bit instanceof BitField)
        return bit.bitfield;
      if (Array.isArray(bit))
        return bit.map((p) => this.resolve(p)).reduce((prev, p) => prev | p, DefaultBit);
      if (typeof bit === "string") {
        if (!isNaN(bit))
          return typeof DefaultBit === "bigint" ? BigInt(bit) : Number(bit);
        if (this.Flags[bit] !== undefined)
          return this.Flags[bit];
      }
      throw new DiscordjsRangeError(ErrorCodes.BitFieldInvalid, bit);
    }
  }
  module.exports = BitField;
});

// node_modules/discord.js/src/util/ChannelFlagsBitField.js
var require_ChannelFlagsBitField = __commonJS((exports, module) => {
  var { ChannelFlags } = require_v106();
  var BitField = require_BitField();

  class ChannelFlagsBitField extends BitField {
    static Flags = ChannelFlags;
  }
  module.exports = ChannelFlagsBitField;
});

// node_modules/discord.js/src/util/Constants.js
var require_Constants = __commonJS((exports) => {
  var { ChannelType, MessageType, ComponentType, ImageFormat, StickerFormatType } = require_v106();
  exports.MaxBulkDeletableMessageAge = 1209600000;
  exports.SweeperKeys = [
    "autoModerationRules",
    "applicationCommands",
    "bans",
    "emojis",
    "invites",
    "guildMembers",
    "messages",
    "presences",
    "reactions",
    "stageInstances",
    "stickers",
    "threadMembers",
    "threads",
    "users",
    "voiceStates"
  ];
  exports.NonSystemMessageTypes = [
    MessageType.Default,
    MessageType.Reply,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand
  ];
  exports.GuildTextBasedChannelTypes = [
    ChannelType.GuildText,
    ChannelType.GuildAnnouncement,
    ChannelType.AnnouncementThread,
    ChannelType.PublicThread,
    ChannelType.PrivateThread,
    ChannelType.GuildVoice,
    ChannelType.GuildStageVoice
  ];
  exports.TextBasedChannelTypes = [...exports.GuildTextBasedChannelTypes, ChannelType.DM];
  exports.ThreadChannelTypes = [ChannelType.AnnouncementThread, ChannelType.PublicThread, ChannelType.PrivateThread];
  exports.VoiceBasedChannelTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  exports.SelectMenuTypes = [
    ComponentType.StringSelect,
    ComponentType.UserSelect,
    ComponentType.RoleSelect,
    ComponentType.MentionableSelect,
    ComponentType.ChannelSelect
  ];
  exports.DeletableMessageTypes = [
    MessageType.AutoModerationAction,
    MessageType.ChannelFollowAdd,
    MessageType.ChannelPinnedMessage,
    MessageType.ChatInputCommand,
    MessageType.ContextMenuCommand,
    MessageType.Default,
    MessageType.GuildBoost,
    MessageType.GuildBoostTier1,
    MessageType.GuildBoostTier2,
    MessageType.GuildBoostTier3,
    MessageType.GuildInviteReminder,
    MessageType.InteractionPremiumUpsell,
    MessageType.Reply,
    MessageType.RoleSubscriptionPurchase,
    MessageType.StageEnd,
    MessageType.StageRaiseHand,
    MessageType.StageSpeaker,
    MessageType.StageStart,
    MessageType.StageTopic,
    MessageType.ThreadCreated,
    MessageType.UserJoin
  ];
  exports.StickerFormatExtensionMap = {
    [StickerFormatType.PNG]: ImageFormat.PNG,
    [StickerFormatType.APNG]: ImageFormat.PNG,
    [StickerFormatType.Lottie]: ImageFormat.Lottie,
    [StickerFormatType.GIF]: ImageFormat.GIF
  };
});

// node_modules/discord.js/src/structures/BaseChannel.js
var require_BaseChannel = __commonJS((exports) => {
  var { channelLink } = require_dist10();
  var { DiscordSnowflake } = require_dist3();
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { ThreadChannelTypes } = require_Constants();

  class BaseChannel extends Base {
    constructor(client, data, immediatePatch = true) {
      super(client);
      this.type = data.type;
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("flags" in data) {
        this.flags = new ChannelFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new ChannelFlagsBitField().freeze();
      }
      this.id = data.id;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.isDMBased() ? channelLink(this.id) : channelLink(this.id, this.guildId);
    }
    get partial() {
      return false;
    }
    toString() {
      return `<#${this.id}>`;
    }
    async delete() {
      await this.client.rest.delete(Routes.channel(this.id));
      return this;
    }
    fetch(force = true) {
      return this.client.channels.fetch(this.id, { force });
    }
    isThread() {
      return ThreadChannelTypes.includes(this.type);
    }
    isTextBased() {
      return "messages" in this;
    }
    isDMBased() {
      return [ChannelType.DM, ChannelType.GroupDM].includes(this.type);
    }
    isVoiceBased() {
      return "bitrate" in this;
    }
    toJSON(...props) {
      return super.toJSON({ createdTimestamp: true }, ...props);
    }
  }
  exports.BaseChannel = BaseChannel;
});

// node_modules/discord.js/src/managers/BaseManager.js
var require_BaseManager = __commonJS((exports, module) => {
  class BaseManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
    }
  }
  module.exports = BaseManager;
});

// node_modules/discord.js/src/managers/DataManager.js
var require_DataManager = __commonJS((exports, module) => {
  var BaseManager = require_BaseManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class DataManager extends BaseManager {
    constructor(client, holds) {
      super(client);
      Object.defineProperty(this, "holds", { value: holds });
    }
    get cache() {
      throw new DiscordjsError(ErrorCodes.NotImplemented, "get cache", this.constructor.name);
    }
    resolve(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance;
      if (typeof idOrInstance === "string")
        return this.cache.get(idOrInstance) ?? null;
      return null;
    }
    resolveId(idOrInstance) {
      if (idOrInstance instanceof this.holds)
        return idOrInstance.id;
      if (typeof idOrInstance === "string")
        return idOrInstance;
      return null;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = DataManager;
});

// node_modules/discord.js/src/util/Symbols.js
var require_Symbols = __commonJS((exports) => {
  exports.MakeCacheOverrideSymbol = Symbol("djs.managers.makeCacheOverride");
});

// node_modules/discord.js/src/managers/CachedManager.js
var require_CachedManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class CachedManager extends DataManager {
    constructor(client, holds, iterable) {
      super(client, holds);
      Object.defineProperty(this, "_cache", {
        value: this.client.options.makeCache(this.constructor[MakeCacheOverrideSymbol] ?? this.constructor, this.holds, this.constructor)
      });
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    get cache() {
      return this._cache;
    }
    _add(data, cache = true, { id, extras = [] } = {}) {
      const existing = this.cache.get(id ?? data.id);
      if (existing) {
        if (cache) {
          existing._patch(data);
          return existing;
        }
        const clone = existing._clone();
        clone._patch(data);
        return clone;
      }
      const entry = this.holds ? new this.holds(this.client, data, ...extras) : data;
      if (cache)
        this.cache.set(id ?? entry.id, entry);
      return entry;
    }
  }
  module.exports = CachedManager;
});

// node_modules/discord.js/src/util/PermissionsBitField.js
var require_PermissionsBitField = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BitField = require_BitField();

  class PermissionsBitField extends BitField {
    static Flags = PermissionFlagsBits;
    static All = Object.values(PermissionFlagsBits).reduce((all, p) => all | p, 0n);
    static Default = BigInt(104324673);
    static StageModerator = PermissionFlagsBits.ManageChannels | PermissionFlagsBits.MuteMembers | PermissionFlagsBits.MoveMembers;
    static DefaultBit = BigInt(0);
    missing(bits, checkAdmin = true) {
      return checkAdmin && this.has(PermissionFlagsBits.Administrator) ? [] : super.missing(bits);
    }
    any(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.any(permission);
    }
    has(permission, checkAdmin = true) {
      return checkAdmin && super.has(PermissionFlagsBits.Administrator) || super.has(permission);
    }
    toArray() {
      return super.toArray(false);
    }
  }
  module.exports = PermissionsBitField;
});

// node_modules/discord.js/src/util/RoleFlagsBitField.js
var require_RoleFlagsBitField = __commonJS((exports, module) => {
  var { RoleFlags } = require_v106();
  var BitField = require_BitField();

  class RoleFlagsBitField extends BitField {
    static Flags = RoleFlags;
  }
  module.exports = RoleFlagsBitField;
});

// node_modules/discord.js/src/structures/Role.js
var require_Role = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();
  var RoleFlagsBitField = require_RoleFlagsBitField();

  class Role extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.icon = null;
      this.unicodeEmoji = null;
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("color" in data) {
        this.color = data.color;
      }
      if ("hoist" in data) {
        this.hoist = data.hoist;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("permissions" in data) {
        this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("mentionable" in data) {
        this.mentionable = data.mentionable;
      }
      if ("icon" in data)
        this.icon = data.icon;
      if ("unicode_emoji" in data)
        this.unicodeEmoji = data.unicode_emoji;
      if ("flags" in data) {
        this.flags = new RoleFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new RoleFlagsBitField().freeze();
      }
      this.tags = data.tags ? {} : null;
      if (data.tags) {
        if ("bot_id" in data.tags) {
          this.tags.botId = data.tags.bot_id;
        }
        if ("integration_id" in data.tags) {
          this.tags.integrationId = data.tags.integration_id;
        }
        if ("premium_subscriber" in data.tags) {
          this.tags.premiumSubscriberRole = true;
        }
        if ("subscription_listing_id" in data.tags) {
          this.tags.subscriptionListingId = data.tags.subscription_listing_id;
        }
        if ("available_for_purchase" in data.tags) {
          this.tags.availableForPurchase = true;
        }
        if ("guild_connections" in data.tags) {
          this.tags.guildConnections = true;
        }
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get hexColor() {
      return `#${this.color.toString(16).padStart(6, "0")}`;
    }
    get members() {
      return this.id === this.guild.id ? this.guild.members.cache.clone() : this.guild.members.cache.filter((m) => m._roles.includes(this.id));
    }
    get editable() {
      if (this.managed)
        return false;
      const clientMember = this.guild.members.resolve(this.client.user);
      if (!clientMember.permissions.has(PermissionFlagsBits.ManageRoles))
        return false;
      return clientMember.roles.highest.comparePositionTo(this) > 0;
    }
    get position() {
      return this.guild.roles.cache.reduce((acc, role) => acc + (this.rawPosition === role.rawPosition ? BigInt(this.id) > BigInt(role.id) : this.rawPosition > role.rawPosition), 0);
    }
    comparePositionTo(role) {
      return this.guild.roles.comparePositions(this, role);
    }
    edit(options) {
      return this.guild.roles.edit(this, options);
    }
    permissionsIn(channel, checkAdmin = true) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.rolePermissions(this, checkAdmin);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setColor(color, reason) {
      return this.edit({ color, reason });
    }
    setHoist(hoist = true, reason) {
      return this.edit({ hoist, reason });
    }
    setPermissions(permissions, reason) {
      return this.edit({ permissions, reason });
    }
    setMentionable(mentionable = true, reason) {
      return this.edit({ mentionable, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setUnicodeEmoji(unicodeEmoji, reason) {
      return this.edit({ unicodeEmoji, reason });
    }
    setPosition(position, options = {}) {
      return this.guild.roles.setPosition(this, position, options);
    }
    async delete(reason) {
      await this.guild.roles.delete(this.id, reason);
      return this;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.roleIcon(this.id, this.icon, options);
    }
    equals(role) {
      return role && this.id === role.id && this.name === role.name && this.color === role.color && this.hoist === role.hoist && this.position === role.position && this.permissions.bitfield === role.permissions.bitfield && this.managed === role.managed && this.icon === role.icon && this.unicodeEmoji === role.unicodeEmoji;
    }
    toString() {
      if (this.id === this.guild.id)
        return "@everyone";
      return `<@&${this.id}>`;
    }
    toJSON() {
      return {
        ...super.toJSON({ createdTimestamp: true }),
        permissions: this.permissions.toJSON()
      };
    }
  }
  exports.Role = Role;
});

// node_modules/discord.js/src/structures/PermissionOverwrites.js
var require_PermissionOverwrites = __commonJS((exports, module) => {
  var { OverwriteType } = require_v106();
  var Base = require_Base();
  var { Role } = require_Role();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionsBitField = require_PermissionsBitField();

  class PermissionOverwrites extends Base {
    constructor(client, data, channel) {
      super(client);
      Object.defineProperty(this, "channel", { value: channel });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("deny" in data) {
        this.deny = new PermissionsBitField(BigInt(data.deny)).freeze();
      }
      if ("allow" in data) {
        this.allow = new PermissionsBitField(BigInt(data.allow)).freeze();
      }
    }
    async edit(options, reason) {
      await this.channel.permissionOverwrites.upsert(this.id, options, { type: this.type, reason }, this);
      return this;
    }
    async delete(reason) {
      await this.channel.permissionOverwrites.delete(this.id, reason);
      return this;
    }
    toJSON() {
      return {
        id: this.id,
        type: this.type,
        allow: this.allow,
        deny: this.deny
      };
    }
    static resolveOverwriteOptions(options, { allow, deny } = {}) {
      allow = new PermissionsBitField(allow);
      deny = new PermissionsBitField(deny);
      for (const [perm, value] of Object.entries(options)) {
        if (value === true) {
          allow.add(perm);
          deny.remove(perm);
        } else if (value === false) {
          allow.remove(perm);
          deny.add(perm);
        } else if (value === null) {
          allow.remove(perm);
          deny.remove(perm);
        }
      }
      return { allow, deny };
    }
    static resolve(overwrite, guild) {
      if (overwrite instanceof this)
        return overwrite.toJSON();
      if (typeof overwrite.id === "string" && (overwrite.type in OverwriteType)) {
        return {
          id: overwrite.id,
          type: overwrite.type,
          allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
          deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
        };
      }
      const userOrRole = guild.roles.resolve(overwrite.id) ?? guild.client.users.resolve(overwrite.id);
      if (!userOrRole)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      const type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      return {
        id: userOrRole.id,
        type,
        allow: PermissionsBitField.resolve(overwrite.allow ?? PermissionsBitField.DefaultBit).toString(),
        deny: PermissionsBitField.resolve(overwrite.deny ?? PermissionsBitField.DefaultBit).toString()
      };
    }
  }
  module.exports = PermissionOverwrites;
});

// node_modules/discord.js/src/managers/PermissionOverwriteManager.js
var require_PermissionOverwriteManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist2();
  var { OverwriteType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var PermissionOverwrites = require_PermissionOverwrites();
  var { Role } = require_Role();
  var cacheWarningEmitted = false;

  class PermissionOverwriteManager extends CachedManager {
    constructor(channel, iterable) {
      super(channel.client, PermissionOverwrites);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.channel = channel;
      if (iterable) {
        for (const item of iterable) {
          this._add(item);
        }
      }
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.channel] });
    }
    set(overwrites, reason) {
      if (!Array.isArray(overwrites) && !(overwrites instanceof Collection)) {
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, "overwrites", "Array or Collection of Permission Overwrites", true));
      }
      return this.channel.edit({ permissionOverwrites: overwrites, reason });
    }
    async upsert(userOrRole, options, overwriteOptions = {}, existing) {
      let userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      let { type, reason } = overwriteOptions;
      if (typeof type !== "number") {
        userOrRole = this.channel.guild.roles.resolve(userOrRole) ?? this.client.users.resolve(userOrRole);
        if (!userOrRole)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
        type = userOrRole instanceof Role ? OverwriteType.Role : OverwriteType.Member;
      }
      const { allow, deny } = PermissionOverwrites.resolveOverwriteOptions(options, existing);
      await this.client.rest.put(Routes.channelPermission(this.channel.id, userOrRoleId), {
        body: { id: userOrRoleId, type, allow, deny },
        reason
      });
      return this.channel;
    }
    create(userOrRole, options, overwriteOptions) {
      return this.upsert(userOrRole, options, overwriteOptions);
    }
    edit(userOrRole, options, overwriteOptions) {
      const existing = this.cache.get(this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole));
      return this.upsert(userOrRole, options, overwriteOptions, existing);
    }
    async delete(userOrRole, reason) {
      const userOrRoleId = this.channel.guild.roles.resolveId(userOrRole) ?? this.client.users.resolveId(userOrRole);
      if (!userOrRoleId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "parameter", "User nor a Role");
      await this.client.rest.delete(Routes.channelPermission(this.channel.id, userOrRoleId), { reason });
      return this.channel;
    }
  }
  module.exports = PermissionOverwriteManager;
});

// node_modules/discord.js/src/structures/GuildChannel.js
var require_GuildChannel = __commonJS((exports, module) => {
  var { Snowflake } = require_dist3();
  var { PermissionFlagsBits, ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var PermissionOverwriteManager = require_PermissionOverwriteManager();
  var { VoiceBasedChannelTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();
  var { getSortableGroupTypes } = require_Util();

  class GuildChannel extends BaseChannel {
    constructor(guild, data, client, immediatePatch = true) {
      super(client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.permissionOverwrites = new PermissionOverwriteManager(this);
      if (data && immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("position" in data) {
        this.rawPosition = data.position;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("permission_overwrites" in data) {
        this.permissionOverwrites.cache.clear();
        for (const overwrite of data.permission_overwrites) {
          this.permissionOverwrites._add(overwrite);
        }
      }
    }
    _clone() {
      const clone = super._clone();
      clone.permissionOverwrites = new PermissionOverwriteManager(clone, this.permissionOverwrites.cache.values());
      return clone;
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    get permissionsLocked() {
      if (!this.parent)
        return null;
      const overwriteIds = new Set([
        ...this.permissionOverwrites.cache.keys(),
        ...this.parent.permissionOverwrites.cache.keys()
      ]);
      return [...overwriteIds].every((key) => {
        const channelVal = this.permissionOverwrites.cache.get(key);
        const parentVal = this.parent.permissionOverwrites.cache.get(key);
        if (!channelVal && parentVal.deny.bitfield === PermissionsBitField.DefaultBit && parentVal.allow.bitfield === PermissionsBitField.DefaultBit || !parentVal && channelVal.deny.bitfield === PermissionsBitField.DefaultBit && channelVal.allow.bitfield === PermissionsBitField.DefaultBit) {
          return true;
        }
        return channelVal !== undefined && parentVal !== undefined && channelVal.deny.bitfield === parentVal.deny.bitfield && channelVal.allow.bitfield === parentVal.allow.bitfield;
      });
    }
    get position() {
      const selfIsCategory = this.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(this.type);
      let count = 0;
      for (const channel of this.guild.channels.cache.values()) {
        if (!types.includes(channel.type))
          continue;
        if (!selfIsCategory && channel.parentId !== this.parentId)
          continue;
        if (this.rawPosition === channel.rawPosition) {
          if (Snowflake.compare(channel.id, this.id) === -1)
            count++;
        } else if (this.rawPosition > channel.rawPosition) {
          count++;
        }
      }
      return count;
    }
    permissionsFor(memberOrRole, checkAdmin = true) {
      const member = this.guild.members.resolve(memberOrRole);
      if (member)
        return this.memberPermissions(member, checkAdmin);
      const role = this.guild.roles.resolve(memberOrRole);
      return role && this.rolePermissions(role, checkAdmin);
    }
    overwritesFor(member, verified = false, roles = null) {
      if (!verified)
        member = this.guild.members.resolve(member);
      if (!member)
        return [];
      roles ??= member.roles.cache;
      const roleOverwrites = [];
      let memberOverwrites;
      let everyoneOverwrites;
      for (const overwrite of this.permissionOverwrites.cache.values()) {
        if (overwrite.id === this.guild.id) {
          everyoneOverwrites = overwrite;
        } else if (roles.has(overwrite.id)) {
          roleOverwrites.push(overwrite);
        } else if (overwrite.id === member.id) {
          memberOverwrites = overwrite;
        }
      }
      return {
        everyone: everyoneOverwrites,
        roles: roleOverwrites,
        member: memberOverwrites
      };
    }
    memberPermissions(member, checkAdmin) {
      if (checkAdmin && member.id === this.guild.ownerId) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const roles = member.roles.cache;
      const permissions = new PermissionsBitField(roles.map((role) => role.permissions));
      if (checkAdmin && permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const overwrites = this.overwritesFor(member, true, roles);
      return permissions.remove(overwrites.everyone?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.everyone?.allow ?? PermissionsBitField.DefaultBit).remove(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.deny) : PermissionsBitField.DefaultBit).add(overwrites.roles.length > 0 ? overwrites.roles.map((role) => role.allow) : PermissionsBitField.DefaultBit).remove(overwrites.member?.deny ?? PermissionsBitField.DefaultBit).add(overwrites.member?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    rolePermissions(role, checkAdmin) {
      if (checkAdmin && role.permissions.has(PermissionFlagsBits.Administrator)) {
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      }
      const everyoneOverwrites = this.permissionOverwrites.cache.get(this.guild.id);
      const roleOverwrites = this.permissionOverwrites.cache.get(role.id);
      return role.permissions.remove(everyoneOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(everyoneOverwrites?.allow ?? PermissionsBitField.DefaultBit).remove(roleOverwrites?.deny ?? PermissionsBitField.DefaultBit).add(roleOverwrites?.allow ?? PermissionsBitField.DefaultBit).freeze();
    }
    lockPermissions() {
      if (!this.parent)
        return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelOrphan));
      const permissionOverwrites = this.parent.permissionOverwrites.cache.map((overwrite) => overwrite.toJSON());
      return this.edit({ permissionOverwrites });
    }
    get members() {
      return this.guild.members.cache.filter((m) => this.permissionsFor(m).has(PermissionFlagsBits.ViewChannel, false));
    }
    edit(options) {
      return this.guild.channels.edit(this, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setParent(channel, { lockPermissions = true, reason } = {}) {
      return this.edit({
        parent: channel ?? null,
        lockPermissions,
        reason
      });
    }
    setPosition(position, options = {}) {
      return this.guild.channels.setPosition(this, position, options);
    }
    clone(options = {}) {
      return this.guild.channels.create({
        name: options.name ?? this.name,
        permissionOverwrites: this.permissionOverwrites.cache,
        topic: this.topic,
        type: this.type,
        nsfw: this.nsfw,
        parent: this.parent,
        bitrate: this.bitrate,
        userLimit: this.userLimit,
        rateLimitPerUser: this.rateLimitPerUser,
        position: this.rawPosition,
        reason: null,
        ...options
      });
    }
    equals(channel) {
      let equal = channel && this.id === channel.id && this.type === channel.type && this.topic === channel.topic && this.position === channel.position && this.name === channel.name;
      if (equal) {
        if (this.permissionOverwrites && channel.permissionOverwrites) {
          equal = this.permissionOverwrites.cache.equals(channel.permissionOverwrites.cache);
        } else {
          equal = !this.permissionOverwrites && !channel.permissionOverwrites;
        }
      }
      return equal;
    }
    get deletable() {
      return this.manageable && this.guild.rulesChannelId !== this.id && this.guild.publicUpdatesChannelId !== this.id;
    }
    get manageable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      if (this.guild.members.me.communicationDisabledUntilTimestamp > Date.now())
        return false;
      const bitfield = VoiceBasedChannelTypes.includes(this.type) ? PermissionFlagsBits.ManageChannels | PermissionFlagsBits.Connect : PermissionFlagsBits.ViewChannel | PermissionFlagsBits.ManageChannels;
      return permissions.has(bitfield, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
  }
  module.exports = GuildChannel;
});

// node_modules/discord.js/src/util/Util.js
var require_Util = __commonJS((exports, module) => {
  var flatten = function(obj, ...props) {
    if (!isObject(obj))
      return obj;
    const objProps = Object.keys(obj).filter((k) => !k.startsWith("_")).map((k) => ({ [k]: true }));
    props = objProps.length ? Object.assign(...objProps, ...props) : Object.assign({}, ...props);
    const out = {};
    for (let [prop, newProp] of Object.entries(props)) {
      if (!newProp)
        continue;
      newProp = newProp === true ? prop : newProp;
      const element = obj[prop];
      const elemIsObj = isObject(element);
      const valueOf = elemIsObj && typeof element.valueOf === "function" ? element.valueOf() : null;
      const hasToJSON = elemIsObj && typeof element.toJSON === "function";
      if (element instanceof Collection)
        out[newProp] = Array.from(element.keys());
      else if (valueOf instanceof Collection)
        out[newProp] = Array.from(valueOf.keys());
      else if (Array.isArray(element))
        out[newProp] = element.map((e) => e.toJSON?.() ?? flatten(e));
      else if (typeof valueOf !== "object")
        out[newProp] = valueOf;
      else if (hasToJSON)
        out[newProp] = element.toJSON();
      else if (typeof element === "object")
        out[newProp] = flatten(element);
      else if (!elemIsObj)
        out[newProp] = element;
    }
    return out;
  };
  async function fetchRecommendedShardCount(token, { guildsPerShard = 1000, multipleOf = 1 } = {}) {
    if (!token)
      throw new DiscordjsError(ErrorCodes.TokenMissing);
    const response = await fetch2(RouteBases.api + Routes.gatewayBot(), {
      method: "GET",
      headers: { Authorization: `Bot ${token.replace(/^Bot\s*/i, "")}` }
    });
    if (!response.ok) {
      if (response.status === 401)
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      throw response;
    }
    const { shards } = await response.json();
    return Math.ceil(shards * (1000 / guildsPerShard) / multipleOf) * multipleOf;
  }
  var parseEmoji = function(text) {
    if (text.includes("%"))
      text = decodeURIComponent(text);
    if (!text.includes(":"))
      return { animated: false, name: text, id: undefined };
    const match = text.match(/<?(?:(a):)?(\w{2,32}):(\d{17,19})?>?/);
    return match && { animated: Boolean(match[1]), name: match[2], id: match[3] };
  };
  var resolvePartialEmoji = function(emoji) {
    if (!emoji)
      return null;
    if (typeof emoji === "string")
      return /^\d{17,19}$/.test(emoji) ? { id: emoji } : parseEmoji(emoji);
    const { id, name, animated } = emoji;
    if (!id && !name)
      return null;
    return { id, name, animated: Boolean(animated) };
  };
  var mergeDefault = function(def, given) {
    if (!given)
      return def;
    for (const key in def) {
      if (!Object.hasOwn(given, key) || given[key] === undefined) {
        given[key] = def[key];
      } else if (given[key] === Object(given[key])) {
        given[key] = mergeDefault(def[key], given[key]);
      }
    }
    return given;
  };
  var makeError = function(obj) {
    const err = new Error(obj.message);
    err.name = obj.name;
    err.stack = obj.stack;
    return err;
  };
  var makePlainError = function(err) {
    return {
      name: err.name,
      message: err.message,
      stack: err.stack
    };
  };
  var getSortableGroupTypes = function(type) {
    switch (type) {
      case ChannelType.GuildText:
      case ChannelType.GuildAnnouncement:
      case ChannelType.GuildForum:
        return TextSortableGroupTypes;
      case ChannelType.GuildVoice:
      case ChannelType.GuildStageVoice:
        return VoiceSortableGroupTypes;
      case ChannelType.GuildCategory:
        return CategorySortableGroupTypes;
      default:
        return [type];
    }
  };
  var moveElementInArray = function(array, element, newIndex, offset = false) {
    const index = array.indexOf(element);
    newIndex = (offset ? index : 0) + newIndex;
    if (newIndex > -1 && newIndex < array.length) {
      const removedElement = array.splice(index, 1)[0];
      array.splice(newIndex, 0, removedElement);
    }
    return array.indexOf(element);
  };
  var verifyString = function(data, error = Error, errorMessage = `Expected a string, got ${data} instead.`, allowEmpty = true) {
    if (typeof data !== "string")
      throw new error(errorMessage);
    if (!allowEmpty && data.length === 0)
      throw new error(errorMessage);
    return data;
  };
  var resolveColor = function(color) {
    if (typeof color === "string") {
      if (color === "Random")
        return Math.floor(Math.random() * (16777215 + 1));
      if (color === "Default")
        return 0;
      if (/^#?[\da-f]{6}$/i.test(color))
        return parseInt(color.replace("#", ""), 16);
      color = Colors[color];
    } else if (Array.isArray(color)) {
      color = (color[0] << 16) + (color[1] << 8) + color[2];
    }
    if (color < 0 || color > 16777215)
      throw new DiscordjsRangeError(ErrorCodes.ColorRange);
    if (typeof color !== "number" || Number.isNaN(color))
      throw new DiscordjsTypeError(ErrorCodes.ColorConvert);
    return color;
  };
  var discordSort = function(collection) {
    const isGuildChannel = collection.first() instanceof GuildChannel;
    return collection.sorted(isGuildChannel ? (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(a.id) - BigInt(b.id)) : (a, b) => a.rawPosition - b.rawPosition || Number(BigInt(b.id) - BigInt(a.id)));
  };
  async function setPosition(item, position, relative, sorted, client, route, reason) {
    let updatedItems = [...sorted.values()];
    moveElementInArray(updatedItems, item, position, relative);
    updatedItems = updatedItems.map((r, i) => ({ id: r.id, position: i }));
    await client.rest.patch(route, { body: updatedItems, reason });
    return updatedItems;
  }
  var basename = function(path, ext) {
    const res = parse(path);
    return ext && res.ext.startsWith(ext) ? res.name : res.base.split("?")[0];
  };
  var cleanContent = function(str, channel) {
    return str.replaceAll(/<(@[!&]?|#)(\d{17,19})>/g, (match, type, id) => {
      switch (type) {
        case "@":
        case "@!": {
          const member = channel.guild?.members.cache.get(id);
          if (member) {
            return `@${member.displayName}`;
          }
          const user = channel.client.users.cache.get(id);
          return user ? `@${user.username}` : match;
        }
        case "@&": {
          if (channel.type === ChannelType.DM)
            return match;
          const role = channel.guild.roles.cache.get(id);
          return role ? `@${role.name}` : match;
        }
        case "#": {
          const mentionedChannel = channel.client.channels.cache.get(id);
          return mentionedChannel ? `#${mentionedChannel.name}` : match;
        }
        default: {
          return match;
        }
      }
    });
  };
  var cleanCodeBlockContent = function(text) {
    return text.replaceAll("```", "`\u200B``");
  };
  var parseWebhookURL = function(url) {
    const matches = url.match(/https?:\/\/(?:ptb\.|canary\.)?discord\.com\/api(?:\/v\d{1,2})?\/webhooks\/(\d{17,19})\/([\w-]{68})/i);
    if (!matches || matches.length <= 2)
      return null;
    const [, id, token] = matches;
    return {
      id,
      token
    };
  };
  var { parse } = __require("node:path");
  var { Collection } = require_dist2();
  var { ChannelType, RouteBases, Routes } = require_v106();
  var { fetch: fetch2 } = require_undici();
  var Colors = require_Colors();
  var { DiscordjsError, DiscordjsRangeError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var isObject = (d) => typeof d === "object" && d !== null;
  var TextSortableGroupTypes = [ChannelType.GuildText, ChannelType.GuildAnnouncement, ChannelType.GuildForum];
  var VoiceSortableGroupTypes = [ChannelType.GuildVoice, ChannelType.GuildStageVoice];
  var CategorySortableGroupTypes = [ChannelType.GuildCategory];
  module.exports = {
    flatten,
    fetchRecommendedShardCount,
    parseEmoji,
    resolvePartialEmoji,
    mergeDefault,
    makeError,
    makePlainError,
    getSortableGroupTypes,
    moveElementInArray,
    verifyString,
    resolveColor,
    discordSort,
    setPosition,
    basename,
    cleanContent,
    cleanCodeBlockContent,
    parseWebhookURL
  };
  var GuildChannel = require_GuildChannel();
});

// node_modules/discord.js/src/client/BaseClient.js
var require_BaseClient = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { REST } = require_dist7();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Options = require_Options();
  var { mergeDefault, flatten } = require_Util();

  class BaseClient extends EventEmitter {
    constructor(options = {}) {
      super({ captureRejections: true });
      if (typeof options !== "object" || options === null) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      }
      this.options = mergeDefault(Options.createDefault(), {
        ...options,
        rest: {
          ...options.rest,
          userAgentAppendix: options.rest?.userAgentAppendix ? `${Options.userAgentAppendix} ${options.rest.userAgentAppendix}` : undefined
        }
      });
      this.rest = new REST(this.options.rest);
    }
    destroy() {
      this.rest.clearHashSweeper();
      this.rest.clearHandlerSweeper();
    }
    incrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners() {
      const maxListeners = this.getMaxListeners();
      if (maxListeners !== 0) {
        this.setMaxListeners(maxListeners - 1);
      }
    }
    toJSON(...props) {
      return flatten(this, ...props);
    }
  }
  module.exports = BaseClient;
});

// node_modules/discord.js/src/util/Enums.js
var require_Enums = __commonJS((exports, module) => {
  var createEnum = function(keys) {
    const obj = {};
    for (const [index, key] of keys.entries()) {
      if (key === null)
        continue;
      obj[key] = index;
      obj[index] = key;
    }
    return obj;
  };
  module.exports = { createEnum };
});

// node_modules/discord.js/src/util/Partials.js
var require_Partials = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "User",
    "Channel",
    "GuildMember",
    "Message",
    "Reaction",
    "GuildScheduledEvent",
    "ThreadMember"
  ]);
});

// node_modules/discord.js/src/client/actions/Action.js
var require_Action = __commonJS((exports, module) => {
  var Partials = require_Partials();

  class GenericAction {
    constructor(client) {
      this.client = client;
    }
    handle(data) {
      return data;
    }
    getPayload(data, manager, id, partialType, cache) {
      return this.client.options.partials.includes(partialType) ? manager._add(data, cache) : manager.cache.get(id);
    }
    getChannel(data) {
      const payloadData = {};
      const id = data.channel_id ?? data.id;
      if ("recipients" in data) {
        payloadData.recipients = data.recipients;
      } else {
        const recipient = data.author ?? data.user ?? { id: data.user_id };
        if (recipient.id !== this.client.user.id)
          payloadData.recipients = [recipient];
      }
      if (id !== undefined)
        payloadData.id = id;
      if ("guild_id" in data)
        payloadData.guild_id = data.guild_id;
      if ("last_message_id" in data)
        payloadData.last_message_id = data.last_message_id;
      return data[this.client.actions.injectedChannel] ?? this.getPayload(payloadData, this.client.channels, id, Partials.Channel);
    }
    getMessage(data, channel, cache) {
      const id = data.message_id ?? data.id;
      return data[this.client.actions.injectedMessage] ?? this.getPayload({
        id,
        channel_id: channel.id,
        guild_id: data.guild_id ?? channel.guild?.id
      }, channel.messages, id, Partials.Message, cache);
    }
    getReaction(data, message, user) {
      const id = data.emoji.id ?? decodeURIComponent(data.emoji.name);
      return this.getPayload({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user?.id === this.client.user.id
      }, message.reactions, id, Partials.Reaction);
    }
    getMember(data, guild) {
      return this.getPayload(data, guild.members, data.user.id, Partials.GuildMember);
    }
    getUser(data) {
      const id = data.user_id;
      return data[this.client.actions.injectedUser] ?? this.getPayload({ id }, this.client.users, id, Partials.User);
    }
    getUserFromMember(data) {
      if (data.guild_id && data.member?.user) {
        const guild = this.client.guilds.cache.get(data.guild_id);
        if (guild) {
          return guild.members._add(data.member).user;
        } else {
          return this.client.users._add(data.member.user);
        }
      }
      return this.getUser(data);
    }
    getScheduledEvent(data, guild) {
      const id = data.guild_scheduled_event_id ?? data.id;
      return this.getPayload({ id, guild_id: data.guild_id ?? guild.id }, guild.scheduledEvents, id, Partials.GuildScheduledEvent);
    }
    getThreadMember(id, manager) {
      return this.getPayload({ user_id: id }, manager, id, Partials.ThreadMember, false);
    }
  }
  module.exports = GenericAction;
});

// node_modules/discord.js/src/util/Events.js
var require_Events = __commonJS((exports, module) => {
  module.exports = {
    ApplicationCommandPermissionsUpdate: "applicationCommandPermissionsUpdate",
    AutoModerationActionExecution: "autoModerationActionExecution",
    AutoModerationRuleCreate: "autoModerationRuleCreate",
    AutoModerationRuleDelete: "autoModerationRuleDelete",
    AutoModerationRuleUpdate: "autoModerationRuleUpdate",
    CacheSweep: "cacheSweep",
    ChannelCreate: "channelCreate",
    ChannelDelete: "channelDelete",
    ChannelPinsUpdate: "channelPinsUpdate",
    ChannelUpdate: "channelUpdate",
    ClientReady: "ready",
    Debug: "debug",
    Error: "error",
    GuildAuditLogEntryCreate: "guildAuditLogEntryCreate",
    GuildAvailable: "guildAvailable",
    GuildBanAdd: "guildBanAdd",
    GuildBanRemove: "guildBanRemove",
    GuildCreate: "guildCreate",
    GuildDelete: "guildDelete",
    GuildEmojiCreate: "emojiCreate",
    GuildEmojiDelete: "emojiDelete",
    GuildEmojiUpdate: "emojiUpdate",
    GuildIntegrationsUpdate: "guildIntegrationsUpdate",
    GuildMemberAdd: "guildMemberAdd",
    GuildMemberAvailable: "guildMemberAvailable",
    GuildMemberRemove: "guildMemberRemove",
    GuildMembersChunk: "guildMembersChunk",
    GuildMemberUpdate: "guildMemberUpdate",
    GuildRoleCreate: "roleCreate",
    GuildRoleDelete: "roleDelete",
    GuildRoleUpdate: "roleUpdate",
    GuildScheduledEventCreate: "guildScheduledEventCreate",
    GuildScheduledEventDelete: "guildScheduledEventDelete",
    GuildScheduledEventUpdate: "guildScheduledEventUpdate",
    GuildScheduledEventUserAdd: "guildScheduledEventUserAdd",
    GuildScheduledEventUserRemove: "guildScheduledEventUserRemove",
    GuildStickerCreate: "stickerCreate",
    GuildStickerDelete: "stickerDelete",
    GuildStickerUpdate: "stickerUpdate",
    GuildUnavailable: "guildUnavailable",
    GuildUpdate: "guildUpdate",
    InteractionCreate: "interactionCreate",
    Invalidated: "invalidated",
    InviteCreate: "inviteCreate",
    InviteDelete: "inviteDelete",
    MessageBulkDelete: "messageDeleteBulk",
    MessageCreate: "messageCreate",
    MessageDelete: "messageDelete",
    MessageReactionAdd: "messageReactionAdd",
    MessageReactionRemove: "messageReactionRemove",
    MessageReactionRemoveAll: "messageReactionRemoveAll",
    MessageReactionRemoveEmoji: "messageReactionRemoveEmoji",
    MessageUpdate: "messageUpdate",
    PresenceUpdate: "presenceUpdate",
    Raw: "raw",
    ShardDisconnect: "shardDisconnect",
    ShardError: "shardError",
    ShardReady: "shardReady",
    ShardReconnecting: "shardReconnecting",
    ShardResume: "shardResume",
    StageInstanceCreate: "stageInstanceCreate",
    StageInstanceDelete: "stageInstanceDelete",
    StageInstanceUpdate: "stageInstanceUpdate",
    ThreadCreate: "threadCreate",
    ThreadDelete: "threadDelete",
    ThreadListSync: "threadListSync",
    ThreadMembersUpdate: "threadMembersUpdate",
    ThreadMemberUpdate: "threadMemberUpdate",
    ThreadUpdate: "threadUpdate",
    TypingStart: "typingStart",
    UserUpdate: "userUpdate",
    VoiceServerUpdate: "voiceServerUpdate",
    VoiceStateUpdate: "voiceStateUpdate",
    Warn: "warn",
    WebhooksUpdate: "webhookUpdate"
  };
});

// node_modules/discord.js/src/client/actions/ApplicationCommandPermissionsUpdate.js
var require_ApplicationCommandPermissionsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ApplicationCommandPermissionsUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      client.emit(Events.ApplicationCommandPermissionsUpdate, {
        permissions: data.permissions,
        id: data.id,
        guildId: data.guild_id,
        applicationId: data.application_id
      });
    }
  }
  module.exports = ApplicationCommandPermissionsUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationActionExecution.js
var require_AutoModerationActionExecution = __commonJS((exports, module) => {
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationActionExecution {
    constructor(data, guild) {
      this.guild = guild;
      this.action = _transformAPIAutoModerationAction(data.action);
      this.ruleId = data.rule_id;
      this.ruleTriggerType = data.rule_trigger_type;
      this.userId = data.user_id;
      this.channelId = data.channel_id ?? null;
      this.messageId = data.message_id ?? null;
      this.alertSystemMessageId = data.alert_system_message_id ?? null;
      this.content = data.content;
      this.matchedKeyword = data.matched_keyword ?? null;
      this.matchedContent = data.matched_content ?? null;
    }
    get autoModerationRule() {
      return this.guild.autoModerationRules.cache.get(this.ruleId) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get user() {
      return this.guild.client.users.cache.get(this.userId) ?? null;
    }
    get member() {
      return this.guild.members.cache.get(this.userId) ?? null;
    }
  }
  module.exports = AutoModerationActionExecution;
});

// node_modules/discord.js/src/client/actions/AutoModerationActionExecution.js
var require_AutoModerationActionExecution2 = __commonJS((exports, module) => {
  var Action = require_Action();
  var AutoModerationActionExecution = require_AutoModerationActionExecution();
  var Events = require_Events();

  class AutoModerationActionExecutionAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        client.emit(Events.AutoModerationActionExecution, new AutoModerationActionExecution(data, guild));
      }
      return {};
    }
  }
  module.exports = AutoModerationActionExecutionAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleCreate.js
var require_AutoModerationRuleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleCreateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleCreate, autoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleCreateAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleDelete.js
var require_AutoModerationRuleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleDeleteAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const autoModerationRule = guild.autoModerationRules.cache.get(data.id);
        if (autoModerationRule) {
          guild.autoModerationRules.cache.delete(autoModerationRule.id);
          client.emit(Events.AutoModerationRuleDelete, autoModerationRule);
        }
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleDeleteAction;
});

// node_modules/discord.js/src/client/actions/AutoModerationRuleUpdate.js
var require_AutoModerationRuleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class AutoModerationRuleUpdateAction extends Action {
    handle(data) {
      const { client } = this;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldAutoModerationRule = guild.autoModerationRules.cache.get(data.id)?._clone() ?? null;
        const newAutoModerationRule = guild.autoModerationRules._add(data);
        client.emit(Events.AutoModerationRuleUpdate, oldAutoModerationRule, newAutoModerationRule);
      }
      return {};
    }
  }
  module.exports = AutoModerationRuleUpdateAction;
});

// node_modules/discord.js/src/client/actions/ChannelCreate.js
var require_ChannelCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const channel = client.channels._add(data);
      if (!existing && channel) {
        client.emit(Events.ChannelCreate, channel);
      }
      return { channel };
    }
  }
  module.exports = ChannelCreateAction;
});

// node_modules/discord.js/src/client/actions/ChannelDelete.js
var require_ChannelDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ChannelDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.id);
      if (channel) {
        client.channels._remove(channel.id);
        client.emit(Events.ChannelDelete, channel);
      }
    }
  }
  module.exports = ChannelDeleteAction;
});

// node_modules/discord.js/src/managers/CategoryChannelChildManager.js
var require_CategoryChannelChildManager = __commonJS((exports, module) => {
  var DataManager = require_DataManager();
  var GuildChannel = require_GuildChannel();

  class CategoryChannelChildManager extends DataManager {
    constructor(channel) {
      super(channel.client, GuildChannel);
      this.channel = channel;
    }
    get cache() {
      return this.guild.channels.cache.filter((c) => c.parentId === this.channel.id);
    }
    get guild() {
      return this.channel.guild;
    }
    create(options) {
      return this.guild.channels.create({
        ...options,
        parent: this.channel.id
      });
    }
  }
  module.exports = CategoryChannelChildManager;
});

// node_modules/discord.js/src/structures/CategoryChannel.js
var require_CategoryChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var CategoryChannelChildManager = require_CategoryChannelChildManager();

  class CategoryChannel extends GuildChannel {
    get children() {
      return new CategoryChannelChildManager(this);
    }
  }
  module.exports = CategoryChannel;
});

// node_modules/discord.js/src/structures/interfaces/Collector.js
var require_Collector = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist2();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { flatten } = require_Util();

  class Collector extends EventEmitter {
    constructor(client, options = {}) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.filter = options.filter ?? (() => true);
      this.options = options;
      this.collected = new Collection;
      this.ended = false;
      this._timeout = null;
      this._idletimeout = null;
      this._endReason = null;
      if (typeof this.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.filter", "function");
      }
      this.handleCollect = this.handleCollect.bind(this);
      this.handleDispose = this.handleDispose.bind(this);
      if (options.time)
        this._timeout = setTimeout2(() => this.stop("time"), options.time).unref();
      if (options.idle)
        this._idletimeout = setTimeout2(() => this.stop("idle"), options.idle).unref();
      this.lastCollectedTimestamp = null;
    }
    get lastCollectedAt() {
      return this.lastCollectedTimestamp && new Date(this.lastCollectedTimestamp);
    }
    async handleCollect(...args) {
      const collectedId = await this.collect(...args);
      if (collectedId) {
        const filterResult = await this.filter(...args, this.collected);
        if (filterResult) {
          this.collected.set(collectedId, args[0]);
          this.emit("collect", ...args);
          this.lastCollectedTimestamp = Date.now();
          if (this._idletimeout) {
            clearTimeout2(this._idletimeout);
            this._idletimeout = setTimeout2(() => this.stop("idle"), this.options.idle).unref();
          }
        } else {
          this.emit("ignore", ...args);
        }
      }
      this.checkEnd();
    }
    async handleDispose(...args) {
      if (!this.options.dispose)
        return;
      const dispose = this.dispose(...args);
      if (!dispose || !await this.filter(...args) || !this.collected.has(dispose))
        return;
      this.collected.delete(dispose);
      this.emit("dispose", ...args);
      this.checkEnd();
    }
    get next() {
      return new Promise((resolve, reject) => {
        if (this.ended) {
          reject(this.collected);
          return;
        }
        const cleanup = () => {
          this.removeListener("collect", onCollect);
          this.removeListener("end", onEnd);
        };
        const onCollect = (item) => {
          cleanup();
          resolve(item);
        };
        const onEnd = () => {
          cleanup();
          reject(this.collected);
        };
        this.on("collect", onCollect);
        this.on("end", onEnd);
      });
    }
    stop(reason = "user") {
      if (this.ended)
        return;
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = null;
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = null;
      }
      this._endReason = reason;
      this.ended = true;
      this.emit("end", this.collected, reason);
    }
    resetTimer({ time, idle } = {}) {
      if (this._timeout) {
        clearTimeout2(this._timeout);
        this._timeout = setTimeout2(() => this.stop("time"), time ?? this.options.time).unref();
      }
      if (this._idletimeout) {
        clearTimeout2(this._idletimeout);
        this._idletimeout = setTimeout2(() => this.stop("idle"), idle ?? this.options.idle).unref();
      }
    }
    checkEnd() {
      const reason = this.endReason;
      if (reason)
        this.stop(reason);
      return Boolean(reason);
    }
    async* [Symbol.asyncIterator]() {
      const queue = [];
      const onCollect = (...item) => queue.push(item);
      this.on("collect", onCollect);
      try {
        while (queue.length || !this.ended) {
          if (queue.length) {
            yield queue.shift();
          } else {
            await new Promise((resolve) => {
              const tick = () => {
                this.removeListener("collect", tick);
                this.removeListener("end", tick);
                return resolve();
              };
              this.on("collect", tick);
              this.on("end", tick);
            });
          }
        }
      } finally {
        this.removeListener("collect", onCollect);
      }
    }
    toJSON() {
      return flatten(this);
    }
    get endReason() {
      return this._endReason;
    }
    collect() {
    }
    dispose() {
    }
  }
  module.exports = Collector;
});

// node_modules/discord.js/src/structures/InteractionCollector.js
var require_InteractionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Collector = require_Collector();
  var Events = require_Events();

  class InteractionCollector extends Collector {
    constructor(client, options = {}) {
      super(client, options);
      this.messageId = options.message?.id ?? options.interactionResponse?.interaction.message?.id ?? null;
      this.messageInteractionId = options.interactionResponse?.id ?? null;
      this.channelId = options.interactionResponse?.interaction.channelId ?? options.message?.channelId ?? options.message?.channel_id ?? this.client.channels.resolveId(options.channel);
      this.guildId = options.interactionResponse?.interaction.guildId ?? options.message?.guildId ?? options.message?.guild_id ?? this.client.guilds.resolveId(options.channel?.guild) ?? this.client.guilds.resolveId(options.guild);
      this.interactionType = options.interactionType ?? null;
      this.componentType = options.componentType ?? null;
      this.users = new Collection;
      this.total = 0;
      this.client.incrementMaxListeners();
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.messageId))
          this.stop("messageDelete");
      };
      if (this.messageId || this.messageInteractionId) {
        this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
        this.client.on(Events.MessageDelete, this._handleMessageDeletion);
        this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      }
      if (this.channelId) {
        this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
        this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
        this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      }
      if (this.guildId) {
        this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
        this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      }
      this.client.on(Events.InteractionCreate, this.handleCollect);
      this.once("end", () => {
        this.client.removeListener(Events.InteractionCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (interaction) => {
        this.total++;
        this.users.set(interaction.user.id, interaction.user);
      });
    }
    collect(interaction) {
      if (this.interactionType && interaction.type !== this.interactionType)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interaction?.id && interaction.message.interaction.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    dispose(interaction) {
      if (this.type && interaction.type !== this.type)
        return null;
      if (this.componentType && interaction.componentType !== this.componentType)
        return null;
      if (this.messageId && interaction.message?.id !== this.messageId)
        return null;
      if (this.messageInteractionId && interaction.message?.interaction?.id && interaction.message.interaction.id !== this.messageInteractionId) {
        return null;
      }
      if (this.channelId && interaction.channelId !== this.channelId)
        return null;
      if (this.guildId && interaction.guildId !== this.guildId)
        return null;
      return interaction.id;
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxComponents && this.collected.size >= this.options.maxComponents)
        return "componentLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.messageId) {
        this.stop("messageDelete");
      }
      if (message.interaction?.id === this.messageInteractionId) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channelId || channel.threads?.cache.has(this.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.guildId) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = InteractionCollector;
});

// node_modules/discord.js/src/structures/MessageCollector.js
var require_MessageCollector = __commonJS((exports, module) => {
  var Collector = require_Collector();
  var Events = require_Events();

  class MessageCollector extends Collector {
    constructor(channel, options = {}) {
      super(channel.client, options);
      this.channel = channel;
      this.received = 0;
      const bulkDeleteListener = (messages) => {
        for (const message of messages.values())
          this.handleDispose(message);
      };
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageCreate, this.handleCollect);
      this.client.on(Events.MessageDelete, this.handleDispose);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageCreate, this.handleCollect);
        this.client.removeListener(Events.MessageDelete, this.handleDispose);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
    }
    collect(message) {
      if (message.channelId !== this.channel.id)
        return null;
      this.received++;
      return message.id;
    }
    dispose(message) {
      return message.channelId === this.channel.id ? message.id : null;
    }
    get endReason() {
      if (this.options.max && this.collected.size >= this.options.max)
        return "limit";
      if (this.options.maxProcessed && this.received === this.options.maxProcessed)
        return "processedLimit";
      return super.endReason;
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.channel.id || channel.id === this.channel.parentId) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.channel.id) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.channel.guild?.id) {
        this.stop("guildDelete");
      }
    }
  }
  module.exports = MessageCollector;
});

// node_modules/discord.js/src/structures/Component.js
var require_Component = __commonJS((exports, module) => {
  var isEqual = require_fast_deep_equal();

  class Component {
    constructor(data) {
      this.data = data;
    }
    get type() {
      return this.data.type;
    }
    equals(other) {
      if (other instanceof Component) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
    toJSON() {
      return { ...this.data };
    }
  }
  module.exports = Component;
});

// node_modules/discord.js/src/structures/ActionRow.js
var require_ActionRow = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { isJSONEncodable } = require_dist();
  var Component = require_Component();
  var { createComponent } = require_Components();

  class ActionRow extends Component {
    constructor({ components, ...data }) {
      super(data);
      this.components = components.map((c) => createComponent(c));
    }
    static from = deprecate((other) => new this(isJSONEncodable(other) ? other.toJSON() : other), "ActionRow.from() is deprecated. Use ActionRowBuilder.from() instead.");
    toJSON() {
      return { ...this.data, components: this.components.map((c) => c.toJSON()) };
    }
  }
  module.exports = ActionRow;
});

// node_modules/discord.js/src/structures/ButtonBuilder.js
var require_ButtonBuilder = __commonJS((exports, module) => {
  var { ButtonBuilder: BuildersButton } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class ButtonBuilder extends BuildersButton {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({ ...data, emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ButtonBuilder;
});

// node_modules/discord.js/src/structures/ButtonComponent.js
var require_ButtonComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class ButtonComponent extends Component {
    get style() {
      return this.data.style;
    }
    get label() {
      return this.data.label ?? null;
    }
    get emoji() {
      return this.data.emoji ?? null;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
    get customId() {
      return this.data.custom_id ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
  }
  module.exports = ButtonComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuBuilder.js
var require_ChannelSelectMenuBuilder = __commonJS((exports, module) => {
  var { ChannelSelectMenuBuilder: BuildersChannelSelectMenu } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ChannelSelectMenuBuilder extends BuildersChannelSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ChannelSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/BaseSelectMenuComponent.js
var require_BaseSelectMenuComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class BaseSelectMenuComponent extends Component {
    get placeholder() {
      return this.data.placeholder ?? null;
    }
    get maxValues() {
      return this.data.max_values ?? null;
    }
    get minValues() {
      return this.data.min_values ?? null;
    }
    get customId() {
      return this.data.custom_id;
    }
    get disabled() {
      return this.data.disabled ?? false;
    }
  }
  module.exports = BaseSelectMenuComponent;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuComponent.js
var require_ChannelSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class ChannelSelectMenuComponent extends BaseSelectMenuComponent {
    get channelTypes() {
      return this.data.channel_types ?? null;
    }
  }
  module.exports = ChannelSelectMenuComponent;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuBuilder.js
var require_MentionableSelectMenuBuilder = __commonJS((exports, module) => {
  var { MentionableSelectMenuBuilder: BuildersMentionableSelectMenu } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class MentionableSelectMenuBuilder extends BuildersMentionableSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = MentionableSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuComponent.js
var require_MentionableSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class MentionableSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = MentionableSelectMenuComponent;
});

// node_modules/discord.js/src/structures/RoleSelectMenuBuilder.js
var require_RoleSelectMenuBuilder = __commonJS((exports, module) => {
  var { RoleSelectMenuBuilder: BuildersRoleSelectMenu } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class RoleSelectMenuBuilder extends BuildersRoleSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = RoleSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/RoleSelectMenuComponent.js
var require_RoleSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class RoleSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = RoleSelectMenuComponent;
});

// node_modules/discord.js/src/structures/StringSelectMenuBuilder.js
var require_StringSelectMenuBuilder = __commonJS((exports, module) => {
  var { SelectMenuBuilder: BuildersSelectMenu, normalizeArray } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuBuilder extends BuildersSelectMenu {
    constructor({ options, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        options: options?.map(({ emoji, ...option }) => ({
          ...option,
          emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
        }))
      }));
    }
    static normalizeEmoji(selectMenuOption) {
      if (isJSONEncodable(selectMenuOption)) {
        return selectMenuOption;
      }
      const { emoji, ...option } = selectMenuOption;
      return {
        ...option,
        emoji: typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      };
    }
    addOptions(...options) {
      return super.addOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    setOptions(...options) {
      return super.setOptions(normalizeArray(options).map((option) => StringSelectMenuBuilder.normalizeEmoji(option)));
    }
    static from(other) {
      if (isJSONEncodable(other)) {
        return new this(other.toJSON());
      }
      return new this(other);
    }
  }
  module.exports = StringSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/StringSelectMenuComponent.js
var require_StringSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class StringSelectMenuComponent extends BaseSelectMenuComponent {
    get options() {
      return this.data.options;
    }
  }
  module.exports = StringSelectMenuComponent;
});

// node_modules/discord.js/src/structures/TextInputBuilder.js
var require_TextInputBuilder = __commonJS((exports, module) => {
  var { TextInputBuilder: BuildersTextInput } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class TextInputBuilder extends BuildersTextInput {
    constructor(data) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = TextInputBuilder;
});

// node_modules/discord.js/src/structures/TextInputComponent.js
var require_TextInputComponent = __commonJS((exports, module) => {
  var Component = require_Component();

  class TextInputComponent extends Component {
    get customId() {
      return this.data.custom_id;
    }
    get value() {
      return this.data.value;
    }
  }
  module.exports = TextInputComponent;
});

// node_modules/discord.js/src/structures/UserSelectMenuBuilder.js
var require_UserSelectMenuBuilder = __commonJS((exports, module) => {
  var { UserSelectMenuBuilder: BuildersUserSelectMenu } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class UserSelectMenuBuilder extends BuildersUserSelectMenu {
    constructor(data = {}) {
      super(toSnakeCase(data));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = UserSelectMenuBuilder;
});

// node_modules/discord.js/src/structures/UserSelectMenuComponent.js
var require_UserSelectMenuComponent = __commonJS((exports, module) => {
  var BaseSelectMenuComponent = require_BaseSelectMenuComponent();

  class UserSelectMenuComponent extends BaseSelectMenuComponent {
  }
  module.exports = UserSelectMenuComponent;
});

// node_modules/discord.js/src/util/Components.js
var require_Components = __commonJS((exports, module) => {
  var createComponent = function(data) {
    if (data instanceof Component) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRow(data);
      case ComponentType.Button:
        return new ButtonComponent(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuComponent(data);
      case ComponentType.TextInput:
        return new TextInputComponent(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuComponent(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuComponent(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuComponent(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuComponent(data);
      default:
        return new Component(data);
    }
  };
  var createComponentBuilder = function(data) {
    if (data instanceof ComponentBuilder) {
      return data;
    }
    switch (data.type) {
      case ComponentType.ActionRow:
        return new ActionRowBuilder(data);
      case ComponentType.Button:
        return new ButtonBuilder(data);
      case ComponentType.StringSelect:
        return new StringSelectMenuBuilder(data);
      case ComponentType.TextInput:
        return new TextInputBuilder(data);
      case ComponentType.UserSelect:
        return new UserSelectMenuBuilder(data);
      case ComponentType.RoleSelect:
        return new RoleSelectMenuBuilder(data);
      case ComponentType.MentionableSelect:
        return new MentionableSelectMenuBuilder(data);
      case ComponentType.ChannelSelect:
        return new ChannelSelectMenuBuilder(data);
      default:
        return new ComponentBuilder(data);
    }
  };
  var { ComponentBuilder } = require_dist10();
  var { ComponentType } = require_v106();
  module.exports = { createComponent, createComponentBuilder };
  var ActionRow = require_ActionRow();
  var ActionRowBuilder = require_ActionRowBuilder();
  var ButtonBuilder = require_ButtonBuilder();
  var ButtonComponent = require_ButtonComponent();
  var ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  var ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  var Component = require_Component();
  var MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  var MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  var RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  var RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var TextInputBuilder = require_TextInputBuilder();
  var TextInputComponent = require_TextInputComponent();
  var UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  var UserSelectMenuComponent = require_UserSelectMenuComponent();
});

// node_modules/discord.js/src/structures/ActionRowBuilder.js
var require_ActionRowBuilder = __commonJS((exports, module) => {
  var { ActionRowBuilder: BuildersActionRow } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { createComponentBuilder } = require_Components();
  var { toSnakeCase } = require_Transformers();

  class ActionRowBuilder extends BuildersActionRow {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((c) => createComponentBuilder(c))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ActionRowBuilder;
});

// node_modules/discord.js/src/structures/GuildScheduledEvent.js
var require_GuildScheduledEvent = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var { GuildScheduledEventStatus, GuildScheduledEventEntityType, RouteBases } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class GuildScheduledEvent extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.guildId = data.guild_id;
      this._patch(data);
    }
    _patch(data) {
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      } else {
        this.creatorId ??= null;
      }
      this.name = data.name;
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.scheduledStartTimestamp = data.scheduled_start_time ? Date.parse(data.scheduled_start_time) : null;
      this.scheduledEndTimestamp = data.scheduled_end_time ? Date.parse(data.scheduled_end_time) : null;
      this.privacyLevel = data.privacy_level;
      this.status = data.status;
      this.entityType = data.entity_type;
      if ("entity_id" in data) {
        this.entityId = data.entity_id;
      } else {
        this.entityId ??= null;
      }
      if ("user_count" in data) {
        this.userCount = data.user_count;
      } else {
        this.userCount ??= null;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      } else {
        this.creator ??= this.client.users.resolve(this.creatorId);
      }
      if ("entity_metadata" in data) {
        if (data.entity_metadata) {
          this.entityMetadata = {
            location: data.entity_metadata.location ?? this.entityMetadata?.location ?? null
          };
        } else {
          this.entityMetadata = null;
        }
      } else {
        this.entityMetadata ??= null;
      }
      if ("image" in data) {
        this.image = data.image;
      } else {
        this.image ??= null;
      }
    }
    coverImageURL(options = {}) {
      return this.image && this.client.rest.cdn.guildScheduledEventCover(this.id, this.image, options);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get scheduledStartAt() {
      return this.scheduledStartTimestamp && new Date(this.scheduledStartTimestamp);
    }
    get scheduledEndAt() {
      return this.scheduledEndTimestamp && new Date(this.scheduledEndTimestamp);
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.scheduledEvent}/${this.guildId}/${this.id}`;
    }
    async createInviteURL(options) {
      let channelId = this.channelId;
      if (this.entityType === GuildScheduledEventEntityType.External) {
        if (!options?.channel)
          throw new DiscordjsError(ErrorCodes.InviteOptionsMissingChannel);
        channelId = this.guild.channels.resolveId(options.channel);
        if (!channelId)
          throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      }
      const invite = await this.guild.invites.create(channelId, options);
      return `${RouteBases.invite}/${invite.code}?event=${this.id}`;
    }
    edit(options) {
      return this.guild.scheduledEvents.edit(this.id, options);
    }
    async delete() {
      await this.guild.scheduledEvents.delete(this.id);
      return this;
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setScheduledStartTime(scheduledStartTime, reason) {
      return this.edit({ scheduledStartTime, reason });
    }
    setScheduledEndTime(scheduledEndTime, reason) {
      return this.edit({ scheduledEndTime, reason });
    }
    setDescription(description, reason) {
      return this.edit({ description, reason });
    }
    setStatus(status, reason) {
      return this.edit({ status, reason });
    }
    setLocation(location, reason) {
      return this.edit({ entityMetadata: { location }, reason });
    }
    fetchSubscribers(options) {
      return this.guild.scheduledEvents.fetchSubscribers(this.id, options);
    }
    toString() {
      return this.url;
    }
    isActive() {
      return this.status === GuildScheduledEventStatus.Active;
    }
    isCanceled() {
      return this.status === GuildScheduledEventStatus.Canceled;
    }
    isCompleted() {
      return this.status === GuildScheduledEventStatus.Completed;
    }
    isScheduled() {
      return this.status === GuildScheduledEventStatus.Scheduled;
    }
  }
  exports.GuildScheduledEvent = GuildScheduledEvent;
});

// node_modules/discord.js/src/structures/interfaces/Application.js
var require_Application = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();

  class Application extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      } else {
        this.name ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.appIcon(this.id, this.icon, options);
    }
    coverURL(options = {}) {
      return this.cover && this.client.rest.cdn.appIcon(this.id, this.cover, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Application;
});

// node_modules/discord.js/src/structures/IntegrationApplication.js
var require_IntegrationApplication = __commonJS((exports, module) => {
  var Application = require_Application();

  class IntegrationApplication extends Application {
    _patch(data) {
      super._patch(data);
      if ("bot" in data) {
        this.bot = this.client.users._add(data.bot);
      } else {
        this.bot ??= null;
      }
      if ("terms_of_service_url" in data) {
        this.termsOfServiceURL = data.terms_of_service_url;
      } else {
        this.termsOfServiceURL ??= null;
      }
      if ("privacy_policy_url" in data) {
        this.privacyPolicyURL = data.privacy_policy_url;
      } else {
        this.privacyPolicyURL ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("hook" in data) {
        this.hook = data.hook;
      } else {
        this.hook ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("verify_key" in data) {
        this.verifyKey = data.verify_key;
      } else {
        this.verifyKey ??= null;
      }
    }
  }
  module.exports = IntegrationApplication;
});

// node_modules/discord.js/src/structures/InviteStageInstance.js
var require_InviteStageInstance = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Base = require_Base();

  class InviteStageInstance extends Base {
    constructor(client, data, channelId, guildId) {
      super(client);
      this.channelId = channelId;
      this.guildId = guildId;
      this.members = new Collection;
      this._patch(data);
    }
    _patch(data) {
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("participant_count" in data) {
        this.participantCount = data.participant_count;
      }
      if ("speaker_count" in data) {
        this.speakerCount = data.speaker_count;
      }
      this.members.clear();
      for (const rawMember of data.members) {
        const member = this.guild.members._add(rawMember);
        this.members.set(member.id, member);
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
  }
  module.exports = InviteStageInstance;
});

// node_modules/discord.js/src/structures/BaseGuild.js
var require_BaseGuild = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, GuildFeature } = require_v106();
  var Base = require_Base();

  class BaseGuild extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.name = data.name;
      this.icon = data.icon;
      this.features = data.features;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get nameAcronym() {
      return this.name.replace(/'s /g, " ").replace(/\w+/g, (e) => e[0]).replace(/\s/g, "");
    }
    get partnered() {
      return this.features.includes(GuildFeature.Partnered);
    }
    get verified() {
      return this.features.includes(GuildFeature.Verified);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guild(this.id), {
        query: makeURLSearchParams({ with_counts: true })
      });
      return this.client.guilds._add(data);
    }
    toString() {
      return this.name;
    }
  }
  module.exports = BaseGuild;
});

// node_modules/discord.js/src/structures/AnonymousGuild.js
var require_AnonymousGuild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();

  class AnonymousGuild extends BaseGuild {
    constructor(client, data, immediatePatch = true) {
      super(client, data);
      if (immediatePatch)
        this._patch(data);
    }
    _patch(data) {
      if ("features" in data)
        this.features = data.features;
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("verification_level" in data) {
        this.verificationLevel = data.verification_level;
      }
      if ("vanity_url_code" in data) {
        this.vanityURLCode = data.vanity_url_code;
      }
      if ("nsfw_level" in data) {
        this.nsfwLevel = data.nsfw_level;
      }
      if ("premium_subscription_count" in data) {
        this.premiumSubscriptionCount = data.premium_subscription_count;
      } else {
        this.premiumSubscriptionCount ??= null;
      }
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
  }
  module.exports = AnonymousGuild;
});

// node_modules/discord.js/src/structures/Emoji.js
var require_Emoji = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();

  class Emoji extends Base {
    constructor(client, emoji) {
      super(client);
      this.animated = emoji.animated ?? null;
      this.name = emoji.name ?? null;
      this.id = emoji.id;
    }
    get identifier() {
      if (this.id)
        return `${this.animated ? "a:" : ""}${this.name}:${this.id}`;
      return encodeURIComponent(this.name);
    }
    get url() {
      return this.id && this.client.rest.cdn.emoji(this.id, this.animated ? "gif" : "png");
    }
    get createdTimestamp() {
      return this.id && DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return this.id && new Date(this.createdTimestamp);
    }
    toString() {
      return this.id ? `<${this.animated ? "a" : ""}:${this.name}:${this.id}>` : this.name;
    }
    toJSON() {
      return super.toJSON({
        guild: "guildId",
        createdTimestamp: true,
        url: true,
        identifier: true
      });
    }
  }
  exports.Emoji = Emoji;
});

// node_modules/discord.js/src/structures/WelcomeChannel.js
var require_WelcomeChannel = __commonJS((exports, module) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();

  class WelcomeChannel extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description;
      this._emoji = {
        name: data.emoji_name,
        id: data.emoji_id
      };
      this.channelId = data.channel_id;
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get emoji() {
      return this.client.emojis.resolve(this._emoji.id) ?? new Emoji(this.client, this._emoji);
    }
  }
  module.exports = WelcomeChannel;
});

// node_modules/discord.js/src/structures/WelcomeScreen.js
var require_WelcomeScreen = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { GuildFeature } = require_v106();
  var Base = require_Base();
  var WelcomeChannel = require_WelcomeChannel();

  class WelcomeScreen extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.description = data.description ?? null;
      this.welcomeChannels = new Collection;
      for (const channel of data.welcome_channels) {
        const welcomeChannel = new WelcomeChannel(this.guild, channel);
        this.welcomeChannels.set(welcomeChannel.channelId, welcomeChannel);
      }
    }
    get enabled() {
      return this.guild.features.includes(GuildFeature.WelcomeScreenEnabled);
    }
  }
  module.exports = WelcomeScreen;
});

// node_modules/discord.js/src/structures/InviteGuild.js
var require_InviteGuild = __commonJS((exports, module) => {
  var AnonymousGuild = require_AnonymousGuild();
  var WelcomeScreen = require_WelcomeScreen();

  class InviteGuild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data);
      this.welcomeScreen = data.welcome_screen !== undefined ? new WelcomeScreen(this, data.welcome_screen) : null;
    }
  }
  module.exports = InviteGuild;
});

// node_modules/discord.js/src/structures/Invite.js
var require_Invite = __commonJS((exports, module) => {
  var { RouteBases, Routes, PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var IntegrationApplication = require_IntegrationApplication();
  var InviteStageInstance = require_InviteStageInstance();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class Invite extends Base {
    static InvitesPattern = /discord(?:(?:app)?\.com\/invite|\.gg(?:\/invite)?)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      const InviteGuild = require_InviteGuild();
      this.guild ??= null;
      if (data.guild) {
        this.guild = this.client.guilds.resolve(data.guild.id) ?? new InviteGuild(this.client, data.guild);
      }
      if ("code" in data) {
        this.code = data.code;
      }
      if ("approximate_presence_count" in data) {
        this.presenceCount = data.approximate_presence_count;
      } else {
        this.presenceCount ??= null;
      }
      if ("approximate_member_count" in data) {
        this.memberCount = data.approximate_member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("temporary" in data) {
        this.temporary = data.temporary ?? null;
      } else {
        this.temporary ??= null;
      }
      if ("max_age" in data) {
        this.maxAge = data.max_age;
      } else {
        this.maxAge ??= null;
      }
      if ("uses" in data) {
        this.uses = data.uses;
      } else {
        this.uses ??= null;
      }
      if ("max_uses" in data) {
        this.maxUses = data.max_uses;
      } else {
        this.maxUses ??= null;
      }
      if ("inviter_id" in data) {
        this.inviterId = data.inviter_id;
      } else {
        this.inviterId ??= null;
      }
      if ("inviter" in data) {
        this.client.users._add(data.inviter);
        this.inviterId = data.inviter.id;
      }
      if ("target_user" in data) {
        this.targetUser = this.client.users._add(data.target_user);
      } else {
        this.targetUser ??= null;
      }
      if ("target_application" in data) {
        this.targetApplication = new IntegrationApplication(this.client, data.target_application);
      } else {
        this.targetApplication ??= null;
      }
      if ("target_type" in data) {
        this.targetType = data.target_type;
      } else {
        this.targetType ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("channel" in data) {
        this.channel = this.client.channels._add(data.channel, this.guild, { cache: false }) ?? this.client.channels.resolve(this.channelId);
        this.channelId ??= data.channel.id;
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      } else {
        this.createdTimestamp ??= null;
      }
      if ("expires_at" in data) {
        this._expiresTimestamp = data.expires_at && Date.parse(data.expires_at);
      } else {
        this._expiresTimestamp ??= null;
      }
      if ("stage_instance" in data) {
        this.stageInstance = new InviteStageInstance(this.client, data.stage_instance, this.channel.id, this.guild.id);
      } else {
        this.stageInstance ??= null;
      }
      if ("guild_scheduled_event" in data) {
        this.guildScheduledEvent = new GuildScheduledEvent(this.client, data.guild_scheduled_event);
      } else {
        this.guildScheduledEvent ??= null;
      }
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get deletable() {
      const guild = this.guild;
      if (!guild || !this.client.guilds.cache.has(guild.id))
        return false;
      if (!guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return Boolean(this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageChannels, false) || guild.members.me.permissions.has(PermissionFlagsBits.ManageGuild));
    }
    get expiresTimestamp() {
      return this._expiresTimestamp ?? (this.createdTimestamp && this.maxAge ? this.createdTimestamp + this.maxAge * 1000 : null);
    }
    get expiresAt() {
      return this.expiresTimestamp && new Date(this.expiresTimestamp);
    }
    get inviter() {
      return this.inviterId && this.client.users.resolve(this.inviterId);
    }
    get url() {
      return `${RouteBases.invite}/${this.code}`;
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.invite(this.code), { reason });
      return this;
    }
    toString() {
      return this.url;
    }
    toJSON() {
      return super.toJSON({
        url: true,
        expiresTimestamp: true,
        presenceCount: false,
        memberCount: false,
        uses: false,
        channel: "channelId",
        inviter: "inviterId",
        guild: "guildId"
      });
    }
    valueOf() {
      return this.code;
    }
  }
  module.exports = Invite;
});

// node_modules/discord.js/src/structures/GuildTemplate.js
var require_GuildTemplate = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { RouteBases, Routes } = require_v106();
  var Base = require_Base();
  var DataResolver = require_DataResolver();
  var Events = require_Events();

  class GuildTemplate extends Base {
    static GuildTemplatesPattern = /discord(?:app)?\.(?:com\/template|new)\/(?<code>[\w-]{2,255})/i;
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      if ("code" in data) {
        this.code = data.code;
      }
      if ("name" in data) {
        this.name = data.name;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("usage_count" in data) {
        this.usageCount = data.usage_count;
      }
      if ("creator_id" in data) {
        this.creatorId = data.creator_id;
      }
      if ("creator" in data) {
        this.creator = this.client.users._add(data.creator);
      }
      if ("created_at" in data) {
        this.createdTimestamp = Date.parse(data.created_at);
      }
      if ("updated_at" in data) {
        this.updatedTimestamp = Date.parse(data.updated_at);
      }
      if ("source_guild_id" in data) {
        this.guildId = data.source_guild_id;
      }
      if ("serialized_source_guild" in data) {
        this.serializedGuild = data.serialized_source_guild;
      }
      this.unSynced = ("is_dirty" in data) ? Boolean(data.is_dirty) : null;
      return this;
    }
    async createGuild(name, icon) {
      const { client } = this;
      const data = await client.rest.post(Routes.template(this.code), {
        body: {
          name,
          icon: await DataResolver.resolveImage(icon)
        }
      });
      if (client.guilds.cache.has(data.id))
        return client.guilds.cache.get(data.id);
      return new Promise((resolve) => {
        const resolveGuild = (guild) => {
          client.off(Events.GuildCreate, handleGuild);
          client.decrementMaxListeners();
          resolve(guild);
        };
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            resolveGuild(guild);
          }
        };
        client.incrementMaxListeners();
        client.on(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => resolveGuild(client.guilds._add(data)), 1e4).unref();
      });
    }
    async edit({ name, description } = {}) {
      const data = await this.client.rest.patch(Routes.guildTemplate(this.guildId, this.code), {
        body: { name, description }
      });
      return this._patch(data);
    }
    async delete() {
      await this.client.rest.delete(Routes.guildTemplate(this.guildId, this.code));
      return this;
    }
    async sync() {
      const data = await this.client.rest.put(Routes.guildTemplate(this.guildId, this.code));
      return this._patch(data);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get updatedAt() {
      return new Date(this.updatedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return `${RouteBases.template}/${this.code}`;
    }
    toString() {
      return this.code;
    }
  }
  module.exports = GuildTemplate;
});

// node_modules/discord.js/src/util/DataResolver.js
var require_DataResolver = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var fs = __require("node:fs/promises");
  var path = __require("node:path");
  var { fetch: fetch2 } = require_undici();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();

  class DataResolver extends null {
    static resolveCode(data, regex) {
      return regex.exec(data)?.[1] ?? data;
    }
    static resolveInviteCode(data) {
      return this.resolveCode(data, Invite.InvitesPattern);
    }
    static resolveGuildTemplateCode(data) {
      const GuildTemplate = require_GuildTemplate();
      return this.resolveCode(data, GuildTemplate.GuildTemplatesPattern);
    }
    static async resolveImage(image) {
      if (!image)
        return null;
      if (typeof image === "string" && image.startsWith("data:")) {
        return image;
      }
      const file = await this.resolveFile(image);
      return this.resolveBase64(file.data);
    }
    static resolveBase64(data) {
      if (Buffer2.isBuffer(data))
        return `data:image/jpg;base64,${data.toString("base64")}`;
      return data;
    }
    static async resolveFile(resource) {
      if (Buffer2.isBuffer(resource))
        return { data: resource };
      if (typeof resource[Symbol.asyncIterator] === "function") {
        const buffers = [];
        for await (const data of resource)
          buffers.push(Buffer2.from(data));
        return { data: Buffer2.concat(buffers) };
      }
      if (typeof resource === "string") {
        if (/^https?:\/\//.test(resource)) {
          const res = await fetch2(resource);
          return { data: Buffer2.from(await res.arrayBuffer()), contentType: res.headers.get("content-type") };
        }
        const file = path.resolve(resource);
        const stats = await fs.stat(file);
        if (!stats.isFile())
          throw new DiscordjsError(ErrorCodes.FileNotFound, file);
        return { data: await fs.readFile(file) };
      }
      throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
    }
  }
  module.exports = DataResolver;
});

// node_modules/discord.js/src/util/MessageFlagsBitField.js
var require_MessageFlagsBitField = __commonJS((exports, module) => {
  var { MessageFlags } = require_v106();
  var BitField = require_BitField();

  class MessageFlagsBitField extends BitField {
    static Flags = MessageFlags;
  }
  module.exports = MessageFlagsBitField;
});

// node_modules/discord.js/src/structures/BaseInteraction.js
var require_BaseInteraction = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType, ApplicationCommandType, ComponentType } = require_v106();
  var Base = require_Base();
  var { SelectMenuTypes } = require_Constants();
  var PermissionsBitField = require_PermissionsBitField();

  class BaseInteraction extends Base {
    constructor(client, data) {
      super(client);
      this.type = data.type;
      this.id = data.id;
      Object.defineProperty(this, "token", { value: data.token });
      this.applicationId = data.application_id;
      this.channelId = data.channel?.id ?? null;
      this.guildId = data.guild_id ?? null;
      this.user = this.client.users._add(data.user ?? data.member.user);
      this.member = data.member ? this.guild?.members._add(data.member) ?? data.member : null;
      this.version = data.version;
      this.appPermissions = data.app_permissions ? new PermissionsBitField(data.app_permissions).freeze() : null;
      this.memberPermissions = data.member?.permissions ? new PermissionsBitField(data.member.permissions).freeze() : null;
      this.locale = data.locale;
      this.guildLocale = data.guild_locale ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get channel() {
      return this.client.channels.cache.get(this.channelId) ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    inGuild() {
      return Boolean(this.guildId && this.member);
    }
    inCachedGuild() {
      return Boolean(this.guild && this.member);
    }
    inRawGuild() {
      return Boolean(this.guildId && !this.guild && this.member);
    }
    isAutocomplete() {
      return this.type === InteractionType.ApplicationCommandAutocomplete;
    }
    isCommand() {
      return this.type === InteractionType.ApplicationCommand;
    }
    isChatInputCommand() {
      return this.type === InteractionType.ApplicationCommand && this.commandType === ApplicationCommandType.ChatInput;
    }
    isContextMenuCommand() {
      return this.type === InteractionType.ApplicationCommand && [ApplicationCommandType.User, ApplicationCommandType.Message].includes(this.commandType);
    }
    isMessageComponent() {
      return this.type === InteractionType.MessageComponent;
    }
    isModalSubmit() {
      return this.type === InteractionType.ModalSubmit;
    }
    isUserContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.User;
    }
    isMessageContextMenuCommand() {
      return this.isContextMenuCommand() && this.commandType === ApplicationCommandType.Message;
    }
    isButton() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.Button;
    }
    isSelectMenu() {
      return this.isStringSelectMenu();
    }
    isAnySelectMenu() {
      return this.type === InteractionType.MessageComponent && SelectMenuTypes.includes(this.componentType);
    }
    isStringSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.StringSelect;
    }
    isUserSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.UserSelect;
    }
    isRoleSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.RoleSelect;
    }
    isChannelSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.ChannelSelect;
    }
    isMentionableSelectMenu() {
      return this.type === InteractionType.MessageComponent && this.componentType === ComponentType.MentionableSelect;
    }
    isRepliable() {
      return ![InteractionType.Ping, InteractionType.ApplicationCommandAutocomplete].includes(this.type);
    }
  }
  BaseInteraction.prototype.isSelectMenu = deprecate(BaseInteraction.prototype.isSelectMenu, "BaseInteraction#isSelectMenu() is deprecated. Use BaseInteraction#isStringSelectMenu() instead.");
  module.exports = BaseInteraction;
});

// node_modules/discord.js/src/util/AttachmentFlagsBitField.js
var require_AttachmentFlagsBitField = __commonJS((exports, module) => {
  var { AttachmentFlags } = require_v106();
  var BitField = require_BitField();

  class AttachmentFlagsBitField extends BitField {
    static Flags = AttachmentFlags;
  }
  module.exports = AttachmentFlagsBitField;
});

// node_modules/discord.js/src/structures/Attachment.js
var require_Attachment = __commonJS((exports, module) => {
  var AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  var { basename, flatten } = require_Util();

  class Attachment {
    constructor(data) {
      this.attachment = data.url;
      this.name = data.filename;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("size" in data) {
        this.size = data.size;
      }
      if ("url" in data) {
        this.url = data.url;
      }
      if ("proxy_url" in data) {
        this.proxyURL = data.proxy_url;
      }
      if ("height" in data) {
        this.height = data.height;
      } else {
        this.height ??= null;
      }
      if ("width" in data) {
        this.width = data.width;
      } else {
        this.width ??= null;
      }
      if ("content_type" in data) {
        this.contentType = data.content_type;
      } else {
        this.contentType ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      this.ephemeral = data.ephemeral ?? false;
      if ("duration_secs" in data) {
        this.duration = data.duration_secs;
      } else {
        this.duration ??= null;
      }
      if ("waveform" in data) {
        this.waveform = data.waveform;
      } else {
        this.waveform ??= null;
      }
      if ("flags" in data) {
        this.flags = new AttachmentFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new AttachmentFlagsBitField().freeze();
      }
    }
    get spoiler() {
      return basename(this.url ?? this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = Attachment;
});

// node_modules/discord.js/src/structures/ApplicationRoleConnectionMetadata.js
var require_ApplicationRoleConnectionMetadata = __commonJS((exports) => {
  class ApplicationRoleConnectionMetadata {
    constructor(data) {
      this.name = data.name;
      this.nameLocalizations = data.name_localizations ?? null;
      this.description = data.description;
      this.descriptionLocalizations = data.description_localizations ?? null;
      this.key = data.key;
      this.type = data.type;
    }
  }
  exports.ApplicationRoleConnectionMetadata = ApplicationRoleConnectionMetadata;
});

// node_modules/discord.js/src/structures/TeamMember.js
var require_TeamMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class TeamMember extends Base {
    constructor(team, data) {
      super(team.client);
      this.team = team;
      this._patch(data);
    }
    _patch(data) {
      if ("permissions" in data) {
        this.permissions = data.permissions;
      }
      if ("membership_state" in data) {
        this.membershipState = data.membership_state;
      }
      if ("user" in data) {
        this.user = this.client.users._add(data.user);
      }
    }
    get id() {
      return this.user.id;
    }
    toString() {
      return this.user.toString();
    }
  }
  module.exports = TeamMember;
});

// node_modules/discord.js/src/structures/Team.js
var require_Team = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var TeamMember = require_TeamMember();

  class Team extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      } else {
        this.icon ??= null;
      }
      if ("owner_user_id" in data) {
        this.ownerId = data.owner_user_id;
      } else {
        this.ownerId ??= null;
      }
      this.members = new Collection;
      for (const memberData of data.members) {
        const member = new TeamMember(this, memberData);
        this.members.set(member.id, member);
      }
    }
    get owner() {
      return this.members.get(this.ownerId) ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.teamIcon(this.id, this.icon, options);
    }
    toString() {
      return this.name;
    }
    toJSON() {
      return super.toJSON({ createdTimestamp: true });
    }
  }
  module.exports = Team;
});

// node_modules/discord.js/src/managers/ApplicationCommandPermissionsManager.js
var require_ApplicationCommandPermissionsManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { ApplicationCommandPermissionType, RESTJSONErrorCodes, Routes } = require_v106();
  var BaseManager = require_BaseManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ApplicationCommandPermissionsManager extends BaseManager {
    constructor(manager) {
      super(manager.client);
      this.manager = manager;
      this.guild = manager.guild ?? null;
      this.guildId = manager.guildId ?? manager.guild?.id ?? null;
      this.commandId = manager.id ?? null;
    }
    permissionsPath(guildId, commandId) {
      if (commandId) {
        return Routes.applicationCommandPermissions(this.client.application.id, guildId, commandId);
      }
      return Routes.guildApplicationCommandsPermissions(this.client.application.id, guildId);
    }
    async fetch({ guild, command } = {}) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (commandId) {
        const data2 = await this.client.rest.get(this.permissionsPath(guildId, commandId));
        return data2.permissions;
      }
      const data = await this.client.rest.get(this.permissionsPath(guildId));
      return data.reduce((coll, perm) => coll.set(perm.id, perm.permissions), new Collection);
    }
    async set({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      if (!commandId) {
        commandId = this.client.user.id;
      }
      const data = await this.client.rest.put(this.permissionsPath(guildId, commandId), {
        body: { permissions },
        auth: false,
        headers: { Authorization: `Bearer ${token}` }
      });
      return data.permissions;
    }
    async add({ guild, command, permissions, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!Array.isArray(permissions)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissions", "Array of ApplicationCommandPermissions", true);
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const newPermissions = permissions.slice();
      for (const perm of existing) {
        if (!newPermissions.some((x) => x.id === perm.id)) {
          newPermissions.push(perm);
        }
      }
      return this.set({ guild: guildId, command: commandId, permissions: newPermissions, token });
    }
    async remove({ guild, command, users, roles, channels, token } = {}) {
      if (!token) {
        throw new DiscordjsError(ErrorCodes.ApplicationCommandPermissionsTokenMissing);
      }
      let { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId) {
        commandId = this.client.user.id;
      }
      if (!users && !roles && !channels) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "users OR roles OR channels", "Array or Resolvable", true);
      }
      let resolvedUserIds = [];
      if (Array.isArray(users)) {
        for (const user of users) {
          const userId = this.client.users.resolveId(user);
          if (!userId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", user);
          resolvedUserIds.push(userId);
        }
      }
      let resolvedRoleIds = [];
      if (Array.isArray(roles)) {
        for (const role of roles) {
          if (typeof role === "string") {
            resolvedRoleIds.push(role);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          const roleId = this.guild.roles.resolveId(role);
          if (!roleId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "users", role);
          resolvedRoleIds.push(roleId);
        }
      }
      let resolvedChannelIds = [];
      if (Array.isArray(channels)) {
        for (const channel of channels) {
          if (typeof channel === "string") {
            resolvedChannelIds.push(channel);
            continue;
          }
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "channels");
          const channelId = this.guild.channels.resolveId(channel);
          if (!channelId)
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "channels", channel);
          resolvedChannelIds.push(channelId);
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      const permissions = existing.filter((perm) => {
        switch (perm.type) {
          case ApplicationCommandPermissionType.Role:
            return !resolvedRoleIds.includes(perm.id);
          case ApplicationCommandPermissionType.User:
            return !resolvedUserIds.includes(perm.id);
          case ApplicationCommandPermissionType.Channel:
            return !resolvedChannelIds.includes(perm.id);
        }
        return true;
      });
      return this.set({ guild: guildId, command: commandId, permissions, token });
    }
    async has({ guild, command, permissionId, permissionType }) {
      const { guildId, commandId } = this._validateOptions(guild, command);
      if (!commandId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      if (!permissionId) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
      }
      let resolvedId = permissionId;
      if (typeof permissionId !== "string") {
        resolvedId = this.client.users.resolveId(permissionId);
        if (!resolvedId) {
          if (!this.guild)
            throw new DiscordjsError(ErrorCodes.GuildUncachedEntityResolve, "roles");
          resolvedId = this.guild.roles.resolveId(permissionId);
        }
        if (!resolvedId) {
          resolvedId = this.guild.channels.resolveId(permissionId);
        }
        if (!resolvedId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "permissionId", "UserResolvable, RoleResolvable, ChannelResolvable, or Permission Constant");
        }
      }
      let existing = [];
      try {
        existing = await this.fetch({ guild: guildId, command: commandId });
      } catch (error) {
        if (error.code !== RESTJSONErrorCodes.UnknownApplicationCommandPermissions)
          throw error;
      }
      return existing.some((perm) => perm.id === resolvedId && (permissionType ?? perm.type) === perm.type);
    }
    _validateOptions(guild, command) {
      const guildId = this.guildId ?? this.client.guilds.resolveId(guild);
      if (!guildId)
        throw new DiscordjsError(ErrorCodes.GlobalCommandPermissions);
      let commandId = this.commandId;
      if (command && !commandId) {
        commandId = this.manager.resolveId?.(command);
        if (!commandId && this.guild) {
          commandId = this.guild.commands.resolveId(command);
        }
        commandId ??= this.client.application?.commands.resolveId(command);
        if (!commandId) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable", true);
        }
      }
      return { guildId, commandId };
    }
  }
  module.exports = ApplicationCommandPermissionsManager;
});

// node_modules/discord.js/src/structures/ApplicationCommand.js
var require_ApplicationCommand = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var { ApplicationCommandOptionType } = require_v106();
  var isEqual = require_fast_deep_equal();
  var Base = require_Base();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommand extends Base {
    constructor(client, data, guild, guildId) {
      super(client);
      this.id = data.id;
      this.applicationId = data.application_id;
      this.guild = guild ?? null;
      this.guildId = guild?.id ?? guildId ?? null;
      this.permissions = new ApplicationCommandPermissionsManager(this);
      this.type = data.type;
      this.nsfw = data.nsfw ?? false;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("name_localizations" in data) {
        this.nameLocalizations = data.name_localizations;
      } else {
        this.nameLocalizations ??= null;
      }
      if ("name_localized" in data) {
        this.nameLocalized = data.name_localized;
      } else {
        this.nameLocalized ??= null;
      }
      if ("description" in data) {
        this.description = data.description;
      }
      if ("description_localizations" in data) {
        this.descriptionLocalizations = data.description_localizations;
      } else {
        this.descriptionLocalizations ??= null;
      }
      if ("description_localized" in data) {
        this.descriptionLocalized = data.description_localized;
      } else {
        this.descriptionLocalized ??= null;
      }
      if ("options" in data) {
        this.options = data.options.map((o) => this.constructor.transformOption(o, true));
      } else {
        this.options ??= [];
      }
      if ("default_member_permissions" in data) {
        this.defaultMemberPermissions = data.default_member_permissions ? new PermissionsBitField(BigInt(data.default_member_permissions)).freeze() : null;
      } else {
        this.defaultMemberPermissions ??= null;
      }
      if ("dm_permission" in data) {
        this.dmPermission = data.dm_permission;
      } else {
        this.dmPermission ??= null;
      }
      if ("version" in data) {
        this.version = data.version;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get manager() {
      return (this.guild ?? this.client.application).commands;
    }
    edit(data) {
      return this.manager.edit(this, data, this.guildId);
    }
    setName(name) {
      return this.edit({ name });
    }
    setNameLocalizations(nameLocalizations) {
      return this.edit({ nameLocalizations });
    }
    setDescription(description) {
      return this.edit({ description });
    }
    setDescriptionLocalizations(descriptionLocalizations) {
      return this.edit({ descriptionLocalizations });
    }
    setDefaultMemberPermissions(defaultMemberPermissions) {
      return this.edit({ defaultMemberPermissions });
    }
    setDMPermission(dmPermission = true) {
      return this.edit({ dmPermission });
    }
    setOptions(options) {
      return this.edit({ options });
    }
    delete() {
      return this.manager.delete(this, this.guildId);
    }
    equals(command, enforceOptionOrder = false) {
      if (command.id && this.id !== command.id)
        return false;
      let defaultMemberPermissions = null;
      let dmPermission = command.dmPermission ?? command.dm_permission;
      if ("default_member_permissions" in command) {
        defaultMemberPermissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield : null;
      }
      if ("defaultMemberPermissions" in command) {
        defaultMemberPermissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield : null;
      }
      if (command.name !== this.name || ("description" in command) && command.description !== this.description || ("version" in command) && command.version !== this.version || command.type && command.type !== this.type || ("nsfw" in command) && command.nsfw !== this.nsfw || (command.options?.length ?? 0) !== (this.options?.length ?? 0) || defaultMemberPermissions !== (this.defaultMemberPermissions?.bitfield ?? null) || dmPermission !== undefined && dmPermission !== this.dmPermission || !isEqual(command.nameLocalizations ?? command.name_localizations ?? {}, this.nameLocalizations ?? {}) || !isEqual(command.descriptionLocalizations ?? command.description_localizations ?? {}, this.descriptionLocalizations ?? {})) {
        return false;
      }
      if (command.options) {
        return this.constructor.optionsEqual(this.options, command.options, enforceOptionOrder);
      }
      return true;
    }
    static optionsEqual(existing, options, enforceOptionOrder = false) {
      if (existing.length !== options.length)
        return false;
      if (enforceOptionOrder) {
        return existing.every((option, index) => this._optionEquals(option, options[index], enforceOptionOrder));
      }
      const newOptions = new Map(options.map((option) => [option.name, option]));
      for (const option of existing) {
        const foundOption = newOptions.get(option.name);
        if (!foundOption || !this._optionEquals(option, foundOption))
          return false;
      }
      return true;
    }
    static _optionEquals(existing, option, enforceOptionOrder = false) {
      if (option.name !== existing.name || option.type !== existing.type || option.description !== existing.description || option.autocomplete !== existing.autocomplete || (option.required ?? ([ApplicationCommandOptionType.Subcommand, ApplicationCommandOptionType.SubcommandGroup].includes(option.type) ? undefined : false)) !== existing.required || option.choices?.length !== existing.choices?.length || option.options?.length !== existing.options?.length || (option.channelTypes ?? option.channel_types)?.length !== existing.channelTypes?.length || (option.minValue ?? option.min_value) !== existing.minValue || (option.maxValue ?? option.max_value) !== existing.maxValue || (option.minLength ?? option.min_length) !== existing.minLength || (option.maxLength ?? option.max_length) !== existing.maxLength || !isEqual(option.nameLocalizations ?? option.name_localizations ?? {}, existing.nameLocalizations ?? {}) || !isEqual(option.descriptionLocalizations ?? option.description_localizations ?? {}, existing.descriptionLocalizations ?? {})) {
        return false;
      }
      if (existing.choices) {
        if (enforceOptionOrder && !existing.choices.every((choice, index) => choice.name === option.choices[index].name && choice.value === option.choices[index].value && isEqual(choice.nameLocalizations ?? {}, option.choices[index].nameLocalizations ?? option.choices[index].name_localizations ?? {}))) {
          return false;
        }
        if (!enforceOptionOrder) {
          const newChoices = new Map(option.choices.map((choice) => [choice.name, choice]));
          for (const choice of existing.choices) {
            const foundChoice = newChoices.get(choice.name);
            if (!foundChoice || foundChoice.value !== choice.value)
              return false;
          }
        }
      }
      if (existing.channelTypes) {
        const newTypes = option.channelTypes ?? option.channel_types;
        for (const type of existing.channelTypes) {
          if (!newTypes.includes(type))
            return false;
        }
      }
      if (existing.options) {
        return this.optionsEqual(existing.options, option.options, enforceOptionOrder);
      }
      return true;
    }
    static transformOption(option, received) {
      const channelTypesKey = received ? "channelTypes" : "channel_types";
      const minValueKey = received ? "minValue" : "min_value";
      const maxValueKey = received ? "maxValue" : "max_value";
      const minLengthKey = received ? "minLength" : "min_length";
      const maxLengthKey = received ? "maxLength" : "max_length";
      const nameLocalizationsKey = received ? "nameLocalizations" : "name_localizations";
      const nameLocalizedKey = received ? "nameLocalized" : "name_localized";
      const descriptionLocalizationsKey = received ? "descriptionLocalizations" : "description_localizations";
      const descriptionLocalizedKey = received ? "descriptionLocalized" : "description_localized";
      return {
        type: option.type,
        name: option.name,
        [nameLocalizationsKey]: option.nameLocalizations ?? option.name_localizations,
        [nameLocalizedKey]: option.nameLocalized ?? option.name_localized,
        description: option.description,
        [descriptionLocalizationsKey]: option.descriptionLocalizations ?? option.description_localizations,
        [descriptionLocalizedKey]: option.descriptionLocalized ?? option.description_localized,
        required: option.required ?? (option.type === ApplicationCommandOptionType.Subcommand || option.type === ApplicationCommandOptionType.SubcommandGroup ? undefined : false),
        autocomplete: option.autocomplete,
        choices: option.choices?.map((choice) => ({
          name: choice.name,
          [nameLocalizedKey]: choice.nameLocalized ?? choice.name_localized,
          [nameLocalizationsKey]: choice.nameLocalizations ?? choice.name_localizations,
          value: choice.value
        })),
        options: option.options?.map((o) => this.transformOption(o, received)),
        [channelTypesKey]: option.channelTypes ?? option.channel_types,
        [minValueKey]: option.minValue ?? option.min_value,
        [maxValueKey]: option.maxValue ?? option.max_value,
        [minLengthKey]: option.minLength ?? option.min_length,
        [maxLengthKey]: option.maxLength ?? option.max_length
      };
    }
  }
  module.exports = ApplicationCommand;
});

// node_modules/discord.js/src/managers/ApplicationCommandManager.js
var require_ApplicationCommandManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { isJSONEncodable } = require_dist();
  var { Routes } = require_v106();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ApplicationCommand = require_ApplicationCommand();
  var PermissionsBitField = require_PermissionsBitField();

  class ApplicationCommandManager extends CachedManager {
    constructor(client, iterable) {
      super(client, ApplicationCommand, iterable);
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
    _add(data, cache, guildId) {
      return super._add(data, cache, { extras: [this.guild, guildId] });
    }
    commandPath({ id, guildId } = {}) {
      if (this.guild ?? guildId) {
        if (id) {
          return Routes.applicationGuildCommand(this.client.application.id, this.guild?.id ?? guildId, id);
        }
        return Routes.applicationGuildCommands(this.client.application.id, this.guild?.id ?? guildId);
      }
      if (id) {
        return Routes.applicationCommand(this.client.application.id, id);
      }
      return Routes.applicationCommands(this.client.application.id);
    }
    async fetch(id, { guildId, cache = true, force = false, locale, withLocalizations } = {}) {
      if (typeof id === "object") {
        ({ guildId, cache = true, locale, withLocalizations } = id);
      } else if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const command = await this.client.rest.get(this.commandPath({ id, guildId }));
        return this._add(command, cache);
      }
      const data = await this.client.rest.get(this.commandPath({ guildId }), {
        headers: {
          "X-Discord-Locale": locale
        },
        query: makeURLSearchParams({ with_localizations: withLocalizations })
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, cache, guildId)), new Collection);
    }
    async create(command, guildId) {
      const data = await this.client.rest.post(this.commandPath({ guildId }), {
        body: this.constructor.transformCommand(command)
      });
      return this._add(data, true, guildId);
    }
    async set(commands, guildId) {
      const data = await this.client.rest.put(this.commandPath({ guildId }), {
        body: commands.map((c) => this.constructor.transformCommand(c))
      });
      return data.reduce((coll, command) => coll.set(command.id, this._add(command, true, guildId)), new Collection);
    }
    async edit(command, data, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      const patched = await this.client.rest.patch(this.commandPath({ id, guildId }), {
        body: this.constructor.transformCommand(data)
      });
      return this._add(patched, true, guildId);
    }
    async delete(command, guildId) {
      const id = this.resolveId(command);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "command", "ApplicationCommandResolvable");
      await this.client.rest.delete(this.commandPath({ id, guildId }));
      const cached = this.cache.get(id);
      this.cache.delete(id);
      return cached ?? null;
    }
    static transformCommand(command) {
      if (isJSONEncodable(command))
        return command.toJSON();
      let default_member_permissions;
      if ("default_member_permissions" in command) {
        default_member_permissions = command.default_member_permissions ? new PermissionsBitField(BigInt(command.default_member_permissions)).bitfield.toString() : command.default_member_permissions;
      }
      if ("defaultMemberPermissions" in command) {
        default_member_permissions = command.defaultMemberPermissions !== null ? new PermissionsBitField(command.defaultMemberPermissions).bitfield.toString() : command.defaultMemberPermissions;
      }
      return {
        name: command.name,
        name_localizations: command.nameLocalizations ?? command.name_localizations,
        description: command.description,
        nsfw: command.nsfw,
        description_localizations: command.descriptionLocalizations ?? command.description_localizations,
        type: command.type,
        options: command.options?.map((o) => ApplicationCommand.transformOption(o)),
        default_member_permissions,
        dm_permission: command.dmPermission ?? command.dm_permission
      };
    }
  }
  module.exports = ApplicationCommandManager;
});

// node_modules/discord.js/src/util/ApplicationFlagsBitField.js
var require_ApplicationFlagsBitField = __commonJS((exports, module) => {
  var { ApplicationFlags } = require_v106();
  var BitField = require_BitField();

  class ApplicationFlagsBitField extends BitField {
    static Flags = ApplicationFlags;
  }
  module.exports = ApplicationFlagsBitField;
});

// node_modules/discord.js/src/structures/ClientApplication.js
var require_ClientApplication = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var { ApplicationRoleConnectionMetadata } = require_ApplicationRoleConnectionMetadata();
  var Team = require_Team();
  var Application = require_Application();
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class ClientApplication extends Application {
    constructor(client, data) {
      super(client, data);
      this.commands = new ApplicationCommandManager(this.client);
    }
    _patch(data) {
      super._patch(data);
      this.tags = data.tags ?? [];
      if ("install_params" in data) {
        this.installParams = {
          scopes: data.install_params.scopes,
          permissions: new PermissionsBitField(data.install_params.permissions).freeze()
        };
      } else {
        this.installParams ??= null;
      }
      if ("custom_install_url" in data) {
        this.customInstallURL = data.custom_install_url;
      } else {
        this.customInstallURL = null;
      }
      if ("flags" in data) {
        this.flags = new ApplicationFlagsBitField(data.flags).freeze();
      }
      if ("approximate_guild_count" in data) {
        this.approximateGuildCount = data.approximate_guild_count;
      } else {
        this.approximateGuildCount ??= null;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("cover_image" in data) {
        this.cover = data.cover_image;
      } else {
        this.cover ??= null;
      }
      if ("rpc_origins" in data) {
        this.rpcOrigins = data.rpc_origins;
      } else {
        this.rpcOrigins ??= [];
      }
      if ("bot_require_code_grant" in data) {
        this.botRequireCodeGrant = data.bot_require_code_grant;
      } else {
        this.botRequireCodeGrant ??= null;
      }
      if ("bot_public" in data) {
        this.botPublic = data.bot_public;
      } else {
        this.botPublic ??= null;
      }
      if ("role_connections_verification_url" in data) {
        this.roleConnectionsVerificationURL = data.role_connections_verification_url;
      } else {
        this.roleConnectionsVerificationURL ??= null;
      }
      this.owner = data.team ? new Team(this.client, data.team) : data.owner ? this.client.users._add(data.owner) : this.owner ?? null;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId) ?? null;
    }
    get partial() {
      return !this.name;
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.currentApplication());
      this._patch(data);
      return this;
    }
    async fetchRoleConnectionMetadataRecords() {
      const metadata = await this.client.rest.get(Routes.applicationRoleConnectionMetadata(this.client.user.id));
      return metadata.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
    async editRoleConnectionMetadataRecords(records) {
      const newRecords = await this.client.rest.put(Routes.applicationRoleConnectionMetadata(this.client.user.id), {
        body: records.map((record) => ({
          type: record.type,
          key: record.key,
          name: record.name,
          name_localizations: record.nameLocalizations,
          description: record.description,
          description_localizations: record.descriptionLocalizations
        }))
      });
      return newRecords.map((data) => new ApplicationRoleConnectionMetadata(data));
    }
  }
  module.exports = ClientApplication;
});

// node_modules/discord.js/src/structures/Embed.js
var require_Embed = __commonJS((exports, module) => {
  var { embedLength } = require_dist10();
  var isEqual = require_fast_deep_equal();

  class Embed {
    constructor(data) {
      this.data = { ...data };
    }
    get fields() {
      return this.data.fields ?? [];
    }
    get title() {
      return this.data.title ?? null;
    }
    get description() {
      return this.data.description ?? null;
    }
    get url() {
      return this.data.url ?? null;
    }
    get color() {
      return this.data.color ?? null;
    }
    get timestamp() {
      return this.data.timestamp ?? null;
    }
    get thumbnail() {
      if (!this.data.thumbnail)
        return null;
      return {
        url: this.data.thumbnail.url,
        proxyURL: this.data.thumbnail.proxy_url,
        height: this.data.thumbnail.height,
        width: this.data.thumbnail.width
      };
    }
    get image() {
      if (!this.data.image)
        return null;
      return {
        url: this.data.image.url,
        proxyURL: this.data.image.proxy_url,
        height: this.data.image.height,
        width: this.data.image.width
      };
    }
    get video() {
      if (!this.data.video)
        return null;
      return {
        url: this.data.video.url,
        proxyURL: this.data.video.proxy_url,
        height: this.data.video.height,
        width: this.data.video.width
      };
    }
    get author() {
      if (!this.data.author)
        return null;
      return {
        name: this.data.author.name,
        url: this.data.author.url,
        iconURL: this.data.author.icon_url,
        proxyIconURL: this.data.author.proxy_icon_url
      };
    }
    get provider() {
      return this.data.provider ?? null;
    }
    get footer() {
      if (!this.data.footer)
        return null;
      return {
        text: this.data.footer.text,
        iconURL: this.data.footer.icon_url,
        proxyIconURL: this.data.footer.proxy_icon_url
      };
    }
    get length() {
      return embedLength(this.data);
    }
    get hexColor() {
      return typeof this.data.color === "number" ? `#${this.data.color.toString(16).padStart(6, "0")}` : this.data.color ?? null;
    }
    toJSON() {
      return { ...this.data };
    }
    equals(other) {
      if (other instanceof Embed) {
        return isEqual(other.data, this.data);
      }
      return isEqual(other, this.data);
    }
  }
  module.exports = Embed;
});

// node_modules/discord.js/src/structures/MessageMentions.js
var require_MessageMentions = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { FormattingPatterns } = require_v106();
  var { flatten } = require_Util();

  class MessageMentions {
    static EveryonePattern = /@(?<mention>everyone|here)/;
    static UsersPattern = FormattingPatterns.UserWithOptionalNickname;
    static RolesPattern = FormattingPatterns.Role;
    static ChannelsPattern = FormattingPatterns.Channel;
    static GlobalChannelsPattern = new RegExp(this.ChannelsPattern.source, "g");
    static GlobalUsersPattern = new RegExp(this.UsersPattern.source, "g");
    constructor(message, users, roles, everyone, crosspostedChannels, repliedUser) {
      Object.defineProperty(this, "client", { value: message.client });
      Object.defineProperty(this, "guild", { value: message.guild });
      Object.defineProperty(this, "_content", { value: message.content });
      this.everyone = Boolean(everyone);
      if (users) {
        if (users instanceof Collection) {
          this.users = new Collection(users);
        } else {
          this.users = new Collection;
          for (const mention of users) {
            if (mention.member && message.guild) {
              message.guild.members._add(Object.assign(mention.member, { user: mention }));
            }
            const user = message.client.users._add(mention);
            this.users.set(user.id, user);
          }
        }
      } else {
        this.users = new Collection;
      }
      if (roles instanceof Collection) {
        this.roles = new Collection(roles);
      } else if (roles) {
        this.roles = new Collection;
        const guild = message.guild;
        if (guild) {
          for (const mention of roles) {
            const role = guild.roles.cache.get(mention);
            if (role)
              this.roles.set(role.id, role);
          }
        }
      } else {
        this.roles = new Collection;
      }
      this._members = null;
      this._channels = null;
      this._parsedUsers = null;
      if (crosspostedChannels) {
        if (crosspostedChannels instanceof Collection) {
          this.crosspostedChannels = new Collection(crosspostedChannels);
        } else {
          this.crosspostedChannels = new Collection;
          for (const d of crosspostedChannels) {
            this.crosspostedChannels.set(d.id, {
              channelId: d.id,
              guildId: d.guild_id,
              type: d.type,
              name: d.name
            });
          }
        }
      } else {
        this.crosspostedChannels = new Collection;
      }
      this.repliedUser = repliedUser ? this.client.users._add(repliedUser) : null;
    }
    get members() {
      if (this._members)
        return this._members;
      if (!this.guild)
        return null;
      this._members = new Collection;
      this.users.forEach((user) => {
        const member = this.guild.members.resolve(user);
        if (member)
          this._members.set(member.user.id, member);
      });
      return this._members;
    }
    get channels() {
      if (this._channels)
        return this._channels;
      this._channels = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalChannelsPattern.exec(this._content)) !== null) {
        const channel = this.client.channels.cache.get(matches.groups.id);
        if (channel)
          this._channels.set(channel.id, channel);
      }
      return this._channels;
    }
    get parsedUsers() {
      if (this._parsedUsers)
        return this._parsedUsers;
      this._parsedUsers = new Collection;
      let matches;
      while ((matches = this.constructor.GlobalUsersPattern.exec(this._content)) !== null) {
        const user = this.client.users.cache.get(matches[1]);
        if (user)
          this._parsedUsers.set(user.id, user);
      }
      return this._parsedUsers;
    }
    has(data, { ignoreDirect = false, ignoreRoles = false, ignoreRepliedUser = false, ignoreEveryone = false } = {}) {
      const user = this.client.users.resolve(data);
      if (!ignoreEveryone && user && this.everyone)
        return true;
      const userWasRepliedTo = user && this.repliedUser?.id === user.id;
      if (!ignoreRepliedUser && userWasRepliedTo && this.users.has(user.id))
        return true;
      if (!ignoreDirect) {
        if (user && (!ignoreRepliedUser || this.parsedUsers.has(user.id)) && this.users.has(user.id))
          return true;
        const role = this.guild?.roles.resolve(data);
        if (role && this.roles.has(role.id))
          return true;
        const channel = this.client.channels.resolve(data);
        if (channel && this.channels.has(channel.id))
          return true;
      }
      if (!ignoreRoles) {
        const member = this.guild?.members.resolve(data);
        if (member) {
          for (const mentionedRole of this.roles.values())
            if (member.roles.cache.has(mentionedRole.id))
              return true;
        }
      }
      return false;
    }
    toJSON() {
      return flatten(this, {
        members: true,
        channels: true
      });
    }
  }
  module.exports = MessageMentions;
});

// node_modules/discord.js/src/structures/ReactionCollector.js
var require_ReactionCollector = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Collector = require_Collector();
  var Events = require_Events();

  class ReactionCollector extends Collector {
    constructor(message, options = {}) {
      super(message.client, options);
      this.message = message;
      this.users = new Collection;
      this.total = 0;
      this.empty = this.empty.bind(this);
      this._handleChannelDeletion = this._handleChannelDeletion.bind(this);
      this._handleThreadDeletion = this._handleThreadDeletion.bind(this);
      this._handleGuildDeletion = this._handleGuildDeletion.bind(this);
      this._handleMessageDeletion = this._handleMessageDeletion.bind(this);
      const bulkDeleteListener = (messages) => {
        if (messages.has(this.message.id))
          this.stop("messageDelete");
      };
      this.client.incrementMaxListeners();
      this.client.on(Events.MessageReactionAdd, this.handleCollect);
      this.client.on(Events.MessageReactionRemove, this.handleDispose);
      this.client.on(Events.MessageReactionRemoveAll, this.empty);
      this.client.on(Events.MessageDelete, this._handleMessageDeletion);
      this.client.on(Events.MessageBulkDelete, bulkDeleteListener);
      this.client.on(Events.ChannelDelete, this._handleChannelDeletion);
      this.client.on(Events.ThreadDelete, this._handleThreadDeletion);
      this.client.on(Events.GuildDelete, this._handleGuildDeletion);
      this.once("end", () => {
        this.client.removeListener(Events.MessageReactionAdd, this.handleCollect);
        this.client.removeListener(Events.MessageReactionRemove, this.handleDispose);
        this.client.removeListener(Events.MessageReactionRemoveAll, this.empty);
        this.client.removeListener(Events.MessageDelete, this._handleMessageDeletion);
        this.client.removeListener(Events.MessageBulkDelete, bulkDeleteListener);
        this.client.removeListener(Events.ChannelDelete, this._handleChannelDeletion);
        this.client.removeListener(Events.ThreadDelete, this._handleThreadDeletion);
        this.client.removeListener(Events.GuildDelete, this._handleGuildDeletion);
        this.client.decrementMaxListeners();
      });
      this.on("collect", (reaction, user) => {
        if (reaction.count === 1) {
          this.emit("create", reaction, user);
        }
        this.total++;
        this.users.set(user.id, user);
      });
      this.on("remove", (reaction, user) => {
        this.total--;
        if (!this.collected.some((r) => r.users.cache.has(user.id)))
          this.users.delete(user.id);
      });
    }
    collect(reaction) {
      if (reaction.message.id !== this.message.id)
        return null;
      return ReactionCollector.key(reaction);
    }
    dispose(reaction, user) {
      if (reaction.message.id !== this.message.id)
        return null;
      if (this.collected.has(ReactionCollector.key(reaction)) && this.users.has(user.id)) {
        this.emit("remove", reaction, user);
      }
      return reaction.count ? null : ReactionCollector.key(reaction);
    }
    empty() {
      this.total = 0;
      this.collected.clear();
      this.users.clear();
      this.checkEnd();
    }
    get endReason() {
      if (this.options.max && this.total >= this.options.max)
        return "limit";
      if (this.options.maxEmojis && this.collected.size >= this.options.maxEmojis)
        return "emojiLimit";
      if (this.options.maxUsers && this.users.size >= this.options.maxUsers)
        return "userLimit";
      return super.endReason;
    }
    _handleMessageDeletion(message) {
      if (message.id === this.message.id) {
        this.stop("messageDelete");
      }
    }
    _handleChannelDeletion(channel) {
      if (channel.id === this.message.channelId || channel.threads?.cache.has(this.message.channelId)) {
        this.stop("channelDelete");
      }
    }
    _handleThreadDeletion(thread) {
      if (thread.id === this.message.channelId) {
        this.stop("threadDelete");
      }
    }
    _handleGuildDeletion(guild) {
      if (guild.id === this.message.guild?.id) {
        this.stop("guildDelete");
      }
    }
    static key(reaction) {
      return reaction.emoji.id ?? reaction.emoji.name;
    }
  }
  module.exports = ReactionCollector;
});

// node_modules/discord.js/src/structures/Sticker.js
var require_Sticker = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var { Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { StickerFormatExtensionMap } = require_Constants();

  class Sticker extends Base {
    constructor(client, sticker) {
      super(client);
      this._patch(sticker);
    }
    _patch(sticker) {
      this.id = sticker.id;
      if ("description" in sticker) {
        this.description = sticker.description;
      } else {
        this.description ??= null;
      }
      if ("type" in sticker) {
        this.type = sticker.type;
      } else {
        this.type ??= null;
      }
      if ("format_type" in sticker) {
        this.format = sticker.format_type;
      }
      if ("name" in sticker) {
        this.name = sticker.name;
      }
      if ("pack_id" in sticker) {
        this.packId = sticker.pack_id;
      } else {
        this.packId ??= null;
      }
      if ("tags" in sticker) {
        this.tags = sticker.tags;
      } else {
        this.tags ??= null;
      }
      if ("available" in sticker) {
        this.available = sticker.available;
      } else {
        this.available ??= null;
      }
      if ("guild_id" in sticker) {
        this.guildId = sticker.guild_id;
      } else {
        this.guildId ??= null;
      }
      if ("user" in sticker) {
        this.user = this.client.users._add(sticker.user);
      } else {
        this.user ??= null;
      }
      if ("sort_value" in sticker) {
        this.sortValue = sticker.sort_value;
      } else {
        this.sortValue ??= null;
      }
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get partial() {
      return !this.type;
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get url() {
      return this.client.rest.cdn.sticker(this.id, StickerFormatExtensionMap[this.format]);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.sticker(this.id));
      this._patch(data);
      return this;
    }
    async fetchPack() {
      return (this.packId && (await this.client.fetchPremiumStickerPacks()).get(this.packId)) ?? null;
    }
    async fetchUser() {
      if (this.partial)
        await this.fetch();
      if (!this.guildId)
        throw new DiscordjsError(ErrorCodes.NotGuildSticker);
      return this.guild.stickers.fetchUser(this);
    }
    edit(options) {
      return this.guild.stickers.edit(this, options);
    }
    async delete(reason) {
      await this.guild.stickers.delete(this, reason);
      return this;
    }
    equals(other) {
      if (other instanceof Sticker) {
        return other.id === this.id && other.description === this.description && other.type === this.type && other.format === this.format && other.name === this.name && other.packId === this.packId && other.tags === this.tags && other.available === this.available && other.guildId === this.guildId && other.sortValue === this.sortValue;
      } else {
        return other.id === this.id && other.description === this.description && other.name === this.name && other.tags === this.tags;
      }
    }
  }
  exports.Sticker = Sticker;
});

// node_modules/discord.js/src/structures/BaseGuildEmoji.js
var require_BaseGuildEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();

  class BaseGuildEmoji extends Emoji {
    constructor(client, data, guild) {
      super(client, data);
      this.guild = guild;
      this.requiresColons = null;
      this.managed = null;
      this.available = null;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data)
        this.name = data.name;
      if ("require_colons" in data) {
        this.requiresColons = data.require_colons;
      }
      if ("managed" in data) {
        this.managed = data.managed;
      }
      if ("available" in data) {
        this.available = data.available;
      }
    }
  }
  module.exports = BaseGuildEmoji;
});

// node_modules/discord.js/src/managers/GuildEmojiRoleManager.js
var require_GuildEmojiRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildEmojiRoleManager extends DataManager {
    constructor(emoji) {
      super(emoji.client, Role);
      this.emoji = emoji;
      this.guild = emoji.guild;
    }
    get cache() {
      return this.guild.roles.cache.filter((role) => this.emoji._roles.includes(role.id));
    }
    add(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoles = [];
      for (const role of roleOrRoles.values()) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role));
        }
        resolvedRoles.push(resolvedRole);
      }
      const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
      return this.set(newRoles);
    }
    remove(roleOrRoles) {
      if (!Array.isArray(roleOrRoles) && !(roleOrRoles instanceof Collection))
        roleOrRoles = [roleOrRoles];
      const resolvedRoleIds = [];
      for (const role of roleOrRoles.values()) {
        const roleId = this.guild.roles.resolveId(role);
        if (!roleId) {
          return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role));
        }
        resolvedRoleIds.push(roleId);
      }
      const newRoles = [...this.cache.keys()].filter((id) => !resolvedRoleIds.includes(id));
      return this.set(newRoles);
    }
    set(roles) {
      return this.emoji.edit({ roles });
    }
    clone() {
      const clone = new this.constructor(this.emoji);
      clone._patch([...this.cache.keys()]);
      return clone;
    }
    _patch(roles) {
      this.emoji._roles = roles;
    }
    valueOf() {
      return this.cache;
    }
  }
  module.exports = GuildEmojiRoleManager;
});

// node_modules/discord.js/src/structures/GuildEmoji.js
var require_GuildEmoji = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildEmoji = require_BaseGuildEmoji();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildEmojiRoleManager = require_GuildEmojiRoleManager();

  class GuildEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.author = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      this._patch(data);
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    _patch(data) {
      super._patch(data);
      if (data.user)
        this.author = this.client.users._add(data.user);
      if (data.roles)
        this._roles = data.roles;
    }
    get deletable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return !this.managed && this.guild.members.me.permissions.has(PermissionFlagsBits.ManageGuildExpressions);
    }
    get roles() {
      return new GuildEmojiRoleManager(this);
    }
    fetchAuthor() {
      return this.guild.emojis.fetchAuthor(this);
    }
    edit(options) {
      return this.guild.emojis.edit(this.id, options);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    async delete(reason) {
      await this.guild.emojis.delete(this.id, reason);
      return this;
    }
    equals(other) {
      if (other instanceof GuildEmoji) {
        return other.id === this.id && other.name === this.name && other.managed === this.managed && other.available === this.available && other.requiresColons === this.requiresColons && other.roles.cache.size === this.roles.cache.size && other.roles.cache.every((role) => this.roles.cache.has(role.id));
      } else {
        return other.id === this.id && other.name === this.name && other.roles.length === this.roles.cache.size && other.roles.every((role) => this.roles.cache.has(role));
      }
    }
  }
  module.exports = GuildEmoji;
});

// node_modules/discord.js/src/structures/ReactionEmoji.js
var require_ReactionEmoji = __commonJS((exports, module) => {
  var { Emoji } = require_Emoji();
  var { flatten } = require_Util();

  class ReactionEmoji extends Emoji {
    constructor(reaction, emoji) {
      super(reaction.message.client, emoji);
      this.reaction = reaction;
    }
    toJSON() {
      return flatten(this, { identifier: true });
    }
    valueOf() {
      return this.id;
    }
  }
  module.exports = ReactionEmoji;
});

// node_modules/discord.js/src/util/UserFlagsBitField.js
var require_UserFlagsBitField = __commonJS((exports, module) => {
  var { UserFlags } = require_v106();
  var BitField = require_BitField();

  class UserFlagsBitField extends BitField {
    static Flags = UserFlags;
  }
  module.exports = UserFlagsBitField;
});

// node_modules/discord.js/src/structures/User.js
var require_User = __commonJS((exports, module) => {
  var { userMention } = require_dist10();
  var { calculateUserDefaultAvatarIndex } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var TextBasedChannel = require_TextBasedChannel();
  var UserFlagsBitField = require_UserFlagsBitField();

  class User extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.bot = null;
      this.system = null;
      this.flags = null;
      this._patch(data);
    }
    _patch(data) {
      if ("username" in data) {
        this.username = data.username;
      } else {
        this.username ??= null;
      }
      if ("global_name" in data) {
        this.globalName = data.global_name;
      } else {
        this.globalName ??= null;
      }
      if ("bot" in data) {
        this.bot = Boolean(data.bot);
      } else if (!this.partial && typeof this.bot !== "boolean") {
        this.bot = false;
      }
      if ("discriminator" in data) {
        this.discriminator = data.discriminator;
      } else {
        this.discriminator ??= null;
      }
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else {
        this.avatar ??= null;
      }
      if ("banner" in data) {
        this.banner = data.banner;
      } else if (this.banner !== null) {
        this.banner ??= undefined;
      }
      if ("accent_color" in data) {
        this.accentColor = data.accent_color;
      } else if (this.accentColor !== null) {
        this.accentColor ??= undefined;
      }
      if ("system" in data) {
        this.system = Boolean(data.system);
      } else if (!this.partial && typeof this.system !== "boolean") {
        this.system = false;
      }
      if ("public_flags" in data) {
        this.flags = new UserFlagsBitField(data.public_flags);
      }
      if ("avatar_decoration" in data) {
        this.avatarDecoration = data.avatar_decoration;
      } else {
        this.avatarDecoration ??= null;
      }
    }
    get partial() {
      return typeof this.username !== "string";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    avatarDecorationURL(options = {}) {
      return this.avatarDecoration && this.client.rest.cdn.avatarDecoration(this.id, this.avatarDecoration, options);
    }
    get defaultAvatarURL() {
      const index = this.discriminator === "0" ? calculateUserDefaultAvatarIndex(this.id) : this.discriminator % 5;
      return this.client.rest.cdn.defaultAvatar(index);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.defaultAvatarURL;
    }
    get hexAccentColor() {
      if (typeof this.accentColor !== "number")
        return this.accentColor;
      return `#${this.accentColor.toString(16).padStart(6, "0")}`;
    }
    bannerURL(options = {}) {
      return this.banner && this.client.rest.cdn.banner(this.id, this.banner, options);
    }
    get tag() {
      return typeof this.username === "string" ? this.discriminator === "0" ? this.username : `${this.username}#${this.discriminator}` : null;
    }
    get displayName() {
      return this.globalName ?? this.username;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    createDM(force = false) {
      return this.client.users.createDM(this.id, { force });
    }
    deleteDM() {
      return this.client.users.deleteDM(this.id);
    }
    equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.globalName && this.avatar === user.avatar && this.flags?.bitfield === user.flags?.bitfield && this.banner === user.banner && this.accentColor === user.accentColor;
    }
    _equals(user) {
      return user && this.id === user.id && this.username === user.username && this.discriminator === user.discriminator && this.globalName === user.global_name && this.avatar === user.avatar && this.flags?.bitfield === user.public_flags && ("banner" in user ? this.banner === user.banner : true) && ("accent_color" in user ? this.accentColor === user.accent_color : true);
    }
    fetchFlags(force = false) {
      return this.client.users.fetchFlags(this.id, { force });
    }
    fetch(force = true) {
      return this.client.users.fetch(this.id, { force });
    }
    toString() {
      return userMention(this.id);
    }
    toJSON(...props) {
      const json = super.toJSON({
        createdTimestamp: true,
        defaultAvatarURL: true,
        hexAccentColor: true,
        tag: true
      }, ...props);
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      json.bannerURL = this.banner ? this.bannerURL() : this.banner;
      return json;
    }
  }
  TextBasedChannel.applyToClass(User);
  module.exports = User;
});

// node_modules/discord.js/src/managers/ReactionUserManager.js
var require_ReactionUserManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var User = require_User();

  class ReactionUserManager extends CachedManager {
    constructor(reaction, iterable) {
      super(reaction.client, User, iterable);
      this.reaction = reaction;
    }
    async fetch({ limit = 100, after } = {}) {
      const message = this.reaction.message;
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.channelMessageReaction(message.channelId, message.id, this.reaction.emoji.identifier), { query });
      const users = new Collection;
      for (const rawUser of data) {
        const user = this.client.users._add(rawUser);
        this.cache.set(user.id, user);
        users.set(user.id, user);
      }
      return users;
    }
    async remove(user = this.client.user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsError(ErrorCodes.ReactionResolveUser);
      const message = this.reaction.message;
      const route = userId === this.client.user.id ? Routes.channelMessageOwnReaction(message.channelId, message.id, this.reaction.emoji.identifier) : Routes.channelMessageUserReaction(message.channelId, message.id, this.reaction.emoji.identifier, userId);
      await this.client.rest.delete(route);
      return this.reaction;
    }
  }
  module.exports = ReactionUserManager;
});

// node_modules/discord.js/src/structures/MessageReaction.js
var require_MessageReaction = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var ReactionUserManager = require_ReactionUserManager();
  var { flatten } = require_Util();

  class MessageReaction {
    constructor(client, data, message) {
      Object.defineProperty(this, "client", { value: client });
      this.message = message;
      this.me = data.me;
      this.users = new ReactionUserManager(this, this.me ? [client.user] : []);
      this._emoji = new ReactionEmoji(this, data.emoji);
      this._patch(data);
    }
    _patch(data) {
      if ("count" in data) {
        this.count ??= data.count;
      }
    }
    react() {
      return this.message.react(this.emoji);
    }
    async remove() {
      await this.client.rest.delete(Routes.channelMessageReaction(this.message.channelId, this.message.id, this._emoji.identifier));
      return this;
    }
    get emoji() {
      if (this._emoji instanceof GuildEmoji)
        return this._emoji;
      if (this._emoji.id) {
        const emojis = this.message.client.emojis.cache;
        if (emojis.has(this._emoji.id)) {
          const emoji = emojis.get(this._emoji.id);
          this._emoji = emoji;
          return emoji;
        }
      }
      return this._emoji;
    }
    get partial() {
      return this.count === null;
    }
    async fetch() {
      const message = await this.message.fetch();
      const existing = message.reactions.cache.get(this.emoji.id ?? this.emoji.name);
      this._patch(existing ?? { count: 0 });
      return this;
    }
    toJSON() {
      return flatten(this, { emoji: "emojiId", message: "messageId" });
    }
    valueOf() {
      return this._emoji.id ?? this._emoji.name;
    }
    _add(user) {
      if (this.partial)
        return;
      this.users.cache.set(user.id, user);
      if (!this.me || user.id !== this.message.client.user.id || this.count === 0)
        this.count++;
      this.me ||= user.id === this.message.client.user.id;
    }
    _remove(user) {
      if (this.partial)
        return;
      this.users.cache.delete(user.id);
      if (!this.me || user.id !== this.message.client.user.id)
        this.count--;
      if (user.id === this.message.client.user.id)
        this.me = false;
      if (this.count <= 0 && this.users.cache.size === 0) {
        this.message.reactions.cache.delete(this.emoji.id ?? this.emoji.name);
      }
    }
  }
  module.exports = MessageReaction;
});

// node_modules/discord.js/src/managers/ReactionManager.js
var require_ReactionManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var MessageReaction = require_MessageReaction();

  class ReactionManager extends CachedManager {
    constructor(message, iterable) {
      super(message.client, MessageReaction, iterable);
      this.message = message;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.emoji.id ?? data.emoji.name, extras: [this.message] });
    }
    async removeAll() {
      await this.client.rest.delete(Routes.channelMessageAllReactions(this.message.channelId, this.message.id));
      return this.message;
    }
  }
  module.exports = ReactionManager;
});

// node_modules/discord.js/src/structures/Message.js
var require_Message = __commonJS((exports) => {
  var { messageLink } = require_dist10();
  var { Collection } = require_dist2();
  var { DiscordSnowflake } = require_dist3();
  var {
    InteractionType,
    ChannelType,
    MessageType,
    MessageFlags,
    PermissionFlagsBits
  } = require_v106();
  var Attachment = require_Attachment();
  var Base = require_Base();
  var ClientApplication = require_ClientApplication();
  var Embed = require_Embed();
  var InteractionCollector = require_InteractionCollector();
  var Mentions = require_MessageMentions();
  var MessagePayload = require_MessagePayload();
  var ReactionCollector = require_ReactionCollector();
  var { Sticker } = require_Sticker();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ReactionManager = require_ReactionManager();
  var { createComponent } = require_Components();
  var { NonSystemMessageTypes, MaxBulkDeletableMessageAge, DeletableMessageTypes } = require_Constants();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();
  var { cleanContent, resolvePartialEmoji } = require_Util();

  class Message extends Base {
    constructor(client, data) {
      super(client);
      this.channelId = data.channel_id;
      this.guildId = data.guild_id ?? this.channel?.guild?.id ?? null;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      this.createdTimestamp = DiscordSnowflake.timestampFrom(this.id);
      if ("type" in data) {
        this.type = data.type;
        this.system = !NonSystemMessageTypes.includes(this.type);
      } else {
        this.system ??= null;
        this.type ??= null;
      }
      if ("content" in data) {
        this.content = data.content;
      } else {
        this.content ??= null;
      }
      if ("author" in data) {
        this.author = this.client.users._add(data.author, !data.webhook_id);
      } else {
        this.author ??= null;
      }
      if ("pinned" in data) {
        this.pinned = Boolean(data.pinned);
      } else {
        this.pinned ??= null;
      }
      if ("tts" in data) {
        this.tts = data.tts;
      } else {
        this.tts ??= null;
      }
      if ("nonce" in data) {
        this.nonce = data.nonce;
      } else {
        this.nonce ??= null;
      }
      if ("embeds" in data) {
        this.embeds = data.embeds.map((e) => new Embed(e));
      } else {
        this.embeds = this.embeds?.slice() ?? [];
      }
      if ("components" in data) {
        this.components = data.components.map((c) => createComponent(c));
      } else {
        this.components = this.components?.slice() ?? [];
      }
      if ("attachments" in data) {
        this.attachments = new Collection;
        if (data.attachments) {
          for (const attachment of data.attachments) {
            this.attachments.set(attachment.id, new Attachment(attachment));
          }
        }
      } else {
        this.attachments = new Collection(this.attachments);
      }
      if (("sticker_items" in data) || ("stickers" in data)) {
        this.stickers = new Collection((data.sticker_items ?? data.stickers)?.map((s) => [s.id, new Sticker(this.client, s)]));
      } else {
        this.stickers = new Collection(this.stickers);
      }
      if ("position" in data) {
        this.position = data.position;
      } else {
        this.position ??= null;
      }
      if ("role_subscription_data" in data) {
        this.roleSubscriptionData = {
          roleSubscriptionListingId: data.role_subscription_data.role_subscription_listing_id,
          tierName: data.role_subscription_data.tier_name,
          totalMonthsSubscribed: data.role_subscription_data.total_months_subscribed,
          isRenewal: data.role_subscription_data.is_renewal
        };
      } else {
        this.roleSubscriptionData ??= null;
      }
      if (data.edited_timestamp) {
        this.editedTimestamp = Date.parse(data.edited_timestamp);
      } else {
        this.editedTimestamp ??= null;
      }
      if ("reactions" in data) {
        this.reactions = new ReactionManager(this);
        if (data.reactions?.length > 0) {
          for (const reaction of data.reactions) {
            this.reactions._add(reaction);
          }
        }
      } else {
        this.reactions ??= new ReactionManager(this);
      }
      if (!this.mentions) {
        this.mentions = new Mentions(this, data.mentions, data.mention_roles, data.mention_everyone, data.mention_channels, data.referenced_message?.author);
      } else {
        this.mentions = new Mentions(this, data.mentions ?? this.mentions.users, data.mention_roles ?? this.mentions.roles, data.mention_everyone ?? this.mentions.everyone, data.mention_channels ?? this.mentions.crosspostedChannels, data.referenced_message?.author ?? this.mentions.repliedUser);
      }
      if ("webhook_id" in data) {
        this.webhookId = data.webhook_id;
      } else {
        this.webhookId ??= null;
      }
      if ("application" in data) {
        this.groupActivityApplication = new ClientApplication(this.client, data.application);
      } else {
        this.groupActivityApplication ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("activity" in data) {
        this.activity = {
          partyId: data.activity.party_id,
          type: data.activity.type
        };
      } else {
        this.activity ??= null;
      }
      if ("thread" in data) {
        this.client.channels._add(data.thread, this.guild);
      }
      if (this.member && data.member) {
        this.member._patch(data.member);
      } else if (data.member && this.guild && this.author) {
        this.guild.members._add(Object.assign(data.member, { user: this.author }));
      }
      if ("flags" in data) {
        this.flags = new MessageFlagsBitField(data.flags).freeze();
      } else {
        this.flags = new MessageFlagsBitField(this.flags).freeze();
      }
      if ("message_reference" in data) {
        this.reference = {
          channelId: data.message_reference.channel_id,
          guildId: data.message_reference.guild_id,
          messageId: data.message_reference.message_id
        };
      } else {
        this.reference ??= null;
      }
      if (data.referenced_message) {
        this.channel?.messages._add({ guild_id: data.message_reference?.guild_id, ...data.referenced_message });
      }
      if (data.interaction) {
        this.interaction = {
          id: data.interaction.id,
          type: data.interaction.type,
          commandName: data.interaction.name,
          user: this.client.users._add(data.interaction.user)
        };
      } else {
        this.interaction ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get partial() {
      return typeof this.content !== "string" || !this.author;
    }
    get member() {
      return this.guild?.members.resolve(this.author) ?? null;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get editedAt() {
      return this.editedTimestamp && new Date(this.editedTimestamp);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId) ?? this.channel?.guild ?? null;
    }
    get hasThread() {
      return this.flags.has(MessageFlags.HasThread);
    }
    get thread() {
      return this.channel?.threads?.resolve(this.id) ?? null;
    }
    get url() {
      return this.inGuild() ? messageLink(this.channelId, this.id, this.guildId) : messageLink(this.channelId, this.id);
    }
    get cleanContent() {
      return this.content != null ? cleanContent(this.content, this.channel) : null;
    }
    createReactionCollector(options = {}) {
      return new ReactionCollector(this, options);
    }
    awaitReactions(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createReactionCollector(options);
        collector.once("end", (reactions, reason) => {
          if (options.errors?.includes(reason))
            reject(reactions);
          else
            resolve(reactions);
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        message: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    get editable() {
      const precheck = Boolean(this.author.id === this.client.user.id && (!this.guild || this.channel?.viewable));
      if (this.channel?.isThread()) {
        if (this.channel.archived)
          return false;
        if (this.channel.locked) {
          const permissions = this.channel.permissionsFor(this.client.user);
          if (!permissions?.has(PermissionFlagsBits.ManageThreads, true))
            return false;
        }
      }
      return precheck;
    }
    get deletable() {
      if (!DeletableMessageTypes.includes(this.type))
        return false;
      if (!this.guild) {
        return this.author.id === this.client.user.id;
      }
      if (!this.channel?.viewable) {
        return false;
      }
      const permissions = this.channel?.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.type !== MessageType.AutoModerationAction && this.author.id === this.client.user.id || permissions.has(PermissionFlagsBits.ManageMessages, false) && !this.guild.members.me.isCommunicationDisabled();
    }
    get bulkDeletable() {
      return (this.inGuild() && Date.now() - this.createdTimestamp < MaxBulkDeletableMessageAge && this.deletable && this.channel?.permissionsFor(this.client.user).has(PermissionFlagsBits.ManageMessages, false)) ?? false;
    }
    get pinnable() {
      const { channel } = this;
      return Boolean(!this.system && (!this.guild || channel?.viewable && channel?.permissionsFor(this.client.user)?.has(PermissionFlagsBits.ManageMessages, false)));
    }
    async fetchReference() {
      if (!this.reference)
        throw new DiscordjsError(ErrorCodes.MessageReferenceMissing);
      const { channelId, messageId } = this.reference;
      const channel = this.client.channels.resolve(channelId);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const message = await channel.messages.fetch(messageId);
      return message;
    }
    get crosspostable() {
      const bitfield = PermissionFlagsBits.SendMessages | (this.author.id === this.client.user.id ? PermissionsBitField.DefaultBit : PermissionFlagsBits.ManageMessages);
      const { channel } = this;
      return Boolean(channel?.type === ChannelType.GuildAnnouncement && !this.flags.has(MessageFlags.Crossposted) && this.type === MessageType.Default && channel.viewable && channel.permissionsFor(this.client.user)?.has(bitfield, false));
    }
    edit(options) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.edit(this, options);
    }
    crosspost() {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.crosspost(this.id);
    }
    async pin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.pin(this.id, reason);
      return this;
    }
    async unpin(reason) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.unpin(this.id, reason);
      return this;
    }
    async react(emoji) {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.react(this.id, emoji);
      return this.client.actions.MessageReactionAdd.handle({
        [this.client.actions.injectedUser]: this.client.user,
        [this.client.actions.injectedChannel]: this.channel,
        [this.client.actions.injectedMessage]: this,
        emoji: resolvePartialEmoji(emoji)
      }, true).reaction;
    }
    async delete() {
      if (!this.channel)
        throw new DiscordjsError(ErrorCodes.ChannelNotCached);
      await this.channel.messages.delete(this.id);
      return this;
    }
    reply(options) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      let data;
      if (options instanceof MessagePayload) {
        data = options;
      } else {
        data = MessagePayload.create(this, options, {
          reply: {
            messageReference: this,
            failIfNotExists: options?.failIfNotExists ?? this.client.options.failIfNotExists
          }
        });
      }
      return this.channel.send(data);
    }
    startThread(options = {}) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      if (![ChannelType.GuildText, ChannelType.GuildAnnouncement].includes(this.channel.type)) {
        return Promise.reject(new DiscordjsError(ErrorCodes.MessageThreadParent));
      }
      if (this.hasThread)
        return Promise.reject(new DiscordjsError(ErrorCodes.MessageExistingThread));
      return this.channel.threads.create({ ...options, startMessage: this });
    }
    fetch(force = true) {
      if (!this.channel)
        return Promise.reject(new DiscordjsError(ErrorCodes.ChannelNotCached));
      return this.channel.messages.fetch({ message: this.id, force });
    }
    fetchWebhook() {
      if (!this.webhookId)
        return Promise.reject(new DiscordjsError(ErrorCodes.WebhookMessage));
      if (this.webhookId === this.applicationId)
        return Promise.reject(new DiscordjsError(ErrorCodes.WebhookApplication));
      return this.client.fetchWebhook(this.webhookId);
    }
    suppressEmbeds(suppress = true) {
      const flags = new MessageFlagsBitField(this.flags.bitfield);
      if (suppress) {
        flags.add(MessageFlags.SuppressEmbeds);
      } else {
        flags.remove(MessageFlags.SuppressEmbeds);
      }
      return this.edit({ flags });
    }
    removeAttachments() {
      return this.edit({ attachments: [] });
    }
    resolveComponent(customId) {
      return this.components.flatMap((row) => row.components).find((component) => component.customId === customId) ?? null;
    }
    equals(message, rawData) {
      if (!message)
        return false;
      const embedUpdate = !message.author && !message.attachments;
      if (embedUpdate)
        return this.id === message.id && this.embeds.length === message.embeds.length;
      let equal = this.id === message.id && this.author.id === message.author.id && this.content === message.content && this.tts === message.tts && this.nonce === message.nonce && this.embeds.length === message.embeds.length && this.attachments.length === message.attachments.length;
      if (equal && rawData) {
        equal = this.mentions.everyone === message.mentions.everyone && this.createdTimestamp === Date.parse(rawData.timestamp) && this.editedTimestamp === Date.parse(rawData.edited_timestamp);
      }
      return equal;
    }
    inGuild() {
      return Boolean(this.guildId);
    }
    toString() {
      return this.content;
    }
    toJSON() {
      return super.toJSON({
        channel: "channelId",
        author: "authorId",
        groupActivityApplication: "groupActivityApplicationId",
        guild: "guildId",
        cleanContent: true,
        member: false,
        reactions: false
      });
    }
  }
  exports.Message = Message;
});

// node_modules/discord.js/src/structures/Webhook.js
var require_Webhook = __commonJS((exports, module) => {
  var { makeURLSearchParams } = require_dist7();
  var { lazy } = require_dist();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, WebhookType } = require_v106();
  var MessagePayload = require_MessagePayload();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();
  var getMessage = lazy(() => require_Message().Message);

  class Webhook {
    constructor(client, data) {
      Object.defineProperty(this, "client", { value: client });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      Object.defineProperty(this, "token", {
        value: data.token ?? null,
        writable: true,
        configurable: true
      });
      if ("avatar" in data) {
        this.avatar = data.avatar;
      }
      this.id = data.id;
      if ("type" in data) {
        this.type = data.type;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("user" in data) {
        this.owner = this.client.users?._add(data.user) ?? data.user;
      } else {
        this.owner ??= null;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      } else {
        this.applicationId ??= null;
      }
      if ("source_guild" in data) {
        this.sourceGuild = this.client.guilds?.resolve(data.source_guild.id) ?? data.source_guild;
      } else {
        this.sourceGuild ??= null;
      }
      if ("source_channel" in data) {
        this.sourceChannel = this.client.channels?.resolve(data.source_channel?.id) ?? data.source_channel;
      } else {
        this.sourceChannel ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    async send(options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const query = makeURLSearchParams({
        wait: true,
        thread_id: messagePayload.options.threadId
      });
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.webhook(this.id, this.token), {
        body,
        files,
        query,
        auth: false
      });
      if (!this.client.channels)
        return d;
      return this.client.channels.cache.get(d.channel_id)?.messages._add(d, false) ?? new (getMessage())(this.client, d);
    }
    async sendSlackMessage(body) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.post(Routes.webhookPlatform(this.id, this.token, "slack"), {
        query: makeURLSearchParams({ wait: true }),
        auth: false,
        body
      });
      return data.toString() === "ok";
    }
    async edit({ name = this.name, avatar, channel, reason }) {
      if (avatar && !(typeof avatar === "string" && avatar.startsWith("data:"))) {
        avatar = await DataResolver.resolveImage(avatar);
      }
      channel &&= channel.id ?? channel;
      const data = await this.client.rest.patch(Routes.webhook(this.id, channel ? undefined : this.token), {
        body: { name, avatar, channel_id: channel },
        reason,
        auth: !this.token || Boolean(channel)
      });
      this.name = data.name;
      this.avatar = data.avatar;
      this.channelId = data.channel_id;
      return this;
    }
    async fetchMessage(message, { threadId } = {}) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      const data = await this.client.rest.get(Routes.webhookMessage(this.id, this.token, message), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
      if (!this.client.channels)
        return data;
      return this.client.channels.cache.get(data.channel_id)?.messages._add(data, false) ?? new (getMessage())(this.client, data);
    }
    async editMessage(message, options) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body, files } = await messagePayload.resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        body,
        files,
        query: messagePayload.options.threadId ? makeURLSearchParams({ thread_id: messagePayload.options.threadId }) : undefined,
        auth: false
      });
      const channelManager = this.client.channels;
      if (!channelManager)
        return d;
      const messageManager = channelManager.cache.get(d.channel_id)?.messages;
      if (!messageManager)
        return new (getMessage())(this.client, d);
      const existing = messageManager.cache.get(d.id);
      if (!existing)
        return messageManager._add(d);
      const clone = existing._clone();
      clone._patch(d);
      return clone;
    }
    delete(reason) {
      return this.client.deleteWebhook(this.id, { token: this.token, reason });
    }
    async deleteMessage(message, threadId) {
      if (!this.token)
        throw new DiscordjsError(ErrorCodes.WebhookTokenUnavailable);
      await this.client.rest.delete(Routes.webhookMessage(this.id, this.token, typeof message === "string" ? message : message.id), {
        query: threadId ? makeURLSearchParams({ thread_id: threadId }) : undefined,
        auth: false
      });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get url() {
      return this.client.options.rest.api + Routes.webhook(this.id, this.token);
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.avatar(this.id, this.avatar, options);
    }
    isUserCreated() {
      return Boolean(this.type === WebhookType.Incoming && this.owner && !this.owner.bot);
    }
    isApplicationCreated() {
      return this.type === WebhookType.Application;
    }
    isChannelFollower() {
      return this.type === WebhookType.ChannelFollower;
    }
    isIncoming() {
      return this.type === WebhookType.Incoming;
    }
    static applyToClass(structure, ignore = []) {
      for (const prop of [
        "send",
        "sendSlackMessage",
        "fetchMessage",
        "edit",
        "editMessage",
        "delete",
        "deleteMessage",
        "createdTimestamp",
        "createdAt",
        "url"
      ]) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(Webhook.prototype, prop));
      }
    }
  }
  module.exports = Webhook;
});

// node_modules/discord.js/src/client/WebhookClient.js
var require_WebhookClient = __commonJS((exports, module) => {
  var BaseClient = require_BaseClient();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Webhook = require_Webhook();
  var { parseWebhookURL } = require_Util();

  class WebhookClient extends BaseClient {
    constructor(data, options) {
      super(options);
      Object.defineProperty(this, "client", { value: this });
      let { id, token } = data;
      if ("url" in data) {
        const parsed = parseWebhookURL(data.url);
        if (!parsed) {
          throw new DiscordjsError(ErrorCodes.WebhookURLInvalid);
        }
        ({ id, token } = parsed);
      }
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    sendSlackMessage() {
    }
    edit() {
    }
    delete() {
    }
    deleteMessage() {
    }
    get createdTimestamp() {
    }
    get createdAt() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(WebhookClient);
  module.exports = WebhookClient;
});

// node_modules/discord.js/src/structures/VoiceState.js
var require_VoiceState = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var Base = require_Base();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();

  class VoiceState extends Base {
    constructor(guild, data) {
      super(guild.client);
      this.guild = guild;
      this.id = data.user_id;
      this._patch(data);
    }
    _patch(data) {
      if ("deaf" in data) {
        this.serverDeaf = data.deaf;
      } else {
        this.serverDeaf ??= null;
      }
      if ("mute" in data) {
        this.serverMute = data.mute;
      } else {
        this.serverMute ??= null;
      }
      if ("self_deaf" in data) {
        this.selfDeaf = data.self_deaf;
      } else {
        this.selfDeaf ??= null;
      }
      if ("self_mute" in data) {
        this.selfMute = data.self_mute;
      } else {
        this.selfMute ??= null;
      }
      if ("self_video" in data) {
        this.selfVideo = data.self_video;
      } else {
        this.selfVideo ??= null;
      }
      if ("session_id" in data) {
        this.sessionId = data.session_id;
      } else {
        this.sessionId ??= null;
      }
      if ("self_video" in data) {
        this.streaming = data.self_stream ?? false;
      } else {
        this.streaming ??= null;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      } else {
        this.channelId ??= null;
      }
      if ("suppress" in data) {
        this.suppress = data.suppress;
      } else {
        this.suppress ??= null;
      }
      if ("request_to_speak_timestamp" in data) {
        this.requestToSpeakTimestamp = data.request_to_speak_timestamp && Date.parse(data.request_to_speak_timestamp);
      } else {
        this.requestToSpeakTimestamp ??= null;
      }
      return this;
    }
    get member() {
      return this.guild.members.cache.get(this.id) ?? null;
    }
    get channel() {
      return this.guild.channels.cache.get(this.channelId) ?? null;
    }
    get deaf() {
      return this.serverDeaf || this.selfDeaf;
    }
    get mute() {
      return this.serverMute || this.selfMute;
    }
    setMute(mute = true, reason) {
      return this.guild.members.edit(this.id, { mute, reason });
    }
    setDeaf(deaf = true, reason) {
      return this.guild.members.edit(this.id, { deaf, reason });
    }
    disconnect(reason) {
      return this.setChannel(null, reason);
    }
    setChannel(channel, reason) {
      return this.guild.members.edit(this.id, { channel, reason });
    }
    async edit(options) {
      if (this.channel?.type !== ChannelType.GuildStageVoice)
        throw new DiscordjsError(ErrorCodes.VoiceNotStageChannel);
      const target = this.client.user.id === this.id ? "@me" : this.id;
      if (target !== "@me" && options.requestToSpeak !== undefined) {
        throw new DiscordjsError(ErrorCodes.VoiceStateNotOwn);
      }
      if (!["boolean", "undefined"].includes(typeof options.requestToSpeak)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "requestToSpeak");
      }
      if (!["boolean", "undefined"].includes(typeof options.suppressed)) {
        throw new DiscordjsTypeError(ErrorCodes.VoiceStateInvalidType, "suppressed");
      }
      await this.client.rest.patch(Routes.guildVoiceState(this.guild.id, target), {
        body: {
          channel_id: this.channelId,
          request_to_speak_timestamp: options.requestToSpeak ? new Date().toISOString() : options.requestToSpeak === false ? null : undefined,
          suppress: options.suppressed
        }
      });
      return this;
    }
    setRequestToSpeak(requestToSpeak = true) {
      return this.edit({ requestToSpeak });
    }
    setSuppressed(suppressed = true) {
      return this.edit({ suppressed });
    }
    toJSON() {
      return super.toJSON({
        id: true,
        serverDeaf: true,
        serverMute: true,
        selfDeaf: true,
        selfMute: true,
        sessionId: true,
        channelId: "channel"
      });
    }
  }
  module.exports = VoiceState;
});

// node_modules/discord.js/src/managers/GuildMemberRoleManager.js
var require_GuildMemberRoleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var DataManager = require_DataManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();

  class GuildMemberRoleManager extends DataManager {
    constructor(member) {
      super(member.client, Role);
      this.member = member;
      this.guild = member.guild;
    }
    get cache() {
      const everyone = this.guild.roles.everyone;
      return this.guild.roles.cache.filter((role) => this.member._roles.includes(role.id)).set(everyone.id, everyone);
    }
    get hoist() {
      const hoistedRoles = this.cache.filter((role) => role.hoist);
      if (!hoistedRoles.size)
        return null;
      return hoistedRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get icon() {
      const iconRoles = this.cache.filter((role) => role.icon || role.unicodeEmoji);
      if (!iconRoles.size)
        return null;
      return iconRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get color() {
      const coloredRoles = this.cache.filter((role) => role.color);
      if (!coloredRoles.size)
        return null;
      return coloredRoles.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev);
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get botRole() {
      if (!this.member.user.bot)
        return null;
      return this.cache.find((role) => role.tags?.botId === this.member.user.id) ?? null;
    }
    async add(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = [...new Set(resolvedRoles.concat(...this.cache.keys()))];
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.put(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        clone._roles = [...this.cache.keys(), roleOrRoles];
        return clone;
      }
    }
    async remove(roleOrRoles, reason) {
      if (roleOrRoles instanceof Collection || Array.isArray(roleOrRoles)) {
        const resolvedRoles = [];
        for (const role of roleOrRoles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        const newRoles = this.cache.filter((role) => !resolvedRoles.includes(role.id));
        return this.set(newRoles, reason);
      } else {
        roleOrRoles = this.guild.roles.resolveId(roleOrRoles);
        if (roleOrRoles === null) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "roles", "Role, Snowflake or Array or Collection of Roles or Snowflakes");
        }
        await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, this.member.id, roleOrRoles), { reason });
        const clone = this.member._clone();
        const newRoles = this.cache.filter((role) => role.id !== roleOrRoles);
        clone._roles = [...newRoles.keys()];
        return clone;
      }
    }
    set(roles, reason) {
      return this.member.edit({ roles, reason });
    }
    clone() {
      const clone = new this.constructor(this.member);
      clone.member._roles = [...this.cache.keys()];
      return clone;
    }
  }
  module.exports = GuildMemberRoleManager;
});

// node_modules/discord.js/src/util/GuildMemberFlagsBitField.js
var require_GuildMemberFlagsBitField = __commonJS((exports) => {
  var { GuildMemberFlags } = require_v106();
  var BitField = require_BitField();

  class GuildMemberFlagsBitField extends BitField {
    static Flags = GuildMemberFlags;
  }
  exports.GuildMemberFlagsBitField = GuildMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/GuildMember.js
var require_GuildMember = __commonJS((exports) => {
  var { PermissionFlagsBits } = require_v106();
  var Base = require_Base();
  var VoiceState = require_VoiceState();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var GuildMemberRoleManager = require_GuildMemberRoleManager();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var PermissionsBitField = require_PermissionsBitField();

  class GuildMember extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.joinedTimestamp = null;
      this.premiumSinceTimestamp = null;
      this.nickname = null;
      this.pending = null;
      this.communicationDisabledUntilTimestamp = null;
      Object.defineProperty(this, "_roles", { value: [], writable: true });
      if (data)
        this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("nick" in data)
        this.nickname = data.nick;
      if ("avatar" in data) {
        this.avatar = data.avatar;
      } else if (typeof this.avatar !== "string") {
        this.avatar = null;
      }
      if ("joined_at" in data)
        this.joinedTimestamp = Date.parse(data.joined_at);
      if ("premium_since" in data) {
        this.premiumSinceTimestamp = data.premium_since ? Date.parse(data.premium_since) : null;
      }
      if ("roles" in data)
        this._roles = data.roles;
      if ("pending" in data) {
        this.pending = data.pending;
      } else if (!this.partial) {
        this.pending ??= false;
      }
      if ("communication_disabled_until" in data) {
        this.communicationDisabledUntilTimestamp = data.communication_disabled_until && Date.parse(data.communication_disabled_until);
      }
      if ("flags" in data) {
        this.flags = new GuildMemberFlagsBitField(data.flags).freeze();
      } else {
        this.flags ??= new GuildMemberFlagsBitField().freeze();
      }
    }
    _clone() {
      const clone = super._clone();
      clone._roles = this._roles.slice();
      return clone;
    }
    get partial() {
      return this.joinedTimestamp === null;
    }
    get roles() {
      return new GuildMemberRoleManager(this);
    }
    get voice() {
      return this.guild.voiceStates.cache.get(this.id) ?? new VoiceState(this.guild, { user_id: this.id });
    }
    avatarURL(options = {}) {
      return this.avatar && this.client.rest.cdn.guildMemberAvatar(this.guild.id, this.id, this.avatar, options);
    }
    displayAvatarURL(options) {
      return this.avatarURL(options) ?? this.user.displayAvatarURL(options);
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get communicationDisabledUntil() {
      return this.communicationDisabledUntilTimestamp && new Date(this.communicationDisabledUntilTimestamp);
    }
    get premiumSince() {
      return this.premiumSinceTimestamp && new Date(this.premiumSinceTimestamp);
    }
    get presence() {
      return this.guild.presences.resolve(this.id);
    }
    get displayColor() {
      return this.roles.color?.color ?? 0;
    }
    get displayHexColor() {
      return this.roles.color?.hexColor ?? "#000000";
    }
    get id() {
      return this.user.id;
    }
    get dmChannel() {
      return this.client.users.dmChannel(this.id);
    }
    get displayName() {
      return this.nickname ?? this.user.displayName;
    }
    get permissions() {
      if (this.user.id === this.guild.ownerId)
        return new PermissionsBitField(PermissionsBitField.All).freeze();
      return new PermissionsBitField(this.roles.cache.map((role) => role.permissions)).freeze();
    }
    get manageable() {
      if (this.user.id === this.guild.ownerId)
        return false;
      if (this.user.id === this.client.user.id)
        return false;
      if (this.client.user.id === this.guild.ownerId)
        return true;
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.guild.members.me.roles.highest.comparePositionTo(this.roles.highest) > 0;
    }
    get kickable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.KickMembers);
    }
    get bannable() {
      if (!this.guild.members.me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      return this.manageable && this.guild.members.me.permissions.has(PermissionFlagsBits.BanMembers);
    }
    get moderatable() {
      return !this.permissions.has(PermissionFlagsBits.Administrator) && this.manageable && (this.guild.members.me?.permissions.has(PermissionFlagsBits.ModerateMembers) ?? false);
    }
    isCommunicationDisabled() {
      return this.communicationDisabledUntilTimestamp > Date.now();
    }
    permissionsIn(channel) {
      channel = this.guild.channels.resolve(channel);
      if (!channel)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      return channel.permissionsFor(this);
    }
    edit(options) {
      return this.guild.members.edit(this, options);
    }
    setFlags(flags, reason) {
      return this.edit({ flags, reason });
    }
    setNickname(nick, reason) {
      return this.edit({ nick, reason });
    }
    createDM(force = false) {
      return this.user.createDM(force);
    }
    deleteDM() {
      return this.user.deleteDM();
    }
    kick(reason) {
      return this.guild.members.kick(this, reason);
    }
    ban(options) {
      return this.guild.bans.create(this, options);
    }
    disableCommunicationUntil(communicationDisabledUntil, reason) {
      return this.edit({ communicationDisabledUntil, reason });
    }
    timeout(timeout, reason) {
      return this.disableCommunicationUntil(timeout && Date.now() + timeout, reason);
    }
    fetch(force = true) {
      return this.guild.members.fetch({ user: this.id, cache: true, force });
    }
    equals(member) {
      return member instanceof this.constructor && this.id === member.id && this.partial === member.partial && this.guild.id === member.guild.id && this.joinedTimestamp === member.joinedTimestamp && this.nickname === member.nickname && this.avatar === member.avatar && this.pending === member.pending && this.communicationDisabledUntilTimestamp === member.communicationDisabledUntilTimestamp && this.flags.bitfield === member.flags.bitfield && (this._roles === member._roles || this._roles.length === member._roles.length && this._roles.every((role, i) => role === member._roles[i]));
    }
    toString() {
      return this.user.toString();
    }
    toJSON() {
      const json = super.toJSON({
        guild: "guildId",
        user: "userId",
        displayName: true,
        roles: true
      });
      json.avatarURL = this.avatarURL();
      json.displayAvatarURL = this.displayAvatarURL();
      return json;
    }
  }
  TextBasedChannel.applyToClass(GuildMember);
  exports.GuildMember = GuildMember;
});

// node_modules/discord.js/src/managers/MessageManager.js
var require_MessageManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Message } = require_Message();
  var MessagePayload = require_MessagePayload();
  var { MakeCacheOverrideSymbol } = require_Symbols();
  var { resolvePartialEmoji } = require_Util();

  class MessageManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = MessageManager;
    constructor(channel, iterable) {
      super(channel.client, Message, iterable);
      this.channel = channel;
    }
    _add(data, cache) {
      return super._add(data, cache);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { message, cache, force } = options;
      const resolvedMessage = this.resolveId(message ?? options);
      if (resolvedMessage)
        return this._fetchSingle({ message: resolvedMessage, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ message, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(message);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channelMessage(this.channel.id, message));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.channelMessages(this.channel.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((_data, message) => _data.set(message.id, this._add(message, options.cache)), new Collection);
    }
    async fetchPinned(cache = true) {
      const data = await this.client.rest.get(Routes.channelPins(this.channel.id));
      const messages = new Collection;
      for (const message of data)
        messages.set(message.id, this._add(message, cache));
      return messages;
    }
    async edit(message, options) {
      const messageId = this.resolveId(message);
      if (!messageId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const { body, files } = await (options instanceof MessagePayload ? options : MessagePayload.create(message instanceof Message ? message : this, options)).resolveBody().resolveFiles();
      const d = await this.client.rest.patch(Routes.channelMessage(this.channel.id, messageId), { body, files });
      const existing = this.cache.get(messageId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async crosspost(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      const data = await this.client.rest.post(Routes.channelMessageCrosspost(this.channel.id, message));
      return this.cache.get(data.id) ?? this._add(data);
    }
    async pin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.put(Routes.channelPin(this.channel.id, message), { reason });
    }
    async unpin(message, reason) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelPin(this.channel.id, message), { reason });
    }
    async react(message, emoji) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      emoji = resolvePartialEmoji(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.EmojiType, "emoji", "EmojiIdentifierResolvable");
      const emojiId = emoji.id ? `${emoji.animated ? "a:" : ""}${emoji.name}:${emoji.id}` : encodeURIComponent(emoji.name);
      await this.client.rest.put(Routes.channelMessageOwnReaction(this.channel.id, message, emojiId));
    }
    async delete(message) {
      message = this.resolveId(message);
      if (!message)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "message", "MessageResolvable");
      await this.client.rest.delete(Routes.channelMessage(this.channel.id, message));
    }
  }
  module.exports = MessageManager;
});

// node_modules/discord.js/src/structures/InteractionWebhook.js
var require_InteractionWebhook = __commonJS((exports, module) => {
  var Webhook = require_Webhook();

  class InteractionWebhook {
    constructor(client, id, token) {
      Object.defineProperty(this, "client", { value: client });
      this.id = id;
      Object.defineProperty(this, "token", { value: token, writable: true, configurable: true });
    }
    send() {
    }
    fetchMessage() {
    }
    editMessage() {
    }
    deleteMessage() {
    }
    get url() {
    }
  }
  Webhook.applyToClass(InteractionWebhook, ["sendSlackMessage", "edit", "delete", "createdTimestamp", "createdAt"]);
  module.exports = InteractionWebhook;
});

// node_modules/discord.js/src/structures/MessagePayload.js
var require_MessagePayload = __commonJS((exports, module) => {
  var { Buffer: Buffer2 } = __require("node:buffer");
  var { lazy, isJSONEncodable } = require_dist();
  var { MessageFlags } = require_v106();
  var ActionRowBuilder = require_ActionRowBuilder();
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();
  var MessageFlagsBitField = require_MessageFlagsBitField();
  var { basename, verifyString } = require_Util();
  var getBaseInteraction = lazy(() => require_BaseInteraction());

  class MessagePayload {
    constructor(target, options) {
      this.target = target;
      this.options = options;
      this.body = null;
      this.files = null;
    }
    get isWebhook() {
      const Webhook = require_Webhook();
      const WebhookClient = require_WebhookClient();
      return this.target instanceof Webhook || this.target instanceof WebhookClient;
    }
    get isUser() {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      return this.target instanceof User || this.target instanceof GuildMember;
    }
    get isMessage() {
      const { Message } = require_Message();
      return this.target instanceof Message;
    }
    get isMessageManager() {
      const MessageManager = require_MessageManager();
      return this.target instanceof MessageManager;
    }
    get isInteraction() {
      const BaseInteraction = getBaseInteraction();
      const InteractionWebhook = require_InteractionWebhook();
      return this.target instanceof BaseInteraction || this.target instanceof InteractionWebhook;
    }
    makeContent() {
      let content;
      if (this.options.content === null) {
        content = "";
      } else if (this.options.content !== undefined) {
        content = verifyString(this.options.content, DiscordjsRangeError, ErrorCodes.MessageContentType, true);
      }
      return content;
    }
    resolveBody() {
      if (this.body)
        return this;
      const isInteraction = this.isInteraction;
      const isWebhook = this.isWebhook;
      const content = this.makeContent();
      const tts = Boolean(this.options.tts);
      let nonce;
      if (this.options.nonce !== undefined) {
        nonce = this.options.nonce;
        if (typeof nonce === "number" ? !Number.isInteger(nonce) : typeof nonce !== "string") {
          throw new DiscordjsRangeError(ErrorCodes.MessageNonceType);
        }
      }
      const components = this.options.components?.map((c) => (isJSONEncodable(c) ? c : new ActionRowBuilder(c)).toJSON());
      let username;
      let avatarURL;
      let threadName;
      if (isWebhook) {
        username = this.options.username ?? this.target.name;
        if (this.options.avatarURL)
          avatarURL = this.options.avatarURL;
        if (this.options.threadName)
          threadName = this.options.threadName;
      }
      let flags;
      if (this.options.flags !== undefined || this.isMessage && this.options.reply === undefined || this.isMessageManager) {
        flags = this.options.flags != null ? new MessageFlagsBitField(this.options.flags).bitfield : this.target.flags?.bitfield;
      }
      if (isInteraction && this.options.ephemeral) {
        flags |= MessageFlags.Ephemeral;
      }
      let allowedMentions = this.options.allowedMentions === undefined ? this.target.client.options.allowedMentions : this.options.allowedMentions;
      if (allowedMentions?.repliedUser !== undefined) {
        allowedMentions = { ...allowedMentions, replied_user: allowedMentions.repliedUser };
        delete allowedMentions.repliedUser;
      }
      let message_reference;
      if (typeof this.options.reply === "object") {
        const reference = this.options.reply.messageReference;
        const message_id = this.isMessage ? reference.id ?? reference : this.target.messages.resolveId(reference);
        if (message_id) {
          message_reference = {
            message_id,
            fail_if_not_exists: this.options.reply.failIfNotExists ?? this.target.client.options.failIfNotExists
          };
        }
      }
      const attachments = this.options.files?.map((file, index) => ({
        id: index.toString(),
        description: file.description
      }));
      if (Array.isArray(this.options.attachments)) {
        this.options.attachments.push(...attachments ?? []);
      } else {
        this.options.attachments = attachments;
      }
      this.body = {
        content,
        tts,
        nonce,
        embeds: this.options.embeds?.map((embed) => isJSONEncodable(embed) ? embed.toJSON() : this.target.client.options.jsonTransformer(embed)),
        components,
        username,
        avatar_url: avatarURL,
        allowed_mentions: content === undefined && message_reference === undefined ? undefined : allowedMentions,
        flags,
        message_reference,
        attachments: this.options.attachments,
        sticker_ids: this.options.stickers?.map((sticker) => sticker.id ?? sticker),
        thread_name: threadName
      };
      return this;
    }
    async resolveFiles() {
      if (this.files)
        return this;
      this.files = await Promise.all(this.options.files?.map((file) => this.constructor.resolveFile(file)) ?? []);
      return this;
    }
    static async resolveFile(fileLike) {
      let attachment;
      let name;
      const findName = (thing) => {
        if (typeof thing === "string") {
          return basename(thing);
        }
        if (thing.path) {
          return basename(thing.path);
        }
        return "file.jpg";
      };
      const ownAttachment = typeof fileLike === "string" || fileLike instanceof Buffer2 || typeof fileLike.pipe === "function";
      if (ownAttachment) {
        attachment = fileLike;
        name = findName(attachment);
      } else {
        attachment = fileLike.attachment;
        name = fileLike.name ?? findName(attachment);
      }
      const { data, contentType } = await DataResolver.resolveFile(attachment);
      return { data, name, contentType };
    }
    static create(target, options, extra = {}) {
      return new this(target, typeof options !== "object" || options === null ? { content: options, ...extra } : { ...options, ...extra });
    }
  }
  module.exports = MessagePayload;
});

// node_modules/discord.js/src/managers/GuildMessageManager.js
var require_GuildMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class GuildMessageManager extends MessageManager {
  }
  module.exports = GuildMessageManager;
});

// node_modules/discord.js/src/structures/interfaces/TextBasedChannel.js
var require_TextBasedChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType, Routes } = require_v106();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { MaxBulkDeletableMessageAge } = require_Constants();
  var InteractionCollector = require_InteractionCollector();
  var MessageCollector = require_MessageCollector();
  var MessagePayload = require_MessagePayload();

  class TextBasedChannel {
    constructor() {
      this.messages = new GuildMessageManager(this);
      this.lastMessageId = null;
      this.lastPinTimestamp = null;
    }
    get lastMessage() {
      return this.messages.resolve(this.lastMessageId);
    }
    get lastPinAt() {
      return this.lastPinTimestamp && new Date(this.lastPinTimestamp);
    }
    async send(options) {
      const User = require_User();
      const { GuildMember } = require_GuildMember();
      if (this instanceof User || this instanceof GuildMember) {
        const dm = await this.createDM();
        return dm.send(options);
      }
      let messagePayload;
      if (options instanceof MessagePayload) {
        messagePayload = options.resolveBody();
      } else {
        messagePayload = MessagePayload.create(this, options).resolveBody();
      }
      const { body, files } = await messagePayload.resolveFiles();
      const d = await this.client.rest.post(Routes.channelMessages(this.id), { body, files });
      return this.messages.cache.get(d.id) ?? this.messages._add(d);
    }
    async sendTyping() {
      await this.client.rest.post(Routes.channelTyping(this.id));
    }
    createMessageCollector(options = {}) {
      return new MessageCollector(this, options);
    }
    awaitMessages(options = {}) {
      return new Promise((resolve, reject) => {
        const collector = this.createMessageCollector(options);
        collector.once("end", (collection, reason) => {
          if (options.errors?.includes(reason)) {
            reject(collection);
          } else {
            resolve(collection);
          }
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionType: InteractionType.MessageComponent,
        channel: this
      });
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    async bulkDelete(messages, filterOld = false) {
      if (Array.isArray(messages) || messages instanceof Collection) {
        let messageIds = messages instanceof Collection ? [...messages.keys()] : messages.map((m) => m.id ?? m);
        if (filterOld) {
          messageIds = messageIds.filter((id) => Date.now() - DiscordSnowflake.timestampFrom(id) < MaxBulkDeletableMessageAge);
        }
        if (messageIds.length === 0)
          return new Collection;
        if (messageIds.length === 1) {
          const message = this.client.actions.MessageDelete.getMessage({
            message_id: messageIds[0]
          }, this);
          await this.client.rest.delete(Routes.channelMessage(this.id, messageIds[0]));
          return message ? new Collection([[message.id, message]]) : new Collection;
        }
        await this.client.rest.post(Routes.channelBulkDelete(this.id), { body: { messages: messageIds } });
        return messageIds.reduce((col, id) => col.set(id, this.client.actions.MessageDeleteBulk.getMessage({
          message_id: id
        }, this)), new Collection);
      }
      if (!isNaN(messages)) {
        const msgs = await this.messages.fetch({ limit: messages });
        return this.bulkDelete(msgs, filterOld);
      }
      throw new DiscordjsTypeError(ErrorCodes.MessageBulkDeleteType);
    }
    fetchWebhooks() {
      return this.guild.channels.fetchWebhooks(this.id);
    }
    createWebhook(options) {
      return this.guild.channels.createWebhook({ channel: this.id, ...options });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setNSFW(nsfw = true, reason) {
      return this.edit({ nsfw, reason });
    }
    static applyToClass(structure, full = false, ignore = []) {
      const props = ["send"];
      if (full) {
        props.push("lastMessage", "lastPinAt", "bulkDelete", "sendTyping", "createMessageCollector", "awaitMessages", "createMessageComponentCollector", "awaitMessageComponent", "fetchWebhooks", "createWebhook", "setRateLimitPerUser", "setNSFW");
      }
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(TextBasedChannel.prototype, prop));
      }
    }
  }
  module.exports = TextBasedChannel;
  var GuildMessageManager = require_GuildMessageManager();
});

// node_modules/discord.js/src/managers/DMMessageManager.js
var require_DMMessageManager = __commonJS((exports, module) => {
  var MessageManager = require_MessageManager();

  class DMMessageManager extends MessageManager {
  }
  module.exports = DMMessageManager;
});

// node_modules/discord.js/src/structures/DMChannel.js
var require_DMChannel = __commonJS((exports, module) => {
  var { userMention } = require_dist10();
  var { ChannelType } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var DMMessageManager = require_DMMessageManager();
  var Partials = require_Partials();

  class DMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.type = ChannelType.DM;
      this.messages = new DMMessageManager(this);
    }
    _patch(data) {
      super._patch(data);
      if (data.recipients) {
        const recipient = data.recipients[0];
        this.recipientId = recipient.id;
        if (("username" in recipient) || this.client.options.partials.includes(Partials.User)) {
          this.client.users._add(recipient);
        }
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = Date.parse(data.last_pin_timestamp);
      } else {
        this.lastPinTimestamp ??= null;
      }
    }
    get partial() {
      return this.lastMessageId === undefined;
    }
    get recipient() {
      return this.client.users.resolve(this.recipientId);
    }
    fetch(force = true) {
      return this.client.users.createDM(this.recipientId, { force });
    }
    toString() {
      return userMention(this.recipientId);
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
  }
  TextBasedChannel.applyToClass(DMChannel, true, [
    "bulkDelete",
    "fetchWebhooks",
    "createWebhook",
    "setRateLimitPerUser",
    "setNSFW"
  ]);
  module.exports = DMChannel;
});

// node_modules/discord.js/src/util/ThreadMemberFlagsBitField.js
var require_ThreadMemberFlagsBitField = __commonJS((exports, module) => {
  var BitField = require_BitField();

  class ThreadMemberFlagsBitField extends BitField {
    static Flags = {};
  }
  module.exports = ThreadMemberFlagsBitField;
});

// node_modules/discord.js/src/structures/ThreadMember.js
var require_ThreadMember = __commonJS((exports, module) => {
  var Base = require_Base();
  var ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();

  class ThreadMember extends Base {
    constructor(thread, data, extra = {}) {
      super(thread.client);
      this.thread = thread;
      this.joinedTimestamp = null;
      this.flags = null;
      this.id = data.user_id;
      this._patch(data, extra);
    }
    _patch(data, extra = {}) {
      if ("join_timestamp" in data)
        this.joinedTimestamp = Date.parse(data.join_timestamp);
      if ("flags" in data)
        this.flags = new ThreadMemberFlagsBitField(data.flags).freeze();
      if ("member" in data) {
        this.member = this.thread.guild.members._add(data.member, extra.cache);
      } else {
        this.member ??= null;
      }
    }
    get partial() {
      return this.flags === null;
    }
    get guildMember() {
      return this.member ?? this.thread.guild.members.resolve(this.id);
    }
    get joinedAt() {
      return this.joinedTimestamp && new Date(this.joinedTimestamp);
    }
    get user() {
      return this.client.users.resolve(this.id);
    }
    get manageable() {
      return !this.thread.archived && this.thread.editable;
    }
    async remove(reason) {
      await this.thread.members.remove(this.id, reason);
      return this;
    }
  }
  module.exports = ThreadMember;
});

// node_modules/discord.js/src/managers/ThreadMemberManager.js
var require_ThreadMemberManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadMember = require_ThreadMember();

  class ThreadMemberManager extends CachedManager {
    constructor(thread, iterable) {
      super(thread.client, ThreadMember, iterable);
      this.thread = thread;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (cache)
        existing?._patch(data, { cache });
      if (existing)
        return existing;
      const member = new ThreadMember(this.thread, data, { cache });
      if (cache)
        this.cache.set(data.user_id, member);
      return member;
    }
    fetchMe(options) {
      return this.fetch({ ...options, member: this.client.user.id });
    }
    get me() {
      return this.resolve(this.client.user.id);
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      if (userResolvable)
        return super.resolve(userResolvable);
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(member, reason) {
      const id = member === "@me" ? member : this.client.users.resolveId(member);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "member", "UserResolvable");
      await this.client.rest.put(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    async remove(id, reason) {
      await this.client.rest.delete(Routes.threadMembers(this.thread.id, id), { reason });
      return id;
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { member, withMember, cache, force } = options;
      const resolvedMember = this.resolveId(member ?? options);
      if (resolvedMember)
        return this._fetchSingle({ member: resolvedMember, withMember, cache, force });
      return this._fetchMany(options);
    }
    async _fetchSingle({ member, withMember, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(member);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id, member), {
        query: makeURLSearchParams({ with_member: withMember })
      });
      return this._add(data, cache);
    }
    async _fetchMany({ withMember, after, limit, cache } = {}) {
      const data = await this.client.rest.get(Routes.threadMembers(this.thread.id), {
        query: makeURLSearchParams({ with_member: withMember, after, limit })
      });
      return data.reduce((col, member) => col.set(member.user_id, this._add(member, cache)), new Collection);
    }
  }
  module.exports = ThreadMemberManager;
});

// node_modules/discord.js/src/structures/ThreadChannel.js
var require_ThreadChannel = __commonJS((exports, module) => {
  var { ChannelType, PermissionFlagsBits, Routes, ChannelFlags } = require_v106();
  var { BaseChannel } = require_BaseChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var { DiscordjsRangeError, ErrorCodes } = require_errors2();
  var GuildMessageManager = require_GuildMessageManager();
  var ThreadMemberManager = require_ThreadMemberManager();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();

  class ThreadChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(guild?.client ?? client, data, false);
      this.guild = guild;
      this.guildId = guild?.id ?? data.guild_id;
      this.messages = new GuildMessageManager(this);
      this.members = new ThreadMemberManager(this);
      if (data)
        this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("message" in data)
        this.messages._add(data.message);
      if ("name" in data) {
        this.name = data.name;
      }
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("parent_id" in data) {
        this.parentId = data.parent_id;
      } else {
        this.parentId ??= null;
      }
      if ("thread_metadata" in data) {
        this.locked = data.thread_metadata.locked ?? false;
        this.invitable = this.type === ChannelType.PrivateThread ? data.thread_metadata.invitable ?? false : null;
        this.archived = data.thread_metadata.archived;
        this.autoArchiveDuration = data.thread_metadata.auto_archive_duration;
        this.archiveTimestamp = Date.parse(data.thread_metadata.archive_timestamp);
        if ("create_timestamp" in data.thread_metadata) {
          this._createdTimestamp = Date.parse(data.thread_metadata.create_timestamp);
        }
      } else {
        this.locked ??= null;
        this.archived ??= null;
        this.autoArchiveDuration ??= null;
        this.archiveTimestamp ??= null;
        this.invitable ??= null;
      }
      this._createdTimestamp ??= this.type === ChannelType.PrivateThread ? super.createdTimestamp : null;
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      } else {
        this.ownerId ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      } else {
        this.lastMessageId ??= null;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      } else {
        this.lastPinTimestamp ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user ?? 0;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("message_count" in data) {
        this.messageCount = data.message_count;
      } else {
        this.messageCount ??= null;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      } else {
        this.memberCount ??= null;
      }
      if ("total_message_sent" in data) {
        this.totalMessageSent = data.total_message_sent;
      } else {
        this.totalMessageSent ??= null;
      }
      if (data.member && this.client.user)
        this.members._add({ user_id: this.client.user.id, ...data.member });
      if (data.messages)
        for (const message of data.messages)
          this.messages._add(message);
      if ("applied_tags" in data) {
        this.appliedTags = data.applied_tags;
      } else {
        this.appliedTags ??= [];
      }
    }
    get createdTimestamp() {
      return this._createdTimestamp;
    }
    get guildMembers() {
      return this.members.cache.mapValues((member) => member.guildMember);
    }
    get archivedAt() {
      return this.archiveTimestamp && new Date(this.archiveTimestamp);
    }
    get createdAt() {
      return this.createdTimestamp && new Date(this.createdTimestamp);
    }
    get parent() {
      return this.guild.channels.resolve(this.parentId);
    }
    async join() {
      await this.members.add("@me");
      return this;
    }
    async leave() {
      await this.members.remove("@me");
      return this;
    }
    permissionsFor(memberOrRole, checkAdmin) {
      return this.parent?.permissionsFor(memberOrRole, checkAdmin) ?? null;
    }
    async fetchOwner({ cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.members.cache.get(this.ownerId);
        if (existing)
          return existing;
      }
      const members = await this.members.fetch({ cache });
      return members.get(this.ownerId) ?? null;
    }
    async fetchStarterMessage(options) {
      const channel = this.parent?.type === ChannelType.GuildForum ? this : this.parent;
      return channel?.messages.fetch({ message: this.id, ...options }) ?? null;
    }
    async edit(options) {
      const newData = await this.client.rest.patch(Routes.channel(this.id), {
        body: {
          name: (options.name ?? this.name).trim(),
          archived: options.archived,
          auto_archive_duration: options.autoArchiveDuration,
          rate_limit_per_user: options.rateLimitPerUser,
          locked: options.locked,
          invitable: this.type === ChannelType.PrivateThread ? options.invitable : undefined,
          applied_tags: options.appliedTags,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    setArchived(archived = true, reason) {
      return this.edit({ archived, reason });
    }
    setAutoArchiveDuration(autoArchiveDuration, reason) {
      return this.edit({ autoArchiveDuration, reason });
    }
    setInvitable(invitable = true, reason) {
      if (this.type !== ChannelType.PrivateThread) {
        return Promise.reject(new DiscordjsRangeError(ErrorCodes.ThreadInvitableType, this.type));
      }
      return this.edit({ invitable, reason });
    }
    setLocked(locked = true, reason) {
      return this.edit({ locked, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
    setAppliedTags(appliedTags, reason) {
      return this.edit({ appliedTags, reason });
    }
    pin(reason) {
      return this.edit({ flags: this.flags.add(ChannelFlags.Pinned), reason });
    }
    unpin(reason) {
      return this.edit({ flags: this.flags.remove(ChannelFlags.Pinned), reason });
    }
    get joined() {
      return this.members.cache.has(this.client.user?.id);
    }
    get editable() {
      return this.ownerId === this.client.user.id && (this.type !== ChannelType.PrivateThread || this.joined) || this.manageable;
    }
    get joinable() {
      return !this.archived && !this.joined && this.permissionsFor(this.client.user)?.has(this.type === ChannelType.PrivateThread ? PermissionFlagsBits.ManageThreads : PermissionFlagsBits.ViewChannel, false);
    }
    get manageable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.ManageThreads, false);
    }
    get viewable() {
      if (this.client.user.id === this.guild.ownerId)
        return true;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      return permissions.has(PermissionFlagsBits.ViewChannel, false);
    }
    get sendable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return !(this.archived && this.locked && !this.manageable) && (this.type !== ChannelType.PrivateThread || this.joined || this.manageable) && permissions.has(PermissionFlagsBits.SendMessagesInThreads, false) && this.guild.members.me.communicationDisabledUntilTimestamp < Date.now();
    }
    get unarchivable() {
      return this.archived && this.sendable && (!this.locked || this.manageable);
    }
    async delete(reason) {
      await this.guild.channels.delete(this.id, reason);
      return this;
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
  }
  TextBasedChannel.applyToClass(ThreadChannel, true, ["fetchWebhooks", "setRateLimitPerUser", "setNSFW"]);
  module.exports = ThreadChannel;
});

// node_modules/discord.js/src/managers/ThreadManager.js
var require_ThreadManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var ThreadChannel = require_ThreadChannel();
  var { MakeCacheOverrideSymbol } = require_Symbols();

  class ThreadManager extends CachedManager {
    static [MakeCacheOverrideSymbol] = ThreadManager;
    constructor(channel, iterable) {
      super(channel.client, ThreadChannel, iterable);
      this.channel = channel;
    }
    _add(thread) {
      const existing = this.cache.get(thread.id);
      if (existing)
        return existing;
      this.cache.set(thread.id, thread);
      return thread;
    }
    fetch(options, { cache, force } = {}) {
      if (!options)
        return this.fetchActive(cache);
      const channel = this.client.channels.resolveId(options);
      if (channel)
        return this.client.channels.fetch(channel, { cache, force });
      if (options.archived) {
        return this.fetchArchived(options.archived, cache);
      }
      return this.fetchActive(cache);
    }
    async fetchArchived({ type = "public", fetchAll = false, before, limit } = {}, cache = true) {
      let path = Routes.channelThreads(this.channel.id, type);
      if (type === "private" && !fetchAll) {
        path = Routes.channelJoinedArchivedThreads(this.channel.id);
      }
      let timestamp;
      let id;
      const query = makeURLSearchParams({ limit });
      if (before !== undefined) {
        if (before instanceof ThreadChannel || /^\d{17,19}$/.test(String(before))) {
          id = this.resolveId(before);
          timestamp = this.resolve(before)?.archivedAt?.toISOString();
          const toUse = type === "private" && !fetchAll ? id : timestamp;
          if (toUse) {
            query.set("before", toUse);
          }
        } else {
          try {
            timestamp = new Date(before).toISOString();
            if (type === "public" || fetchAll) {
              query.set("before", timestamp);
            }
          } catch {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, "before", "DateResolvable or ThreadChannelResolvable");
          }
        }
      }
      const raw2 = await this.client.rest.get(path, { query });
      return this.constructor._mapThreads(raw2, this.client, { parent: this.channel, cache });
    }
    async fetchActive(cache = true) {
      const data = await this.channel.guild.channels.rawFetchGuildActiveThreads();
      return this.constructor._mapThreads(data, this.client, { parent: this.channel, cache });
    }
    static _mapThreads(rawThreads, client, { parent, guild, cache }) {
      const threads = rawThreads.threads.reduce((coll, raw2) => {
        const thread = client.channels._add(raw2, guild ?? parent?.guild, { cache });
        if (parent && thread.parentId !== parent.id)
          return coll;
        return coll.set(thread.id, thread);
      }, new Collection);
      const threadMembers = rawThreads.members.reduce((coll, raw2) => {
        const thread = threads.get(raw2.id);
        return thread ? coll.set(raw2.user_id, thread.members._add(raw2)) : coll;
      }, new Collection);
      const response = { threads, members: threadMembers };
      if ("has_more" in rawThreads)
        response.hasMore = rawThreads.has_more;
      return response;
    }
  }
  module.exports = ThreadManager;
});

// node_modules/discord.js/src/managers/GuildTextThreadManager.js
var require_GuildTextThreadManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class GuildTextThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      startMessage,
      type,
      invitable,
      reason,
      rateLimitPerUser
    } = {}) {
      let resolvedType = this.channel.type === ChannelType.GuildAnnouncement ? ChannelType.AnnouncementThread : ChannelType.PublicThread;
      let startMessageId;
      if (startMessage) {
        startMessageId = this.channel.messages.resolveId(startMessage);
        if (!startMessageId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "startMessage", "MessageResolvable");
      } else if (this.channel.type !== ChannelType.GuildAnnouncement) {
        resolvedType = type ?? resolvedType;
      }
      const data = await this.client.rest.post(Routes.threads(this.channel.id, startMessageId), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          type: resolvedType,
          invitable: resolvedType === ChannelType.PrivateThread ? invitable : undefined,
          rate_limit_per_user: rateLimitPerUser
        },
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildTextThreadManager;
});

// node_modules/discord.js/src/structures/BaseGuildTextChannel.js
var require_BaseGuildTextChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();

  class BaseGuildTextChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.threads = new GuildTextThreadManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("nsfw" in data) {
        this.nsfw = Boolean(data.nsfw);
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("last_pin_timestamp" in data) {
        this.lastPinTimestamp = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setType(type, reason) {
      return this.edit({ type, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    get lastMessage() {
    }
    get lastPinAt() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildTextChannel, true);
  module.exports = BaseGuildTextChannel;
});

// node_modules/discord.js/src/structures/NewsChannel.js
var require_NewsChannel = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var BaseGuildTextChannel = require_BaseGuildTextChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class NewsChannel extends BaseGuildTextChannel {
    async addFollower(channel, reason) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      await this.client.rest.post(Routes.channelFollowers(this.id), { body: { webhook_channel_id: channelId }, reason });
      return this;
    }
  }
  module.exports = NewsChannel;
});

// node_modules/discord.js/src/structures/BaseGuildVoiceChannel.js
var require_BaseGuildVoiceChannel = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { PermissionFlagsBits } = require_v106();
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildMessageManager = require_GuildMessageManager();

  class BaseGuildVoiceChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.messages = new GuildMessageManager(this);
      this.nsfw = Boolean(data.nsfw);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("rtc_region" in data) {
        this.rtcRegion = data.rtc_region;
      }
      if ("bitrate" in data) {
        this.bitrate = data.bitrate;
      }
      if ("user_limit" in data) {
        this.userLimit = data.user_limit;
      }
      if ("video_quality_mode" in data) {
        this.videoQualityMode = data.video_quality_mode;
      } else {
        this.videoQualityMode ??= null;
      }
      if ("last_message_id" in data) {
        this.lastMessageId = data.last_message_id;
      }
      if ("messages" in data) {
        for (const message of data.messages)
          this.messages._add(message);
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      }
    }
    get members() {
      const coll = new Collection;
      for (const state of this.guild.voiceStates.cache.values()) {
        if (state.channelId === this.id && state.member) {
          coll.set(state.id, state.member);
        }
      }
      return coll;
    }
    get full() {
      return this.userLimit > 0 && this.members.size >= this.userLimit;
    }
    get joinable() {
      if (!this.viewable)
        return false;
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Connect, false);
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache = true) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setBitrate(bitrate, reason) {
      return this.edit({ bitrate, reason });
    }
    setRTCRegion(rtcRegion, reason) {
      return this.edit({ rtcRegion, reason });
    }
    setUserLimit(userLimit, reason) {
      return this.edit({ userLimit, reason });
    }
    setVideoQualityMode(videoQualityMode, reason) {
      return this.edit({ videoQualityMode, reason });
    }
    get lastMessage() {
    }
    send() {
    }
    sendTyping() {
    }
    createMessageCollector() {
    }
    awaitMessages() {
    }
    createMessageComponentCollector() {
    }
    awaitMessageComponent() {
    }
    bulkDelete() {
    }
    fetchWebhooks() {
    }
    createWebhook() {
    }
    setRateLimitPerUser() {
    }
    setNSFW() {
    }
  }
  TextBasedChannel.applyToClass(BaseGuildVoiceChannel, true, ["lastPinAt"]);
  module.exports = BaseGuildVoiceChannel;
});

// node_modules/discord.js/src/structures/StageChannel.js
var require_StageChannel = __commonJS((exports, module) => {
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class StageChannel extends BaseGuildVoiceChannel {
    _patch(data) {
      super._patch(data);
      if ("topic" in data) {
        this.topic = data.topic;
      }
    }
    get stageInstance() {
      return this.guild.stageInstances.cache.find((stageInstance) => stageInstance.channelId === this.id) ?? null;
    }
    createStageInstance(options) {
      return this.guild.stageInstances.create(this.id, options);
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
  }
  module.exports = StageChannel;
});

// node_modules/discord.js/src/structures/TextChannel.js
var require_TextChannel = __commonJS((exports, module) => {
  var BaseGuildTextChannel = require_BaseGuildTextChannel();

  class TextChannel extends BaseGuildTextChannel {
    _patch(data) {
      super._patch(data);
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      }
    }
    setRateLimitPerUser(rateLimitPerUser, reason) {
      return this.edit({ rateLimitPerUser, reason });
    }
  }
  module.exports = TextChannel;
});

// node_modules/discord.js/src/structures/VoiceChannel.js
var require_VoiceChannel = __commonJS((exports, module) => {
  var { PermissionFlagsBits } = require_v106();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();

  class VoiceChannel extends BaseGuildVoiceChannel {
    get joinable() {
      if (!super.joinable)
        return false;
      if (this.full && !this.permissionsFor(this.client.user).has(PermissionFlagsBits.MoveMembers, false))
        return false;
      return true;
    }
    get speakable() {
      const permissions = this.permissionsFor(this.client.user);
      if (!permissions)
        return false;
      if (permissions.has(PermissionFlagsBits.Administrator, false))
        return true;
      return this.guild.members.me.communicationDisabledUntilTimestamp < Date.now() && permissions.has(PermissionFlagsBits.Speak, false);
    }
  }
  module.exports = VoiceChannel;
});

// node_modules/discord.js/src/structures/DirectoryChannel.js
var require_DirectoryChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();

  class DirectoryChannel extends BaseChannel {
    constructor(guild, data, client) {
      super(client, data);
      this.guild = guild;
      this.guildId = guild.id;
    }
    _patch(data) {
      super._patch(data);
      this.name = data.name;
    }
  }
  module.exports = DirectoryChannel;
});

// node_modules/discord.js/src/structures/PartialGroupDMChannel.js
var require_PartialGroupDMChannel = __commonJS((exports, module) => {
  var { BaseChannel } = require_BaseChannel();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class PartialGroupDMChannel extends BaseChannel {
    constructor(client, data) {
      super(client, data);
      this.flags = null;
      this.name = data.name;
      this.icon = data.icon;
      this.recipients = data.recipients;
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.channelIcon(this.id, this.icon, options);
    }
    delete() {
      return Promise.reject(new DiscordjsError(ErrorCodes.DeleteGroupDMChannel));
    }
    fetch() {
      return Promise.reject(new DiscordjsError(ErrorCodes.FetchGroupDMChannel));
    }
  }
  module.exports = PartialGroupDMChannel;
});

// node_modules/discord.js/src/managers/GuildForumThreadManager.js
var require_GuildForumThreadManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var ThreadManager = require_ThreadManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();

  class GuildForumThreadManager extends ThreadManager {
    async create({
      name,
      autoArchiveDuration = this.channel.defaultAutoArchiveDuration,
      message,
      reason,
      rateLimitPerUser,
      appliedTags
    } = {}) {
      if (!message) {
        throw new DiscordjsTypeError(ErrorCodes.GuildForumMessageRequired);
      }
      const { body, files } = await (message instanceof MessagePayload ? message : MessagePayload.create(this, message)).resolveBody().resolveFiles();
      const data = await this.client.rest.post(Routes.threads(this.channel.id), {
        body: {
          name,
          auto_archive_duration: autoArchiveDuration,
          rate_limit_per_user: rateLimitPerUser,
          applied_tags: appliedTags,
          message: body
        },
        files,
        reason
      });
      return this.client.actions.ThreadCreate.handle(data).thread;
    }
  }
  module.exports = GuildForumThreadManager;
});

// node_modules/discord.js/src/structures/ForumChannel.js
var require_ForumChannel = __commonJS((exports, module) => {
  var GuildChannel = require_GuildChannel();
  var TextBasedChannel = require_TextBasedChannel();
  var GuildForumThreadManager = require_GuildForumThreadManager();
  var { transformAPIGuildForumTag, transformAPIGuildDefaultReaction } = require_Channels();

  class ForumChannel extends GuildChannel {
    constructor(guild, data, client) {
      super(guild, data, client, false);
      this.threads = new GuildForumThreadManager(this);
      this._patch(data);
    }
    _patch(data) {
      super._patch(data);
      if ("available_tags" in data) {
        this.availableTags = data.available_tags.map((tag) => transformAPIGuildForumTag(tag));
      } else {
        this.availableTags ??= [];
      }
      if ("default_reaction_emoji" in data) {
        this.defaultReactionEmoji = data.default_reaction_emoji ? transformAPIGuildDefaultReaction(data.default_reaction_emoji) : null;
      } else {
        this.defaultReactionEmoji ??= null;
      }
      if ("default_thread_rate_limit_per_user" in data) {
        this.defaultThreadRateLimitPerUser = data.default_thread_rate_limit_per_user;
      } else {
        this.defaultThreadRateLimitPerUser ??= null;
      }
      if ("rate_limit_per_user" in data) {
        this.rateLimitPerUser = data.rate_limit_per_user;
      } else {
        this.rateLimitPerUser ??= null;
      }
      if ("default_auto_archive_duration" in data) {
        this.defaultAutoArchiveDuration = data.default_auto_archive_duration;
      } else {
        this.defaultAutoArchiveDuration ??= null;
      }
      if ("nsfw" in data) {
        this.nsfw = data.nsfw;
      } else {
        this.nsfw ??= false;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("default_sort_order" in data) {
        this.defaultSortOrder = data.default_sort_order;
      } else {
        this.defaultSortOrder ??= null;
      }
      this.defaultForumLayout = data.default_forum_layout;
    }
    setAvailableTags(availableTags, reason) {
      return this.edit({ availableTags, reason });
    }
    setDefaultReactionEmoji(defaultReactionEmoji, reason) {
      return this.edit({ defaultReactionEmoji, reason });
    }
    setDefaultThreadRateLimitPerUser(defaultThreadRateLimitPerUser, reason) {
      return this.edit({ defaultThreadRateLimitPerUser, reason });
    }
    createInvite(options) {
      return this.guild.invites.create(this.id, options);
    }
    fetchInvites(cache) {
      return this.guild.invites.fetch({ channelId: this.id, cache });
    }
    setDefaultAutoArchiveDuration(defaultAutoArchiveDuration, reason) {
      return this.edit({ defaultAutoArchiveDuration, reason });
    }
    setTopic(topic, reason) {
      return this.edit({ topic, reason });
    }
    setDefaultSortOrder(defaultSortOrder, reason) {
      return this.edit({ defaultSortOrder, reason });
    }
    setDefaultForumLayout(defaultForumLayout, reason) {
      return this.edit({ defaultForumLayout, reason });
    }
    createWebhook() {
    }
    fetchWebhooks() {
    }
    setNSFW() {
    }
    setRateLimitPerUser() {
    }
  }
  TextBasedChannel.applyToClass(ForumChannel, true, [
    "send",
    "lastMessage",
    "lastPinAt",
    "bulkDelete",
    "sendTyping",
    "createMessageCollector",
    "awaitMessages",
    "createMessageComponentCollector",
    "awaitMessageComponent"
  ]);
  module.exports = ForumChannel;
});

// node_modules/discord.js/src/util/Channels.js
var require_Channels = __commonJS((exports, module) => {
  var createChannel = function(client, data, guild, { allowUnknownGuild } = {}) {
    let channel;
    if (!data.guild_id && !guild) {
      if (data.recipients && data.type !== ChannelType.GroupDM || data.type === ChannelType.DM) {
        channel = new (getDMChannel())(client, data);
      } else if (data.type === ChannelType.GroupDM) {
        channel = new (getPartialGroupDMChannel())(client, data);
      }
    } else {
      guild ??= client.guilds.cache.get(data.guild_id);
      if (guild || allowUnknownGuild) {
        switch (data.type) {
          case ChannelType.GuildText: {
            channel = new (getTextChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildVoice: {
            channel = new (getVoiceChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildCategory: {
            channel = new (getCategoryChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildAnnouncement: {
            channel = new (getNewsChannel())(guild, data, client);
            break;
          }
          case ChannelType.GuildStageVoice: {
            channel = new (getStageChannel())(guild, data, client);
            break;
          }
          case ChannelType.AnnouncementThread:
          case ChannelType.PublicThread:
          case ChannelType.PrivateThread: {
            channel = new (getThreadChannel())(guild, data, client);
            if (!allowUnknownGuild)
              channel.parent?.threads.cache.set(channel.id, channel);
            break;
          }
          case ChannelType.GuildDirectory:
            channel = new (getDirectoryChannel())(guild, data, client);
            break;
          case ChannelType.GuildForum:
            channel = new (getForumChannel())(guild, data, client);
            break;
        }
        if (channel && !allowUnknownGuild)
          guild.channels?.cache.set(channel.id, channel);
      }
    }
    return channel;
  };
  var transformAPIGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji: tag.emoji_id ?? tag.emoji_name ? {
        id: tag.emoji_id,
        name: tag.emoji_name
      } : null
    };
  };
  var transformGuildForumTag = function(tag) {
    return {
      id: tag.id,
      name: tag.name,
      moderated: tag.moderated,
      emoji_id: tag.emoji?.id ?? null,
      emoji_name: tag.emoji?.name ?? null
    };
  };
  var transformAPIGuildDefaultReaction = function(defaultReaction) {
    return {
      id: defaultReaction.emoji_id,
      name: defaultReaction.emoji_name
    };
  };
  var transformGuildDefaultReaction = function(defaultReaction) {
    return {
      emoji_id: defaultReaction.id,
      emoji_name: defaultReaction.name
    };
  };
  var { lazy } = require_dist();
  var { ChannelType } = require_v106();
  var getCategoryChannel = lazy(() => require_CategoryChannel());
  var getDMChannel = lazy(() => require_DMChannel());
  var getNewsChannel = lazy(() => require_NewsChannel());
  var getStageChannel = lazy(() => require_StageChannel());
  var getTextChannel = lazy(() => require_TextChannel());
  var getThreadChannel = lazy(() => require_ThreadChannel());
  var getVoiceChannel = lazy(() => require_VoiceChannel());
  var getDirectoryChannel = lazy(() => require_DirectoryChannel());
  var getPartialGroupDMChannel = lazy(() => require_PartialGroupDMChannel());
  var getForumChannel = lazy(() => require_ForumChannel());
  module.exports = {
    createChannel,
    transformAPIGuildForumTag,
    transformGuildForumTag,
    transformAPIGuildDefaultReaction,
    transformGuildDefaultReaction
  };
});

// node_modules/discord.js/src/client/actions/ChannelUpdate.js
var require_ChannelUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var { createChannel } = require_Channels();

  class ChannelUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      let channel = client.channels.cache.get(data.id);
      if (channel) {
        const old = channel._update(data);
        if (channel.type !== data.type) {
          const newChannel = createChannel(this.client, data, channel.guild);
          if (!newChannel) {
            this.client.channels.cache.delete(channel.id);
            return {};
          }
          if (channel.isTextBased() && newChannel.isTextBased()) {
            for (const [id, message] of channel.messages.cache)
              newChannel.messages.cache.set(id, message);
          }
          channel = newChannel;
          this.client.channels.cache.set(channel.id, channel);
        }
        return {
          old,
          updated: channel
        };
      } else {
        client.channels._add(data);
      }
      return {};
    }
  }
  module.exports = ChannelUpdateAction;
});

// node_modules/discord.js/src/structures/AutoModerationRule.js
var require_AutoModerationRule = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Base = require_Base();
  var { _transformAPIAutoModerationAction } = require_Transformers();

  class AutoModerationRule extends Base {
    constructor(client, data, guild) {
      super(client);
      this.id = data.id;
      this.guild = guild;
      this.creatorId = data.creator_id;
      this.triggerType = data.trigger_type;
      this._patch(data);
    }
    _patch(data) {
      if ("name" in data) {
        this.name = data.name;
      }
      if ("event_type" in data) {
        this.eventType = data.event_type;
      }
      if ("trigger_metadata" in data) {
        this.triggerMetadata = {
          keywordFilter: data.trigger_metadata.keyword_filter ?? [],
          regexPatterns: data.trigger_metadata.regex_patterns ?? [],
          presets: data.trigger_metadata.presets ?? [],
          allowList: data.trigger_metadata.allow_list ?? [],
          mentionTotalLimit: data.trigger_metadata.mention_total_limit ?? null,
          mentionRaidProtectionEnabled: data.trigger_metadata.mention_raid_protection_enabled ?? false
        };
      }
      if ("actions" in data) {
        this.actions = data.actions.map((action) => _transformAPIAutoModerationAction(action));
      }
      if ("enabled" in data) {
        this.enabled = data.enabled;
      }
      if ("exempt_roles" in data) {
        this.exemptRoles = new Collection(data.exempt_roles.map((exemptRole) => [exemptRole, this.guild.roles.cache.get(exemptRole)]));
      }
      if ("exempt_channels" in data) {
        this.exemptChannels = new Collection(data.exempt_channels.map((exemptChannel) => [exemptChannel, this.guild.channels.cache.get(exemptChannel)]));
      }
    }
    edit(options) {
      return this.guild.autoModerationRules.edit(this.id, options);
    }
    delete(reason) {
      return this.guild.autoModerationRules.delete(this.id, reason);
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setEventType(eventType, reason) {
      return this.edit({ eventType, reason });
    }
    setKeywordFilter(keywordFilter, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, keywordFilter }, reason });
    }
    setRegexPatterns(regexPatterns, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, regexPatterns }, reason });
    }
    setPresets(presets, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, presets }, reason });
    }
    setAllowList(allowList, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, allowList }, reason });
    }
    setMentionTotalLimit(mentionTotalLimit, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionTotalLimit }, reason });
    }
    setMentionRaidProtectionEnabled(mentionRaidProtectionEnabled, reason) {
      return this.edit({ triggerMetadata: { ...this.triggerMetadata, mentionRaidProtectionEnabled }, reason });
    }
    setActions(actions, reason) {
      return this.edit({ actions, reason });
    }
    setEnabled(enabled = true, reason) {
      return this.edit({ enabled, reason });
    }
    setExemptRoles(exemptRoles, reason) {
      return this.edit({ exemptRoles, reason });
    }
    setExemptChannels(exemptChannels, reason) {
      return this.edit({ exemptChannels, reason });
    }
  }
  module.exports = AutoModerationRule;
});

// node_modules/discord.js/src/structures/Integration.js
var require_Integration = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var Base = require_Base();
  var IntegrationApplication = require_IntegrationApplication();

  class Integration extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this.id = data.id;
      this.name = data.name;
      this.type = data.type;
      this.enabled = data.enabled ?? null;
      if ("syncing" in data) {
        this.syncing = data.syncing;
      } else {
        this.syncing ??= null;
      }
      this.role = this.guild.roles.resolve(data.role_id);
      if ("enable_emoticons" in data) {
        this.enableEmoticons = data.enable_emoticons;
      } else {
        this.enableEmoticons ??= null;
      }
      if (data.user) {
        this.user = this.client.users._add(data.user);
      } else {
        this.user ??= null;
      }
      this.account = data.account;
      if ("synced_at" in data) {
        this.syncedTimestamp = Date.parse(data.synced_at);
      } else {
        this.syncedTimestamp ??= null;
      }
      if ("subscriber_count" in data) {
        this.subscriberCount = data.subscriber_count;
      } else {
        this.subscriberCount ??= null;
      }
      if ("revoked" in data) {
        this.revoked = data.revoked;
      } else {
        this.revoked ??= null;
      }
      this._patch(data);
    }
    get syncedAt() {
      return this.syncedTimestamp && new Date(this.syncedTimestamp);
    }
    get roles() {
      const roles = this.guild.roles.cache;
      return roles.filter((role) => role.tags?.integrationId === this.id);
    }
    _patch(data) {
      if ("expire_behavior" in data) {
        this.expireBehavior = data.expire_behavior;
      } else {
        this.expireBehavior ??= null;
      }
      if ("expire_grace_period" in data) {
        this.expireGracePeriod = data.expire_grace_period;
      } else {
        this.expireGracePeriod ??= null;
      }
      if ("application" in data) {
        if (this.application) {
          this.application._patch(data.application);
        } else {
          this.application = new IntegrationApplication(this.client, data.application);
        }
      } else {
        this.application ??= null;
      }
      if ("scopes" in data) {
        this.scopes = data.scopes;
      } else {
        this.scopes ??= [];
      }
    }
    async delete(reason) {
      await this.client.rest.delete(Routes.guildIntegration(this.guild.id, this.id), { reason });
      return this;
    }
    toJSON() {
      return super.toJSON({
        role: "roleId",
        guild: "guildId",
        user: "userId"
      });
    }
  }
  module.exports = Integration;
});

// node_modules/discord.js/src/structures/StageInstance.js
var require_StageInstance = __commonJS((exports) => {
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();

  class StageInstance extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this._patch(data);
    }
    _patch(data) {
      if ("guild_id" in data) {
        this.guildId = data.guild_id;
      }
      if ("channel_id" in data) {
        this.channelId = data.channel_id;
      }
      if ("topic" in data) {
        this.topic = data.topic;
      }
      if ("privacy_level" in data) {
        this.privacyLevel = data.privacy_level;
      }
      if ("discoverable_disabled" in data) {
        this.discoverableDisabled = data.discoverable_disabled;
      } else {
        this.discoverableDisabled ??= null;
      }
      if ("guild_scheduled_event_id" in data) {
        this.guildScheduledEventId = data.guild_scheduled_event_id;
      } else {
        this.guildScheduledEventId ??= null;
      }
    }
    get channel() {
      return this.client.channels.resolve(this.channelId);
    }
    get guild() {
      return this.client.guilds.resolve(this.guildId);
    }
    get guildScheduledEvent() {
      return this.guild?.scheduledEvents.resolve(this.guildScheduledEventId) ?? null;
    }
    edit(options) {
      return this.guild.stageInstances.edit(this.channelId, options);
    }
    async delete() {
      await this.guild.stageInstances.delete(this.channelId);
      const clone = this._clone();
      return clone;
    }
    setTopic(topic) {
      return this.guild.stageInstances.edit(this.channelId, { topic });
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
  }
  exports.StageInstance = StageInstance;
});

// node_modules/discord.js/src/structures/GuildAuditLogsEntry.js
var require_GuildAuditLogsEntry = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var { AuditLogOptionsType, AuditLogEvent } = require_v106();
  var AutoModerationRule = require_AutoModerationRule();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var Integration = require_Integration();
  var Invite = require_Invite();
  var { StageInstance } = require_StageInstance();
  var { Sticker } = require_Sticker();
  var Webhook = require_Webhook();
  var Partials = require_Partials();
  var { flatten } = require_Util();
  var Targets = {
    All: "All",
    Guild: "Guild",
    GuildScheduledEvent: "GuildScheduledEvent",
    Channel: "Channel",
    User: "User",
    Role: "Role",
    Invite: "Invite",
    Webhook: "Webhook",
    Emoji: "Emoji",
    Message: "Message",
    Integration: "Integration",
    StageInstance: "StageInstance",
    Sticker: "Sticker",
    Thread: "Thread",
    ApplicationCommand: "ApplicationCommand",
    AutoModeration: "AutoModeration",
    Unknown: "Unknown"
  };

  class GuildAuditLogsEntry {
    static Targets = Targets;
    constructor(guild, data, logs) {
      this.targetType = GuildAuditLogsEntry.targetType(data.action_type);
      const targetType = this.targetType;
      this.actionType = GuildAuditLogsEntry.actionType(data.action_type);
      this.action = data.action_type;
      this.reason = data.reason ?? null;
      this.executorId = data.user_id;
      this.executor = data.user_id ? guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.user_id }) : guild.client.users.cache.get(data.user_id) ?? null : null;
      this.changes = data.changes?.map((c) => ({ key: c.key, old: c.old_value, new: c.new_value })) ?? [];
      this.id = data.id;
      this.extra = null;
      switch (data.action_type) {
        case AuditLogEvent.MemberPrune:
          this.extra = {
            removed: Number(data.options.members_removed),
            days: Number(data.options.delete_member_days)
          };
          break;
        case AuditLogEvent.MemberMove:
        case AuditLogEvent.MessageDelete:
        case AuditLogEvent.MessageBulkDelete:
          this.extra = {
            channel: guild.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.MessagePin:
        case AuditLogEvent.MessageUnpin:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options.channel_id) ?? { id: data.options.channel_id },
            messageId: data.options.message_id
          };
          break;
        case AuditLogEvent.MemberDisconnect:
          this.extra = {
            count: Number(data.options.count)
          };
          break;
        case AuditLogEvent.ChannelOverwriteCreate:
        case AuditLogEvent.ChannelOverwriteUpdate:
        case AuditLogEvent.ChannelOverwriteDelete:
          switch (data.options.type) {
            case AuditLogOptionsType.Role:
              this.extra = guild.roles.cache.get(data.options.id) ?? {
                id: data.options.id,
                name: data.options.role_name,
                type: AuditLogOptionsType.Role
              };
              break;
            case AuditLogOptionsType.Member:
              this.extra = guild.members.cache.get(data.options.id) ?? {
                id: data.options.id,
                type: AuditLogOptionsType.Member
              };
              break;
            default:
              break;
          }
          break;
        case AuditLogEvent.StageInstanceCreate:
        case AuditLogEvent.StageInstanceDelete:
        case AuditLogEvent.StageInstanceUpdate:
          this.extra = {
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        case AuditLogEvent.ApplicationCommandPermissionUpdate:
          this.extra = {
            applicationId: data.options.application_id
          };
          break;
        case AuditLogEvent.AutoModerationBlockMessage:
        case AuditLogEvent.AutoModerationFlagToChannel:
        case AuditLogEvent.AutoModerationUserCommunicationDisabled:
          this.extra = {
            autoModerationRuleName: data.options.auto_moderation_rule_name,
            autoModerationRuleTriggerType: data.options.auto_moderation_rule_trigger_type,
            channel: guild.client.channels.cache.get(data.options?.channel_id) ?? { id: data.options?.channel_id }
          };
          break;
        default:
          break;
      }
      this.targetId = data.target_id;
      this.target = null;
      if (targetType === Targets.Unknown) {
        this.target = this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, {});
        this.target.id = data.target_id;
      } else if (targetType === Targets.User && data.target_id) {
        this.target = guild.client.options.partials.includes(Partials.User) ? guild.client.users._add({ id: data.target_id }) : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Guild) {
        this.target = guild.client.guilds.cache.get(data.target_id);
      } else if (targetType === Targets.Webhook) {
        this.target = logs?.webhooks.get(data.target_id) ?? new Webhook(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, {
          id: data.target_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Invite) {
        let change = this.changes.find((c) => c.key === "code");
        change = change.new ?? change.old;
        this.target = guild.invites.cache.get(change) ?? new Invite(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { guild }));
      } else if (targetType === Targets.Message) {
        this.target = data.action_type === AuditLogEvent.MessageBulkDelete ? guild.channels.cache.get(data.target_id) ?? { id: data.target_id } : guild.client.users.cache.get(data.target_id) ?? null;
      } else if (targetType === Targets.Integration) {
        this.target = logs?.integrations.get(data.target_id) ?? new Integration(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { id: data.target_id }), guild);
      } else if (targetType === Targets.Channel || targetType === Targets.Thread) {
        this.target = guild.channels.cache.get(data.target_id) ?? this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { id: data.target_id });
      } else if (targetType === Targets.StageInstance) {
        this.target = guild.stageInstances.cache.get(data.target_id) ?? new StageInstance(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, {
          id: data.target_id,
          channel_id: data.options?.channel_id,
          guild_id: guild.id
        }));
      } else if (targetType === Targets.Sticker) {
        this.target = guild.stickers.cache.get(data.target_id) ?? new Sticker(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { id: data.target_id }));
      } else if (targetType === Targets.GuildScheduledEvent) {
        this.target = guild.scheduledEvents.cache.get(data.target_id) ?? new GuildScheduledEvent(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { id: data.target_id, guild_id: guild.id }));
      } else if (targetType === Targets.ApplicationCommand) {
        this.target = logs?.applicationCommands.get(data.target_id) ?? { id: data.target_id };
      } else if (targetType === Targets.AutoModeration) {
        this.target = guild.autoModerationRules.cache.get(data.target_id) ?? new AutoModerationRule(guild.client, this.changes.reduce((o, c) => {
          o[c.key] = c.new ?? c.old;
          return o;
        }, { id: data.target_id, guild_id: guild.id }), guild);
      } else if (data.target_id) {
        this.target = guild[`${targetType.toLowerCase()}s`]?.cache.get(data.target_id) ?? { id: data.target_id };
      }
    }
    static targetType(target) {
      if (target < 10)
        return Targets.Guild;
      if (target < 20)
        return Targets.Channel;
      if (target < 30)
        return Targets.User;
      if (target < 40)
        return Targets.Role;
      if (target < 50)
        return Targets.Invite;
      if (target < 60)
        return Targets.Webhook;
      if (target < 70)
        return Targets.Emoji;
      if (target < 80)
        return Targets.Message;
      if (target < 83)
        return Targets.Integration;
      if (target < 86)
        return Targets.StageInstance;
      if (target < 100)
        return Targets.Sticker;
      if (target < 110)
        return Targets.GuildScheduledEvent;
      if (target < 120)
        return Targets.Thread;
      if (target < 130)
        return Targets.ApplicationCommand;
      if (target >= 140 && target < 150)
        return Targets.AutoModeration;
      return Targets.Unknown;
    }
    static actionType(action) {
      if ([
        AuditLogEvent.ChannelCreate,
        AuditLogEvent.ChannelOverwriteCreate,
        AuditLogEvent.MemberBanRemove,
        AuditLogEvent.BotAdd,
        AuditLogEvent.RoleCreate,
        AuditLogEvent.InviteCreate,
        AuditLogEvent.WebhookCreate,
        AuditLogEvent.EmojiCreate,
        AuditLogEvent.MessagePin,
        AuditLogEvent.IntegrationCreate,
        AuditLogEvent.StageInstanceCreate,
        AuditLogEvent.StickerCreate,
        AuditLogEvent.GuildScheduledEventCreate,
        AuditLogEvent.ThreadCreate,
        AuditLogEvent.AutoModerationRuleCreate,
        AuditLogEvent.AutoModerationBlockMessage
      ].includes(action)) {
        return "Create";
      }
      if ([
        AuditLogEvent.ChannelDelete,
        AuditLogEvent.ChannelOverwriteDelete,
        AuditLogEvent.MemberKick,
        AuditLogEvent.MemberPrune,
        AuditLogEvent.MemberBanAdd,
        AuditLogEvent.MemberDisconnect,
        AuditLogEvent.RoleDelete,
        AuditLogEvent.InviteDelete,
        AuditLogEvent.WebhookDelete,
        AuditLogEvent.EmojiDelete,
        AuditLogEvent.MessageDelete,
        AuditLogEvent.MessageBulkDelete,
        AuditLogEvent.MessageUnpin,
        AuditLogEvent.IntegrationDelete,
        AuditLogEvent.StageInstanceDelete,
        AuditLogEvent.StickerDelete,
        AuditLogEvent.GuildScheduledEventDelete,
        AuditLogEvent.ThreadDelete,
        AuditLogEvent.AutoModerationRuleDelete
      ].includes(action)) {
        return "Delete";
      }
      if ([
        AuditLogEvent.GuildUpdate,
        AuditLogEvent.ChannelUpdate,
        AuditLogEvent.ChannelOverwriteUpdate,
        AuditLogEvent.MemberUpdate,
        AuditLogEvent.MemberRoleUpdate,
        AuditLogEvent.MemberMove,
        AuditLogEvent.RoleUpdate,
        AuditLogEvent.InviteUpdate,
        AuditLogEvent.WebhookUpdate,
        AuditLogEvent.EmojiUpdate,
        AuditLogEvent.IntegrationUpdate,
        AuditLogEvent.StageInstanceUpdate,
        AuditLogEvent.StickerUpdate,
        AuditLogEvent.GuildScheduledEventUpdate,
        AuditLogEvent.ThreadUpdate,
        AuditLogEvent.ApplicationCommandPermissionUpdate,
        AuditLogEvent.AutoModerationRuleUpdate
      ].includes(action)) {
        return "Update";
      }
      return "All";
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toJSON() {
      return flatten(this, { createdTimestamp: true });
    }
  }
  module.exports = GuildAuditLogsEntry;
});

// node_modules/discord.js/src/client/actions/GuildAuditLogEntryCreate.js
var require_GuildAuditLogEntryCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Events = require_Events();

  class GuildAuditLogEntryCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let auditLogEntry;
      if (guild) {
        auditLogEntry = new GuildAuditLogsEntry(guild, data);
        client.emit(Events.GuildAuditLogEntryCreate, auditLogEntry, guild);
      }
      return { auditLogEntry };
    }
  }
  module.exports = GuildAuditLogEntryCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildBanAdd.js
var require_GuildBanAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildBanAdd extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildBanAdd, guild.bans._add(data));
    }
  }
  module.exports = GuildBanAdd;
});

// node_modules/discord.js/src/structures/GuildBan.js
var require_GuildBan = __commonJS((exports, module) => {
  var Base = require_Base();

  class GuildBan extends Base {
    constructor(client, data, guild) {
      super(client);
      this.guild = guild;
      this._patch(data);
    }
    _patch(data) {
      if ("user" in data) {
        this.user = this.client.users._add(data.user, true);
      }
      if ("reason" in data) {
        this.reason = data.reason;
      }
    }
    get partial() {
      return !("reason" in this);
    }
    fetch(force = true) {
      return this.guild.bans.fetch({ user: this.user, cache: true, force });
    }
  }
  module.exports = GuildBan;
});

// node_modules/discord.js/src/client/actions/GuildBanRemove.js
var require_GuildBanRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var GuildBan = require_GuildBan();
  var Events = require_Events();

  class GuildBanRemove extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const ban = guild.bans.cache.get(data.user.id) ?? new GuildBan(client, data, guild);
        guild.bans.cache.delete(ban.user.id);
        client.emit(Events.GuildBanRemove, ban);
      }
    }
  }
  module.exports = GuildBanRemove;
});

// node_modules/discord.js/src/client/actions/GuildChannelsPositionUpdate.js
var require_GuildChannelsPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildChannelsPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialChannel of data.channels) {
          const channel = guild.channels.cache.get(partialChannel.id);
          if (channel)
            channel.rawPosition = partialChannel.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildChannelsPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildDelete.js
var require_GuildDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      let guild = client.guilds.cache.get(data.id);
      if (guild) {
        if (data.unavailable) {
          guild.available = false;
          client.emit(Events.GuildUnavailable, guild);
          return;
        }
        for (const channel of guild.channels.cache.values())
          this.client.channels._remove(channel.id);
        client.voice.adapters.get(data.id)?.destroy();
        client.guilds.cache.delete(guild.id);
        client.emit(Events.GuildDelete, guild);
      }
    }
  }
  module.exports = GuildDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiCreate.js
var require_GuildEmojiCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiCreateAction extends Action {
    handle(guild, createdEmoji) {
      const already = guild.emojis.cache.has(createdEmoji.id);
      const emoji = guild.emojis._add(createdEmoji);
      if (!already)
        this.client.emit(Events.GuildEmojiCreate, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiDelete.js
var require_GuildEmojiDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiDeleteAction extends Action {
    handle(emoji) {
      emoji.guild.emojis.cache.delete(emoji.id);
      this.client.emit(Events.GuildEmojiDelete, emoji);
      return { emoji };
    }
  }
  module.exports = GuildEmojiDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojiUpdate.js
var require_GuildEmojiUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildEmojiUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildEmojiUpdate, old, current);
      return { emoji: current };
    }
  }
  module.exports = GuildEmojiUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildEmojisUpdate.js
var require_GuildEmojisUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildEmojisUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.emojis)
        return;
      const deletions = new Map(guild.emojis.cache);
      for (const emoji of data.emojis) {
        const cachedEmoji = guild.emojis.cache.get(emoji.id);
        if (cachedEmoji) {
          deletions.delete(emoji.id);
          if (!cachedEmoji.equals(emoji)) {
            this.client.actions.GuildEmojiUpdate.handle(cachedEmoji, emoji);
          }
        } else {
          this.client.actions.GuildEmojiCreate.handle(guild, emoji);
        }
      }
      for (const emoji of deletions.values()) {
        this.client.actions.GuildEmojiDelete.handle(emoji);
      }
    }
  }
  module.exports = GuildEmojisUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildIntegrationsUpdate.js
var require_GuildIntegrationsUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildIntegrationsUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild)
        client.emit(Events.GuildIntegrationsUpdate, guild);
    }
  }
  module.exports = GuildIntegrationsUpdate;
});

// node_modules/discord.js/src/util/Status.js
var require_Status = __commonJS((exports, module) => {
  var { createEnum } = require_Enums();
  module.exports = createEnum([
    "Ready",
    "Connecting",
    "Reconnecting",
    "Idle",
    "Nearly",
    "Disconnected",
    "WaitingForGuilds",
    "Identifying",
    "Resuming"
  ]);
});

// node_modules/discord.js/src/client/actions/GuildMemberRemove.js
var require_GuildMemberRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberRemoveAction extends Action {
    handle(data, shard) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let member = null;
      if (guild) {
        member = this.getMember({ user: data.user }, guild);
        guild.memberCount--;
        if (member) {
          guild.members.cache.delete(member.id);
          if (shard.status === Status.Ready)
            client.emit(Events.GuildMemberRemove, member);
        }
        guild.presences.cache.delete(data.user.id);
        guild.voiceStates.cache.delete(data.user.id);
      }
      return { guild, member };
    }
  }
  module.exports = GuildMemberRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildMemberUpdate.js
var require_GuildMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Status = require_Status();

  class GuildMemberUpdateAction extends Action {
    handle(data, shard) {
      const { client } = this;
      if (data.user.username) {
        const user = client.users.cache.get(data.user.id);
        if (!user) {
          client.users._add(data.user);
        } else if (!user._equals(data.user)) {
          client.actions.UserUpdate.handle(data.user);
        }
      }
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const member = this.getMember({ user: data.user }, guild);
        if (member) {
          const old = member._update(data);
          if (shard.status === Status.Ready && !member.equals(old))
            client.emit(Events.GuildMemberUpdate, old, member);
        } else {
          const newMember = guild.members._add(data);
          this.client.emit(Events.GuildMemberAvailable, newMember);
        }
      }
    }
  }
  module.exports = GuildMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleCreate.js
var require_GuildRoleCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleCreate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        const already = guild.roles.cache.has(data.role.id);
        role = guild.roles._add(data.role);
        if (!already)
          client.emit(Events.GuildRoleCreate, role);
      }
      return { role };
    }
  }
  module.exports = GuildRoleCreate;
});

// node_modules/discord.js/src/client/actions/GuildRoleDelete.js
var require_GuildRoleDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      let role;
      if (guild) {
        role = guild.roles.cache.get(data.role_id);
        if (role) {
          guild.roles.cache.delete(data.role_id);
          client.emit(Events.GuildRoleDelete, role);
        }
      }
      return { role };
    }
  }
  module.exports = GuildRoleDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildRoleUpdate.js
var require_GuildRoleUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildRoleUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        let old = null;
        const role = guild.roles.cache.get(data.role.id);
        if (role) {
          old = role._update(data.role);
          client.emit(Events.GuildRoleUpdate, old, role);
        }
        return {
          old,
          updated: role
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildRoleUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildRolesPositionUpdate.js
var require_GuildRolesPositionUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildRolesPositionUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        for (const partialRole of data.roles) {
          const role = guild.roles.cache.get(partialRole.id);
          if (role)
            role.rawPosition = partialRole.position;
        }
      }
      return { guild };
    }
  }
  module.exports = GuildRolesPositionUpdate;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventCreate.js
var require_GuildScheduledEventCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventCreate, guildScheduledEvent);
        return { guildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventDelete.js
var require_GuildScheduledEventDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        if (guildScheduledEvent) {
          guild.scheduledEvents.cache.delete(guildScheduledEvent.id);
          client.emit(Events.GuildScheduledEventDelete, guildScheduledEvent);
          return { guildScheduledEvent };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUpdate.js
var require_GuildScheduledEventUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldGuildScheduledEvent = guild.scheduledEvents.cache.get(data.id)?._clone() ?? null;
        const newGuildScheduledEvent = guild.scheduledEvents._add(data);
        client.emit(Events.GuildScheduledEventUpdate, oldGuildScheduledEvent, newGuildScheduledEvent);
        return { oldGuildScheduledEvent, newGuildScheduledEvent };
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserAdd.js
var require_GuildScheduledEventUserAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserAddAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserAdd, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserAddAction;
});

// node_modules/discord.js/src/client/actions/GuildScheduledEventUserRemove.js
var require_GuildScheduledEventUserRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildScheduledEventUserRemoveAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const guildScheduledEvent = this.getScheduledEvent(data, guild);
        const user = this.getUser(data);
        if (guildScheduledEvent && user) {
          client.emit(Events.GuildScheduledEventUserRemove, guildScheduledEvent, user);
          return { guildScheduledEvent, user };
        }
      }
      return {};
    }
  }
  module.exports = GuildScheduledEventUserRemoveAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerCreate.js
var require_GuildStickerCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerCreateAction extends Action {
    handle(guild, createdSticker) {
      const already = guild.stickers.cache.has(createdSticker.id);
      const sticker = guild.stickers._add(createdSticker);
      if (!already)
        this.client.emit(Events.GuildStickerCreate, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerCreateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerDelete.js
var require_GuildStickerDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerDeleteAction extends Action {
    handle(sticker) {
      sticker.guild.stickers.cache.delete(sticker.id);
      this.client.emit(Events.GuildStickerDelete, sticker);
      return { sticker };
    }
  }
  module.exports = GuildStickerDeleteAction;
});

// node_modules/discord.js/src/client/actions/GuildStickerUpdate.js
var require_GuildStickerUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildStickerUpdateAction extends Action {
    handle(current, data) {
      const old = current._update(data);
      this.client.emit(Events.GuildStickerUpdate, old, current);
      return { sticker: current };
    }
  }
  module.exports = GuildStickerUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildStickersUpdate.js
var require_GuildStickersUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class GuildStickersUpdateAction extends Action {
    handle(data) {
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild?.stickers)
        return;
      const deletions = new Map(guild.stickers.cache);
      for (const sticker of data.stickers) {
        const cachedSticker = guild.stickers.cache.get(sticker.id);
        if (cachedSticker) {
          deletions.delete(sticker.id);
          if (!cachedSticker.equals(sticker)) {
            this.client.actions.GuildStickerUpdate.handle(cachedSticker, sticker);
          }
        } else {
          this.client.actions.GuildStickerCreate.handle(guild, sticker);
        }
      }
      for (const sticker of deletions.values()) {
        this.client.actions.GuildStickerDelete.handle(sticker);
      }
    }
  }
  module.exports = GuildStickersUpdateAction;
});

// node_modules/discord.js/src/client/actions/GuildUpdate.js
var require_GuildUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class GuildUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.id);
      if (guild) {
        const old = guild._update(data);
        client.emit(Events.GuildUpdate, old, guild);
        return {
          old,
          updated: guild
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = GuildUpdateAction;
});

// node_modules/discord.js/src/structures/CommandInteractionOptionResolver.js
var require_CommandInteractionOptionResolver = __commonJS((exports, module) => {
  var { ApplicationCommandOptionType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class CommandInteractionOptionResolver {
    constructor(client, options, resolved) {
      Object.defineProperty(this, "client", { value: client });
      this._group = null;
      this._subcommand = null;
      this._hoistedOptions = options;
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.SubcommandGroup) {
        this._group = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      if (this._hoistedOptions[0]?.type === ApplicationCommandOptionType.Subcommand) {
        this._subcommand = this._hoistedOptions[0].name;
        this._hoistedOptions = this._hoistedOptions[0].options ?? [];
      }
      Object.defineProperty(this, "data", { value: Object.freeze([...options]) });
      Object.defineProperty(this, "resolved", { value: resolved ? Object.freeze(resolved) : null });
    }
    get(name, required = false) {
      const option = this._hoistedOptions.find((opt) => opt.name === name);
      if (!option) {
        if (required) {
          throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNotFound, name);
        }
        return null;
      }
      return option;
    }
    _getTypedOption(name, allowedTypes, properties, required) {
      const option = this.get(name, required);
      if (!option) {
        return null;
      } else if (!allowedTypes.includes(option.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionType, name, option.type, allowedTypes.join(", "));
      } else if (required && properties.every((prop) => option[prop] === null || option[prop] === undefined)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionEmpty, name, option.type);
      }
      return option;
    }
    getSubcommand(required = true) {
      if (required && !this._subcommand) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommand);
      }
      return this._subcommand;
    }
    getSubcommandGroup(required = false) {
      if (required && !this._group) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionNoSubcommandGroup);
      }
      return this._group;
    }
    getBoolean(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Boolean], ["value"], required);
      return option?.value ?? null;
    }
    getChannel(name, required = false, channelTypes = []) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Channel], ["channel"], required);
      const channel = option?.channel ?? null;
      if (channel && channelTypes.length > 0 && !channelTypes.includes(channel.type)) {
        throw new DiscordjsTypeError(ErrorCodes.CommandInteractionOptionInvalidChannelType, name, channel.type, channelTypes.join(", "));
      }
      return channel;
    }
    getString(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.String], ["value"], required);
      return option?.value ?? null;
    }
    getInteger(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Integer], ["value"], required);
      return option?.value ?? null;
    }
    getNumber(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Number], ["value"], required);
      return option?.value ?? null;
    }
    getUser(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["user"], required);
      return option?.user ?? null;
    }
    getMember(name) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.User, ApplicationCommandOptionType.Mentionable], ["member"], false);
      return option?.member ?? null;
    }
    getRole(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Role, ApplicationCommandOptionType.Mentionable], ["role"], required);
      return option?.role ?? null;
    }
    getAttachment(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Attachment], ["attachment"], required);
      return option?.attachment ?? null;
    }
    getMentionable(name, required = false) {
      const option = this._getTypedOption(name, [ApplicationCommandOptionType.Mentionable], ["user", "member", "role"], required);
      return option?.member ?? option?.user ?? option?.role ?? null;
    }
    getMessage(name, required = false) {
      const option = this._getTypedOption(name, ["_MESSAGE"], ["message"], required);
      return option?.message ?? null;
    }
    getFocused(getFull = false) {
      const focusedOption = this._hoistedOptions.find((option) => option.focused);
      if (!focusedOption)
        throw new DiscordjsTypeError(ErrorCodes.AutocompleteInteractionOptionNoFocusedOption);
      return getFull ? focusedOption : focusedOption.value;
    }
  }
  module.exports = CommandInteractionOptionResolver;
});

// node_modules/discord.js/src/structures/AutocompleteInteraction.js
var require_AutocompleteInteraction = __commonJS((exports, module) => {
  var { InteractionResponseType, Routes } = require_v106();
  var BaseInteraction = require_BaseInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class AutocompleteInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.responded = false;
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options ?? []);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    async respond(options) {
      if (this.responded)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ApplicationCommandAutocompleteResult,
          data: {
            choices: options.map(({ nameLocalizations, ...option }) => ({
              ...this.client.options.jsonTransformer(option),
              name_localizations: nameLocalizations
            }))
          }
        },
        auth: false
      });
      this.responded = true;
    }
  }
  module.exports = AutocompleteInteraction;
});

// node_modules/discord.js/src/structures/InteractionResponse.js
var require_InteractionResponse = __commonJS((exports, module) => {
  var { DiscordSnowflake } = require_dist3();
  var { InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();

  class InteractionResponse {
    constructor(interaction, id) {
      this.interaction = interaction;
      this.id = id ?? interaction.id;
      this.client = interaction.client;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    awaitMessageComponent(options = {}) {
      const _options = { ...options, max: 1 };
      return new Promise((resolve, reject) => {
        const collector = this.createMessageComponentCollector(_options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    createMessageComponentCollector(options = {}) {
      return new InteractionCollector(this.client, {
        ...options,
        interactionResponse: this,
        interactionType: InteractionType.MessageComponent
      });
    }
    fetch() {
      return this.interaction.fetchReply();
    }
    delete() {
      return this.interaction.deleteReply();
    }
    edit(options) {
      return this.interaction.editReply(options);
    }
  }
  var InteractionCollector = require_InteractionCollector();
  module.exports = InteractionResponse;
});

// node_modules/discord.js/src/structures/interfaces/InteractionResponses.js
var require_InteractionResponses = __commonJS((exports, module) => {
  var { isJSONEncodable } = require_dist();
  var { InteractionResponseType, MessageFlags, Routes, InteractionType } = require_v106();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var InteractionCollector = require_InteractionCollector();
  var InteractionResponse = require_InteractionResponse();
  var MessagePayload = require_MessagePayload();

  class InteractionResponses {
    async deferReply(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      this.ephemeral = options.ephemeral ?? false;
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredChannelMessageWithSource,
          data: {
            flags: options.ephemeral ? MessageFlags.Ephemeral : undefined
          }
        },
        auth: false
      });
      this.deferred = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    async reply(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      this.ephemeral = options.ephemeral ?? false;
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.ChannelMessageWithSource,
          data
        },
        files,
        auth: false
      });
      this.replied = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this);
    }
    fetchReply(message = "@original") {
      return this.webhook.fetchMessage(message);
    }
    async editReply(options) {
      if (!this.deferred && !this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionNotReplied);
      const msg = await this.webhook.editMessage(options.message ?? "@original", options);
      this.replied = true;
      return msg;
    }
    async deleteReply(message = "@original") {
      await this.webhook.deleteMessage(message);
    }
    followUp(options) {
      if (!this.deferred && !this.replied)
        return Promise.reject(new DiscordjsError(ErrorCodes.InteractionNotReplied));
      return this.webhook.send(options);
    }
    async deferUpdate(options = {}) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.DeferredMessageUpdate
        },
        auth: false
      });
      this.deferred = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message?.interaction?.id);
    }
    async update(options) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      let messagePayload;
      if (options instanceof MessagePayload)
        messagePayload = options;
      else
        messagePayload = MessagePayload.create(this, options);
      const { body: data, files } = await messagePayload.resolveBody().resolveFiles();
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.UpdateMessage,
          data
        },
        files,
        auth: false
      });
      this.replied = true;
      return options.fetchReply ? this.fetchReply() : new InteractionResponse(this, this.message.interaction?.id);
    }
    async showModal(modal) {
      if (this.deferred || this.replied)
        throw new DiscordjsError(ErrorCodes.InteractionAlreadyReplied);
      await this.client.rest.post(Routes.interactionCallback(this.id, this.token), {
        body: {
          type: InteractionResponseType.Modal,
          data: isJSONEncodable(modal) ? modal.toJSON() : this.client.options.jsonTransformer(modal)
        },
        auth: false
      });
      this.replied = true;
    }
    awaitModalSubmit(options) {
      if (typeof options.time !== "number")
        throw new DiscordjsError(ErrorCodes.InvalidType, "time", "number");
      const _options = { ...options, max: 1, interactionType: InteractionType.ModalSubmit };
      return new Promise((resolve, reject) => {
        const collector = new InteractionCollector(this.client, _options);
        collector.once("end", (interactions, reason) => {
          const interaction = interactions.first();
          if (interaction)
            resolve(interaction);
          else
            reject(new DiscordjsError(ErrorCodes.InteractionCollectorError, reason));
        });
      });
    }
    static applyToClass(structure, ignore = []) {
      const props = [
        "deferReply",
        "reply",
        "fetchReply",
        "editReply",
        "deleteReply",
        "followUp",
        "deferUpdate",
        "update",
        "showModal",
        "awaitModalSubmit"
      ];
      for (const prop of props) {
        if (ignore.includes(prop))
          continue;
        Object.defineProperty(structure.prototype, prop, Object.getOwnPropertyDescriptor(InteractionResponses.prototype, prop));
      }
    }
  }
  module.exports = InteractionResponses;
});

// node_modules/discord.js/src/structures/MessageComponentInteraction.js
var require_MessageComponentInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class MessageComponentInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(client, data.message);
      this.customId = data.data.custom_id;
      this.componentType = data.data.component_type;
      this.deferred = false;
      this.ephemeral = null;
      this.replied = false;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get component() {
      return this.message.components.flatMap((row) => row.components).find((component) => (component.customId ?? component.custom_id) === this.customId);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
    showModal() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(MessageComponentInteraction);
  module.exports = MessageComponentInteraction;
});

// node_modules/discord.js/src/structures/ButtonInteraction.js
var require_ButtonInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ButtonInteraction extends MessageComponentInteraction {
  }
  module.exports = ButtonInteraction;
});

// node_modules/discord.js/src/structures/ChannelSelectMenuInteraction.js
var require_ChannelSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class ChannelSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.channels = new Collection;
      for (const channel of Object.values(resolved?.channels ?? {})) {
        this.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
      }
    }
  }
  module.exports = ChannelSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/CommandInteraction.js
var require_CommandInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Attachment = require_Attachment();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var InteractionResponses = require_InteractionResponses();

  class CommandInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.commandId = data.data.id;
      this.commandName = data.data.name;
      this.commandType = data.data.type;
      this.commandGuildId = data.data.guild_id ?? null;
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    get command() {
      const id = this.commandId;
      return this.guild?.commands.cache.get(id) ?? this.client.application.commands.cache.get(id) ?? null;
    }
    transformResolved({ members, users, channels, roles, messages, attachments }) {
      const result = {};
      if (members) {
        result.members = new Collection;
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          result.members.set(id, this.guild?.members._add({ user, ...member }) ?? member);
        }
      }
      if (users) {
        result.users = new Collection;
        for (const user of Object.values(users)) {
          result.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        result.roles = new Collection;
        for (const role of Object.values(roles)) {
          result.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
      if (channels) {
        result.channels = new Collection;
        for (const channel of Object.values(channels)) {
          result.channels.set(channel.id, this.client.channels._add(channel, this.guild) ?? channel);
        }
      }
      if (messages) {
        result.messages = new Collection;
        for (const message of Object.values(messages)) {
          result.messages.set(message.id, this.channel?.messages?._add(message) ?? message);
        }
      }
      if (attachments) {
        result.attachments = new Collection;
        for (const attachment of Object.values(attachments)) {
          const patched = new Attachment(attachment);
          result.attachments.set(attachment.id, patched);
        }
      }
      return result;
    }
    transformOption(option, resolved) {
      const result = {
        name: option.name,
        type: option.type
      };
      if ("value" in option)
        result.value = option.value;
      if ("options" in option)
        result.options = option.options.map((opt) => this.transformOption(opt, resolved));
      if (resolved) {
        const user = resolved.users?.[option.value];
        if (user)
          result.user = this.client.users._add(user);
        const member = resolved.members?.[option.value];
        if (member)
          result.member = this.guild?.members._add({ user, ...member }) ?? member;
        const channel = resolved.channels?.[option.value];
        if (channel)
          result.channel = this.client.channels._add(channel, this.guild) ?? channel;
        const role = resolved.roles?.[option.value];
        if (role)
          result.role = this.guild?.roles._add(role) ?? role;
        const attachment = resolved.attachments?.[option.value];
        if (attachment)
          result.attachment = new Attachment(attachment);
      }
      return result;
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    showModal() {
    }
    awaitModalSubmit() {
    }
  }
  InteractionResponses.applyToClass(CommandInteraction, ["deferUpdate", "update"]);
  module.exports = CommandInteraction;
});

// node_modules/discord.js/src/structures/ChatInputCommandInteraction.js
var require_ChatInputCommandInteraction = __commonJS((exports, module) => {
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();

  class ChatInputCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, data.data.options?.map((option) => this.transformOption(option, data.data.resolved)) ?? [], this.transformResolved(data.data.resolved ?? {}));
    }
    toString() {
      const properties = [
        this.commandName,
        this.options._group,
        this.options._subcommand,
        ...this.options._hoistedOptions.map((o) => `${o.name}:${o.value}`)
      ];
      return `/${properties.filter(Boolean).join(" ")}`;
    }
  }
  module.exports = ChatInputCommandInteraction;
});

// node_modules/discord.js/src/structures/MentionableSelectMenuInteraction.js
var require_MentionableSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class MentionableSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      const { members, users, roles } = resolved ?? {};
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      this.roles = new Collection;
      if (members) {
        for (const [id, member] of Object.entries(members)) {
          const user = users[id];
          if (!user) {
            this.client.emit(Events.Debug, `[MentionableSelectMenuInteraction] Received a member without a user, skipping ${id}`);
            continue;
          }
          this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
        }
      }
      if (users) {
        for (const user of Object.values(users)) {
          this.users.set(user.id, this.client.users._add(user));
        }
      }
      if (roles) {
        for (const role of Object.values(roles)) {
          this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
        }
      }
    }
  }
  module.exports = MentionableSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/ContextMenuCommandInteraction.js
var require_ContextMenuCommandInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var { ApplicationCommandOptionType } = require_v106();
  var CommandInteraction = require_CommandInteraction();
  var CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  var getMessage = lazy(() => require_Message().Message);

  class ContextMenuCommandInteraction extends CommandInteraction {
    constructor(client, data) {
      super(client, data);
      this.options = new CommandInteractionOptionResolver(this.client, this.resolveContextMenuOptions(data.data), this.transformResolved(data.data.resolved));
      this.targetId = data.data.target_id;
    }
    resolveContextMenuOptions({ target_id, resolved }) {
      const result = [];
      if (resolved.users?.[target_id]) {
        result.push(this.transformOption({ name: "user", type: ApplicationCommandOptionType.User, value: target_id }, resolved));
      }
      if (resolved.messages?.[target_id]) {
        result.push({
          name: "message",
          type: "_MESSAGE",
          value: target_id,
          message: this.channel?.messages._add(resolved.messages[target_id]) ?? new (getMessage())(this.client, resolved.messages[target_id])
        });
      }
      return result;
    }
  }
  module.exports = ContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/MessageContextMenuCommandInteraction.js
var require_MessageContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class MessageContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetMessage() {
      return this.options.getMessage("message");
    }
  }
  module.exports = MessageContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/ModalSubmitFields.js
var require_ModalSubmitFields = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { ComponentType } = require_v106();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ModalSubmitFields {
    constructor(components) {
      this.components = components;
      this.fields = components.reduce((accumulator, next) => {
        next.components.forEach((c) => accumulator.set(c.customId, c));
        return accumulator;
      }, new Collection);
    }
    getField(customId, type) {
      const field = this.fields.get(customId);
      if (!field)
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldNotFound, customId);
      if (type !== undefined && type !== field.type) {
        throw new DiscordjsTypeError(ErrorCodes.ModalSubmitInteractionFieldType, customId, field.type, type);
      }
      return field;
    }
    getTextInputValue(customId) {
      return this.getField(customId, ComponentType.TextInput).value;
    }
  }
  module.exports = ModalSubmitFields;
});

// node_modules/discord.js/src/structures/ModalSubmitInteraction.js
var require_ModalSubmitInteraction = __commonJS((exports, module) => {
  var { lazy } = require_dist();
  var BaseInteraction = require_BaseInteraction();
  var InteractionWebhook = require_InteractionWebhook();
  var ModalSubmitFields = require_ModalSubmitFields();
  var InteractionResponses = require_InteractionResponses();
  var getMessage = lazy(() => require_Message().Message);

  class ModalSubmitInteraction extends BaseInteraction {
    constructor(client, data) {
      super(client, data);
      this.customId = data.data.custom_id;
      if ("message" in data) {
        this.message = this.channel?.messages._add(data.message) ?? new (getMessage())(this.client, data.message);
      } else {
        this.message = null;
      }
      this.components = data.data.components?.map((c) => ModalSubmitInteraction.transformComponent(c));
      this.fields = new ModalSubmitFields(this.components);
      this.deferred = false;
      this.replied = false;
      this.ephemeral = null;
      this.webhook = new InteractionWebhook(this.client, this.applicationId, this.token);
    }
    static transformComponent(rawComponent) {
      return rawComponent.components ? { type: rawComponent.type, components: rawComponent.components.map((c) => this.transformComponent(c)) } : {
        value: rawComponent.value,
        type: rawComponent.type,
        customId: rawComponent.custom_id
      };
    }
    isFromMessage() {
      return Boolean(this.message);
    }
    deferReply() {
    }
    reply() {
    }
    fetchReply() {
    }
    editReply() {
    }
    deleteReply() {
    }
    followUp() {
    }
    deferUpdate() {
    }
    update() {
    }
  }
  InteractionResponses.applyToClass(ModalSubmitInteraction, "showModal");
  module.exports = ModalSubmitInteraction;
});

// node_modules/discord.js/src/structures/RoleSelectMenuInteraction.js
var require_RoleSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class RoleSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.roles = new Collection;
      for (const role of Object.values(resolved?.roles ?? {})) {
        this.roles.set(role.id, this.guild?.roles._add(role) ?? role);
      }
    }
  }
  module.exports = RoleSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuInteraction.js
var require_StringSelectMenuInteraction = __commonJS((exports, module) => {
  var MessageComponentInteraction = require_MessageComponentInteraction();

  class StringSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      this.values = data.data.values ?? [];
    }
  }
  module.exports = StringSelectMenuInteraction;
});

// node_modules/discord.js/src/structures/UserContextMenuCommandInteraction.js
var require_UserContextMenuCommandInteraction = __commonJS((exports, module) => {
  var ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();

  class UserContextMenuCommandInteraction extends ContextMenuCommandInteraction {
    get targetUser() {
      return this.options.getUser("user");
    }
    get targetMember() {
      return this.options.getMember("user");
    }
  }
  module.exports = UserContextMenuCommandInteraction;
});

// node_modules/discord.js/src/structures/UserSelectMenuInteraction.js
var require_UserSelectMenuInteraction = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var MessageComponentInteraction = require_MessageComponentInteraction();
  var Events = require_Events();

  class UserSelectMenuInteraction extends MessageComponentInteraction {
    constructor(client, data) {
      super(client, data);
      const { resolved, values } = data.data;
      this.values = values ?? [];
      this.users = new Collection;
      this.members = new Collection;
      for (const user of Object.values(resolved?.users ?? {})) {
        this.users.set(user.id, this.client.users._add(user));
      }
      for (const [id, member] of Object.entries(resolved?.members ?? {})) {
        const user = resolved.users[id];
        if (!user) {
          this.client.emit(Events.Debug, `[UserSelectMenuInteraction] Received a member without a user, skipping ${id}`);
          continue;
        }
        this.members.set(id, this.guild?.members._add({ user, ...member }) ?? { user, ...member });
      }
    }
  }
  module.exports = UserSelectMenuInteraction;
});

// node_modules/discord.js/src/client/actions/InteractionCreate.js
var require_InteractionCreate = __commonJS((exports, module) => {
  var { InteractionType, ComponentType, ApplicationCommandType } = require_v106();
  var Action = require_Action();
  var AutocompleteInteraction = require_AutocompleteInteraction();
  var ButtonInteraction = require_ButtonInteraction();
  var ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  var ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  var MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  var MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  var ModalSubmitInteraction = require_ModalSubmitInteraction();
  var RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  var UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  var Events = require_Events();

  class InteractionCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = data.channel && this.getChannel(data.channel);
      let InteractionClass;
      switch (data.type) {
        case InteractionType.ApplicationCommand:
          switch (data.data.type) {
            case ApplicationCommandType.ChatInput:
              InteractionClass = ChatInputCommandInteraction;
              break;
            case ApplicationCommandType.User:
              InteractionClass = UserContextMenuCommandInteraction;
              break;
            case ApplicationCommandType.Message:
              if (channel && !channel.isTextBased())
                return;
              InteractionClass = MessageContextMenuCommandInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received application command interaction with unknown type: ${data.data.type}`);
              return;
          }
          break;
        case InteractionType.MessageComponent:
          if (channel && !channel.isTextBased())
            return;
          switch (data.data.component_type) {
            case ComponentType.Button:
              InteractionClass = ButtonInteraction;
              break;
            case ComponentType.StringSelect:
              InteractionClass = StringSelectMenuInteraction;
              break;
            case ComponentType.UserSelect:
              InteractionClass = UserSelectMenuInteraction;
              break;
            case ComponentType.RoleSelect:
              InteractionClass = RoleSelectMenuInteraction;
              break;
            case ComponentType.MentionableSelect:
              InteractionClass = MentionableSelectMenuInteraction;
              break;
            case ComponentType.ChannelSelect:
              InteractionClass = ChannelSelectMenuInteraction;
              break;
            default:
              client.emit(Events.Debug, `[INTERACTION] Received component interaction with unknown type: ${data.data.component_type}`);
              return;
          }
          break;
        case InteractionType.ApplicationCommandAutocomplete:
          InteractionClass = AutocompleteInteraction;
          break;
        case InteractionType.ModalSubmit:
          InteractionClass = ModalSubmitInteraction;
          break;
        default:
          client.emit(Events.Debug, `[INTERACTION] Received interaction with unknown type: ${data.type}`);
          return;
      }
      const interaction = new InteractionClass(client, data);
      client.emit(Events.InteractionCreate, interaction);
    }
  }
  module.exports = InteractionCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteCreate.js
var require_InviteCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class InviteCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = guild.invites._add(inviteData);
      client.emit(Events.InviteCreate, invite);
      return { invite };
    }
  }
  module.exports = InviteCreateAction;
});

// node_modules/discord.js/src/client/actions/InviteDelete.js
var require_InviteDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Invite = require_Invite();
  var Events = require_Events();

  class InviteDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      const guild = client.guilds.cache.get(data.guild_id);
      if (!channel)
        return false;
      const inviteData = Object.assign(data, { channel, guild });
      const invite = new Invite(client, inviteData);
      guild.invites.cache.delete(invite.code);
      client.emit(Events.InviteDelete, invite);
      return { invite };
    }
  }
  module.exports = InviteDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageCreate.js
var require_MessageCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread()) {
          channel.messageCount++;
          channel.totalMessageSent++;
        }
        const existing = channel.messages.cache.get(data.id);
        if (existing)
          return { message: existing };
        const message = channel.messages._add(data);
        channel.lastMessageId = data.id;
        client.emit(Events.MessageCreate, message);
        return { message };
      }
      return {};
    }
  }
  module.exports = MessageCreateAction;
});

// node_modules/discord.js/src/client/actions/MessageDelete.js
var require_MessageDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      let message;
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount--;
        message = this.getMessage(data, channel);
        if (message) {
          channel.messages.cache.delete(message.id);
          client.emit(Events.MessageDelete, message);
        }
      }
      return { message };
    }
  }
  module.exports = MessageDeleteAction;
});

// node_modules/discord.js/src/client/actions/MessageDeleteBulk.js
var require_MessageDeleteBulk = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Action = require_Action();
  var Events = require_Events();

  class MessageDeleteBulkAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        if (channel.isThread())
          channel.messageCount -= data.ids.length;
        const ids = data.ids;
        const messages = new Collection;
        for (const id of ids) {
          const message = this.getMessage({
            id,
            guild_id: data.guild_id
          }, channel, false);
          if (message) {
            messages.set(message.id, message);
            channel.messages.cache.delete(id);
          }
        }
        if (messages.size > 0)
          client.emit(Events.MessageBulkDelete, messages, channel);
        return { messages };
      }
      return {};
    }
  }
  module.exports = MessageDeleteBulkAction;
});

// node_modules/discord.js/src/client/actions/MessageReactionAdd.js
var require_MessageReactionAdd = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();
  var Partials = require_Partials();

  class MessageReactionAdd extends Action {
    handle(data, fromStructure = false) {
      if (!data.emoji)
        return false;
      const user = this.getUserFromMember(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const includePartial = this.client.options.partials.includes(Partials.Reaction);
      if (message.partial && !includePartial)
        return false;
      const reaction = message.reactions._add({
        emoji: data.emoji,
        count: message.partial ? null : 0,
        me: user.id === this.client.user.id
      });
      if (!reaction)
        return false;
      reaction._add(user);
      if (fromStructure)
        return { message, reaction, user };
      this.client.emit(Events.MessageReactionAdd, reaction, user);
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionAdd;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemove.js
var require_MessageReactionRemove = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemove extends Action {
    handle(data) {
      if (!data.emoji)
        return false;
      const user = this.getUser(data);
      if (!user)
        return false;
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message, user);
      if (!reaction)
        return false;
      reaction._remove(user);
      this.client.emit(Events.MessageReactionRemove, reaction, user);
      return { message, reaction, user };
    }
  }
  module.exports = MessageReactionRemove;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveAll.js
var require_MessageReactionRemoveAll = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveAll extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const removed = message.reactions.cache.clone();
      message.reactions.cache.clear();
      this.client.emit(Events.MessageReactionRemoveAll, message, removed);
      return { message };
    }
  }
  module.exports = MessageReactionRemoveAll;
});

// node_modules/discord.js/src/client/actions/MessageReactionRemoveEmoji.js
var require_MessageReactionRemoveEmoji = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class MessageReactionRemoveEmoji extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel?.isTextBased())
        return false;
      const message = this.getMessage(data, channel);
      if (!message)
        return false;
      const reaction = this.getReaction(data, message);
      if (!reaction)
        return false;
      if (!message.partial)
        message.reactions.cache.delete(reaction.emoji.id ?? reaction.emoji.name);
      this.client.emit(Events.MessageReactionRemoveEmoji, reaction);
      return { reaction };
    }
  }
  module.exports = MessageReactionRemoveEmoji;
});

// node_modules/discord.js/src/client/actions/MessageUpdate.js
var require_MessageUpdate = __commonJS((exports, module) => {
  var Action = require_Action();

  class MessageUpdateAction extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (channel) {
        if (!channel.isTextBased())
          return {};
        const { id, channel_id, guild_id, author, timestamp, type } = data;
        const message = this.getMessage({ id, channel_id, guild_id, author, timestamp, type }, channel);
        if (message) {
          const old = message._update(data);
          return {
            old,
            updated: message
          };
        }
      }
      return {};
    }
  }
  module.exports = MessageUpdateAction;
});

// node_modules/discord.js/src/client/actions/PresenceUpdate.js
var require_PresenceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class PresenceUpdateAction extends Action {
    handle(data) {
      let user = this.client.users.cache.get(data.user.id);
      if (!user && data.user.username)
        user = this.client.users._add(data.user);
      if (!user)
        return;
      if (data.user.username) {
        if (!user._equals(data.user))
          this.client.actions.UserUpdate.handle(data.user);
      }
      const guild = this.client.guilds.cache.get(data.guild_id);
      if (!guild)
        return;
      const oldPresence = guild.presences.cache.get(user.id)?._clone() ?? null;
      let member = guild.members.cache.get(user.id);
      if (!member && data.status !== "offline") {
        member = guild.members._add({
          user,
          deaf: false,
          mute: false
        });
        this.client.emit(Events.GuildMemberAvailable, member);
      }
      const newPresence = guild.presences._add(Object.assign(data, { guild }));
      if (this.client.listenerCount(Events.PresenceUpdate) && !newPresence.equals(oldPresence)) {
        this.client.emit(Events.PresenceUpdate, oldPresence, newPresence);
      }
    }
  }
  module.exports = PresenceUpdateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceCreate.js
var require_StageInstanceCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceCreate, stageInstance);
        return { stageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceCreateAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceDelete.js
var require_StageInstanceDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const stageInstance = channel.guild.stageInstances._add(data);
        if (stageInstance) {
          channel.guild.stageInstances.cache.delete(stageInstance.id);
          client.emit(Events.StageInstanceDelete, stageInstance);
          return { stageInstance };
        }
      }
      return {};
    }
  }
  module.exports = StageInstanceDeleteAction;
});

// node_modules/discord.js/src/client/actions/StageInstanceUpdate.js
var require_StageInstanceUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class StageInstanceUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const channel = this.getChannel(data);
      if (channel) {
        const oldStageInstance = channel.guild.stageInstances.cache.get(data.id)?._clone() ?? null;
        const newStageInstance = channel.guild.stageInstances._add(data);
        client.emit(Events.StageInstanceUpdate, oldStageInstance, newStageInstance);
        return { oldStageInstance, newStageInstance };
      }
      return {};
    }
  }
  module.exports = StageInstanceUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadCreate.js
var require_ThreadCreate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadCreateAction extends Action {
    handle(data) {
      const client = this.client;
      const existing = client.channels.cache.has(data.id);
      const thread = client.channels._add(data);
      if (!existing && thread) {
        client.emit(Events.ThreadCreate, thread, data.newly_created ?? false);
      }
      return { thread };
    }
  }
  module.exports = ThreadCreateAction;
});

// node_modules/discord.js/src/client/actions/ThreadDelete.js
var require_ThreadDelete = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadDeleteAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        client.channels._remove(thread.id);
        client.emit(Events.ThreadDelete, thread);
      }
      return { thread };
    }
  }
  module.exports = ThreadDeleteAction;
});

// node_modules/discord.js/src/client/actions/ThreadListSync.js
var require_ThreadListSync = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadListSyncAction extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (!guild)
        return {};
      if (data.channel_ids) {
        for (const id of data.channel_ids) {
          const channel = client.channels.resolve(id);
          if (channel)
            this.removeStale(channel);
        }
      } else {
        for (const channel of guild.channels.cache.values()) {
          this.removeStale(channel);
        }
      }
      const syncedThreads = data.threads.reduce((coll, rawThread) => {
        const thread = client.channels._add(rawThread);
        return coll.set(thread.id, thread);
      }, new Collection);
      for (const rawMember of Object.values(data.members)) {
        const thread = client.channels.cache.get(rawMember.id);
        if (thread) {
          thread.members._add(rawMember);
        }
      }
      client.emit(Events.ThreadListSync, syncedThreads, guild);
      return {
        syncedThreads
      };
    }
    removeStale(channel) {
      channel.threads?.cache.forEach((thread) => {
        if (!thread.archived) {
          this.client.channels._remove(thread.id);
        }
      });
    }
  }
  module.exports = ThreadListSyncAction;
});

// node_modules/discord.js/src/client/actions/ThreadMemberUpdate.js
var require_ThreadMemberUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMemberUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        const member = thread.members.cache.get(data.user_id);
        if (!member) {
          const newMember = thread.members._add(data);
          return { newMember };
        }
        const old = member._update(data);
        client.emit(Events.ThreadMemberUpdate, old, member);
      }
      return {};
    }
  }
  module.exports = ThreadMemberUpdateAction;
});

// node_modules/discord.js/src/client/actions/ThreadMembersUpdate.js
var require_ThreadMembersUpdate = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Action = require_Action();
  var Events = require_Events();

  class ThreadMembersUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const thread = client.channels.cache.get(data.id);
      if (thread) {
        thread.memberCount = data.member_count;
        const addedMembers = new Collection;
        const removedMembers = new Collection;
        data.added_members?.reduce((_addedMembers, addedMember) => _addedMembers.set(addedMember.user_id, thread.members._add(addedMember)), addedMembers);
        data.removed_member_ids?.reduce((removedMembersIds, removedMembersId) => {
          const threadMember = this.getThreadMember(removedMembersId, thread.members);
          if (threadMember)
            removedMembersIds.set(threadMember.id, threadMember);
          thread.members.cache.delete(removedMembersId);
          return removedMembersIds;
        }, removedMembers);
        if (addedMembers.size === 0 && removedMembers.size === 0) {
          return {};
        }
        client.emit(Events.ThreadMembersUpdate, addedMembers, removedMembers, thread);
      }
      return {};
    }
  }
  module.exports = ThreadMembersUpdateAction;
});

// node_modules/discord.js/src/structures/Typing.js
var require_Typing = __commonJS((exports, module) => {
  var Base = require_Base();

  class Typing extends Base {
    constructor(channel, user, data) {
      super(channel.client);
      this.channel = channel;
      this.user = user;
      this._patch(data);
    }
    _patch(data) {
      if ("timestamp" in data) {
        this.startedTimestamp = data.timestamp * 1000;
      }
    }
    inGuild() {
      return this.guild !== null;
    }
    get startedAt() {
      return new Date(this.startedTimestamp);
    }
    get guild() {
      return this.channel.guild ?? null;
    }
    get member() {
      return this.guild?.members.resolve(this.user) ?? null;
    }
  }
  module.exports = Typing;
});

// node_modules/discord.js/src/client/actions/TypingStart.js
var require_TypingStart = __commonJS((exports, module) => {
  var Action = require_Action();
  var Typing = require_Typing();
  var Events = require_Events();

  class TypingStart extends Action {
    handle(data) {
      const channel = this.getChannel(data);
      if (!channel)
        return;
      if (!channel.isTextBased()) {
        this.client.emit(Events.Warn, `Discord sent a typing packet to a ${channel.type} channel ${channel.id}`);
        return;
      }
      const user = this.getUserFromMember(data);
      if (user) {
        this.client.emit(Events.TypingStart, new Typing(channel, user, data));
      }
    }
  }
  module.exports = TypingStart;
});

// node_modules/discord.js/src/client/actions/UserUpdate.js
var require_UserUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var Events = require_Events();

  class UserUpdateAction extends Action {
    handle(data) {
      const client = this.client;
      const newUser = data.id === client.user.id ? client.user : client.users.cache.get(data.id);
      const oldUser = newUser._update(data);
      if (!oldUser.equals(newUser)) {
        client.emit(Events.UserUpdate, oldUser, newUser);
        return {
          old: oldUser,
          updated: newUser
        };
      }
      return {
        old: null,
        updated: null
      };
    }
  }
  module.exports = UserUpdateAction;
});

// node_modules/discord.js/src/client/actions/VoiceStateUpdate.js
var require_VoiceStateUpdate = __commonJS((exports, module) => {
  var Action = require_Action();
  var VoiceState = require_VoiceState();
  var Events = require_Events();

  class VoiceStateUpdate extends Action {
    handle(data) {
      const client = this.client;
      const guild = client.guilds.cache.get(data.guild_id);
      if (guild) {
        const oldState = guild.voiceStates.cache.get(data.user_id)?._clone() ?? new VoiceState(guild, { user_id: data.user_id });
        const newState = guild.voiceStates._add(data);
        let member = guild.members.cache.get(data.user_id);
        if (member && data.member) {
          member._patch(data.member);
        } else if (data.member?.user && data.member.joined_at) {
          member = guild.members._add(data.member);
        }
        if (member?.user.id === client.user.id) {
          client.emit("debug", `[VOICE] received voice state update: ${JSON.stringify(data)}`);
          client.voice.onVoiceStateUpdate(data);
        }
        client.emit(Events.VoiceStateUpdate, oldState, newState);
      }
    }
  }
  module.exports = VoiceStateUpdate;
});

// node_modules/discord.js/src/client/actions/WebhooksUpdate.js
var require_WebhooksUpdate = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var Action = require_Action();
  var deprecationEmitted = false;

  class WebhooksUpdate extends Action {
    handle(data) {
      const client = this.client;
      const channel = client.channels.cache.get(data.channel_id);
      if (!channel)
        return;
      client.emit("webhooksUpdate", channel);
      if (client.emit("webhookUpdate", channel) && !deprecationEmitted) {
        deprecationEmitted = true;
        process2.emitWarning("The webhookUpdate event is deprecated. Use webhooksUpdate instead.", "DeprecationWarning");
      }
    }
  }
  module.exports = WebhooksUpdate;
});

// node_modules/discord.js/src/client/actions/ActionsManager.js
var require_ActionsManager = __commonJS((exports, module) => {
  class ActionsManager {
    injectedUser = Symbol("djs.actions.injectedUser");
    injectedChannel = Symbol("djs.actions.injectedChannel");
    injectedMessage = Symbol("djs.actions.injectedMessage");
    constructor(client) {
      this.client = client;
      this.register(require_ApplicationCommandPermissionsUpdate());
      this.register(require_AutoModerationActionExecution2());
      this.register(require_AutoModerationRuleCreate());
      this.register(require_AutoModerationRuleDelete());
      this.register(require_AutoModerationRuleUpdate());
      this.register(require_ChannelCreate());
      this.register(require_ChannelDelete());
      this.register(require_ChannelUpdate());
      this.register(require_GuildAuditLogEntryCreate());
      this.register(require_GuildBanAdd());
      this.register(require_GuildBanRemove());
      this.register(require_GuildChannelsPositionUpdate());
      this.register(require_GuildDelete());
      this.register(require_GuildEmojiCreate());
      this.register(require_GuildEmojiDelete());
      this.register(require_GuildEmojiUpdate());
      this.register(require_GuildEmojisUpdate());
      this.register(require_GuildIntegrationsUpdate());
      this.register(require_GuildMemberRemove());
      this.register(require_GuildMemberUpdate());
      this.register(require_GuildRoleCreate());
      this.register(require_GuildRoleDelete());
      this.register(require_GuildRoleUpdate());
      this.register(require_GuildRolesPositionUpdate());
      this.register(require_GuildScheduledEventCreate());
      this.register(require_GuildScheduledEventDelete());
      this.register(require_GuildScheduledEventUpdate());
      this.register(require_GuildScheduledEventUserAdd());
      this.register(require_GuildScheduledEventUserRemove());
      this.register(require_GuildStickerCreate());
      this.register(require_GuildStickerDelete());
      this.register(require_GuildStickerUpdate());
      this.register(require_GuildStickersUpdate());
      this.register(require_GuildUpdate());
      this.register(require_InteractionCreate());
      this.register(require_InviteCreate());
      this.register(require_InviteDelete());
      this.register(require_MessageCreate());
      this.register(require_MessageDelete());
      this.register(require_MessageDeleteBulk());
      this.register(require_MessageReactionAdd());
      this.register(require_MessageReactionRemove());
      this.register(require_MessageReactionRemoveAll());
      this.register(require_MessageReactionRemoveEmoji());
      this.register(require_MessageUpdate());
      this.register(require_PresenceUpdate());
      this.register(require_StageInstanceCreate());
      this.register(require_StageInstanceDelete());
      this.register(require_StageInstanceUpdate());
      this.register(require_ThreadCreate());
      this.register(require_ThreadDelete());
      this.register(require_ThreadListSync());
      this.register(require_ThreadMemberUpdate());
      this.register(require_ThreadMembersUpdate());
      this.register(require_TypingStart());
      this.register(require_UserUpdate());
      this.register(require_VoiceStateUpdate());
      this.register(require_WebhooksUpdate());
    }
    register(Action) {
      this[Action.name.replace(/Action$/, "")] = new Action(this.client);
    }
  }
  module.exports = ActionsManager;
});

// node_modules/discord.js/src/client/voice/ClientVoiceManager.js
var require_ClientVoiceManager = __commonJS((exports, module) => {
  var Events = require_Events();

  class ClientVoiceManager {
    constructor(client) {
      Object.defineProperty(this, "client", { value: client });
      this.adapters = new Map;
      client.on(Events.ShardDisconnect, (_, shardId) => {
        for (const [guildId, adapter] of this.adapters.entries()) {
          if (client.guilds.cache.get(guildId)?.shardId === shardId) {
            adapter.destroy();
          }
        }
      });
    }
    onVoiceServer(payload) {
      this.adapters.get(payload.guild_id)?.onVoiceServerUpdate(payload);
    }
    onVoiceStateUpdate(payload) {
      if (payload.guild_id && payload.session_id && payload.user_id === this.client.user?.id) {
        this.adapters.get(payload.guild_id)?.onVoiceStateUpdate(payload);
      }
    }
  }
  module.exports = ClientVoiceManager;
});

// node_modules/ws/lib/constants.js
var require_constants5 = __commonJS((exports, module) => {
  module.exports = {
    BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
    EMPTY_BUFFER: Buffer.alloc(0),
    GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
    kListener: Symbol("kListener"),
    kStatusCode: Symbol("status-code"),
    kWebSocket: Symbol("websocket"),
    NOOP: () => {
    }
  };
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS((exports, module) => {
  var concat = function(list, totalLength) {
    if (list.length === 0)
      return EMPTY_BUFFER;
    if (list.length === 1)
      return list[0];
    const target = Buffer.allocUnsafe(totalLength);
    let offset = 0;
    for (let i = 0;i < list.length; i++) {
      const buf = list[i];
      target.set(buf, offset);
      offset += buf.length;
    }
    if (offset < totalLength) {
      return new FastBuffer(target.buffer, target.byteOffset, offset);
    }
    return target;
  };
  var _mask = function(source, mask, output, offset, length) {
    for (let i = 0;i < length; i++) {
      output[offset + i] = source[i] ^ mask[i & 3];
    }
  };
  var _unmask = function(buffer, mask) {
    for (let i = 0;i < buffer.length; i++) {
      buffer[i] ^= mask[i & 3];
    }
  };
  var toArrayBuffer = function(buf) {
    if (buf.length === buf.buffer.byteLength) {
      return buf.buffer;
    }
    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
  };
  var toBuffer = function(data) {
    toBuffer.readOnly = true;
    if (Buffer.isBuffer(data))
      return data;
    let buf;
    if (data instanceof ArrayBuffer) {
      buf = new FastBuffer(data);
    } else if (ArrayBuffer.isView(data)) {
      buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
    } else {
      buf = Buffer.from(data);
      toBuffer.readOnly = false;
    }
    return buf;
  };
  var { EMPTY_BUFFER } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  module.exports = {
    concat,
    mask: _mask,
    toArrayBuffer,
    toBuffer,
    unmask: _unmask
  };
  if (!process.env.WS_NO_BUFFER_UTIL) {
    try {
      const bufferUtil = (()=>{ throw new Error(`Cannot require module "bufferutil"`);})();
      module.exports.mask = function(source, mask, output, offset, length) {
        if (length < 48)
          _mask(source, mask, output, offset, length);
        else
          bufferUtil.mask(source, mask, output, offset, length);
      };
      module.exports.unmask = function(buffer, mask) {
        if (buffer.length < 32)
          _unmask(buffer, mask);
        else
          bufferUtil.unmask(buffer, mask);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS((exports, module) => {
  var kDone = Symbol("kDone");
  var kRun = Symbol("kRun");

  class Limiter {
    constructor(concurrency) {
      this[kDone] = () => {
        this.pending--;
        this[kRun]();
      };
      this.concurrency = concurrency || Infinity;
      this.jobs = [];
      this.pending = 0;
    }
    add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    [kRun]() {
      if (this.pending === this.concurrency)
        return;
      if (this.jobs.length) {
        const job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }
  module.exports = Limiter;
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS((exports, module) => {
  var deflateOnData = function(chunk) {
    this[kBuffers].push(chunk);
    this[kTotalLength] += chunk.length;
  };
  var inflateOnData = function(chunk) {
    this[kTotalLength] += chunk.length;
    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
      this[kBuffers].push(chunk);
      return;
    }
    this[kError] = new RangeError("Max payload size exceeded");
    this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
    this[kError][kStatusCode] = 1009;
    this.removeListener("data", inflateOnData);
    this.reset();
  };
  var inflateOnError = function(err) {
    this[kPerMessageDeflate]._inflate = null;
    err[kStatusCode] = 1007;
    this[kCallback](err);
  };
  var zlib = __require("zlib");
  var bufferUtil = require_buffer_util();
  var Limiter = require_limiter();
  var { kStatusCode } = require_constants5();
  var FastBuffer = Buffer[Symbol.species];
  var TRAILER = Buffer.from([0, 0, 255, 255]);
  var kPerMessageDeflate = Symbol("permessage-deflate");
  var kTotalLength = Symbol("total-length");
  var kCallback = Symbol("callback");
  var kBuffers = Symbol("buffers");
  var kError = Symbol("error");
  var zlibLimiter;

  class PerMessageDeflate {
    constructor(options, isServer, maxPayload) {
      this._maxPayload = maxPayload | 0;
      this._options = options || {};
      this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
      this._isServer = !!isServer;
      this._deflate = null;
      this._inflate = null;
      this.params = null;
      if (!zlibLimiter) {
        const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
        zlibLimiter = new Limiter(concurrency);
      }
    }
    static get extensionName() {
      return "permessage-deflate";
    }
    offer() {
      const params = {};
      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }
      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }
      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }
      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }
      return params;
    }
    accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    cleanup() {
      if (this._inflate) {
        this._inflate.close();
        this._inflate = null;
      }
      if (this._deflate) {
        const callback = this._deflate[kCallback];
        this._deflate.close();
        this._deflate = null;
        if (callback) {
          callback(new Error("The deflate stream was closed while data was being processed"));
        }
      }
    }
    acceptAsServer(offers) {
      const opts = this._options;
      const accepted = offers.find((params) => {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
          return false;
        }
        return true;
      });
      if (!accepted) {
        throw new Error("None of the extension offers can be accepted");
      }
      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }
      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }
      if (typeof opts.serverMaxWindowBits === "number") {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }
      if (typeof opts.clientMaxWindowBits === "number") {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }
      return accepted;
    }
    acceptAsClient(response) {
      const params = response[0];
      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }
      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === "number") {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }
      return params;
    }
    normalizeParams(configurations) {
      configurations.forEach((params) => {
        Object.keys(params).forEach((key) => {
          let value = params[key];
          if (value.length > 1) {
            throw new Error(`Parameter "${key}" must have only a single value`);
          }
          value = value[0];
          if (key === "client_max_window_bits") {
            if (value !== true) {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (!this._isServer) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else if (key === "server_max_window_bits") {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
            value = num;
          } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
            if (value !== true) {
              throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
            }
          } else {
            throw new Error(`Unknown parameter "${key}"`);
          }
          params[key] = value;
        });
      });
      return configurations;
    }
    decompress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._decompress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    compress(data, fin, callback) {
      zlibLimiter.add((done) => {
        this._compress(data, fin, (err, result) => {
          done();
          callback(err, result);
        });
      });
    }
    _decompress(data, fin, callback) {
      const endpoint = this._isServer ? "client" : "server";
      if (!this._inflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw({
          ...this._options.zlibInflateOptions,
          windowBits
        });
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];
        this._inflate.on("error", inflateOnError);
        this._inflate.on("data", inflateOnData);
      }
      this._inflate[kCallback] = callback;
      this._inflate.write(data);
      if (fin)
        this._inflate.write(TRAILER);
      this._inflate.flush(() => {
        const err = this._inflate[kError];
        if (err) {
          this._inflate.close();
          this._inflate = null;
          callback(err);
          return;
        }
        const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
        if (this._inflate._readableState.endEmitted) {
          this._inflate.close();
          this._inflate = null;
        } else {
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.reset();
          }
        }
        callback(null, data2);
      });
    }
    _compress(data, fin, callback) {
      const endpoint = this._isServer ? "server" : "client";
      if (!this._deflate) {
        const key = `${endpoint}_max_window_bits`;
        const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw({
          ...this._options.zlibDeflateOptions,
          windowBits
        });
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        this._deflate.on("data", deflateOnData);
      }
      this._deflate[kCallback] = callback;
      this._deflate.write(data);
      this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
        if (!this._deflate) {
          return;
        }
        let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
        if (fin) {
          data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
        }
        this._deflate[kCallback] = null;
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];
        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._deflate.reset();
        }
        callback(null, data2);
      });
    }
  }
  module.exports = PerMessageDeflate;
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS((exports, module) => {
  var isValidStatusCode = function(code) {
    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
  };
  var _isValidUTF8 = function(buf) {
    const len = buf.length;
    let i = 0;
    while (i < len) {
      if ((buf[i] & 128) === 0) {
        i++;
      } else if ((buf[i] & 224) === 192) {
        if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
          return false;
        }
        i += 2;
      } else if ((buf[i] & 240) === 224) {
        if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
          return false;
        }
        i += 3;
      } else if ((buf[i] & 248) === 240) {
        if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
          return false;
        }
        i += 4;
      } else {
        return false;
      }
    }
    return true;
  };
  var { isUtf8 } = __require("buffer");
  var tokenChars = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    1,
    0,
    1,
    0
  ];
  module.exports = {
    isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars
  };
  if (isUtf8) {
    module.exports.isValidUTF8 = function(buf) {
      return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
    };
  } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
    try {
      const isValidUTF8 = (()=>{ throw new Error(`Cannot require module "utf-8-validate"`);})();
      module.exports.isValidUTF8 = function(buf) {
        return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
      };
    } catch (e) {
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver2 = __commonJS((exports, module) => {
  var error = function(ErrorCtor, message, prefix, statusCode, errorCode) {
    const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
    Error.captureStackTrace(err, error);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  };
  var { Writable } = __require("stream");
  var PerMessageDeflate = require_permessage_deflate();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    kStatusCode,
    kWebSocket
  } = require_constants5();
  var { concat, toArrayBuffer, unmask } = require_buffer_util();
  var { isValidStatusCode, isValidUTF8 } = require_validation();
  var FastBuffer = Buffer[Symbol.species];
  var promise = Promise.resolve();
  var GET_INFO = 0;
  var GET_PAYLOAD_LENGTH_16 = 1;
  var GET_PAYLOAD_LENGTH_64 = 2;
  var GET_MASK = 3;
  var GET_DATA = 4;
  var INFLATING = 5;
  var WAIT_MICROTASK = 6;

  class Receiver extends Writable {
    constructor(options = {}) {
      super();
      this._binaryType = options.binaryType || BINARY_TYPES[0];
      this._extensions = options.extensions || {};
      this._isServer = !!options.isServer;
      this._maxPayload = options.maxPayload | 0;
      this._skipUTF8Validation = !!options.skipUTF8Validation;
      this[kWebSocket] = undefined;
      this._bufferedBytes = 0;
      this._buffers = [];
      this._compressed = false;
      this._payloadLength = 0;
      this._mask = undefined;
      this._fragmented = 0;
      this._masked = false;
      this._fin = false;
      this._opcode = 0;
      this._totalPayloadLength = 0;
      this._messageLength = 0;
      this._fragments = [];
      this._state = GET_INFO;
      this._loop = false;
    }
    _write(chunk, encoding, cb) {
      if (this._opcode === 8 && this._state == GET_INFO)
        return cb();
      this._bufferedBytes += chunk.length;
      this._buffers.push(chunk);
      this.startLoop(cb);
    }
    consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length)
        return this._buffers.shift();
      if (n < this._buffers[0].length) {
        const buf = this._buffers[0];
        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        return new FastBuffer(buf.buffer, buf.byteOffset, n);
      }
      const dst = Buffer.allocUnsafe(n);
      do {
        const buf = this._buffers[0];
        const offset = dst.length - n;
        if (n >= buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
        }
        n -= buf.length;
      } while (n > 0);
      return dst;
    }
    startLoop(cb) {
      let err;
      this._loop = true;
      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;
          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;
          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;
          case GET_MASK:
            this.getMask();
            break;
          case GET_DATA:
            err = this.getData(cb);
            break;
          case INFLATING:
            this._loop = false;
            return;
          default:
            this._loop = false;
            promise.then(() => {
              this._state = GET_INFO;
              this.startLoop(cb);
            });
            return;
        }
      } while (this._loop);
      cb(err);
    }
    getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      const buf = this.consume(2);
      if ((buf[0] & 48) !== 0) {
        this._loop = false;
        return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
      }
      const compressed = (buf[0] & 64) === 64;
      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
      }
      this._fin = (buf[0] & 128) === 128;
      this._opcode = buf[0] & 15;
      this._payloadLength = buf[1] & 127;
      if (this._opcode === 0) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._opcode = this._fragmented;
      } else if (this._opcode === 1 || this._opcode === 2) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        this._compressed = compressed;
      } else if (this._opcode > 7 && this._opcode < 11) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
        }
        if (compressed) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
          this._loop = false;
          return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
        }
      } else {
        this._loop = false;
        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
      }
      if (!this._fin && !this._fragmented)
        this._fragmented = this._opcode;
      this._masked = (buf[1] & 128) === 128;
      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
      }
      if (this._payloadLength === 126)
        this._state = GET_PAYLOAD_LENGTH_16;
      else if (this._payloadLength === 127)
        this._state = GET_PAYLOAD_LENGTH_64;
      else
        return this.haveLength();
    }
    getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }
      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }
      const buf = this.consume(8);
      const num = buf.readUInt32BE(0);
      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
      }
      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    haveLength() {
      if (this._payloadLength && this._opcode < 8) {
        this._totalPayloadLength += this._payloadLength;
        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
        }
      }
      if (this._masked)
        this._state = GET_MASK;
      else
        this._state = GET_DATA;
    }
    getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }
      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    getData(cb) {
      let data = EMPTY_BUFFER;
      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }
        data = this.consume(this._payloadLength);
        if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
          unmask(data, this._mask);
        }
      }
      if (this._opcode > 7)
        return this.controlMessage(data);
      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }
      if (data.length) {
        this._messageLength = this._totalPayloadLength;
        this._fragments.push(data);
      }
      return this.dataMessage();
    }
    decompress(data, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, (err, buf) => {
        if (err)
          return cb(err);
        if (buf.length) {
          this._messageLength += buf.length;
          if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
            return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
          }
          this._fragments.push(buf);
        }
        const er = this.dataMessage();
        if (er)
          return cb(er);
        this.startLoop(cb);
      });
    }
    dataMessage() {
      if (this._fin) {
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          this.emit("message", data, true);
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("message", buf, false);
        }
      }
      this._state = WAIT_MICROTASK;
    }
    controlMessage(data) {
      if (this._opcode === 8) {
        this._loop = false;
        if (data.length === 0) {
          this.emit("conclude", 1005, EMPTY_BUFFER);
          this.end();
          this._state = GET_INFO;
        } else {
          const code = data.readUInt16BE(0);
          if (!isValidStatusCode(code)) {
            return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
          }
          const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
          }
          this.emit("conclude", code, buf);
          this.end();
          this._state = GET_INFO;
        }
      } else if (this._opcode === 9) {
        this.emit("ping", data);
        this._state = WAIT_MICROTASK;
      } else {
        this.emit("pong", data);
        this._state = WAIT_MICROTASK;
      }
    }
  }
  module.exports = Receiver;
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS((exports, module) => {
  var { Duplex } = __require("stream");
  var { randomFillSync } = __require("crypto");
  var PerMessageDeflate = require_permessage_deflate();
  var { EMPTY_BUFFER } = require_constants5();
  var { isValidStatusCode } = require_validation();
  var { mask: applyMask, toBuffer } = require_buffer_util();
  var kByteLength = Symbol("kByteLength");
  var maskBuffer = Buffer.alloc(4);

  class Sender {
    constructor(socket, extensions, generateMask) {
      this._extensions = extensions || {};
      if (generateMask) {
        this._generateMask = generateMask;
        this._maskBuffer = Buffer.alloc(4);
      }
      this._socket = socket;
      this._firstFragment = true;
      this._compress = false;
      this._bufferedBytes = 0;
      this._deflating = false;
      this._queue = [];
    }
    static frame(data, options) {
      let mask;
      let merge = false;
      let offset = 2;
      let skipMasking = false;
      if (options.mask) {
        mask = options.maskBuffer || maskBuffer;
        if (options.generateMask) {
          options.generateMask(mask);
        } else {
          randomFillSync(mask, 0, 4);
        }
        skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
        offset = 6;
      }
      let dataLength;
      if (typeof data === "string") {
        if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
          dataLength = options[kByteLength];
        } else {
          data = Buffer.from(data);
          dataLength = data.length;
        }
      } else {
        dataLength = data.length;
        merge = options.mask && options.readOnly && !skipMasking;
      }
      let payloadLength = dataLength;
      if (dataLength >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (dataLength > 125) {
        offset += 2;
        payloadLength = 126;
      }
      const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
      target[0] = options.fin ? options.opcode | 128 : options.opcode;
      if (options.rsv1)
        target[0] |= 64;
      target[1] = payloadLength;
      if (payloadLength === 126) {
        target.writeUInt16BE(dataLength, 2);
      } else if (payloadLength === 127) {
        target[2] = target[3] = 0;
        target.writeUIntBE(dataLength, 4, 6);
      }
      if (!options.mask)
        return [target, data];
      target[1] |= 128;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];
      if (skipMasking)
        return [target, data];
      if (merge) {
        applyMask(data, mask, target, offset, dataLength);
        return [target];
      }
      applyMask(data, mask, data, 0, dataLength);
      return [target, data];
    }
    close(code, data, mask, cb) {
      let buf;
      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== "number" || !isValidStatusCode(code)) {
        throw new TypeError("First argument must be a valid error code number");
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        const length = Buffer.byteLength(data);
        if (length > 123) {
          throw new RangeError("The message must not be greater than 123 bytes");
        }
        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);
        if (typeof data === "string") {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }
      const options = {
        [kByteLength]: buf.length,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 8,
        readOnly: false,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, buf, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(buf, options), cb);
      }
    }
    ping(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 9,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    pong(data, mask, cb) {
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (byteLength > 125) {
        throw new RangeError("The data size must not be greater than 125 bytes");
      }
      const options = {
        [kByteLength]: byteLength,
        fin: true,
        generateMask: this._generateMask,
        mask,
        maskBuffer: this._maskBuffer,
        opcode: 10,
        readOnly,
        rsv1: false
      };
      if (this._deflating) {
        this.enqueue([this.dispatch, data, false, options, cb]);
      } else {
        this.sendFrame(Sender.frame(data, options), cb);
      }
    }
    send(data, options, cb) {
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      let opcode = options.binary ? 2 : 1;
      let rsv1 = options.compress;
      let byteLength;
      let readOnly;
      if (typeof data === "string") {
        byteLength = Buffer.byteLength(data);
        readOnly = false;
      } else {
        data = toBuffer(data);
        byteLength = data.length;
        readOnly = toBuffer.readOnly;
      }
      if (this._firstFragment) {
        this._firstFragment = false;
        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
          rsv1 = byteLength >= perMessageDeflate._threshold;
        }
        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }
      if (options.fin)
        this._firstFragment = true;
      if (perMessageDeflate) {
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (this._deflating) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(data, {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1: false
        }), cb);
      }
    }
    dispatch(data, compress, options, cb) {
      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }
      const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += options[kByteLength];
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, (_, buf) => {
        if (this._socket.destroyed) {
          const err = new Error("The socket was closed while data was being compressed");
          if (typeof cb === "function")
            cb(err);
          for (let i = 0;i < this._queue.length; i++) {
            const params = this._queue[i];
            const callback = params[params.length - 1];
            if (typeof callback === "function")
              callback(err);
          }
          return;
        }
        this._bufferedBytes -= options[kByteLength];
        this._deflating = false;
        options.readOnly = false;
        this.sendFrame(Sender.frame(buf, options), cb);
        this.dequeue();
      });
    }
    dequeue() {
      while (!this._deflating && this._queue.length) {
        const params = this._queue.shift();
        this._bufferedBytes -= params[3][kByteLength];
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    enqueue(params) {
      this._bufferedBytes += params[3][kByteLength];
      this._queue.push(params);
    }
    sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();
        this._socket.write(list[0]);
        this._socket.write(list[1], cb);
        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }
  module.exports = Sender;
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS((exports, module) => {
  var callListener = function(listener, thisArg, event) {
    if (typeof listener === "object" && listener.handleEvent) {
      listener.handleEvent.call(listener, event);
    } else {
      listener.call(thisArg, event);
    }
  };
  var { kForOnEventAttribute, kListener } = require_constants5();
  var kCode = Symbol("kCode");
  var kData = Symbol("kData");
  var kError = Symbol("kError");
  var kMessage = Symbol("kMessage");
  var kReason = Symbol("kReason");
  var kTarget = Symbol("kTarget");
  var kType = Symbol("kType");
  var kWasClean = Symbol("kWasClean");

  class Event2 {
    constructor(type) {
      this[kTarget] = null;
      this[kType] = type;
    }
    get target() {
      return this[kTarget];
    }
    get type() {
      return this[kType];
    }
  }
  Object.defineProperty(Event2.prototype, "target", { enumerable: true });
  Object.defineProperty(Event2.prototype, "type", { enumerable: true });

  class CloseEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kCode] = options.code === undefined ? 0 : options.code;
      this[kReason] = options.reason === undefined ? "" : options.reason;
      this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    }
    get code() {
      return this[kCode];
    }
    get reason() {
      return this[kReason];
    }
    get wasClean() {
      return this[kWasClean];
    }
  }
  Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
  Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });

  class ErrorEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kError] = options.error === undefined ? null : options.error;
      this[kMessage] = options.message === undefined ? "" : options.message;
    }
    get error() {
      return this[kError];
    }
    get message() {
      return this[kMessage];
    }
  }
  Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
  Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });

  class MessageEvent extends Event2 {
    constructor(type, options = {}) {
      super(type);
      this[kData] = options.data === undefined ? null : options.data;
    }
    get data() {
      return this[kData];
    }
  }
  Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
  var EventTarget2 = {
    addEventListener(type, handler, options = {}) {
      for (const listener of this.listeners(type)) {
        if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          return;
        }
      }
      let wrapper;
      if (type === "message") {
        wrapper = function onMessage(data, isBinary) {
          const event = new MessageEvent("message", {
            data: isBinary ? data : data.toString()
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "close") {
        wrapper = function onClose(code, message) {
          const event = new CloseEvent("close", {
            code,
            reason: message.toString(),
            wasClean: this._closeFrameReceived && this._closeFrameSent
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "error") {
        wrapper = function onError(error) {
          const event = new ErrorEvent("error", {
            error,
            message: error.message
          });
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else if (type === "open") {
        wrapper = function onOpen() {
          const event = new Event2("open");
          event[kTarget] = this;
          callListener(handler, this, event);
        };
      } else {
        return;
      }
      wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
      wrapper[kListener] = handler;
      if (options.once) {
        this.once(type, wrapper);
      } else {
        this.on(type, wrapper);
      }
    },
    removeEventListener(type, handler) {
      for (const listener of this.listeners(type)) {
        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    }
  };
  module.exports = {
    CloseEvent,
    ErrorEvent,
    Event: Event2,
    EventTarget: EventTarget2,
    MessageEvent
  };
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS((exports, module) => {
  var push = function(dest, name, elem) {
    if (dest[name] === undefined)
      dest[name] = [elem];
    else
      dest[name].push(elem);
  };
  var parse = function(header) {
    const offers = Object.create(null);
    let params = Object.create(null);
    let mustUnescape = false;
    let isEscaping = false;
    let inQuotes = false;
    let extensionName;
    let paramName;
    let start = -1;
    let code = -1;
    let end = -1;
    let i = 0;
    for (;i < header.length; i++) {
      code = header.charCodeAt(i);
      if (extensionName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          const name = header.slice(start, end);
          if (code === 44) {
            push(offers, name, params);
            params = Object.create(null);
          } else {
            extensionName = name;
          }
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (paramName === undefined) {
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (code === 32 || code === 9) {
          if (end === -1 && start !== -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          push(params, header.slice(start, end), true);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          start = end = -1;
        } else if (code === 61 && start !== -1 && end === -1) {
          paramName = header.slice(start, i);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else {
        if (isEscaping) {
          if (tokenChars[code] !== 1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (start === -1)
            start = i;
          else if (!mustUnescape)
            mustUnescape = true;
          isEscaping = false;
        } else if (inQuotes) {
          if (tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 34 && start !== -1) {
            inQuotes = false;
            end = i;
          } else if (code === 92) {
            isEscaping = true;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
          inQuotes = true;
        } else if (end === -1 && tokenChars[code] === 1) {
          if (start === -1)
            start = i;
        } else if (start !== -1 && (code === 32 || code === 9)) {
          if (end === -1)
            end = i;
        } else if (code === 59 || code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1)
            end = i;
          let value = header.slice(start, end);
          if (mustUnescape) {
            value = value.replace(/\\/g, "");
            mustUnescape = false;
          }
          push(params, paramName, value);
          if (code === 44) {
            push(offers, extensionName, params);
            params = Object.create(null);
            extensionName = undefined;
          }
          paramName = undefined;
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
    }
    if (start === -1 || inQuotes || code === 32 || code === 9) {
      throw new SyntaxError("Unexpected end of input");
    }
    if (end === -1)
      end = i;
    const token = header.slice(start, end);
    if (extensionName === undefined) {
      push(offers, token, params);
    } else {
      if (paramName === undefined) {
        push(params, token, true);
      } else if (mustUnescape) {
        push(params, paramName, token.replace(/\\/g, ""));
      } else {
        push(params, paramName, token);
      }
      push(offers, extensionName, params);
    }
    return offers;
  };
  var format = function(extensions) {
    return Object.keys(extensions).map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations))
        configurations = [configurations];
      return configurations.map((params) => {
        return [extension].concat(Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values))
            values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })).join("; ");
      }).join(", ");
    }).join(", ");
  };
  var { tokenChars } = require_validation();
  module.exports = { format, parse };
});

// node_modules/ws/lib/websocket.js
var require_websocket2 = __commonJS((exports, module) => {
  var initAsClient = function(websocket, address, protocols, options) {
    const opts = {
      protocolVersion: protocolVersions[1],
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: true,
      followRedirects: false,
      maxRedirects: 10,
      ...options,
      createConnection: undefined,
      socketPath: undefined,
      hostname: undefined,
      protocol: undefined,
      timeout: undefined,
      method: "GET",
      host: undefined,
      path: undefined,
      port: undefined
    };
    if (!protocolVersions.includes(opts.protocolVersion)) {
      throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(", ")})`);
    }
    let parsedUrl;
    if (address instanceof URL2) {
      parsedUrl = address;
    } else {
      try {
        parsedUrl = new URL2(address);
      } catch (e) {
        throw new SyntaxError(`Invalid URL: ${address}`);
      }
    }
    if (parsedUrl.protocol === "http:") {
      parsedUrl.protocol = "ws:";
    } else if (parsedUrl.protocol === "https:") {
      parsedUrl.protocol = "wss:";
    }
    websocket._url = parsedUrl.href;
    const isSecure = parsedUrl.protocol === "wss:";
    const isIpcUrl = parsedUrl.protocol === "ws+unix:";
    let invalidUrlMessage;
    if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
      invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"';
    } else if (isIpcUrl && !parsedUrl.pathname) {
      invalidUrlMessage = "The URL's pathname is empty";
    } else if (parsedUrl.hash) {
      invalidUrlMessage = "The URL contains a fragment identifier";
    }
    if (invalidUrlMessage) {
      const err = new SyntaxError(invalidUrlMessage);
      if (websocket._redirects === 0) {
        throw err;
      } else {
        emitErrorAndClose(websocket, err);
        return;
      }
    }
    const defaultPort = isSecure ? 443 : 80;
    const key = randomBytes(16).toString("base64");
    const request = isSecure ? https.request : http.request;
    const protocolSet = new Set;
    let perMessageDeflate;
    opts.createConnection = isSecure ? tlsConnect : netConnect;
    opts.defaultPort = opts.defaultPort || defaultPort;
    opts.port = parsedUrl.port || defaultPort;
    opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
    opts.headers = {
      ...opts.headers,
      "Sec-WebSocket-Version": opts.protocolVersion,
      "Sec-WebSocket-Key": key,
      Connection: "Upgrade",
      Upgrade: "websocket"
    };
    opts.path = parsedUrl.pathname + parsedUrl.search;
    opts.timeout = opts.handshakeTimeout;
    if (opts.perMessageDeflate) {
      perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
      opts.headers["Sec-WebSocket-Extensions"] = format({
        [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
      });
    }
    if (protocols.length) {
      for (const protocol of protocols) {
        if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError("An invalid or duplicated subprotocol was specified");
        }
        protocolSet.add(protocol);
      }
      opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
    }
    if (opts.origin) {
      if (opts.protocolVersion < 13) {
        opts.headers["Sec-WebSocket-Origin"] = opts.origin;
      } else {
        opts.headers.Origin = opts.origin;
      }
    }
    if (parsedUrl.username || parsedUrl.password) {
      opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
    }
    if (isIpcUrl) {
      const parts = opts.path.split(":");
      opts.socketPath = parts[0];
      opts.path = parts[1];
    }
    let req;
    if (opts.followRedirects) {
      if (websocket._redirects === 0) {
        websocket._originalIpc = isIpcUrl;
        websocket._originalSecure = isSecure;
        websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
        const headers = options && options.headers;
        options = { ...options, headers: {} };
        if (headers) {
          for (const [key2, value] of Object.entries(headers)) {
            options.headers[key2.toLowerCase()] = value;
          }
        }
      } else if (websocket.listenerCount("redirect") === 0) {
        const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
        if (!isSameHost || websocket._originalSecure && !isSecure) {
          delete opts.headers.authorization;
          delete opts.headers.cookie;
          if (!isSameHost)
            delete opts.headers.host;
          opts.auth = undefined;
        }
      }
      if (opts.auth && !options.headers.authorization) {
        options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
      }
      req = websocket._req = request(opts);
      if (websocket._redirects) {
        websocket.emit("redirect", websocket.url, req);
      }
    } else {
      req = websocket._req = request(opts);
    }
    if (opts.timeout) {
      req.on("timeout", () => {
        abortHandshake(websocket, req, "Opening handshake has timed out");
      });
    }
    req.on("error", (err) => {
      if (req === null || req[kAborted])
        return;
      req = websocket._req = null;
      emitErrorAndClose(websocket, err);
    });
    req.on("response", (res) => {
      const location = res.headers.location;
      const statusCode = res.statusCode;
      if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
        if (++websocket._redirects > opts.maxRedirects) {
          abortHandshake(websocket, req, "Maximum redirects exceeded");
          return;
        }
        req.abort();
        let addr;
        try {
          addr = new URL2(location, address);
        } catch (e) {
          const err = new SyntaxError(`Invalid URL: ${location}`);
          emitErrorAndClose(websocket, err);
          return;
        }
        initAsClient(websocket, addr, protocols, options);
      } else if (!websocket.emit("unexpected-response", req, res)) {
        abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
      }
    });
    req.on("upgrade", (res, socket, head) => {
      websocket.emit("upgrade", res);
      if (websocket.readyState !== WebSocket.CONNECTING)
        return;
      req = websocket._req = null;
      if (res.headers.upgrade.toLowerCase() !== "websocket") {
        abortHandshake(websocket, socket, "Invalid Upgrade header");
        return;
      }
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
        return;
      }
      const serverProt = res.headers["sec-websocket-protocol"];
      let protError;
      if (serverProt !== undefined) {
        if (!protocolSet.size) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (!protocolSet.has(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
      } else if (protocolSet.size) {
        protError = "Server sent no subprotocol";
      }
      if (protError) {
        abortHandshake(websocket, socket, protError);
        return;
      }
      if (serverProt)
        websocket._protocol = serverProt;
      const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
      if (secWebSocketExtensions !== undefined) {
        if (!perMessageDeflate) {
          const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        let extensions;
        try {
          extensions = parse(secWebSocketExtensions);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        const extensionNames = Object.keys(extensions);
        if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
          const message = "Server indicated an extension that was not requested";
          abortHandshake(websocket, socket, message);
          return;
        }
        try {
          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Extensions header";
          abortHandshake(websocket, socket, message);
          return;
        }
        websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
      }
      websocket.setSocket(socket, head, {
        generateMask: opts.generateMask,
        maxPayload: opts.maxPayload,
        skipUTF8Validation: opts.skipUTF8Validation
      });
    });
    if (opts.finishRequest) {
      opts.finishRequest(req, websocket);
    } else {
      req.end();
    }
  };
  var emitErrorAndClose = function(websocket, err) {
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit("error", err);
    websocket.emitClose();
  };
  var netConnect = function(options) {
    options.path = options.socketPath;
    return net.connect(options);
  };
  var tlsConnect = function(options) {
    options.path = undefined;
    if (!options.servername && options.servername !== "") {
      options.servername = net.isIP(options.host) ? "" : options.host;
    }
    return tls.connect(options);
  };
  var abortHandshake = function(websocket, stream, message) {
    websocket._readyState = WebSocket.CLOSING;
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshake);
    if (stream.setHeader) {
      stream[kAborted] = true;
      stream.abort();
      if (stream.socket && !stream.socket.destroyed) {
        stream.socket.destroy();
      }
      process.nextTick(emitErrorAndClose, websocket, err);
    } else {
      stream.destroy(err);
      stream.once("error", websocket.emit.bind(websocket, "error"));
      stream.once("close", websocket.emitClose.bind(websocket));
    }
  };
  var sendAfterClose = function(websocket, data, cb) {
    if (data) {
      const length = toBuffer(data).length;
      if (websocket._socket)
        websocket._sender._bufferedBytes += length;
      else
        websocket._bufferedAmount += length;
    }
    if (cb) {
      const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);
      process.nextTick(cb, err);
    }
  };
  var receiverOnConclude = function(code, reason) {
    const websocket = this[kWebSocket];
    websocket._closeFrameReceived = true;
    websocket._closeMessage = reason;
    websocket._closeCode = code;
    if (websocket._socket[kWebSocket] === undefined)
      return;
    websocket._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket._socket);
    if (code === 1005)
      websocket.close();
    else
      websocket.close(code, reason);
  };
  var receiverOnDrain = function() {
    const websocket = this[kWebSocket];
    if (!websocket.isPaused)
      websocket._socket.resume();
  };
  var receiverOnError = function(err) {
    const websocket = this[kWebSocket];
    if (websocket._socket[kWebSocket] !== undefined) {
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      websocket.close(err[kStatusCode]);
    }
    websocket.emit("error", err);
  };
  var receiverOnFinish = function() {
    this[kWebSocket].emitClose();
  };
  var receiverOnMessage = function(data, isBinary) {
    this[kWebSocket].emit("message", data, isBinary);
  };
  var receiverOnPing = function(data) {
    const websocket = this[kWebSocket];
    websocket.pong(data, !websocket._isServer, NOOP);
    websocket.emit("ping", data);
  };
  var receiverOnPong = function(data) {
    this[kWebSocket].emit("pong", data);
  };
  var resume = function(stream) {
    stream.resume();
  };
  var socketOnClose = function() {
    const websocket = this[kWebSocket];
    this.removeListener("close", socketOnClose);
    this.removeListener("data", socketOnData);
    this.removeListener("end", socketOnEnd);
    websocket._readyState = WebSocket.CLOSING;
    let chunk;
    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
      websocket._receiver.write(chunk);
    }
    websocket._receiver.end();
    this[kWebSocket] = undefined;
    clearTimeout(websocket._closeTimer);
    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
      websocket.emitClose();
    } else {
      websocket._receiver.on("error", receiverOnFinish);
      websocket._receiver.on("finish", receiverOnFinish);
    }
  };
  var socketOnData = function(chunk) {
    if (!this[kWebSocket]._receiver.write(chunk)) {
      this.pause();
    }
  };
  var socketOnEnd = function() {
    const websocket = this[kWebSocket];
    websocket._readyState = WebSocket.CLOSING;
    websocket._receiver.end();
    this.end();
  };
  var socketOnError = function() {
    const websocket = this[kWebSocket];
    this.removeListener("error", socketOnError);
    this.on("error", NOOP);
    if (websocket) {
      websocket._readyState = WebSocket.CLOSING;
      this.destroy();
    }
  };
  var EventEmitter = __require("events");
  var https = __require("https");
  var http = __require("http");
  var net = __require("net");
  var tls = __require("tls");
  var { randomBytes, createHash } = __require("crypto");
  var { Duplex, Readable } = __require("stream");
  var { URL: URL2 } = __require("url");
  var PerMessageDeflate = require_permessage_deflate();
  var Receiver = require_receiver2();
  var Sender = require_sender();
  var {
    BINARY_TYPES,
    EMPTY_BUFFER,
    GUID,
    kForOnEventAttribute,
    kListener,
    kStatusCode,
    kWebSocket,
    NOOP
  } = require_constants5();
  var {
    EventTarget: { addEventListener, removeEventListener }
  } = require_event_target();
  var { format, parse } = require_extension();
  var { toBuffer } = require_buffer_util();
  var closeTimeout = 30 * 1000;
  var kAborted = Symbol("kAborted");
  var protocolVersions = [8, 13];
  var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
  var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

  class WebSocket extends EventEmitter {
    constructor(address, protocols, options) {
      super();
      this._binaryType = BINARY_TYPES[0];
      this._closeCode = 1006;
      this._closeFrameReceived = false;
      this._closeFrameSent = false;
      this._closeMessage = EMPTY_BUFFER;
      this._closeTimer = null;
      this._extensions = {};
      this._paused = false;
      this._protocol = "";
      this._readyState = WebSocket.CONNECTING;
      this._receiver = null;
      this._sender = null;
      this._socket = null;
      if (address !== null) {
        this._bufferedAmount = 0;
        this._isServer = false;
        this._redirects = 0;
        if (protocols === undefined) {
          protocols = [];
        } else if (!Array.isArray(protocols)) {
          if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = [];
          } else {
            protocols = [protocols];
          }
        }
        initAsClient(this, address, protocols, options);
      } else {
        this._isServer = true;
      }
    }
    get binaryType() {
      return this._binaryType;
    }
    set binaryType(type) {
      if (!BINARY_TYPES.includes(type))
        return;
      this._binaryType = type;
      if (this._receiver)
        this._receiver._binaryType = type;
    }
    get bufferedAmount() {
      if (!this._socket)
        return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    get extensions() {
      return Object.keys(this._extensions).join();
    }
    get isPaused() {
      return this._paused;
    }
    get onclose() {
      return null;
    }
    get onerror() {
      return null;
    }
    get onopen() {
      return null;
    }
    get onmessage() {
      return null;
    }
    get protocol() {
      return this._protocol;
    }
    get readyState() {
      return this._readyState;
    }
    get url() {
      return this._url;
    }
    setSocket(socket, head, options) {
      const receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions, options.generateMask);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on("conclude", receiverOnConclude);
      receiver.on("drain", receiverOnDrain);
      receiver.on("error", receiverOnError);
      receiver.on("message", receiverOnMessage);
      receiver.on("ping", receiverOnPing);
      receiver.on("pong", receiverOnPong);
      if (socket.setTimeout)
        socket.setTimeout(0);
      if (socket.setNoDelay)
        socket.setNoDelay();
      if (head.length > 0)
        socket.unshift(head);
      socket.on("close", socketOnClose);
      socket.on("data", socketOnData);
      socket.on("end", socketOnEnd);
      socket.on("error", socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit("open");
    }
    emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
        return;
      }
      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }
      this._receiver.removeAllListeners();
      this._readyState = WebSocket.CLOSED;
      this.emit("close", this._closeCode, this._closeMessage);
    }
    close(code, data) {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }
        return;
      }
      this._readyState = WebSocket.CLOSING;
      this._sender.close(code, data, !this._isServer, (err) => {
        if (err)
          return;
        this._closeFrameSent = true;
        if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
          this._socket.end();
        }
      });
      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    pause() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = true;
      this._socket.pause();
    }
    ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof data === "function") {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === "function") {
        cb = mask;
        mask = undefined;
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      if (mask === undefined)
        mask = !this._isServer;
      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    resume() {
      if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
        return;
      }
      this._paused = false;
      if (!this._receiver._writableState.needDrain)
        this._socket.resume();
    }
    send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
      }
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (typeof data === "number")
        data = data.toString();
      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }
      const opts = {
        binary: typeof data !== "string",
        mask: !this._isServer,
        compress: true,
        fin: true,
        ...options
      };
      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }
      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    terminate() {
      if (this.readyState === WebSocket.CLOSED)
        return;
      if (this.readyState === WebSocket.CONNECTING) {
        const msg = "WebSocket was closed before the connection was established";
        abortHandshake(this, this._req, msg);
        return;
      }
      if (this._socket) {
        this._readyState = WebSocket.CLOSING;
        this._socket.destroy();
      }
    }
  }
  Object.defineProperty(WebSocket, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket.prototype, "CONNECTING", {
    enumerable: true,
    value: readyStates.indexOf("CONNECTING")
  });
  Object.defineProperty(WebSocket, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket.prototype, "OPEN", {
    enumerable: true,
    value: readyStates.indexOf("OPEN")
  });
  Object.defineProperty(WebSocket, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSING", {
    enumerable: true,
    value: readyStates.indexOf("CLOSING")
  });
  Object.defineProperty(WebSocket, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  Object.defineProperty(WebSocket.prototype, "CLOSED", {
    enumerable: true,
    value: readyStates.indexOf("CLOSED")
  });
  [
    "binaryType",
    "bufferedAmount",
    "extensions",
    "isPaused",
    "protocol",
    "readyState",
    "url"
  ].forEach((property) => {
    Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
  });
  ["open", "error", "close", "message"].forEach((method) => {
    Object.defineProperty(WebSocket.prototype, `on${method}`, {
      enumerable: true,
      get() {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute])
            return listener[kListener];
        }
        return null;
      },
      set(handler) {
        for (const listener of this.listeners(method)) {
          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
        if (typeof handler !== "function")
          return;
        this.addEventListener(method, handler, {
          [kForOnEventAttribute]: true
        });
      }
    });
  });
  WebSocket.prototype.addEventListener = addEventListener;
  WebSocket.prototype.removeEventListener = removeEventListener;
  module.exports = WebSocket;
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var emitClose = function(stream) {
    stream.emit("close");
  };
  var duplexOnEnd = function() {
    if (!this.destroyed && this._writableState.finished) {
      this.destroy();
    }
  };
  var duplexOnError = function(err) {
    this.removeListener("error", duplexOnError);
    this.destroy();
    if (this.listenerCount("error") === 0) {
      this.emit("error", err);
    }
  };
  var createWebSocketStream = function(ws, options) {
    let terminateOnDestroy = true;
    const duplex = new Duplex({
      ...options,
      autoDestroy: false,
      emitClose: false,
      objectMode: false,
      writableObjectMode: false
    });
    ws.on("message", function message(msg, isBinary) {
      const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
      if (!duplex.push(data))
        ws.pause();
    });
    ws.once("error", function error(err) {
      if (duplex.destroyed)
        return;
      terminateOnDestroy = false;
      duplex.destroy(err);
    });
    ws.once("close", function close() {
      if (duplex.destroyed)
        return;
      duplex.push(null);
    });
    duplex._destroy = function(err, callback) {
      if (ws.readyState === ws.CLOSED) {
        callback(err);
        process.nextTick(emitClose, duplex);
        return;
      }
      let called = false;
      ws.once("error", function error(err2) {
        called = true;
        callback(err2);
      });
      ws.once("close", function close() {
        if (!called)
          callback(err);
        process.nextTick(emitClose, duplex);
      });
      if (terminateOnDestroy)
        ws.terminate();
    };
    duplex._final = function(callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._final(callback);
        });
        return;
      }
      if (ws._socket === null)
        return;
      if (ws._socket._writableState.finished) {
        callback();
        if (duplex._readableState.endEmitted)
          duplex.destroy();
      } else {
        ws._socket.once("finish", function finish() {
          callback();
        });
        ws.close();
      }
    };
    duplex._read = function() {
      if (ws.isPaused)
        ws.resume();
    };
    duplex._write = function(chunk, encoding, callback) {
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          duplex._write(chunk, encoding, callback);
        });
        return;
      }
      ws.send(chunk, callback);
    };
    duplex.on("end", duplexOnEnd);
    duplex.on("error", duplexOnError);
    return duplex;
  };
  var { Duplex } = __require("stream");
  module.exports = createWebSocketStream;
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS((exports, module) => {
  var parse = function(header) {
    const protocols = new Set;
    let start = -1;
    let end = -1;
    let i = 0;
    for (i;i < header.length; i++) {
      const code = header.charCodeAt(i);
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1)
          start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1)
          end = i;
      } else if (code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1)
          end = i;
        const protocol2 = header.slice(start, end);
        if (protocols.has(protocol2)) {
          throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
        }
        protocols.add(protocol2);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
    if (start === -1 || end !== -1) {
      throw new SyntaxError("Unexpected end of input");
    }
    const protocol = header.slice(start, i);
    if (protocols.has(protocol)) {
      throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
    }
    protocols.add(protocol);
    return protocols;
  };
  var { tokenChars } = require_validation();
  module.exports = { parse };
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS((exports, module) => {
  var addListeners = function(server, map) {
    for (const event of Object.keys(map))
      server.on(event, map[event]);
    return function removeListeners() {
      for (const event of Object.keys(map)) {
        server.removeListener(event, map[event]);
      }
    };
  };
  var emitClose = function(server) {
    server._state = CLOSED;
    server.emit("close");
  };
  var socketOnError = function() {
    this.destroy();
  };
  var abortHandshake = function(socket, code, message, headers) {
    message = message || http.STATUS_CODES[code];
    headers = {
      Connection: "close",
      "Content-Type": "text/html",
      "Content-Length": Buffer.byteLength(message),
      ...headers
    };
    socket.once("finish", socket.destroy);
    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
  };
  var abortHandshakeOrEmitwsClientError = function(server, req, socket, code, message) {
    if (server.listenerCount("wsClientError")) {
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
      server.emit("wsClientError", err, socket, req);
    } else {
      abortHandshake(socket, code, message);
    }
  };
  var EventEmitter = __require("events");
  var http = __require("http");
  var { Duplex } = __require("stream");
  var { createHash } = __require("crypto");
  var extension = require_extension();
  var PerMessageDeflate = require_permessage_deflate();
  var subprotocol = require_subprotocol();
  var WebSocket = require_websocket2();
  var { GUID, kWebSocket } = require_constants5();
  var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
  var RUNNING = 0;
  var CLOSING = 1;
  var CLOSED = 2;

  class WebSocketServer extends EventEmitter {
    constructor(options, callback) {
      super();
      options = {
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: false,
        handleProtocols: null,
        clientTracking: true,
        verifyClient: null,
        noServer: false,
        backlog: null,
        server: null,
        host: null,
        path: null,
        port: null,
        WebSocket,
        ...options
      };
      if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
        throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
      }
      if (options.port != null) {
        this._server = http.createServer((req, res) => {
          const body = http.STATUS_CODES[426];
          res.writeHead(426, {
            "Content-Length": body.length,
            "Content-Type": "text/plain"
          });
          res.end(body);
        });
        this._server.listen(options.port, options.host, options.backlog, callback);
      } else if (options.server) {
        this._server = options.server;
      }
      if (this._server) {
        const emitConnection = this.emit.bind(this, "connection");
        this._removeListeners = addListeners(this._server, {
          listening: this.emit.bind(this, "listening"),
          error: this.emit.bind(this, "error"),
          upgrade: (req, socket, head) => {
            this.handleUpgrade(req, socket, head, emitConnection);
          }
        });
      }
      if (options.perMessageDeflate === true)
        options.perMessageDeflate = {};
      if (options.clientTracking) {
        this.clients = new Set;
        this._shouldEmitClose = false;
      }
      this.options = options;
      this._state = RUNNING;
    }
    address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }
      if (!this._server)
        return null;
      return this._server.address();
    }
    close(cb) {
      if (this._state === CLOSED) {
        if (cb) {
          this.once("close", () => {
            cb(new Error("The server is not running"));
          });
        }
        process.nextTick(emitClose, this);
        return;
      }
      if (cb)
        this.once("close", cb);
      if (this._state === CLOSING)
        return;
      this._state = CLOSING;
      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
        }
        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        const server = this._server;
        this._removeListeners();
        this._removeListeners = this._server = null;
        server.close(() => {
          emitClose(this);
        });
      }
    }
    shouldHandle(req) {
      if (this.options.path) {
        const index = req.url.indexOf("?");
        const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path)
          return false;
      }
      return true;
    }
    handleUpgrade(req, socket, head, cb) {
      socket.on("error", socketOnError);
      const key = req.headers["sec-websocket-key"];
      const version = +req.headers["sec-websocket-version"];
      if (req.method !== "GET") {
        const message = "Invalid HTTP method";
        abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
        return;
      }
      if (req.headers.upgrade.toLowerCase() !== "websocket") {
        const message = "Invalid Upgrade header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!key || !keyRegex.test(key)) {
        const message = "Missing or invalid Sec-WebSocket-Key header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (version !== 8 && version !== 13) {
        const message = "Missing or invalid Sec-WebSocket-Version header";
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
      if (!this.shouldHandle(req)) {
        abortHandshake(socket, 400);
        return;
      }
      const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
      let protocols = new Set;
      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          const message = "Invalid Sec-WebSocket-Protocol header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
      const extensions = {};
      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
        try {
          const offers = extension.parse(secWebSocketExtensions);
          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
      }
      if (this.options.verifyClient) {
        const info = {
          origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req
        };
        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, (verified, code, message, headers) => {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }
            this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }
        if (!this.options.verifyClient(info))
          return abortHandshake(socket, 401);
      }
      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      if (!socket.readable || !socket.writable)
        return socket.destroy();
      if (socket[kWebSocket]) {
        throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
      }
      if (this._state > RUNNING)
        return abortHandshake(socket, 503);
      const digest = createHash("sha1").update(key + GUID).digest("base64");
      const headers = [
        "HTTP/1.1 101 Switching Protocols",
        "Upgrade: websocket",
        "Connection: Upgrade",
        `Sec-WebSocket-Accept: ${digest}`
      ];
      const ws = new this.options.WebSocket(null);
      if (protocols.size) {
        const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
        if (protocol) {
          headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
          ws._protocol = protocol;
        }
      }
      if (extensions[PerMessageDeflate.extensionName]) {
        const params = extensions[PerMessageDeflate.extensionName].params;
        const value = extension.format({
          [PerMessageDeflate.extensionName]: [params]
        });
        headers.push(`Sec-WebSocket-Extensions: ${value}`);
        ws._extensions = extensions;
      }
      this.emit("headers", headers, req);
      socket.write(headers.concat("\r\n").join("\r\n"));
      socket.removeListener("error", socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });
      if (this.clients) {
        this.clients.add(ws);
        ws.on("close", () => {
          this.clients.delete(ws);
          if (this._shouldEmitClose && !this.clients.size) {
            process.nextTick(emitClose, this);
          }
        });
      }
      cb(ws, req);
    }
  }
  module.exports = WebSocketServer;
});

// node_modules/ws/index.js
var require_ws = __commonJS((exports, module) => {
  var WebSocket = require_websocket2();
  WebSocket.createWebSocketStream = require_stream();
  WebSocket.Server = require_websocket_server();
  WebSocket.Receiver = require_receiver2();
  WebSocket.Sender = require_sender();
  WebSocket.WebSocket = WebSocket;
  WebSocket.WebSocketServer = WebSocket.Server;
  module.exports = WebSocket;
});

// node_modules/@discordjs/ws/dist/index.js
var require_dist11 = __commonJS((exports, module) => {
  async function managerToFetchingStrategyOptions(manager) {
    const {
      buildIdentifyThrottler,
      buildStrategy,
      retrieveSessionInfo,
      updateSessionInfo,
      shardCount,
      shardIds,
      rest,
      ...managerOptions
    } = manager.options;
    return {
      ...managerOptions,
      gatewayInformation: await manager.fetchGatewayInformation(),
      shardCount: await manager.getShardCount()
    };
  }
  var getInitialSendRateLimitState = function() {
    return {
      remaining: 120,
      resetAt: Date.now() + 60000
    };
  };
  var __dirname = "/Users/jjh/dev/epyc_discord_bun/node_modules/@discordjs/ws/dist";
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __name = (target, value) => __defProp2(target, "name", { value, configurable: true });
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    CloseCodes: () => CloseCodes,
    CompressionMethod: () => CompressionMethod,
    DefaultDeviceProperty: () => DefaultDeviceProperty,
    DefaultWebSocketManagerOptions: () => DefaultWebSocketManagerOptions,
    Encoding: () => Encoding,
    ImportantGatewayOpcodes: () => ImportantGatewayOpcodes,
    SimpleContextFetchingStrategy: () => SimpleContextFetchingStrategy,
    SimpleIdentifyThrottler: () => SimpleIdentifyThrottler,
    SimpleShardingStrategy: () => SimpleShardingStrategy,
    WebSocketManager: () => WebSocketManager,
    WebSocketShard: () => WebSocketShard,
    WebSocketShardDestroyRecovery: () => WebSocketShardDestroyRecovery,
    WebSocketShardEvents: () => WebSocketShardEvents,
    WebSocketShardStatus: () => WebSocketShardStatus,
    WorkerBootstrapper: () => WorkerBootstrapper,
    WorkerContextFetchingStrategy: () => WorkerContextFetchingStrategy,
    WorkerReceivePayloadOp: () => WorkerReceivePayloadOp,
    WorkerSendPayloadOp: () => WorkerSendPayloadOp,
    WorkerShardingStrategy: () => WorkerShardingStrategy,
    getInitialSendRateLimitState: () => getInitialSendRateLimitState,
    managerToFetchingStrategyOptions: () => managerToFetchingStrategyOptions,
    version: () => version
  });
  module.exports = __toCommonJS(src_exports);
  __name(managerToFetchingStrategyOptions, "managerToFetchingStrategyOptions");
  var SimpleContextFetchingStrategy = class _SimpleContextFetchingStrategy {
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    static {
      __name(this, "SimpleContextFetchingStrategy");
    }
    static throttlerCache = new WeakMap;
    static async ensureThrottler(manager) {
      const throttler = _SimpleContextFetchingStrategy.throttlerCache.get(manager);
      if (throttler) {
        return throttler;
      }
      const newThrottler = await manager.options.buildIdentifyThrottler(manager);
      _SimpleContextFetchingStrategy.throttlerCache.set(manager, newThrottler);
      return newThrottler;
    }
    async retrieveSessionInfo(shardId) {
      return this.manager.options.retrieveSessionInfo(shardId);
    }
    updateSessionInfo(shardId, sessionInfo) {
      return this.manager.options.updateSessionInfo(shardId, sessionInfo);
    }
    async waitForIdentify(shardId, signal) {
      const throttler = await _SimpleContextFetchingStrategy.ensureThrottler(this.manager);
      await throttler.waitForIdentify(shardId, signal);
    }
  };
  var import_node_worker_threads2 = __require("worker_threads");
  var import_collection2 = require_dist2();
  var import_node_events = __require("events");
  var import_node_path = __require("path");
  var import_node_worker_threads = __require("worker_threads");
  var import_collection = require_dist2();
  var WorkerSendPayloadOp = ((WorkerSendPayloadOp2) => {
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Connect"] = 0] = "Connect";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Destroy"] = 1] = "Destroy";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["Send"] = 2] = "Send";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["SessionInfoResponse"] = 3] = "SessionInfoResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["ShardIdentifyResponse"] = 4] = "ShardIdentifyResponse";
    WorkerSendPayloadOp2[WorkerSendPayloadOp2["FetchStatus"] = 5] = "FetchStatus";
    return WorkerSendPayloadOp2;
  })(WorkerSendPayloadOp || {});
  var WorkerReceivePayloadOp = ((WorkerReceivePayloadOp2) => {
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Connected"] = 0] = "Connected";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Destroyed"] = 1] = "Destroyed";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["Event"] = 2] = "Event";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["RetrieveSessionInfo"] = 3] = "RetrieveSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["UpdateSessionInfo"] = 4] = "UpdateSessionInfo";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WaitForIdentify"] = 5] = "WaitForIdentify";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["FetchStatusResponse"] = 6] = "FetchStatusResponse";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["WorkerReady"] = 7] = "WorkerReady";
    WorkerReceivePayloadOp2[WorkerReceivePayloadOp2["CancelIdentify"] = 8] = "CancelIdentify";
    return WorkerReceivePayloadOp2;
  })(WorkerReceivePayloadOp || {});
  var WorkerShardingStrategy = class {
    static {
      __name(this, "WorkerShardingStrategy");
    }
    manager;
    options;
    #workers = [];
    #workerByShardId = new import_collection.Collection;
    connectPromises = new import_collection.Collection;
    destroyPromises = new import_collection.Collection;
    fetchStatusPromises = new import_collection.Collection;
    waitForIdentifyControllers = new import_collection.Collection;
    throttler;
    constructor(manager, options) {
      this.manager = manager;
      this.options = options;
    }
    async spawn(shardIds) {
      const shardsPerWorker = this.options.shardsPerWorker === "all" ? shardIds.length : this.options.shardsPerWorker;
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      const loops = Math.ceil(shardIds.length / shardsPerWorker);
      const promises = [];
      for (let idx = 0;idx < loops; idx++) {
        const slice = shardIds.slice(idx * shardsPerWorker, (idx + 1) * shardsPerWorker);
        const workerData2 = {
          ...strategyOptions,
          shardIds: slice
        };
        promises.push(this.setupWorker(workerData2));
      }
      await Promise.all(promises);
    }
    async connect() {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 0,
          shardId
        };
        const promise = new Promise((resolve2) => this.connectPromises.set(shardId, resolve2));
        worker.postMessage(payload);
        promises.push(promise);
      }
      await Promise.all(promises);
    }
    async destroy(options = {}) {
      const promises = [];
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const payload = {
          op: 1,
          shardId,
          options
        };
        promises.push(new Promise((resolve2) => this.destroyPromises.set(shardId, resolve2)).then(async () => worker.terminate()));
        worker.postMessage(payload);
      }
      this.#workers = [];
      this.#workerByShardId.clear();
      await Promise.all(promises);
    }
    send(shardId, data) {
      const worker = this.#workerByShardId.get(shardId);
      if (!worker) {
        throw new Error(`No worker found for shard ${shardId}`);
      }
      const payload = {
        op: 2,
        shardId,
        payload: data
      };
      worker.postMessage(payload);
    }
    async fetchStatus() {
      const statuses = new import_collection.Collection;
      for (const [shardId, worker] of this.#workerByShardId.entries()) {
        const nonce = Math.random();
        const payload = {
          op: 5,
          shardId,
          nonce
        };
        const promise = new Promise((resolve2) => this.fetchStatusPromises.set(nonce, resolve2));
        worker.postMessage(payload);
        const status = await promise;
        statuses.set(shardId, status);
      }
      return statuses;
    }
    async setupWorker(workerData2) {
      const worker = new import_node_worker_threads.Worker(this.resolveWorkerPath(), { workerData: workerData2 });
      await (0, import_node_events.once)(worker, "online");
      await this.waitForWorkerReady(worker);
      worker.on("error", (err) => {
        throw err;
      }).on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => this.onMessage(worker, payload));
      this.#workers.push(worker);
      for (const shardId of workerData2.shardIds) {
        this.#workerByShardId.set(shardId, worker);
      }
    }
    resolveWorkerPath() {
      const path = this.options.workerPath;
      if (!path) {
        return (0, import_node_path.join)(__dirname, "defaultWorker.js");
      }
      if ((0, import_node_path.isAbsolute)(path)) {
        return path;
      }
      if (/^\.\.?[/\\]/.test(path)) {
        return (0, import_node_path.resolve)(path);
      }
      try {
        return require.resolve(path);
      } catch {
        return (0, import_node_path.resolve)(path);
      }
    }
    async waitForWorkerReady(worker) {
      return new Promise((resolve2) => {
        const handler = __name((payload) => {
          if (payload.op === 7) {
            resolve2();
            worker.off("message", handler);
          }
        }, "handler");
        worker.on("message", handler);
      });
    }
    async onMessage(worker, payload) {
      switch (payload.op) {
        case 0: {
          this.connectPromises.get(payload.shardId)?.();
          this.connectPromises.delete(payload.shardId);
          break;
        }
        case 1: {
          this.destroyPromises.get(payload.shardId)?.();
          this.destroyPromises.delete(payload.shardId);
          break;
        }
        case 2: {
          this.manager.emit(payload.event, { ...payload.data, shardId: payload.shardId });
          break;
        }
        case 3: {
          const session = await this.manager.options.retrieveSessionInfo(payload.shardId);
          const response = {
            op: 3,
            nonce: payload.nonce,
            session
          };
          worker.postMessage(response);
          break;
        }
        case 4: {
          await this.manager.options.updateSessionInfo(payload.shardId, payload.session);
          break;
        }
        case 5: {
          const throttler = await this.ensureThrottler();
          try {
            const controller = new AbortController;
            this.waitForIdentifyControllers.set(payload.nonce, controller);
            await throttler.waitForIdentify(payload.shardId, controller.signal);
          } catch {
            return;
          }
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: true
          };
          worker.postMessage(response);
          break;
        }
        case 6: {
          this.fetchStatusPromises.get(payload.nonce)?.(payload.status);
          this.fetchStatusPromises.delete(payload.nonce);
          break;
        }
        case 7: {
          break;
        }
        case 8: {
          this.waitForIdentifyControllers.get(payload.nonce)?.abort();
          this.waitForIdentifyControllers.delete(payload.nonce);
          const response = {
            op: 4,
            nonce: payload.nonce,
            ok: false
          };
          worker.postMessage(response);
          break;
        }
      }
    }
    async ensureThrottler() {
      this.throttler ??= await this.manager.options.buildIdentifyThrottler(this.manager);
      return this.throttler;
    }
  };
  var WorkerContextFetchingStrategy = class {
    constructor(options) {
      this.options = options;
      if (import_node_worker_threads2.isMainThread) {
        throw new Error("Cannot instantiate WorkerContextFetchingStrategy on the main thread");
      }
      import_node_worker_threads2.parentPort.on("message", (payload) => {
        if (payload.op === 3) {
          this.sessionPromises.get(payload.nonce)?.(payload.session);
          this.sessionPromises.delete(payload.nonce);
        }
        if (payload.op === 4) {
          const promise = this.waitForIdentifyPromises.get(payload.nonce);
          if (payload.ok) {
            promise?.resolve();
          } else {
            promise?.reject(promise.signal.reason);
          }
          this.waitForIdentifyPromises.delete(payload.nonce);
        }
      });
    }
    static {
      __name(this, "WorkerContextFetchingStrategy");
    }
    sessionPromises = new import_collection2.Collection;
    waitForIdentifyPromises = new import_collection2.Collection;
    async retrieveSessionInfo(shardId) {
      const nonce = Math.random();
      const payload = {
        op: 3,
        shardId,
        nonce
      };
      const promise = new Promise((resolve2) => this.sessionPromises.set(nonce, resolve2));
      import_node_worker_threads2.parentPort.postMessage(payload);
      return promise;
    }
    updateSessionInfo(shardId, sessionInfo) {
      const payload = {
        op: 4,
        shardId,
        session: sessionInfo
      };
      import_node_worker_threads2.parentPort.postMessage(payload);
    }
    async waitForIdentify(shardId, signal) {
      const nonce = Math.random();
      const payload = {
        op: 5,
        nonce,
        shardId
      };
      const promise = new Promise((resolve2, reject) => this.waitForIdentifyPromises.set(nonce, { signal, resolve: resolve2, reject }));
      import_node_worker_threads2.parentPort.postMessage(payload);
      const listener = __name(() => {
        const payload2 = {
          op: 8,
          nonce
        };
        import_node_worker_threads2.parentPort.postMessage(payload2);
      }, "listener");
      signal.addEventListener("abort", listener);
      try {
        await promise;
      } finally {
        signal.removeEventListener("abort", listener);
      }
    }
  };
  var import_collection6 = require_dist2();
  var import_node_buffer = __require("buffer");
  var import_node_events2 = __require("events");
  var import_node_timers = __require("timers");
  var import_promises2 = __require("timers/promises");
  var import_node_url = __require("url");
  var import_node_util = __require("util");
  var import_node_zlib = null;
  __require("zlib");
  var import_collection5 = require_dist2();
  var import_util2 = require_dist();
  var import_async_queue2 = require_dist6();
  var import_async_event_emitter = require_dist4();
  var import_v102 = require_v106();
  var import_ws = require_ws();
  var import_node_process = __toESM2(__require("process"));
  var import_collection4 = require_dist2();
  var import_util = require_dist();
  var import_v10 = require_v106();
  var import_promises = __require("timers/promises");
  var import_collection3 = require_dist2();
  var import_async_queue = require_dist6();
  var SimpleIdentifyThrottler = class {
    constructor(maxConcurrency) {
      this.maxConcurrency = maxConcurrency;
    }
    static {
      __name(this, "SimpleIdentifyThrottler");
    }
    states = new import_collection3.Collection;
    async waitForIdentify(shardId, signal) {
      const key = shardId % this.maxConcurrency;
      const state = this.states.ensure(key, () => {
        return {
          queue: new import_async_queue.AsyncQueue,
          resetsAt: Number.POSITIVE_INFINITY
        };
      });
      await state.queue.wait({ signal });
      try {
        const diff = state.resetsAt - Date.now();
        if (diff <= 5000) {
          const time = diff + Math.random() * 1500;
          await (0, import_promises.setTimeout)(time);
        }
        state.resetsAt = Date.now() + 5000;
      } finally {
        state.queue.shift();
      }
    }
  };
  var Encoding = ((Encoding2) => {
    Encoding2["JSON"] = "json";
    return Encoding2;
  })(Encoding || {});
  var CompressionMethod = ((CompressionMethod2) => {
    CompressionMethod2["ZlibStream"] = "zlib-stream";
    return CompressionMethod2;
  })(CompressionMethod || {});
  var DefaultDeviceProperty = `@discordjs/ws 1.0.1`;
  var getDefaultSessionStore = (0, import_util.lazy)(() => new import_collection4.Collection);
  var DefaultWebSocketManagerOptions = {
    async buildIdentifyThrottler(manager) {
      const info = await manager.fetchGatewayInformation();
      return new SimpleIdentifyThrottler(info.session_start_limit.max_concurrency);
    },
    buildStrategy: (manager) => new SimpleShardingStrategy(manager),
    shardCount: null,
    shardIds: null,
    largeThreshold: null,
    initialPresence: null,
    identifyProperties: {
      browser: DefaultDeviceProperty,
      device: DefaultDeviceProperty,
      os: import_node_process.default.platform
    },
    version: import_v10.APIVersion,
    encoding: "json",
    compression: null,
    retrieveSessionInfo(shardId) {
      const store = getDefaultSessionStore();
      return store.get(shardId) ?? null;
    },
    updateSessionInfo(shardId, info) {
      const store = getDefaultSessionStore();
      if (info) {
        store.set(shardId, info);
      } else {
        store.delete(shardId);
      }
    },
    handshakeTimeout: 30000,
    helloTimeout: 60000,
    readyTimeout: 15000
  };
  var ImportantGatewayOpcodes = new Set([
    import_v10.GatewayOpcodes.Heartbeat,
    import_v10.GatewayOpcodes.Identify,
    import_v10.GatewayOpcodes.Resume
  ]);
  __name(getInitialSendRateLimitState, "getInitialSendRateLimitState");
  var getZlibSync = null;
  var WebSocketShardEvents = ((WebSocketShardEvents2) => {
    WebSocketShardEvents2["Closed"] = "closed";
    WebSocketShardEvents2["Debug"] = "debug";
    WebSocketShardEvents2["Dispatch"] = "dispatch";
    WebSocketShardEvents2["Error"] = "error";
    WebSocketShardEvents2["HeartbeatComplete"] = "heartbeat";
    WebSocketShardEvents2["Hello"] = "hello";
    WebSocketShardEvents2["Ready"] = "ready";
    WebSocketShardEvents2["Resumed"] = "resumed";
    return WebSocketShardEvents2;
  })(WebSocketShardEvents || {});
  var WebSocketShardStatus = ((WebSocketShardStatus2) => {
    WebSocketShardStatus2[WebSocketShardStatus2["Idle"] = 0] = "Idle";
    WebSocketShardStatus2[WebSocketShardStatus2["Connecting"] = 1] = "Connecting";
    WebSocketShardStatus2[WebSocketShardStatus2["Resuming"] = 2] = "Resuming";
    WebSocketShardStatus2[WebSocketShardStatus2["Ready"] = 3] = "Ready";
    return WebSocketShardStatus2;
  })(WebSocketShardStatus || {});
  var WebSocketShardDestroyRecovery = ((WebSocketShardDestroyRecovery2) => {
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Reconnect"] = 0] = "Reconnect";
    WebSocketShardDestroyRecovery2[WebSocketShardDestroyRecovery2["Resume"] = 1] = "Resume";
    return WebSocketShardDestroyRecovery2;
  })(WebSocketShardDestroyRecovery || {});
  var CloseCodes = ((CloseCodes2) => {
    CloseCodes2[CloseCodes2["Normal"] = 1000] = "Normal";
    CloseCodes2[CloseCodes2["Resuming"] = 4200] = "Resuming";
    return CloseCodes2;
  })(CloseCodes || {});
  var WebSocketConstructor = import_ws.WebSocket;
  var WebSocketShard = class extends import_async_event_emitter.AsyncEventEmitter {
    static {
      __name(this, "WebSocketShard");
    }
    connection = null;
    useIdentifyCompress = false;
    inflate = null;
    textDecoder = new import_node_util.TextDecoder;
    replayedEvents = 0;
    isAck = true;
    sendRateLimitState = getInitialSendRateLimitState();
    initialHeartbeatTimeoutController = null;
    heartbeatInterval = null;
    lastHeartbeatAt = -1;
    initialConnectResolved = false;
    failedToConnectDueToNetworkError = false;
    sendQueue = new import_async_queue2.AsyncQueue;
    timeoutAbortControllers = new import_collection5.Collection;
    strategy;
    id;
    #status = 0;
    get status() {
      return this.#status;
    }
    constructor(strategy, id) {
      super();
      this.strategy = strategy;
      this.id = id;
    }
    async connect() {
      const controller = new AbortController;
      let promise;
      if (!this.initialConnectResolved) {
        promise = Promise.race([
          (0, import_node_events2.once)(this, "ready", { signal: controller.signal }),
          (0, import_node_events2.once)(this, "resumed", { signal: controller.signal })
        ]);
      }
      this.internalConnect();
      try {
        await promise;
      } catch ({ error }) {
        throw error;
      } finally {
        controller.abort();
      }
      this.initialConnectResolved = true;
    }
    async internalConnect() {
      if (this.#status !== 0) {
        throw new Error("Tried to connect a shard that wasn't idle");
      }
      const { version: version2, encoding, compression } = this.strategy.options;
      const params = new import_node_url.URLSearchParams({ v: version2, encoding });
      if (compression) {
        const zlib = await getZlibSync();
        if (zlib) {
          params.append("compress", compression);
          this.inflate = new zlib.Inflate({
            chunkSize: 65535,
            to: "string"
          });
        } else if (!this.useIdentifyCompress) {
          this.useIdentifyCompress = true;
          console.warn("WebSocketShard: Compression is enabled but zlib-sync is not installed, falling back to identify compress");
        }
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      const url = `${session?.resumeURL ?? this.strategy.options.gatewayInformation.url}?${params.toString()}`;
      this.debug([`Connecting to ${url}`]);
      const connection = new WebSocketConstructor(url, {
        handshakeTimeout: this.strategy.options.handshakeTimeout ?? undefined
      });
      connection.binaryType = "arraybuffer";
      connection.onmessage = (event) => {
        this.onMessage(event.data, event.data instanceof ArrayBuffer);
      };
      connection.onerror = (event) => {
        this.onError(event.error);
      };
      connection.onclose = (event) => {
        this.onClose(event.code);
      };
      this.connection = connection;
      this.#status = 1;
      this.sendRateLimitState = getInitialSendRateLimitState();
      const { ok } = await this.waitForEvent("hello", this.strategy.options.helloTimeout);
      if (!ok) {
        return;
      }
      if (session?.shardCount === this.strategy.options.shardCount) {
        await this.resume(session);
      } else {
        await this.identify();
      }
    }
    async destroy(options = {}) {
      if (this.#status === 0) {
        this.debug(["Tried to destroy a shard that was idle"]);
        return;
      }
      if (!options.code) {
        options.code = options.recover === 1 ? 4200 : 1000;
      }
      this.debug([
        "Destroying shard",
        `Reason: ${options.reason ?? "none"}`,
        `Code: ${options.code}`,
        `Recover: ${options.recover === undefined ? "none" : WebSocketShardDestroyRecovery[options.recover]}`
      ]);
      this.isAck = true;
      if (this.heartbeatInterval) {
        (0, import_node_timers.clearInterval)(this.heartbeatInterval);
      }
      if (this.initialHeartbeatTimeoutController) {
        this.initialHeartbeatTimeoutController.abort();
        this.initialHeartbeatTimeoutController = null;
      }
      this.lastHeartbeatAt = -1;
      for (const controller of this.timeoutAbortControllers.values()) {
        controller.abort();
      }
      this.timeoutAbortControllers.clear();
      this.failedToConnectDueToNetworkError = false;
      if (options.recover !== 1) {
        await this.strategy.updateSessionInfo(this.id, null);
      }
      if (this.connection) {
        this.connection.onmessage = null;
        this.connection.onclose = null;
        const shouldClose = this.connection.readyState === import_ws.WebSocket.OPEN;
        this.debug([
          "Connection status during destroy",
          `Needs closing: ${shouldClose}`,
          `Ready state: ${this.connection.readyState}`
        ]);
        if (shouldClose) {
          let outerResolve;
          const promise = new Promise((resolve2) => {
            outerResolve = resolve2;
          });
          this.connection.onclose = outerResolve;
          this.connection.close(options.code, options.reason);
          await promise;
          this.emit("closed", { code: options.code });
        }
        this.connection.onerror = null;
      } else {
        this.debug(["Destroying a shard that has no connection; please open an issue on GitHub"]);
      }
      this.#status = 0;
      if (options.recover !== undefined) {
        await (0, import_promises2.setTimeout)(500);
        return this.internalConnect();
      }
    }
    async waitForEvent(event, timeoutDuration) {
      this.debug([`Waiting for event ${event} ${timeoutDuration ? `for ${timeoutDuration}ms` : "indefinitely"}`]);
      const timeoutController = new AbortController;
      const timeout = timeoutDuration ? (0, import_node_timers.setTimeout)(() => timeoutController.abort(), timeoutDuration).unref() : null;
      this.timeoutAbortControllers.set(event, timeoutController);
      const closeController = new AbortController;
      try {
        const closed = await Promise.race([
          (0, import_node_events2.once)(this, event, { signal: timeoutController.signal }).then(() => false),
          (0, import_node_events2.once)(this, "closed", { signal: closeController.signal }).then(() => true)
        ]);
        return { ok: !closed };
      } catch {
        this.destroy({
          code: 1000,
          reason: "Something timed out or went wrong while waiting for an event",
          recover: 0
        });
        return { ok: false };
      } finally {
        if (timeout) {
          (0, import_node_timers.clearTimeout)(timeout);
        }
        this.timeoutAbortControllers.delete(event);
        if (!closeController.signal.aborted) {
          closeController.abort();
        }
      }
    }
    async send(payload) {
      if (!this.connection) {
        throw new Error("WebSocketShard wasn't connected");
      }
      if (this.#status !== 3 && !ImportantGatewayOpcodes.has(payload.op)) {
        this.debug(["Tried to send a non-crucial payload before the shard was ready, waiting"]);
        try {
          await (0, import_node_events2.once)(this, "ready");
        } catch {
          return this.send(payload);
        }
      }
      await this.sendQueue.wait();
      if (--this.sendRateLimitState.remaining <= 0) {
        const now = Date.now();
        if (this.sendRateLimitState.resetAt > now) {
          const sleepFor = this.sendRateLimitState.resetAt - now;
          this.debug([`Was about to hit the send rate limit, sleeping for ${sleepFor}ms`]);
          const controller = new AbortController;
          const interrupted = await Promise.race([
            (0, import_promises2.setTimeout)(sleepFor).then(() => false),
            (0, import_node_events2.once)(this, "closed", { signal: controller.signal }).then(() => true)
          ]);
          if (interrupted) {
            this.debug(["Connection closed while waiting for the send rate limit to reset, re-queueing payload"]);
            this.sendQueue.shift();
            return this.send(payload);
          }
          controller.abort();
        }
        this.sendRateLimitState = getInitialSendRateLimitState();
      }
      this.sendQueue.shift();
      this.connection.send(JSON.stringify(payload));
    }
    async identify() {
      this.debug(["Waiting for identify throttle"]);
      const controller = new AbortController;
      const closeHandler = __name(() => {
        controller.abort();
      }, "closeHandler");
      this.on("closed", closeHandler);
      try {
        await this.strategy.waitForIdentify(this.id, controller.signal);
      } catch {
        if (controller.signal.aborted) {
          this.debug(["Was waiting for an identify, but the shard closed in the meantime"]);
          return;
        }
        this.debug([
          "IContextFetchingStrategy#waitForIdentify threw an unknown error.",
          "If you're using a custom strategy, this is probably nothing to worry about.",
          "If you're not, please open an issue on GitHub."
        ]);
        await this.destroy({
          reason: "Identify throttling logic failed",
          recover: 1
        });
      } finally {
        this.off("closed", closeHandler);
      }
      this.debug([
        "Identifying",
        `shard id: ${this.id.toString()}`,
        `shard count: ${this.strategy.options.shardCount}`,
        `intents: ${this.strategy.options.intents}`,
        `compression: ${this.inflate ? "zlib-stream" : this.useIdentifyCompress ? "identify" : "none"}`
      ]);
      const d = {
        token: this.strategy.options.token,
        properties: this.strategy.options.identifyProperties,
        intents: this.strategy.options.intents,
        compress: this.useIdentifyCompress,
        shard: [this.id, this.strategy.options.shardCount]
      };
      if (this.strategy.options.largeThreshold) {
        d.large_threshold = this.strategy.options.largeThreshold;
      }
      if (this.strategy.options.initialPresence) {
        d.presence = this.strategy.options.initialPresence;
      }
      await this.send({
        op: import_v102.GatewayOpcodes.Identify,
        d
      });
      await this.waitForEvent("ready", this.strategy.options.readyTimeout);
    }
    async resume(session) {
      this.debug([
        "Resuming session",
        `resume url: ${session.resumeURL}`,
        `sequence: ${session.sequence}`,
        `shard id: ${this.id.toString()}`
      ]);
      this.#status = 2;
      this.replayedEvents = 0;
      return this.send({
        op: import_v102.GatewayOpcodes.Resume,
        d: {
          token: this.strategy.options.token,
          seq: session.sequence,
          session_id: session.sessionId
        }
      });
    }
    async heartbeat(requested = false) {
      if (!this.isAck && !requested) {
        return this.destroy({ reason: "Zombie connection", recover: 1 });
      }
      const session = await this.strategy.retrieveSessionInfo(this.id);
      await this.send({
        op: import_v102.GatewayOpcodes.Heartbeat,
        d: session?.sequence ?? null
      });
      this.lastHeartbeatAt = Date.now();
      this.isAck = false;
    }
    async unpackMessage(data, isBinary) {
      if (!isBinary) {
        try {
          return JSON.parse(data);
        } catch {
          return null;
        }
      }
      const decompressable = new Uint8Array(data);
      if (this.useIdentifyCompress) {
        return new Promise((resolve2, reject) => {
          (0, import_node_zlib.inflate)(decompressable, { chunkSize: 65535 }, (err, result) => {
            if (err) {
              reject(err);
              return;
            }
            resolve2(JSON.parse(this.textDecoder.decode(result)));
          });
        });
      }
      if (this.inflate) {
        const l = decompressable.length;
        const flush = l >= 4 && decompressable[l - 4] === 0 && decompressable[l - 3] === 0 && decompressable[l - 2] === 255 && decompressable[l - 1] === 255;
        const zlib = await getZlibSync();
        this.inflate.push(import_node_buffer.Buffer.from(decompressable), flush ? zlib.Z_SYNC_FLUSH : zlib.Z_NO_FLUSH);
        if (this.inflate.err) {
          this.emit("error", {
            error: new Error(`${this.inflate.err}${this.inflate.msg ? `: ${this.inflate.msg}` : ""}`)
          });
        }
        if (!flush) {
          return null;
        }
        const { result } = this.inflate;
        if (!result) {
          return null;
        }
        return JSON.parse(typeof result === "string" ? result : this.textDecoder.decode(result));
      }
      this.debug([
        "Received a message we were unable to decompress",
        `isBinary: ${isBinary.toString()}`,
        `useIdentifyCompress: ${this.useIdentifyCompress.toString()}`,
        `inflate: ${Boolean(this.inflate).toString()}`
      ]);
      return null;
    }
    async onMessage(data, isBinary) {
      const payload = await this.unpackMessage(data, isBinary);
      if (!payload) {
        return;
      }
      switch (payload.op) {
        case import_v102.GatewayOpcodes.Dispatch: {
          if (this.#status === 2) {
            this.replayedEvents++;
          }
          switch (payload.t) {
            case import_v102.GatewayDispatchEvents.Ready: {
              this.#status = 3;
              const session2 = {
                sequence: payload.s,
                sessionId: payload.d.session_id,
                shardId: this.id,
                shardCount: this.strategy.options.shardCount,
                resumeURL: payload.d.resume_gateway_url
              };
              await this.strategy.updateSessionInfo(this.id, session2);
              this.emit("ready", { data: payload.d });
              break;
            }
            case import_v102.GatewayDispatchEvents.Resumed: {
              this.#status = 3;
              this.debug([`Resumed and replayed ${this.replayedEvents} events`]);
              this.emit("resumed");
              break;
            }
            default: {
              break;
            }
          }
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (session) {
            if (payload.s > session.sequence) {
              await this.strategy.updateSessionInfo(this.id, { ...session, sequence: payload.s });
            }
          } else {
            this.debug([
              `Received a ${payload.t} event but no session is available. Session information cannot be re-constructed in this state without a full reconnect`
            ]);
          }
          this.emit("dispatch", { data: payload });
          break;
        }
        case import_v102.GatewayOpcodes.Heartbeat: {
          await this.heartbeat(true);
          break;
        }
        case import_v102.GatewayOpcodes.Reconnect: {
          await this.destroy({
            reason: "Told to reconnect by Discord",
            recover: 1
          });
          break;
        }
        case import_v102.GatewayOpcodes.InvalidSession: {
          this.debug([`Invalid session; will attempt to resume: ${payload.d.toString()}`]);
          const session = await this.strategy.retrieveSessionInfo(this.id);
          if (payload.d && session) {
            await this.resume(session);
          } else {
            await this.destroy({
              reason: "Invalid session",
              recover: 0
            });
          }
          break;
        }
        case import_v102.GatewayOpcodes.Hello: {
          this.emit("hello");
          const jitter = Math.random();
          const firstWait = Math.floor(payload.d.heartbeat_interval * jitter);
          this.debug([`Preparing first heartbeat of the connection with a jitter of ${jitter}; waiting ${firstWait}ms`]);
          try {
            const controller = new AbortController;
            this.initialHeartbeatTimeoutController = controller;
            await (0, import_promises2.setTimeout)(firstWait, undefined, { signal: controller.signal });
          } catch {
            this.debug(["Cancelled initial heartbeat due to #destroy being called"]);
            return;
          } finally {
            this.initialHeartbeatTimeoutController = null;
          }
          await this.heartbeat();
          this.debug([`First heartbeat sent, starting to beat every ${payload.d.heartbeat_interval}ms`]);
          this.heartbeatInterval = (0, import_node_timers.setInterval)(() => void this.heartbeat(), payload.d.heartbeat_interval);
          break;
        }
        case import_v102.GatewayOpcodes.HeartbeatAck: {
          this.isAck = true;
          const ackAt = Date.now();
          this.emit("heartbeat", {
            ackAt,
            heartbeatAt: this.lastHeartbeatAt,
            latency: ackAt - this.lastHeartbeatAt
          });
          break;
        }
      }
    }
    onError(error) {
      if (("code" in error) && ["ECONNRESET", "ECONNREFUSED"].includes(error.code)) {
        this.debug(["Failed to connect to the gateway URL specified due to a network error"]);
        this.failedToConnectDueToNetworkError = true;
        return;
      }
      this.emit("error", { error });
    }
    async onClose(code) {
      this.emit("closed", { code });
      switch (code) {
        case 1000: {
          return this.destroy({
            code,
            reason: "Got disconnected by Discord",
            recover: 0
          });
        }
        case 4200: {
          break;
        }
        case import_v102.GatewayCloseCodes.UnknownError: {
          this.debug([`An unknown error occurred: ${code}`]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.UnknownOpcode: {
          this.debug(["An invalid opcode was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.DecodeError: {
          this.debug(["An invalid payload was sent to Discord."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.NotAuthenticated: {
          this.debug(["A request was somehow sent before the identify/resume payload."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.AuthenticationFailed: {
          this.emit("error", {
            error: new Error("Authentication failed")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.AlreadyAuthenticated: {
          this.debug(["More than one auth payload was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.InvalidSeq: {
          this.debug(["An invalid sequence was sent."]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.RateLimited: {
          this.debug(["The WebSocket rate limit has been hit, this should never happen"]);
          return this.destroy({ code, recover: 0 });
        }
        case import_v102.GatewayCloseCodes.SessionTimedOut: {
          this.debug(["Session timed out."]);
          return this.destroy({ code, recover: 1 });
        }
        case import_v102.GatewayCloseCodes.InvalidShard: {
          this.emit("error", {
            error: new Error("Invalid shard")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.ShardingRequired: {
          this.emit("error", {
            error: new Error("Sharding is required")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidAPIVersion: {
          this.emit("error", {
            error: new Error("Used an invalid API version")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.InvalidIntents: {
          this.emit("error", {
            error: new Error("Used invalid intents")
          });
          return this.destroy({ code });
        }
        case import_v102.GatewayCloseCodes.DisallowedIntents: {
          this.emit("error", {
            error: new Error("Used disallowed intents")
          });
          return this.destroy({ code });
        }
        default: {
          this.debug([
            `The gateway closed with an unexpected code ${code}, attempting to ${this.failedToConnectDueToNetworkError ? "reconnect" : "resume"}.`
          ]);
          return this.destroy({
            code,
            recover: this.failedToConnectDueToNetworkError ? 0 : 1
          });
        }
      }
    }
    debug(messages) {
      const message = `${messages[0]}${messages.length > 1 ? `
${messages.slice(1).map((m) => `	${m}`).join("\n")}` : ""}`;
      this.emit("debug", { message });
    }
  };
  var SimpleShardingStrategy = class {
    static {
      __name(this, "SimpleShardingStrategy");
    }
    manager;
    shards = new import_collection6.Collection;
    constructor(manager) {
      this.manager = manager;
    }
    async spawn(shardIds) {
      const strategyOptions = await managerToFetchingStrategyOptions(this.manager);
      for (const shardId of shardIds) {
        const strategy = new SimpleContextFetchingStrategy(this.manager, strategyOptions);
        const shard = new WebSocketShard(strategy, shardId);
        for (const event of Object.values(WebSocketShardEvents)) {
          shard.on(event, (payload) => this.manager.emit(event, { ...payload, shardId }));
        }
        this.shards.set(shardId, shard);
      }
    }
    async connect() {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.connect());
      }
      await Promise.all(promises);
    }
    async destroy(options) {
      const promises = [];
      for (const shard of this.shards.values()) {
        promises.push(shard.destroy(options));
      }
      await Promise.all(promises);
      this.shards.clear();
    }
    async send(shardId, payload) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} not found`);
      }
      return shard.send(payload);
    }
    async fetchStatus() {
      return this.shards.mapValues((shard) => shard.status);
    }
  };
  var import_node_worker_threads3 = __require("worker_threads");
  var import_collection7 = require_dist2();
  var WorkerBootstrapper = class {
    static {
      __name(this, "WorkerBootstrapper");
    }
    data = import_node_worker_threads3.workerData;
    shards = new import_collection7.Collection;
    constructor() {
      if (import_node_worker_threads3.isMainThread) {
        throw new Error("Expected WorkerBootstrap to not be used within the main thread");
      }
    }
    async connect(shardId) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.connect();
    }
    async destroy(shardId, options) {
      const shard = this.shards.get(shardId);
      if (!shard) {
        throw new RangeError(`Shard ${shardId} does not exist`);
      }
      await shard.destroy(options);
    }
    setupThreadEvents() {
      import_node_worker_threads3.parentPort.on("messageerror", (err) => {
        throw err;
      }).on("message", async (payload) => {
        switch (payload.op) {
          case 0: {
            await this.connect(payload.shardId);
            const response = {
              op: 0,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 1: {
            await this.destroy(payload.shardId, payload.options);
            const response = {
              op: 1,
              shardId: payload.shardId
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
          case 2: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new RangeError(`Shard ${payload.shardId} does not exist`);
            }
            await shard.send(payload.payload);
            break;
          }
          case 3: {
            break;
          }
          case 4: {
            break;
          }
          case 5: {
            const shard = this.shards.get(payload.shardId);
            if (!shard) {
              throw new Error(`Shard ${payload.shardId} does not exist`);
            }
            const response = {
              op: 6,
              status: shard.status,
              nonce: payload.nonce
            };
            import_node_worker_threads3.parentPort.postMessage(response);
            break;
          }
        }
      });
    }
    async bootstrap(options = {}) {
      for (const shardId of this.data.shardIds) {
        const shard = new WebSocketShard(new WorkerContextFetchingStrategy(this.data), shardId);
        for (const event of options.forwardEvents ?? Object.values(WebSocketShardEvents)) {
          shard.on(event, (data) => {
            const payload = {
              op: 2,
              event,
              data,
              shardId
            };
            import_node_worker_threads3.parentPort.postMessage(payload);
          });
        }
        await options.shardCallback?.(shard);
        this.shards.set(shardId, shard);
      }
      this.setupThreadEvents();
      const message = {
        op: 7
      };
      import_node_worker_threads3.parentPort.postMessage(message);
    }
  };
  var import_util3 = require_dist();
  var import_async_event_emitter2 = require_dist4();
  var import_v103 = require_v106();
  var WebSocketManager = class extends import_async_event_emitter2.AsyncEventEmitter {
    static {
      __name(this, "WebSocketManager");
    }
    options;
    gatewayInformation = null;
    shardIds = null;
    strategy;
    constructor(options) {
      super();
      this.options = { ...DefaultWebSocketManagerOptions, ...options };
      this.strategy = this.options.buildStrategy(this);
    }
    async fetchGatewayInformation(force = false) {
      if (this.gatewayInformation) {
        if (this.gatewayInformation.expiresAt <= Date.now()) {
          this.gatewayInformation = null;
        } else if (!force) {
          return this.gatewayInformation.data;
        }
      }
      const data = await this.options.rest.get(import_v103.Routes.gatewayBot());
      this.gatewayInformation = { data, expiresAt: Date.now() + (data.session_start_limit.reset_after || 5000) };
      return this.gatewayInformation.data;
    }
    async updateShardCount(shardCount) {
      await this.strategy.destroy({ reason: "User is adjusting their shards" });
      this.options.shardCount = shardCount;
      const shardIds = await this.getShardIds(true);
      await this.strategy.spawn(shardIds);
      return this;
    }
    async getShardCount() {
      if (this.options.shardCount) {
        return this.options.shardCount;
      }
      const shardIds = await this.getShardIds();
      return Math.max(...shardIds) + 1;
    }
    async getShardIds(force = false) {
      if (this.shardIds && !force) {
        return this.shardIds;
      }
      let shardIds;
      if (this.options.shardIds) {
        if (Array.isArray(this.options.shardIds)) {
          shardIds = this.options.shardIds;
        } else {
          const { start, end } = this.options.shardIds;
          shardIds = [...(0, import_util3.range)({ start, end: end + 1 })];
        }
      } else {
        const data = await this.fetchGatewayInformation();
        shardIds = [...(0, import_util3.range)(this.options.shardCount ?? data.shards)];
      }
      this.shardIds = shardIds;
      return shardIds;
    }
    async connect() {
      const shardCount = await this.getShardCount();
      const data = await this.fetchGatewayInformation();
      if (data.session_start_limit.remaining < shardCount) {
        throw new Error(`Not enough sessions remaining to spawn ${shardCount} shards; only ${data.session_start_limit.remaining} remaining; resets at ${new Date(Date.now() + data.session_start_limit.reset_after).toISOString()}`);
      }
      await this.updateShardCount(shardCount);
      await this.strategy.connect();
    }
    destroy(options) {
      return this.strategy.destroy(options);
    }
    send(shardId, payload) {
      return this.strategy.send(shardId, payload);
    }
    fetchStatus() {
      return this.strategy.fetchStatus();
    }
  };
  var version = "1.0.1";
});

// node_modules/discord.js/src/util/WebSocketShardEvents.js
var require_WebSocketShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Close: "close",
    Destroyed: "destroyed",
    InvalidSession: "invalidSession",
    Ready: "ready",
    Resumed: "resumed",
    AllReady: "allReady"
  };
});

// node_modules/discord.js/src/client/websocket/WebSocketShard.js
var require_WebSocketShard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { GatewayIntentBits } = require_v106();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var deprecationEmittedForImportant = false;

  class WebSocketShard extends EventEmitter {
    constructor(manager, id) {
      super();
      this.manager = manager;
      this.id = id;
      this.status = Status.Idle;
      this.closeSequence = 0;
      this.ping = -1;
      this.lastPingTimestamp = -1;
      Object.defineProperty(this, "expectedGuilds", { value: null, writable: true });
      Object.defineProperty(this, "readyTimeout", { value: null, writable: true });
      Object.defineProperty(this, "sessionInfo", { value: null, writable: true });
    }
    debug(message) {
      this.manager.debug(message, this.id);
    }
    emitClose(event = {
      code: 1011,
      reason: "INTERNAL_ERROR",
      wasClean: false
    }) {
      this.debug(`[CLOSE]
    Event Code: ${event.code}
    Clean     : ${event.wasClean}
    Reason    : ${event.reason ?? "No reason received"}`);
      this.emit(WebSocketShardEvents.Close, event);
    }
    onReadyPacket(packet) {
      if (!packet) {
        this.debug(`Received broken packet: '${packet}'.`);
        return;
      }
      this.emit(WebSocketShardEvents.Ready);
      this.expectedGuilds = new Set(packet.guilds.map((d) => d.id));
      this.status = Status.WaitingForGuilds;
    }
    gotGuild(guildId) {
      this.expectedGuilds.delete(guildId);
      this.checkReady();
    }
    checkReady() {
      if (this.readyTimeout) {
        clearTimeout2(this.readyTimeout);
        this.readyTimeout = null;
      }
      if (!this.expectedGuilds.size) {
        this.debug("Shard received all its guilds. Marking as fully ready.");
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady);
        return;
      }
      const hasGuildsIntent = this.manager.client.options.intents.has(GatewayIntentBits.Guilds);
      const { waitGuildTimeout } = this.manager.client.options;
      this.readyTimeout = setTimeout2(() => {
        this.debug(`Shard ${hasGuildsIntent ? "did" : "will"} not receive any more guild packets` + `${hasGuildsIntent ? ` in ${waitGuildTimeout} ms` : ""}.\nUnavailable guild count: ${this.expectedGuilds.size}`);
        this.readyTimeout = null;
        this.status = Status.Ready;
        this.emit(WebSocketShardEvents.AllReady, this.expectedGuilds);
      }, hasGuildsIntent ? waitGuildTimeout : 0).unref();
    }
    send(data, important = false) {
      if (important && !deprecationEmittedForImportant) {
        process2.emitWarning("Sending important payloads explicitly is deprecated. They are determined by their opcode implicitly now.", "DeprecationWarning");
        deprecationEmittedForImportant = true;
      }
      this.manager._ws.send(this.id, data);
    }
  }
  module.exports = WebSocketShard;
});

// node_modules/discord.js/src/client/websocket/handlers/APPLICATION_COMMAND_PERMISSIONS_UPDATE.js
var require_APPLICATION_COMMAND_PERMISSIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ApplicationCommandPermissionsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_ACTION_EXECUTION.js
var require_AUTO_MODERATION_ACTION_EXECUTION = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationActionExecution.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_CREATE.js
var require_AUTO_MODERATION_RULE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_DELETE.js
var require_AUTO_MODERATION_RULE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/AUTO_MODERATION_RULE_UPDATE.js
var require_AUTO_MODERATION_RULE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.AutoModerationRuleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_CREATE.js
var require_CHANNEL_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_DELETE.js
var require_CHANNEL_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ChannelDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_PINS_UPDATE.js
var require_CHANNEL_PINS_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const channel = client.channels.cache.get(data.channel_id);
    const time = data.last_pin_timestamp ? Date.parse(data.last_pin_timestamp) : null;
    if (channel) {
      channel.lastPinTimestamp = time;
      client.emit(Events.ChannelPinsUpdate, channel, time);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/CHANNEL_UPDATE.js
var require_CHANNEL_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ChannelUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_AUDIT_LOG_ENTRY_CREATE.js
var require_GUILD_AUDIT_LOG_ENTRY_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildAuditLogEntryCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_ADD.js
var require_GUILD_BAN_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_BAN_REMOVE.js
var require_GUILD_BAN_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildBanRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_CREATE.js
var require_GUILD_CREATE = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    let guild = client.guilds.cache.get(data.id);
    if (guild) {
      if (!guild.available && !data.unavailable) {
        guild._patch(data);
        client.emit(Events.GuildAvailable, guild);
      }
    } else {
      data.shardId = shard.id;
      guild = client.guilds._add(data);
      if (client.ws.status === Status.Ready) {
        client.emit(Events.GuildCreate, guild);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_DELETE.js
var require_GUILD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_EMOJIS_UPDATE.js
var require_GUILD_EMOJIS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildEmojisUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_INTEGRATIONS_UPDATE.js
var require_GUILD_INTEGRATIONS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildIntegrationsUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBERS_CHUNK.js
var require_GUILD_MEMBERS_CHUNK = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var Events = require_Events();
  module.exports = (client, { d: data }) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (!guild)
      return;
    const members = new Collection;
    for (const member of data.members)
      members.set(member.user.id, guild.members._add(member));
    if (data.presences) {
      for (const presence of data.presences)
        guild.presences._add(Object.assign(presence, { guild }));
    }
    client.emit(Events.GuildMembersChunk, members, guild, {
      index: data.chunk_index,
      count: data.chunk_count,
      notFound: data.not_found,
      nonce: data.nonce
    });
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_ADD.js
var require_GUILD_MEMBER_ADD = __commonJS((exports, module) => {
  var Events = require_Events();
  var Status = require_Status();
  module.exports = (client, { d: data }, shard) => {
    const guild = client.guilds.cache.get(data.guild_id);
    if (guild) {
      guild.memberCount++;
      const member = guild.members._add(data);
      if (shard.status === Status.Ready) {
        client.emit(Events.GuildMemberAdd, member);
      }
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_REMOVE.js
var require_GUILD_MEMBER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberRemove.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_MEMBER_UPDATE.js
var require_GUILD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet, shard) => {
    client.actions.GuildMemberUpdate.handle(packet.d, shard);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_CREATE.js
var require_GUILD_ROLE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_DELETE.js
var require_GUILD_ROLE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_ROLE_UPDATE.js
var require_GUILD_ROLE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildRoleUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_CREATE.js
var require_GUILD_SCHEDULED_EVENT_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_DELETE.js
var require_GUILD_SCHEDULED_EVENT_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_UPDATE.js
var require_GUILD_SCHEDULED_EVENT_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_ADD.js
var require_GUILD_SCHEDULED_EVENT_USER_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_SCHEDULED_EVENT_USER_REMOVE.js
var require_GUILD_SCHEDULED_EVENT_USER_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildScheduledEventUserRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_STICKERS_UPDATE.js
var require_GUILD_STICKERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildStickersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/GUILD_UPDATE.js
var require_GUILD_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.GuildUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INTERACTION_CREATE.js
var require_INTERACTION_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InteractionCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_CREATE.js
var require_INVITE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/INVITE_DELETE.js
var require_INVITE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.InviteDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_CREATE.js
var require_MESSAGE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE.js
var require_MESSAGE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_DELETE_BULK.js
var require_MESSAGE_DELETE_BULK = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageDeleteBulk.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_ADD.js
var require_MESSAGE_REACTION_ADD = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionAdd.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE.js
var require_MESSAGE_REACTION_REMOVE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemove.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_ALL.js
var require_MESSAGE_REACTION_REMOVE_ALL = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveAll.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_REACTION_REMOVE_EMOJI.js
var require_MESSAGE_REACTION_REMOVE_EMOJI = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.MessageReactionRemoveEmoji.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/MESSAGE_UPDATE.js
var require_MESSAGE_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.MessageUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.MessageUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/PRESENCE_UPDATE.js
var require_PRESENCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.PresenceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/structures/ClientUser.js
var require_ClientUser = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var User = require_User();
  var DataResolver = require_DataResolver();

  class ClientUser extends User {
    _patch(data) {
      super._patch(data);
      if ("verified" in data) {
        this.verified = data.verified;
      }
      if ("mfa_enabled" in data) {
        this.mfaEnabled = typeof data.mfa_enabled === "boolean" ? data.mfa_enabled : null;
      } else {
        this.mfaEnabled ??= null;
      }
      if ("token" in data)
        this.client.token = data.token;
    }
    get presence() {
      return this.client.presence;
    }
    async edit({ username, avatar }) {
      const data = await this.client.rest.patch(Routes.user(), {
        body: { username, avatar: avatar && await DataResolver.resolveImage(avatar) }
      });
      this.client.token = data.token;
      this.client.rest.setToken(data.token);
      const { updated } = this.client.actions.UserUpdate.handle(data);
      return updated ?? this;
    }
    setUsername(username) {
      return this.edit({ username });
    }
    setAvatar(avatar) {
      return this.edit({ avatar });
    }
    setPresence(data) {
      return this.client.presence.set(data);
    }
    setStatus(status, shardId) {
      return this.setPresence({ status, shardId });
    }
    setActivity(name, options = {}) {
      if (!name)
        return this.setPresence({ activities: [], shardId: options.shardId });
      const activity = Object.assign({}, options, typeof name === "object" ? name : { name });
      return this.setPresence({ activities: [activity], shardId: activity.shardId });
    }
    setAFK(afk = true, shardId) {
      return this.setPresence({ afk, shardId });
    }
  }
  module.exports = ClientUser;
});

// node_modules/discord.js/src/client/websocket/handlers/READY.js
var require_READY = __commonJS((exports, module) => {
  var ClientApplication = require_ClientApplication();
  var ClientUser;
  module.exports = (client, { d: data }, shard) => {
    if (client.user) {
      client.user._patch(data.user);
    } else {
      ClientUser ??= require_ClientUser();
      client.user = new ClientUser(client, data.user);
      client.users.cache.set(client.user.id, client.user);
    }
    for (const guild of data.guilds) {
      guild.shardId = shard.id;
      client.guilds._add(guild);
    }
    if (client.application) {
      client.application._patch(data.application);
    } else {
      client.application = new ClientApplication(client, data.application);
    }
    shard.checkReady();
  };
});

// node_modules/discord.js/src/client/websocket/handlers/RESUMED.js
var require_RESUMED = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet, shard) => {
    const replayed = shard.sessionInfo.sequence - shard.closeSequence;
    client.emit(Events.ShardResume, shard.id, replayed);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_CREATE.js
var require_STAGE_INSTANCE_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_DELETE.js
var require_STAGE_INSTANCE_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/STAGE_INSTANCE_UPDATE.js
var require_STAGE_INSTANCE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.StageInstanceUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_CREATE.js
var require_THREAD_CREATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadCreate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_DELETE.js
var require_THREAD_DELETE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadDelete.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_LIST_SYNC.js
var require_THREAD_LIST_SYNC = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadListSync.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBERS_UPDATE.js
var require_THREAD_MEMBERS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMembersUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_MEMBER_UPDATE.js
var require_THREAD_MEMBER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.ThreadMemberUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/THREAD_UPDATE.js
var require_THREAD_UPDATE = __commonJS((exports, module) => {
  var Events = require_Events();
  module.exports = (client, packet) => {
    const { old, updated } = client.actions.ChannelUpdate.handle(packet.d);
    if (old && updated) {
      client.emit(Events.ThreadUpdate, old, updated);
    }
  };
});

// node_modules/discord.js/src/client/websocket/handlers/TYPING_START.js
var require_TYPING_START = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.TypingStart.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/USER_UPDATE.js
var require_USER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.UserUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_SERVER_UPDATE.js
var require_VOICE_SERVER_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.emit("debug", `[VOICE] received voice server: ${JSON.stringify(packet)}`);
    client.voice.onVoiceServer(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/VOICE_STATE_UPDATE.js
var require_VOICE_STATE_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.VoiceStateUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/WEBHOOKS_UPDATE.js
var require_WEBHOOKS_UPDATE = __commonJS((exports, module) => {
  module.exports = (client, packet) => {
    client.actions.WebhooksUpdate.handle(packet.d);
  };
});

// node_modules/discord.js/src/client/websocket/handlers/index.js
var require_handlers = __commonJS((exports, module) => {
  var handlers = Object.fromEntries([
    ["APPLICATION_COMMAND_PERMISSIONS_UPDATE", require_APPLICATION_COMMAND_PERMISSIONS_UPDATE()],
    ["AUTO_MODERATION_ACTION_EXECUTION", require_AUTO_MODERATION_ACTION_EXECUTION()],
    ["AUTO_MODERATION_RULE_CREATE", require_AUTO_MODERATION_RULE_CREATE()],
    ["AUTO_MODERATION_RULE_DELETE", require_AUTO_MODERATION_RULE_DELETE()],
    ["AUTO_MODERATION_RULE_UPDATE", require_AUTO_MODERATION_RULE_UPDATE()],
    ["CHANNEL_CREATE", require_CHANNEL_CREATE()],
    ["CHANNEL_DELETE", require_CHANNEL_DELETE()],
    ["CHANNEL_PINS_UPDATE", require_CHANNEL_PINS_UPDATE()],
    ["CHANNEL_UPDATE", require_CHANNEL_UPDATE()],
    ["GUILD_AUDIT_LOG_ENTRY_CREATE", require_GUILD_AUDIT_LOG_ENTRY_CREATE()],
    ["GUILD_BAN_ADD", require_GUILD_BAN_ADD()],
    ["GUILD_BAN_REMOVE", require_GUILD_BAN_REMOVE()],
    ["GUILD_CREATE", require_GUILD_CREATE()],
    ["GUILD_DELETE", require_GUILD_DELETE()],
    ["GUILD_EMOJIS_UPDATE", require_GUILD_EMOJIS_UPDATE()],
    ["GUILD_INTEGRATIONS_UPDATE", require_GUILD_INTEGRATIONS_UPDATE()],
    ["GUILD_MEMBERS_CHUNK", require_GUILD_MEMBERS_CHUNK()],
    ["GUILD_MEMBER_ADD", require_GUILD_MEMBER_ADD()],
    ["GUILD_MEMBER_REMOVE", require_GUILD_MEMBER_REMOVE()],
    ["GUILD_MEMBER_UPDATE", require_GUILD_MEMBER_UPDATE()],
    ["GUILD_ROLE_CREATE", require_GUILD_ROLE_CREATE()],
    ["GUILD_ROLE_DELETE", require_GUILD_ROLE_DELETE()],
    ["GUILD_ROLE_UPDATE", require_GUILD_ROLE_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_CREATE", require_GUILD_SCHEDULED_EVENT_CREATE()],
    ["GUILD_SCHEDULED_EVENT_DELETE", require_GUILD_SCHEDULED_EVENT_DELETE()],
    ["GUILD_SCHEDULED_EVENT_UPDATE", require_GUILD_SCHEDULED_EVENT_UPDATE()],
    ["GUILD_SCHEDULED_EVENT_USER_ADD", require_GUILD_SCHEDULED_EVENT_USER_ADD()],
    ["GUILD_SCHEDULED_EVENT_USER_REMOVE", require_GUILD_SCHEDULED_EVENT_USER_REMOVE()],
    ["GUILD_STICKERS_UPDATE", require_GUILD_STICKERS_UPDATE()],
    ["GUILD_UPDATE", require_GUILD_UPDATE()],
    ["INTERACTION_CREATE", require_INTERACTION_CREATE()],
    ["INVITE_CREATE", require_INVITE_CREATE()],
    ["INVITE_DELETE", require_INVITE_DELETE()],
    ["MESSAGE_CREATE", require_MESSAGE_CREATE()],
    ["MESSAGE_DELETE", require_MESSAGE_DELETE()],
    ["MESSAGE_DELETE_BULK", require_MESSAGE_DELETE_BULK()],
    ["MESSAGE_REACTION_ADD", require_MESSAGE_REACTION_ADD()],
    ["MESSAGE_REACTION_REMOVE", require_MESSAGE_REACTION_REMOVE()],
    ["MESSAGE_REACTION_REMOVE_ALL", require_MESSAGE_REACTION_REMOVE_ALL()],
    ["MESSAGE_REACTION_REMOVE_EMOJI", require_MESSAGE_REACTION_REMOVE_EMOJI()],
    ["MESSAGE_UPDATE", require_MESSAGE_UPDATE()],
    ["PRESENCE_UPDATE", require_PRESENCE_UPDATE()],
    ["READY", require_READY()],
    ["RESUMED", require_RESUMED()],
    ["STAGE_INSTANCE_CREATE", require_STAGE_INSTANCE_CREATE()],
    ["STAGE_INSTANCE_DELETE", require_STAGE_INSTANCE_DELETE()],
    ["STAGE_INSTANCE_UPDATE", require_STAGE_INSTANCE_UPDATE()],
    ["THREAD_CREATE", require_THREAD_CREATE()],
    ["THREAD_DELETE", require_THREAD_DELETE()],
    ["THREAD_LIST_SYNC", require_THREAD_LIST_SYNC()],
    ["THREAD_MEMBERS_UPDATE", require_THREAD_MEMBERS_UPDATE()],
    ["THREAD_MEMBER_UPDATE", require_THREAD_MEMBER_UPDATE()],
    ["THREAD_UPDATE", require_THREAD_UPDATE()],
    ["TYPING_START", require_TYPING_START()],
    ["USER_UPDATE", require_USER_UPDATE()],
    ["VOICE_SERVER_UPDATE", require_VOICE_SERVER_UPDATE()],
    ["VOICE_STATE_UPDATE", require_VOICE_STATE_UPDATE()],
    ["WEBHOOKS_UPDATE", require_WEBHOOKS_UPDATE()]
  ]);
  module.exports = handlers;
});

// node_modules/discord.js/src/client/websocket/WebSocketManager.js
var require_WebSocketManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var process2 = __require("node:process");
  var { setImmediate: setImmediate2 } = __require("node:timers");
  var { Collection } = require_dist2();
  var {
    WebSocketManager: WSWebSocketManager,
    WebSocketShardEvents: WSWebSocketShardEvents,
    CompressionMethod,
    CloseCodes
  } = require_dist11();
  var { GatewayCloseCodes, GatewayDispatchEvents } = require_v106();
  var WebSocketShard = require_WebSocketShard();
  var PacketHandlers = require_handlers();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var Status = require_Status();
  var WebSocketShardEvents = require_WebSocketShardEvents();
  var zlib;
  try {
    zlib = (()=>{ throw new Error(`Cannot require module "zlib-sync"`);})();
  } catch {
  }
  var BeforeReadyWhitelist = [
    GatewayDispatchEvents.Ready,
    GatewayDispatchEvents.Resumed,
    GatewayDispatchEvents.GuildCreate,
    GatewayDispatchEvents.GuildDelete,
    GatewayDispatchEvents.GuildMembersChunk,
    GatewayDispatchEvents.GuildMemberAdd,
    GatewayDispatchEvents.GuildMemberRemove
  ];
  var WaitingForGuildEvents = [GatewayDispatchEvents.GuildCreate, GatewayDispatchEvents.GuildDelete];
  var UNRESUMABLE_CLOSE_CODES = [
    CloseCodes.Normal,
    GatewayCloseCodes.AlreadyAuthenticated,
    GatewayCloseCodes.InvalidSeq
  ];
  var reasonIsDeprecated = "the reason property is deprecated, use the code property to determine the reason";
  var deprecationEmittedForInvalidSessionEvent = false;
  var deprecationEmittedForDestroyedEvent = false;

  class WebSocketManager extends EventEmitter {
    constructor(client) {
      super();
      Object.defineProperty(this, "client", { value: client });
      this.gateway = null;
      this.shards = new Collection;
      Object.defineProperty(this, "packetQueue", { value: [] });
      this.status = Status.Idle;
      this.destroyed = false;
      this._ws = null;
    }
    get ping() {
      const sum = this.shards.reduce((a, b) => a + b.ping, 0);
      return sum / this.shards.size;
    }
    debug(message, shardId) {
      this.client.emit(Events.Debug, `[WS => ${typeof shardId === "number" ? `Shard ${shardId}` : "Manager"}] ${message}`);
    }
    async connect() {
      const invalidToken = new DiscordjsError(ErrorCodes.TokenInvalid);
      const { shards, shardCount, intents, ws } = this.client.options;
      if (this._ws && this._ws.options.token !== this.client.token) {
        await this._ws.destroy({ code: CloseCodes.Normal, reason: "Login with differing token requested" });
        this._ws = null;
      }
      if (!this._ws) {
        const wsOptions = {
          intents: intents.bitfield,
          rest: this.client.rest,
          token: this.client.token,
          largeThreshold: ws.large_threshold,
          version: ws.version,
          shardIds: shards === "auto" ? null : shards,
          shardCount: shards === "auto" ? null : shardCount,
          initialPresence: ws.presence,
          retrieveSessionInfo: (shardId) => this.shards.get(shardId).sessionInfo,
          updateSessionInfo: (shardId, sessionInfo) => {
            this.shards.get(shardId).sessionInfo = sessionInfo;
          },
          compression: zlib ? CompressionMethod.ZlibStream : null
        };
        if (ws.buildIdentifyThrottler)
          wsOptions.buildIdentifyThrottler = ws.buildIdentifyThrottler;
        if (ws.buildStrategy)
          wsOptions.buildStrategy = ws.buildStrategy;
        this._ws = new WSWebSocketManager(wsOptions);
        this.attachEvents();
      }
      const {
        url: gatewayURL,
        shards: recommendedShards,
        session_start_limit: sessionStartLimit
      } = await this._ws.fetchGatewayInformation().catch((error) => {
        throw error.status === 401 ? invalidToken : error;
      });
      const { total, remaining } = sessionStartLimit;
      this.debug(`Fetched Gateway Information
    URL: ${gatewayURL}
    Recommended Shards: ${recommendedShards}`);
      this.debug(`Session Limit Information
    Total: ${total}
    Remaining: ${remaining}`);
      this.gateway = `${gatewayURL}/`;
      this.client.options.shardCount = await this._ws.getShardCount();
      this.client.options.shards = await this._ws.getShardIds();
      this.totalShards = this.client.options.shards.length;
      for (const id of this.client.options.shards) {
        if (!this.shards.has(id)) {
          const shard = new WebSocketShard(this, id);
          this.shards.set(id, shard);
          shard.on(WebSocketShardEvents.AllReady, (unavailableGuilds) => {
            this.client.emit(Events.ShardReady, shard.id, unavailableGuilds);
            this.checkShardsReady();
          });
          shard.status = Status.Connecting;
        }
      }
      await this._ws.connect();
      this.shards.forEach((shard) => {
        if (shard.listenerCount(WebSocketShardEvents.InvalidSession) > 0 && !deprecationEmittedForInvalidSessionEvent) {
          process2.emitWarning("The WebSocketShard#invalidSession event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForInvalidSessionEvent = true;
        }
        if (shard.listenerCount(WebSocketShardEvents.Destroyed) > 0 && !deprecationEmittedForDestroyedEvent) {
          process2.emitWarning("The WebSocketShard#destroyed event is deprecated and will never emit.", "DeprecationWarning");
          deprecationEmittedForDestroyedEvent = true;
        }
      });
    }
    attachEvents() {
      this._ws.on(WSWebSocketShardEvents.Debug, ({ message, shardId }) => this.debug(message, shardId));
      this._ws.on(WSWebSocketShardEvents.Dispatch, ({ data, shardId }) => {
        this.client.emit(Events.Raw, data, shardId);
        this.emit(data.t, data.d, shardId);
        const shard = this.shards.get(shardId);
        this.handlePacket(data, shard);
        if (shard.status === Status.WaitingForGuilds && WaitingForGuildEvents.includes(data.t)) {
          shard.gotGuild(data.d.id);
        }
      });
      this._ws.on(WSWebSocketShardEvents.Ready, ({ data, shardId }) => {
        this.shards.get(shardId).onReadyPacket(data);
      });
      this._ws.on(WSWebSocketShardEvents.Closed, ({ code, shardId }) => {
        const shard = this.shards.get(shardId);
        shard.emit(WebSocketShardEvents.Close, { code, reason: reasonIsDeprecated, wasClean: true });
        if (UNRESUMABLE_CLOSE_CODES.includes(code) && this.destroyed) {
          shard.status = Status.Disconnected;
          this.client.emit(Events.ShardDisconnect, { code, reason: reasonIsDeprecated, wasClean: true }, shardId);
          this.debug(GatewayCloseCodes[code], shardId);
          return;
        }
        this.shards.get(shardId).status = Status.Connecting;
        this.client.emit(Events.ShardReconnecting, shardId);
      });
      this._ws.on(WSWebSocketShardEvents.Hello, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        if (shard.sessionInfo) {
          shard.closeSequence = shard.sessionInfo.sequence;
          shard.status = Status.Resuming;
        } else {
          shard.status = Status.Identifying;
        }
      });
      this._ws.on(WSWebSocketShardEvents.Resumed, ({ shardId }) => {
        const shard = this.shards.get(shardId);
        shard.status = Status.Ready;
        shard.emit(WebSocketShardEvents.Resumed);
      });
      this._ws.on(WSWebSocketShardEvents.HeartbeatComplete, ({ heartbeatAt, latency, shardId }) => {
        this.debug(`Heartbeat acknowledged, latency of ${latency}ms.`, shardId);
        const shard = this.shards.get(shardId);
        shard.lastPingTimestamp = heartbeatAt;
        shard.ping = latency;
      });
      this._ws.on(WSWebSocketShardEvents.Error, ({ error, shardId }) => {
        this.client.emit(Events.ShardError, error, shardId);
      });
    }
    broadcast(packet) {
      for (const shardId of this.shards.keys())
        this._ws.send(shardId, packet);
    }
    async destroy() {
      if (this.destroyed)
        return;
      this.debug(`Manager was destroyed. Called by:\n${new Error().stack}`);
      this.destroyed = true;
      await this._ws?.destroy({ code: CloseCodes.Normal });
    }
    handlePacket(packet, shard) {
      if (packet && this.status !== Status.Ready) {
        if (!BeforeReadyWhitelist.includes(packet.t)) {
          this.packetQueue.push({ packet, shard });
          return false;
        }
      }
      if (this.packetQueue.length) {
        const item = this.packetQueue.shift();
        setImmediate2(() => {
          this.handlePacket(item.packet, item.shard);
        }).unref();
      }
      if (packet && PacketHandlers[packet.t]) {
        PacketHandlers[packet.t](this.client, packet, shard);
      }
      return true;
    }
    checkShardsReady() {
      if (this.status === Status.Ready)
        return;
      if (this.shards.size !== this.totalShards || this.shards.some((s) => s.status !== Status.Ready)) {
        return;
      }
      this.triggerClientReady();
    }
    triggerClientReady() {
      this.status = Status.Ready;
      this.client.readyTimestamp = Date.now();
      this.client.emit(Events.ClientReady, this.client);
      this.handlePacket();
    }
  }
  module.exports = WebSocketManager;
});

// node_modules/discord.js/src/managers/BaseGuildEmojiManager.js
var require_BaseGuildEmojiManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var GuildEmoji = require_GuildEmoji();
  var ReactionEmoji = require_ReactionEmoji();
  var { parseEmoji } = require_Util();

  class BaseGuildEmojiManager extends CachedManager {
    constructor(client, iterable) {
      super(client, GuildEmoji, iterable);
    }
    resolve(emoji) {
      if (emoji instanceof ReactionEmoji)
        return super.resolve(emoji.id);
      return super.resolve(emoji);
    }
    resolveId(emoji) {
      if (emoji instanceof ReactionEmoji)
        return emoji.id;
      return super.resolveId(emoji);
    }
    resolveIdentifier(emoji) {
      const emojiResolvable = this.resolve(emoji);
      if (emojiResolvable)
        return emojiResolvable.identifier;
      if (emoji instanceof ReactionEmoji)
        return emoji.identifier;
      if (typeof emoji === "string") {
        const res = parseEmoji(emoji);
        if (res?.name.length) {
          emoji = `${res.animated ? "a:" : ""}${res.name}${res.id ? `:${res.id}` : ""}`;
        }
        if (!emoji.includes("%"))
          return encodeURIComponent(emoji);
        return emoji;
      }
      return null;
    }
  }
  module.exports = BaseGuildEmojiManager;
});

// node_modules/discord.js/src/managers/ChannelManager.js
var require_ChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { BaseChannel } = require_BaseChannel();
  var { createChannel } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var Events = require_Events();
  var cacheWarningEmitted = false;

  class ChannelManager extends CachedManager {
    constructor(client, iterable) {
      super(client, BaseChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    _add(data, guild, { cache = true, allowUnknownGuild = false } = {}) {
      const existing = this.cache.get(data.id);
      if (existing) {
        if (cache)
          existing._patch(data);
        guild?.channels?._add(existing);
        if (ThreadChannelTypes.includes(existing.type)) {
          existing.parent?.threads?._add(existing);
        }
        return existing;
      }
      const channel = createChannel(this.client, data, guild, { allowUnknownGuild });
      if (!channel) {
        this.client.emit(Events.Debug, `Failed to find guild, or unknown type for channel ${data.id} ${data.type}`);
        return null;
      }
      if (cache && !allowUnknownGuild)
        this.cache.set(channel.id, channel);
      return channel;
    }
    _remove(id) {
      const channel = this.cache.get(id);
      channel?.guild?.channels.cache.delete(id);
      for (const [code, invite] of channel?.guild?.invites.cache ?? []) {
        if (invite.channelId === id)
          channel.guild.invites.cache.delete(code);
      }
      channel?.parent?.threads?.cache.delete(id);
      this.cache.delete(id);
    }
    async fetch(id, { allowUnknownGuild = false, cache = true, force = false } = {}) {
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.channel(id));
      return this._add(data, null, { cache, allowUnknownGuild });
    }
  }
  module.exports = ChannelManager;
});

// node_modules/discord.js/src/structures/GuildAuditLogs.js
var require_GuildAuditLogs = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var ApplicationCommand = require_ApplicationCommand();
  var GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var { flatten } = require_Util();

  class GuildAuditLogs {
    constructor(guild, data) {
      if (data.users)
        for (const user of data.users)
          guild.client.users._add(user);
      if (data.threads)
        for (const thread of data.threads)
          guild.client.channels._add(thread, guild);
      this.webhooks = new Collection;
      if (data.webhooks) {
        for (const hook of data.webhooks) {
          this.webhooks.set(hook.id, new Webhook(guild.client, hook));
        }
      }
      this.integrations = new Collection;
      if (data.integrations) {
        for (const integration of data.integrations) {
          this.integrations.set(integration.id, new Integration(guild.client, integration, guild));
        }
      }
      this.guildScheduledEvents = data.guild_scheduled_events.reduce((guildScheduledEvents, guildScheduledEvent) => guildScheduledEvents.set(guildScheduledEvent.id, guild.scheduledEvents._add(guildScheduledEvent)), new Collection);
      this.applicationCommands = new Collection;
      if (data.application_commands) {
        for (const command of data.application_commands) {
          this.applicationCommands.set(command.id, new ApplicationCommand(guild.client, command, guild));
        }
      }
      this.autoModerationRules = data.auto_moderation_rules.reduce((autoModerationRules, autoModerationRule) => autoModerationRules.set(autoModerationRule.id, guild.autoModerationRules._add(autoModerationRule)), new Collection);
      this.entries = new Collection;
      for (const item of data.audit_log_entries) {
        const entry = new GuildAuditLogsEntry(guild, item, this);
        this.entries.set(entry.id, entry);
      }
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = GuildAuditLogs;
});

// node_modules/discord.js/src/structures/GuildOnboardingPromptOption.js
var require_GuildOnboardingPromptOption = __commonJS((exports) => {
  var { Collection } = require_dist2();
  var Base = require_Base();
  var { resolvePartialEmoji } = require_Util();

  class GuildOnboardingPromptOption extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      const guild = this.guild;
      this.id = data.id;
      this.channels = data.channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.roles = data.role_ids.reduce((roles, roleId) => roles.set(roleId, guild.roles.cache.get(roleId)), new Collection);
      this.emoji = resolvePartialEmoji(data.emoji);
      this.title = data.title;
      this.description = data.description;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPromptOption = GuildOnboardingPromptOption;
});

// node_modules/discord.js/src/structures/GuildOnboardingPrompt.js
var require_GuildOnboardingPrompt = __commonJS((exports) => {
  var { Collection } = require_dist2();
  var Base = require_Base();
  var { GuildOnboardingPromptOption } = require_GuildOnboardingPromptOption();

  class GuildOnboardingPrompt extends Base {
    constructor(client, data, guildId) {
      super(client);
      this.guildId = guildId;
      this.id = data.id;
      this.options = data.options.reduce((options, option) => options.set(option.id, new GuildOnboardingPromptOption(client, option, guildId)), new Collection);
      this.title = data.title;
      this.singleSelect = data.single_select;
      this.required = data.required;
      this.inOnboarding = data.in_onboarding;
      this.type = data.type;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboardingPrompt = GuildOnboardingPrompt;
});

// node_modules/discord.js/src/structures/GuildOnboarding.js
var require_GuildOnboarding = __commonJS((exports) => {
  var { Collection } = require_dist2();
  var Base = require_Base();
  var { GuildOnboardingPrompt } = require_GuildOnboardingPrompt();

  class GuildOnboarding extends Base {
    constructor(client, data) {
      super(client);
      this.guildId = data.guild_id;
      const guild = this.guild;
      this.prompts = data.prompts.reduce((prompts, prompt) => prompts.set(prompt.id, new GuildOnboardingPrompt(client, prompt, this.guildId)), new Collection);
      this.defaultChannels = data.default_channel_ids.reduce((channels, channelId) => channels.set(channelId, guild.channels.cache.get(channelId)), new Collection);
      this.enabled = data.enabled;
    }
    get guild() {
      return this.client.guilds.cache.get(this.guildId);
    }
  }
  exports.GuildOnboarding = GuildOnboarding;
});

// node_modules/discord.js/src/structures/GuildPreviewEmoji.js
var require_GuildPreviewEmoji = __commonJS((exports, module) => {
  var BaseGuildEmoji = require_BaseGuildEmoji();

  class GuildPreviewEmoji extends BaseGuildEmoji {
    constructor(client, data, guild) {
      super(client, data, guild);
      this.roles = data.roles;
    }
  }
  module.exports = GuildPreviewEmoji;
});

// node_modules/discord.js/src/structures/GuildPreview.js
var require_GuildPreview = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { DiscordSnowflake } = require_dist3();
  var { Routes } = require_v106();
  var Base = require_Base();
  var GuildPreviewEmoji = require_GuildPreviewEmoji();
  var { Sticker } = require_Sticker();

  class GuildPreview extends Base {
    constructor(client, data) {
      super(client);
      if (!data)
        return;
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("icon" in data) {
        this.icon = data.icon;
      }
      if ("splash" in data) {
        this.splash = data.splash;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("features" in data) {
        this.features = data.features;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      }
      if ("description" in data) {
        this.description = data.description;
      } else {
        this.description ??= null;
      }
      if (!this.emojis) {
        this.emojis = new Collection;
      } else {
        this.emojis.clear();
      }
      for (const emoji of data.emojis) {
        this.emojis.set(emoji.id, new GuildPreviewEmoji(this.client, emoji, this));
      }
      this.stickers = data.stickers.reduce((stickers, sticker) => stickers.set(sticker.id, new Sticker(this.client, sticker)), new Collection);
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    splashURL(options = {}) {
      return this.splash && this.client.rest.cdn.splash(this.id, this.splash, options);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    iconURL(options = {}) {
      return this.icon && this.client.rest.cdn.icon(this.id, this.icon, options);
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      this._patch(data);
      return this;
    }
    toString() {
      return this.name;
    }
    toJSON() {
      const json = super.toJSON();
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      return json;
    }
  }
  module.exports = GuildPreview;
});

// node_modules/discord.js/src/managers/AutoModerationRuleManager.js
var require_AutoModerationRuleManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var AutoModerationRule = require_AutoModerationRule();

  class AutoModerationRuleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, AutoModerationRule, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({
      name,
      eventType,
      triggerType,
      triggerMetadata,
      actions,
      enabled,
      exemptRoles,
      exemptChannels,
      reason
    }) {
      const data = await this.client.rest.post(Routes.guildAutoModerationRules(this.guild.id), {
        body: {
          name,
          event_type: eventType,
          trigger_type: triggerType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    async edit(autoModerationRule, { name, eventType, triggerMetadata, actions, enabled, exemptRoles, exemptChannels, reason }) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      const data = await this.client.rest.patch(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), {
        body: {
          name,
          event_type: eventType,
          trigger_metadata: triggerMetadata && {
            keyword_filter: triggerMetadata.keywordFilter,
            regex_patterns: triggerMetadata.regexPatterns,
            presets: triggerMetadata.presets,
            allow_list: triggerMetadata.allowList,
            mention_total_limit: triggerMetadata.mentionTotalLimit,
            mention_raid_protection_enabled: triggerMetadata.mentionRaidProtectionEnabled
          },
          actions: actions?.map((action) => ({
            type: action.type,
            metadata: {
              duration_seconds: action.metadata?.durationSeconds,
              channel_id: action.metadata?.channel && this.guild.channels.resolveId(action.metadata.channel),
              custom_message: action.metadata?.customMessage
            }
          })),
          enabled,
          exempt_roles: exemptRoles?.map((exemptRole) => this.guild.roles.resolveId(exemptRole)),
          exempt_channels: exemptChannels?.map((exemptChannel) => this.guild.channels.resolveId(exemptChannel))
        },
        reason
      });
      return this._add(data);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { autoModerationRule, cache, force } = options;
      const resolvedAutoModerationRule = this.resolveId(autoModerationRule ?? options);
      if (resolvedAutoModerationRule) {
        return this._fetchSingle({ autoModerationRule: resolvedAutoModerationRule, cache, force });
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ autoModerationRule, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(autoModerationRule);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildAutoModerationRule(this.guild.id, autoModerationRule));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildAutoModerationRules(this.guild.id));
      return data.reduce((col, autoModerationRule) => col.set(autoModerationRule.id, this._add(autoModerationRule, options.cache)), new Collection);
    }
    async delete(autoModerationRule, reason) {
      const autoModerationRuleId = this.resolveId(autoModerationRule);
      await this.client.rest.delete(Routes.guildAutoModerationRule(this.guild.id, autoModerationRuleId), { reason });
    }
  }
  module.exports = AutoModerationRuleManager;
});

// node_modules/discord.js/src/managers/GuildApplicationCommandManager.js
var require_GuildApplicationCommandManager = __commonJS((exports, module) => {
  var ApplicationCommandManager = require_ApplicationCommandManager();
  var ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();

  class GuildApplicationCommandManager extends ApplicationCommandManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
      this.permissions = new ApplicationCommandPermissionsManager(this);
    }
  }
  module.exports = GuildApplicationCommandManager;
});

// node_modules/discord.js/src/managers/GuildBanManager.js
var require_GuildBanManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var GuildBan = require_GuildBan();
  var { GuildMember } = require_GuildMember();
  var deprecationEmittedForDeleteMessageDays = false;

  class GuildBanManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildBan, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(ban) {
      return super.resolve(ban) ?? super.resolve(this.client.users.resolveId(ban));
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user, cache, force, limit, before, after } = options;
      const resolvedUser = this.client.users.resolveId(user ?? options);
      if (resolvedUser)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      if (!before && !after && !limit && cache === undefined) {
        return Promise.reject(new DiscordjsError(ErrorCodes.FetchBanResolveId));
      }
      return this._fetchMany(options);
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildBan(this.guild.id, user));
      return this._add(data, cache);
    }
    async _fetchMany(options = {}) {
      const data = await this.client.rest.get(Routes.guildBans(this.guild.id), {
        query: makeURLSearchParams(options)
      });
      return data.reduce((col, ban) => col.set(ban.user.id, this._add(ban, options.cache)), new Collection);
    }
    async create(user, options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId, true);
      if (options.deleteMessageDays !== undefined && !deprecationEmittedForDeleteMessageDays) {
        process2.emitWarning("The deleteMessageDays option for GuildBanManager#create() is deprecated. Use the deleteMessageSeconds option instead.", "DeprecationWarning");
        deprecationEmittedForDeleteMessageDays = true;
      }
      await this.client.rest.put(Routes.guildBan(this.guild.id, id), {
        body: {
          delete_message_seconds: options.deleteMessageSeconds ?? (options.deleteMessageDays ? options.deleteMessageDays * 24 * 60 * 60 : undefined)
        },
        reason: options.reason
      });
      if (user instanceof GuildMember)
        return user;
      const _user = this.client.users.resolve(id);
      if (_user) {
        return this.guild.members.resolve(_user) ?? _user;
      }
      return id;
    }
    async remove(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsError(ErrorCodes.BanResolveId);
      await this.client.rest.delete(Routes.guildBan(this.guild.id, id), { reason });
      return this.client.users.resolve(user);
    }
  }
  module.exports = GuildBanManager;
});

// node_modules/discord.js/src/managers/GuildChannelManager.js
var require_GuildChannelManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist2();
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var GuildTextThreadManager = require_GuildTextThreadManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var GuildChannel = require_GuildChannel();
  var PermissionOverwrites = require_PermissionOverwrites();
  var ThreadChannel = require_ThreadChannel();
  var Webhook = require_Webhook();
  var ChannelFlagsBitField = require_ChannelFlagsBitField();
  var { transformGuildForumTag, transformGuildDefaultReaction } = require_Channels();
  var { ThreadChannelTypes } = require_Constants();
  var DataResolver = require_DataResolver();
  var { setPosition } = require_Util();
  var cacheWarningEmitted = false;

  class GuildChannelManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildChannel, iterable);
      const defaultCaching = this._cache.constructor.name === "Collection" || this._cache.maxSize === undefined || this._cache.maxSize === Infinity;
      if (!cacheWarningEmitted && !defaultCaching) {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    get channelCountWithoutThreads() {
      return this.cache.reduce((acc, channel) => {
        if (ThreadChannelTypes.includes(channel.type))
          return acc;
        return ++acc;
      }, 0);
    }
    _add(channel) {
      const existing = this.cache.get(channel.id);
      if (existing)
        return existing;
      this.cache.set(channel.id, channel);
      return channel;
    }
    resolve(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolve(channel.id);
      return super.resolve(channel);
    }
    resolveId(channel) {
      if (channel instanceof ThreadChannel)
        return super.resolveId(channel.id);
      return super.resolveId(channel);
    }
    async addFollower(channel, targetChannel, reason) {
      const channelId = this.resolveId(channel);
      const targetChannelId = this.resolveId(targetChannel);
      if (!channelId || !targetChannelId)
        throw new Error(ErrorCodes.GuildChannelResolve);
      const { webhook_id } = await this.client.rest.post(Routes.channelFollowers(channelId), {
        body: { webhook_channel_id: targetChannelId },
        reason
      });
      return webhook_id;
    }
    async create({
      name,
      type,
      topic,
      nsfw,
      bitrate,
      userLimit,
      parent,
      permissionOverwrites,
      position,
      rateLimitPerUser,
      rtcRegion,
      videoQualityMode,
      availableTags,
      defaultReactionEmoji,
      defaultAutoArchiveDuration,
      defaultSortOrder,
      defaultForumLayout,
      reason
    }) {
      parent &&= this.client.channels.resolveId(parent);
      permissionOverwrites &&= permissionOverwrites.map((o) => PermissionOverwrites.resolve(o, this.guild));
      const data = await this.client.rest.post(Routes.guildChannels(this.guild.id), {
        body: {
          name,
          topic,
          type,
          nsfw,
          bitrate,
          user_limit: userLimit,
          parent_id: parent,
          position,
          permission_overwrites: permissionOverwrites,
          rate_limit_per_user: rateLimitPerUser,
          rtc_region: rtcRegion,
          video_quality_mode: videoQualityMode,
          available_tags: availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: defaultReactionEmoji && transformGuildDefaultReaction(defaultReactionEmoji),
          default_auto_archive_duration: defaultAutoArchiveDuration,
          default_sort_order: defaultSortOrder,
          default_forum_layout: defaultForumLayout
        },
        reason
      });
      return this.client.actions.ChannelCreate.handle(data).channel;
    }
    async createWebhook({ channel, name, avatar, reason }) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      if (typeof avatar === "string" && !avatar.startsWith("data:")) {
        avatar = await DataResolver.resolveImage(avatar);
      }
      const data = await this.client.rest.post(Routes.channelWebhooks(id), {
        body: {
          name,
          avatar
        },
        reason
      });
      return new Webhook(this.client, data);
    }
    async edit(channel, options) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const parent = options.parent && this.client.channels.resolveId(options.parent);
      if (options.position !== undefined) {
        await this.setPosition(channel, options.position, { position: options.position, reason: options.reason });
      }
      let permission_overwrites = options.permissionOverwrites?.map((o) => PermissionOverwrites.resolve(o, this.guild));
      if (options.lockPermissions) {
        if (parent) {
          const newParent = this.guild.channels.resolve(parent);
          if (newParent?.type === ChannelType.GuildCategory) {
            permission_overwrites = newParent.permissionOverwrites.cache.map((o) => PermissionOverwrites.resolve(o, this.guild));
          }
        } else if (channel.parent) {
          permission_overwrites = channel.parent.permissionOverwrites.cache.map((o) => PermissionOverwrites.resolve(o, this.guild));
        }
      }
      const newData = await this.client.rest.patch(Routes.channel(channel.id), {
        body: {
          name: (options.name ?? channel.name).trim(),
          type: options.type,
          topic: options.topic,
          nsfw: options.nsfw,
          bitrate: options.bitrate ?? channel.bitrate,
          user_limit: options.userLimit ?? channel.userLimit,
          rtc_region: "rtcRegion" in options ? options.rtcRegion : channel.rtcRegion,
          video_quality_mode: options.videoQualityMode,
          parent_id: parent,
          lock_permissions: options.lockPermissions,
          rate_limit_per_user: options.rateLimitPerUser,
          default_auto_archive_duration: options.defaultAutoArchiveDuration,
          permission_overwrites,
          available_tags: options.availableTags?.map((availableTag) => transformGuildForumTag(availableTag)),
          default_reaction_emoji: options.defaultReactionEmoji && transformGuildDefaultReaction(options.defaultReactionEmoji),
          default_thread_rate_limit_per_user: options.defaultThreadRateLimitPerUser,
          flags: "flags" in options ? ChannelFlagsBitField.resolve(options.flags) : undefined,
          default_sort_order: options.defaultSortOrder,
          default_forum_layout: options.defaultForumLayout
        },
        reason: options.reason
      });
      return this.client.actions.ChannelUpdate.handle(newData).updated;
    }
    async setPosition(channel, position, { relative, reason } = {}) {
      channel = this.resolve(channel);
      if (!channel)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const updatedChannels = await setPosition(channel, position, relative, this.guild._sortedChannels(channel), this.client, Routes.guildChannels(this.guild.id), reason);
      this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: updatedChannels
      });
      return channel;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      if (id) {
        const data2 = await this.client.rest.get(Routes.channel(id));
        if (this.guild.id !== data2.guild_id)
          throw new DiscordjsError(ErrorCodes.GuildChannelUnowned);
        return this.client.channels._add(data2, this.guild, { cache });
      }
      const data = await this.client.rest.get(Routes.guildChannels(this.guild.id));
      const channels = new Collection;
      for (const channel of data)
        channels.set(channel.id, this.client.channels._add(channel, this.guild, { cache }));
      return channels;
    }
    async fetchWebhooks(channel) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      const data = await this.client.rest.get(Routes.channelWebhooks(id));
      return data.reduce((hooks, hook) => hooks.set(hook.id, new Webhook(this.client, hook)), new Collection);
    }
    async setPositions(channelPositions) {
      channelPositions = channelPositions.map((r) => ({
        id: this.client.channels.resolveId(r.channel),
        position: r.position,
        lock_permissions: r.lockPermissions,
        parent_id: r.parent !== undefined ? this.resolveId(r.parent) : undefined
      }));
      await this.client.rest.patch(Routes.guildChannels(this.guild.id), { body: channelPositions });
      return this.client.actions.GuildChannelsPositionUpdate.handle({
        guild_id: this.guild.id,
        channels: channelPositions
      }).guild;
    }
    async fetchActiveThreads(cache = true) {
      const data = await this.rawFetchGuildActiveThreads();
      return GuildTextThreadManager._mapThreads(data, this.client, { guild: this.guild, cache });
    }
    rawFetchGuildActiveThreads() {
      return this.client.rest.get(Routes.guildActiveThreads(this.guild.id));
    }
    async delete(channel, reason) {
      const id = this.resolveId(channel);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "channel", "GuildChannelResolvable");
      await this.client.rest.delete(Routes.channel(id), { reason });
      this.client.actions.ChannelDelete.handle({ id });
    }
  }
  module.exports = GuildChannelManager;
});

// node_modules/discord.js/src/managers/GuildEmojiManager.js
var require_GuildEmojiManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes, PermissionFlagsBits } = require_v106();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var DataResolver = require_DataResolver();

  class GuildEmojiManager extends BaseGuildEmojiManager {
    constructor(guild, iterable) {
      super(guild.client, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ attachment, name, roles, reason }) {
      attachment = await DataResolver.resolveImage(attachment);
      if (!attachment)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      const body = { image: attachment, name };
      if (roles) {
        if (!Array.isArray(roles) && !(roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        body.roles = [];
        for (const role of roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          body.roles.push(resolvedRole);
        }
      }
      const emoji = await this.client.rest.post(Routes.guildEmojis(this.guild.id), { body, reason });
      return this.client.actions.GuildEmojiCreate.handle(this.guild, emoji).emoji;
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const emoji = await this.client.rest.get(Routes.guildEmoji(this.guild.id, id));
        return this._add(emoji, cache);
      }
      const data = await this.client.rest.get(Routes.guildEmojis(this.guild.id));
      const emojis = new Collection;
      for (const emoji of data)
        emojis.set(emoji.id, this._add(emoji, cache));
      return emojis;
    }
    async delete(emoji, reason) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      await this.client.rest.delete(Routes.guildEmoji(this.guild.id, id), { reason });
    }
    async edit(emoji, options) {
      const id = this.resolveId(emoji);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      const roles = options.roles?.map((r) => this.guild.roles.resolveId(r));
      const newData = await this.client.rest.patch(Routes.guildEmoji(this.guild.id, id), {
        body: {
          name: options.name,
          roles
        },
        reason: options.reason
      });
      const existing = this.cache.get(id);
      if (existing) {
        const clone = existing._clone();
        clone._patch(newData);
        return clone;
      }
      return this._add(newData);
    }
    async fetchAuthor(emoji) {
      emoji = this.resolve(emoji);
      if (!emoji)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "emoji", "EmojiResolvable", true);
      if (emoji.managed) {
        throw new DiscordjsError(ErrorCodes.EmojiManaged);
      }
      const { me } = this.guild.members;
      if (!me)
        throw new DiscordjsError(ErrorCodes.GuildUncachedMe);
      if (!me.permissions.has(PermissionFlagsBits.ManageGuildExpressions)) {
        throw new DiscordjsError(ErrorCodes.MissingManageGuildExpressionsPermission, this.guild);
      }
      const data = await this.client.rest.get(Routes.guildEmoji(this.guild.id, emoji.id));
      emoji._patch(data);
      return emoji.author;
    }
  }
  module.exports = GuildEmojiManager;
});

// node_modules/discord.js/src/managers/GuildInviteManager.js
var require_GuildInviteManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var Invite = require_Invite();
  var DataResolver = require_DataResolver();

  class GuildInviteManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Invite, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.code, extras: [this.guild] });
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      if (typeof options === "string") {
        const code = DataResolver.resolveInviteCode(options);
        if (!code)
          return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));
        return this._fetchSingle({ code, cache: true });
      }
      if (!options.code) {
        if (options.channelId) {
          const id = this.guild.channels.resolveId(options.channelId);
          if (!id)
            return Promise.reject(new DiscordjsError(ErrorCodes.GuildChannelResolve));
          return this._fetchChannelMany(id, options.cache);
        }
        if ("cache" in options)
          return this._fetchMany(options.cache);
        return Promise.reject(new DiscordjsError(ErrorCodes.InviteResolveCode));
      }
      return this._fetchSingle({
        ...options,
        code: DataResolver.resolveInviteCode(options.code)
      });
    }
    async _fetchSingle({ code, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(code);
        if (existing)
          return existing;
      }
      const invites = await this._fetchMany(cache);
      const invite = invites.get(code);
      if (!invite)
        throw new DiscordjsError(ErrorCodes.InviteNotFound);
      return invite;
    }
    async _fetchMany(cache) {
      const data = await this.client.rest.get(Routes.guildInvites(this.guild.id));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async _fetchChannelMany(channelId, cache) {
      const data = await this.client.rest.get(Routes.channelInvites(channelId));
      return data.reduce((col, invite) => col.set(invite.code, this._add(invite, cache)), new Collection);
    }
    async create(channel, { temporary, maxAge, maxUses, unique, targetUser, targetApplication, targetType, reason } = {}) {
      const id = this.guild.channels.resolveId(channel);
      if (!id)
        throw new DiscordjsError(ErrorCodes.GuildChannelResolve);
      const invite = await this.client.rest.post(Routes.channelInvites(id), {
        body: {
          temporary,
          max_age: maxAge,
          max_uses: maxUses,
          unique,
          target_user_id: this.client.users.resolveId(targetUser),
          target_application_id: targetApplication?.id ?? targetApplication?.applicationId ?? targetApplication,
          target_type: targetType
        },
        reason
      });
      return new Invite(this.client, invite);
    }
    async delete(invite, reason) {
      const code = DataResolver.resolveInviteCode(invite);
      await this.client.rest.delete(Routes.invite(code), { reason });
    }
  }
  module.exports = GuildInviteManager;
});

// node_modules/discord.js/src/managers/GuildMemberManager.js
var require_GuildMemberManager = __commonJS((exports, module) => {
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { DiscordSnowflake } = require_dist3();
  var { Routes, GatewayOpcodes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  var { GuildMember } = require_GuildMember();
  var { Role } = require_Role();
  var Events = require_Events();
  var { GuildMemberFlagsBitField } = require_GuildMemberFlagsBitField();
  var Partials = require_Partials();

  class GuildMemberManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildMember, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      return super._add(data, cache, { id: data.user.id, extras: [this.guild] });
    }
    resolve(member) {
      const memberResolvable = super.resolve(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      if (userResolvable)
        return super.resolve(userResolvable);
      return null;
    }
    resolveId(member) {
      const memberResolvable = super.resolveId(member);
      if (memberResolvable)
        return memberResolvable;
      const userResolvable = this.client.users.resolveId(member);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
    async add(user, options) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (!options.force) {
        const cachedUser = this.cache.get(userId);
        if (cachedUser)
          return cachedUser;
      }
      const resolvedOptions = {
        access_token: options.accessToken,
        nick: options.nick,
        mute: options.mute,
        deaf: options.deaf
      };
      if (options.roles) {
        if (!Array.isArray(options.roles) && !(options.roles instanceof Collection)) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.roles", "Array or Collection of Roles or Snowflakes", true);
        }
        const resolvedRoles = [];
        for (const role of options.roles.values()) {
          const resolvedRole = this.guild.roles.resolveId(role);
          if (!resolvedRole) {
            throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array or Collection", "options.roles", role);
          }
          resolvedRoles.push(resolvedRole);
        }
        resolvedOptions.roles = resolvedRoles;
      }
      const data = await this.client.rest.put(Routes.guildMember(this.guild.id, userId), { body: resolvedOptions });
      return data instanceof Uint8Array ? options.fetchWhenExisting === false ? null : this.fetch(userId) : this._add(data);
    }
    get me() {
      return this.resolve(this.client.user.id) ?? (this.client.options.partials.includes(Partials.GuildMember) ? this._add({ user: { id: this.client.user.id } }, true) : null);
    }
    fetch(options) {
      if (!options)
        return this._fetchMany();
      const { user: users, limit, withPresences, cache, force } = options;
      const resolvedUser = this.client.users.resolveId(users ?? options);
      if (resolvedUser && !limit && !withPresences)
        return this._fetchSingle({ user: resolvedUser, cache, force });
      const resolvedUsers = users?.map?.((user) => this.client.users.resolveId(user)) ?? resolvedUser ?? undefined;
      return this._fetchMany({ ...options, users: resolvedUsers });
    }
    async _fetchSingle({ user, cache, force = false }) {
      if (!force) {
        const existing = this.cache.get(user);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildMember(this.guild.id, user));
      return this._add(data, cache);
    }
    _fetchMany({
      limit = 0,
      withPresences: presences,
      users,
      query,
      time = 120000,
      nonce = DiscordSnowflake.generate().toString()
    } = {}) {
      if (nonce.length > 32)
        return Promise.reject(new DiscordjsRangeError(ErrorCodes.MemberFetchNonceLength));
      return new Promise((resolve, reject) => {
        if (!query && !users)
          query = "";
        this.guild.shard.send({
          op: GatewayOpcodes.RequestGuildMembers,
          d: {
            guild_id: this.guild.id,
            presences,
            user_ids: users,
            query,
            nonce,
            limit
          }
        });
        const fetchedMembers = new Collection;
        let i = 0;
        const handler = (members, _, chunk) => {
          if (chunk.nonce !== nonce)
            return;
          timeout.refresh();
          i++;
          for (const member of members.values()) {
            fetchedMembers.set(member.id, member);
          }
          if (members.size < 1000 || limit && fetchedMembers.size >= limit || i === chunk.count) {
            clearTimeout2(timeout);
            this.client.removeListener(Events.GuildMembersChunk, handler);
            this.client.decrementMaxListeners();
            resolve(users && !Array.isArray(users) && fetchedMembers.size ? fetchedMembers.first() : fetchedMembers);
          }
        };
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildMembersChunk, handler);
          this.client.decrementMaxListeners();
          reject(new DiscordjsError(ErrorCodes.GuildMembersTimeout));
        }, time).unref();
        this.client.incrementMaxListeners();
        this.client.on(Events.GuildMembersChunk, handler);
      });
    }
    fetchMe(options) {
      return this.fetch({ ...options, user: this.client.user.id });
    }
    async search({ query, limit, cache = true } = {}) {
      const data = await this.client.rest.get(Routes.guildMembersSearch(this.guild.id), {
        query: makeURLSearchParams({ query, limit })
      });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async list({ after, limit, cache = true } = {}) {
      const query = makeURLSearchParams({ limit, after });
      const data = await this.client.rest.get(Routes.guildMembers(this.guild.id), { query });
      return data.reduce((col, member) => col.set(member.user.id, this._add(member, cache)), new Collection);
    }
    async edit(user, { reason, ...options }) {
      const id = this.client.users.resolveId(user);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
      if (options.channel) {
        options.channel = this.guild.channels.resolve(options.channel);
        if (!(options.channel instanceof BaseGuildVoiceChannel)) {
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        }
        options.channel_id = options.channel.id;
        options.channel = undefined;
      } else if (options.channel === null) {
        options.channel_id = null;
        options.channel = undefined;
      }
      options.roles &&= options.roles.map((role) => role instanceof Role ? role.id : role);
      if (options.communicationDisabledUntil !== undefined) {
        options.communication_disabled_until = options.communicationDisabledUntil != null ? new Date(options.communicationDisabledUntil).toISOString() : options.communicationDisabledUntil;
      }
      if (options.flags !== undefined) {
        options.flags = GuildMemberFlagsBitField.resolve(options.flags);
      }
      let endpoint;
      if (id === this.client.user.id) {
        const keys = Object.keys(options);
        if (keys.length === 1 && keys[0] === "nick")
          endpoint = Routes.guildMember(this.guild.id);
        else
          endpoint = Routes.guildMember(this.guild.id, id);
      } else {
        endpoint = Routes.guildMember(this.guild.id, id);
      }
      const d = await this.client.rest.patch(endpoint, { body: options, reason });
      const clone = this.cache.get(id)?._clone();
      clone?._patch(d);
      return clone ?? this._add(d, false);
    }
    async prune({ days, dry = false, count: compute_prune_count, roles = [], reason } = {}) {
      if (typeof days !== "number")
        throw new DiscordjsTypeError(ErrorCodes.PruneDaysType);
      const query = { days };
      const resolvedRoles = [];
      for (const role of roles) {
        const resolvedRole = this.guild.roles.resolveId(role);
        if (!resolvedRole) {
          throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "options.roles", role);
        }
        resolvedRoles.push(resolvedRole);
      }
      if (resolvedRoles.length) {
        query.include_roles = dry ? resolvedRoles.join(",") : resolvedRoles;
      }
      const endpoint = Routes.guildPrune(this.guild.id);
      const { pruned } = await (dry ? this.client.rest.get(endpoint, { query: makeURLSearchParams(query), reason }) : this.client.rest.post(endpoint, { body: { ...query, compute_prune_count }, reason }));
      return pruned;
    }
    async kick(user, reason) {
      const id = this.client.users.resolveId(user);
      if (!id)
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable"));
      await this.client.rest.delete(Routes.guildMember(this.guild.id, id), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? id;
    }
    ban(user, options) {
      return this.guild.bans.create(user, options);
    }
    unban(user, reason) {
      return this.guild.bans.remove(user, reason);
    }
    async addRole(options) {
      const { user, role, reason } = options;
      const userId = this.guild.members.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.put(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
    async removeRole(options) {
      const { user, role, reason } = options;
      const userId = this.guild.members.resolveId(user);
      const roleId = this.guild.roles.resolveId(role);
      await this.client.rest.delete(Routes.guildMemberRole(this.guild.id, userId, roleId), { reason });
      return this.resolve(user) ?? this.client.users.resolve(user) ?? userId;
    }
  }
  module.exports = GuildMemberManager;
});

// node_modules/discord.js/src/managers/GuildScheduledEventManager.js
var require_GuildScheduledEventManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { GuildScheduledEventEntityType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildScheduledEvent } = require_GuildScheduledEvent();
  var DataResolver = require_DataResolver();

  class GuildScheduledEventManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, GuildScheduledEvent, iterable);
      this.guild = guild;
    }
    async create(options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image
      } = options;
      let entity_metadata, channel_id;
      if (entityType === GuildScheduledEventEntityType.External) {
        channel_id = channel === undefined ? channel : null;
        entity_metadata = { location: entityMetadata?.location };
      } else {
        channel_id = this.guild.channels.resolveId(channel);
        if (!channel_id)
          throw new DiscordjsError(ErrorCodes.GuildVoiceChannelResolve);
        entity_metadata = entityMetadata === undefined ? entityMetadata : null;
      }
      const data = await this.client.rest.post(Routes.guildScheduledEvents(this.guild.id), {
        body: {
          channel_id,
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: new Date(scheduledStartTime).toISOString(),
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          entity_metadata,
          image: image && await DataResolver.resolveImage(image)
        },
        reason
      });
      return this._add(data);
    }
    async fetch(options = {}) {
      const id = this.resolveId(options.guildScheduledEvent ?? options);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guildScheduledEvent(this.guild.id, id), {
          query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.guildScheduledEvents(this.guild.id), {
        query: makeURLSearchParams({ with_user_count: options.withUserCount ?? true })
      });
      return data.reduce((coll, rawGuildScheduledEventData) => coll.set(rawGuildScheduledEventData.id, this.guild.scheduledEvents._add(rawGuildScheduledEventData, options.cache)), new Collection);
    }
    async edit(guildScheduledEvent, options) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let {
        privacyLevel,
        entityType,
        channel,
        status,
        name,
        scheduledStartTime,
        description,
        scheduledEndTime,
        entityMetadata,
        reason,
        image
      } = options;
      let entity_metadata;
      if (entityMetadata) {
        entity_metadata = {
          location: entityMetadata.location
        };
      }
      const data = await this.client.rest.patch(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId), {
        body: {
          channel_id: channel === undefined ? channel : this.guild.channels.resolveId(channel),
          name,
          privacy_level: privacyLevel,
          scheduled_start_time: scheduledStartTime ? new Date(scheduledStartTime).toISOString() : undefined,
          scheduled_end_time: scheduledEndTime ? new Date(scheduledEndTime).toISOString() : scheduledEndTime,
          description,
          entity_type: entityType,
          status,
          image: image && await DataResolver.resolveImage(image),
          entity_metadata
        },
        reason
      });
      return this._add(data);
    }
    async delete(guildScheduledEvent) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      await this.client.rest.delete(Routes.guildScheduledEvent(this.guild.id, guildScheduledEventId));
    }
    async fetchSubscribers(guildScheduledEvent, options = {}) {
      const guildScheduledEventId = this.resolveId(guildScheduledEvent);
      if (!guildScheduledEventId)
        throw new DiscordjsError(ErrorCodes.GuildScheduledEventResolve);
      const query = makeURLSearchParams({
        limit: options.limit,
        with_member: options.withMember,
        before: options.before,
        after: options.after
      });
      const data = await this.client.rest.get(Routes.guildScheduledEventUsers(this.guild.id, guildScheduledEventId), {
        query
      });
      return data.reduce((coll, rawData) => coll.set(rawData.user.id, {
        guildScheduledEventId: rawData.guild_scheduled_event_id,
        user: this.client.users._add(rawData.user),
        member: rawData.member ? this.guild.members._add({ ...rawData.member, user: rawData.user }) : null
      }), new Collection);
    }
  }
  module.exports = GuildScheduledEventManager;
});

// node_modules/discord.js/src/managers/GuildStickerManager.js
var require_GuildStickerManager = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var MessagePayload = require_MessagePayload();
  var { Sticker } = require_Sticker();

  class GuildStickerManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Sticker, iterable);
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async create({ file, name, tags, description, reason } = {}) {
      const resolvedFile = await MessagePayload.resolveFile(file);
      if (!resolvedFile)
        throw new DiscordjsTypeError(ErrorCodes.ReqResourceType);
      file = { ...resolvedFile, key: "file" };
      const body = { name, tags, description: description ?? "" };
      const sticker = await this.client.rest.post(Routes.guildStickers(this.guild.id), {
        appendToFormData: true,
        body,
        files: [file],
        reason
      });
      return this.client.actions.GuildStickerCreate.handle(this.guild, sticker).sticker;
    }
    async edit(sticker, options = {}) {
      const stickerId = this.resolveId(sticker);
      if (!stickerId)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const d = await this.client.rest.patch(Routes.guildSticker(this.guild.id, stickerId), {
        body: options,
        reason: options.reason
      });
      const existing = this.cache.get(stickerId);
      if (existing) {
        const clone = existing._clone();
        clone._patch(d);
        return clone;
      }
      return this._add(d);
    }
    async delete(sticker, reason) {
      sticker = this.resolveId(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      await this.client.rest.delete(Routes.guildSticker(this.guild.id, sticker), { reason });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id) {
        if (!force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const sticker = await this.client.rest.get(Routes.guildSticker(this.guild.id, id));
        return this._add(sticker, cache);
      }
      const data = await this.client.rest.get(Routes.guildStickers(this.guild.id));
      return new Collection(data.map((sticker) => [sticker.id, this._add(sticker, cache)]));
    }
    async fetchUser(sticker) {
      sticker = this.resolve(sticker);
      if (!sticker)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "sticker", "StickerResolvable");
      const data = await this.client.rest.get(Routes.guildSticker(this.guild.id, sticker.id));
      sticker._patch(data);
      return sticker.user;
    }
  }
  module.exports = GuildStickerManager;
});

// node_modules/discord.js/src/util/ActivityFlagsBitField.js
var require_ActivityFlagsBitField = __commonJS((exports, module) => {
  var { ActivityFlags } = require_v106();
  var BitField = require_BitField();

  class ActivityFlagsBitField extends BitField {
    static Flags = ActivityFlags;
  }
  module.exports = ActivityFlagsBitField;
});

// node_modules/discord.js/src/structures/Presence.js
var require_Presence = __commonJS((exports) => {
  var Base = require_Base();
  var { Emoji } = require_Emoji();
  var ActivityFlagsBitField = require_ActivityFlagsBitField();
  var { flatten } = require_Util();

  class Presence extends Base {
    constructor(client, data = {}) {
      super(client);
      this.userId = data.user.id;
      this.guild = data.guild ?? null;
      this._patch(data);
    }
    get user() {
      return this.client.users.resolve(this.userId);
    }
    get member() {
      return this.guild.members.resolve(this.userId);
    }
    _patch(data) {
      if ("status" in data) {
        this.status = data.status;
      } else {
        this.status ??= "offline";
      }
      if ("activities" in data) {
        this.activities = data.activities.map((activity) => new Activity(this, activity));
      } else {
        this.activities ??= [];
      }
      if ("client_status" in data) {
        this.clientStatus = data.client_status;
      } else {
        this.clientStatus ??= null;
      }
      return this;
    }
    _clone() {
      const clone = Object.assign(Object.create(this), this);
      clone.activities = this.activities.map((activity) => activity._clone());
      return clone;
    }
    equals(presence) {
      return this === presence || presence && this.status === presence.status && this.activities.length === presence.activities.length && this.activities.every((activity, index) => activity.equals(presence.activities[index])) && this.clientStatus?.web === presence.clientStatus?.web && this.clientStatus?.mobile === presence.clientStatus?.mobile && this.clientStatus?.desktop === presence.clientStatus?.desktop;
    }
    toJSON() {
      return flatten(this);
    }
  }

  class Activity {
    constructor(presence, data) {
      Object.defineProperty(this, "presence", { value: presence });
      this.name = data.name;
      this.type = data.type;
      this.url = data.url ?? null;
      this.details = data.details ?? null;
      this.state = data.state ?? null;
      this.applicationId = data.application_id ?? null;
      this.timestamps = data.timestamps ? {
        start: data.timestamps.start ? new Date(Number(data.timestamps.start)) : null,
        end: data.timestamps.end ? new Date(Number(data.timestamps.end)) : null
      } : null;
      this.party = data.party ?? null;
      this.assets = data.assets ? new RichPresenceAssets(this, data.assets) : null;
      this.flags = new ActivityFlagsBitField(data.flags).freeze();
      this.emoji = data.emoji ? new Emoji(presence.client, data.emoji) : null;
      this.buttons = data.buttons ?? [];
      this.createdTimestamp = data.created_at;
    }
    equals(activity) {
      return this === activity || activity && this.name === activity.name && this.type === activity.type && this.url === activity.url && this.state === activity.state && this.details === activity.details && this.emoji?.id === activity.emoji?.id && this.emoji?.name === activity.emoji?.name;
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    toString() {
      return this.name;
    }
    _clone() {
      return Object.assign(Object.create(this), this);
    }
  }

  class RichPresenceAssets {
    constructor(activity, assets) {
      Object.defineProperty(this, "activity", { value: activity });
      this.largeText = assets.large_text ?? null;
      this.smallText = assets.small_text ?? null;
      this.largeImage = assets.large_image ?? null;
      this.smallImage = assets.small_image ?? null;
    }
    smallImageURL(options = {}) {
      if (!this.smallImage)
        return null;
      if (this.smallImage.includes(":")) {
        const [platform, id] = this.smallImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.smallImage, options);
    }
    largeImageURL(options = {}) {
      if (!this.largeImage)
        return null;
      if (this.largeImage.includes(":")) {
        const [platform, id] = this.largeImage.split(":");
        switch (platform) {
          case "mp":
            return `https://media.discordapp.net/${id}`;
          case "spotify":
            return `https://i.scdn.co/image/${id}`;
          case "youtube":
            return `https://i.ytimg.com/vi/${id}/hqdefault_live.jpg`;
          case "twitch":
            return `https://static-cdn.jtvnw.net/previews-ttv/live_user_${id}.png`;
          default:
            return null;
        }
      }
      return this.activity.presence.client.rest.cdn.appAsset(this.activity.applicationId, this.largeImage, options);
    }
  }
  exports.Presence = Presence;
  exports.Activity = Activity;
  exports.RichPresenceAssets = RichPresenceAssets;
});

// node_modules/discord.js/src/managers/PresenceManager.js
var require_PresenceManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var { Presence } = require_Presence();

  class PresenceManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Presence, iterable);
    }
    _add(data, cache) {
      return super._add(data, cache, { id: data.user.id });
    }
    resolve(presence) {
      const presenceResolvable = super.resolve(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const UserResolvable = this.client.users.resolveId(presence);
      return super.resolve(UserResolvable);
    }
    resolveId(presence) {
      const presenceResolvable = super.resolveId(presence);
      if (presenceResolvable)
        return presenceResolvable;
      const userResolvable = this.client.users.resolveId(presence);
      return this.cache.has(userResolvable) ? userResolvable : null;
    }
  }
  module.exports = PresenceManager;
});

// node_modules/discord.js/src/managers/RoleManager.js
var require_RoleManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();
  var { Role } = require_Role();
  var DataResolver = require_DataResolver();
  var PermissionsBitField = require_PermissionsBitField();
  var { setPosition, resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class RoleManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, Role, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
      this.guild = guild;
    }
    _add(data, cache) {
      return super._add(data, cache, { extras: [this.guild] });
    }
    async fetch(id, { cache = true, force = false } = {}) {
      if (id && !force) {
        const existing = this.cache.get(id);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.guildRoles(this.guild.id));
      const roles = new Collection;
      for (const role of data)
        roles.set(role.id, this._add(role, cache));
      return id ? roles.get(id) ?? null : roles;
    }
    async create(options = {}) {
      let { name, color, hoist, permissions, position, mentionable, reason, icon, unicodeEmoji } = options;
      color &&= resolveColor(color);
      if (permissions !== undefined)
        permissions = new PermissionsBitField(permissions);
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
        icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const data = await this.client.rest.post(Routes.guildRoles(this.guild.id), {
        body: {
          name,
          color,
          hoist,
          permissions,
          mentionable,
          icon,
          unicode_emoji: unicodeEmoji
        },
        reason
      });
      const { role } = this.client.actions.GuildRoleCreate.handle({
        guild_id: this.guild.id,
        role: data
      });
      if (position)
        return this.setPosition(role, position, { reason });
      return role;
    }
    async edit(role, options) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      if (typeof options.position === "number") {
        await this.setPosition(role, options.position, { reason: options.reason });
      }
      let icon = options.icon;
      if (icon) {
        const guildEmojiURL = this.guild.emojis.resolve(icon)?.url;
        icon = guildEmojiURL ? await DataResolver.resolveImage(guildEmojiURL) : await DataResolver.resolveImage(icon);
        if (typeof icon !== "string")
          icon = undefined;
      }
      const body = {
        name: options.name,
        color: options.color === undefined ? undefined : resolveColor(options.color),
        hoist: options.hoist,
        permissions: options.permissions === undefined ? undefined : new PermissionsBitField(options.permissions),
        mentionable: options.mentionable,
        icon,
        unicode_emoji: options.unicodeEmoji
      };
      const d = await this.client.rest.patch(Routes.guildRole(this.guild.id, role.id), { body, reason: options.reason });
      const clone = role._clone();
      clone._patch(d);
      return clone;
    }
    async delete(role, reason) {
      const id = this.resolveId(role);
      await this.client.rest.delete(Routes.guildRole(this.guild.id, id), { reason });
      this.client.actions.GuildRoleDelete.handle({ guild_id: this.guild.id, role_id: id });
    }
    async setPosition(role, position, { relative, reason } = {}) {
      role = this.resolve(role);
      if (!role)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "RoleResolvable");
      const updatedRoles = await setPosition(role, position, relative, this.guild._sortedRoles(), this.client, Routes.guildRoles(this.guild.id), reason);
      this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: updatedRoles
      });
      return role;
    }
    async setPositions(rolePositions) {
      rolePositions = rolePositions.map((o) => ({
        id: this.resolveId(o.role),
        position: o.position
      }));
      await this.client.rest.patch(Routes.guildRoles(this.guild.id), { body: rolePositions });
      return this.client.actions.GuildRolesPositionUpdate.handle({
        guild_id: this.guild.id,
        roles: rolePositions
      }).guild;
    }
    comparePositions(role1, role2) {
      const resolvedRole1 = this.resolve(role1);
      const resolvedRole2 = this.resolve(role2);
      if (!resolvedRole1 || !resolvedRole2) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "role", "Role nor a Snowflake");
      }
      const role1Position = resolvedRole1.position;
      const role2Position = resolvedRole2.position;
      if (role1Position === role2Position) {
        return Number(BigInt(resolvedRole2.id) - BigInt(resolvedRole1.id));
      }
      return role1Position - role2Position;
    }
    botRoleFor(user) {
      const userId = this.client.users.resolveId(user);
      if (!userId)
        return null;
      return this.cache.find((role) => role.tags?.botId === userId) ?? null;
    }
    get everyone() {
      return this.cache.get(this.guild.id);
    }
    get premiumSubscriberRole() {
      return this.cache.find((role) => role.tags?.premiumSubscriberRole) ?? null;
    }
    get highest() {
      return this.cache.reduce((prev, role) => role.comparePositionTo(prev) > 0 ? role : prev, this.cache.first());
    }
  }
  module.exports = RoleManager;
});

// node_modules/discord.js/src/managers/StageInstanceManager.js
var require_StageInstanceManager = __commonJS((exports, module) => {
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsTypeError, DiscordjsError, ErrorCodes } = require_errors2();
  var { StageInstance } = require_StageInstance();

  class StageInstanceManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, StageInstance, iterable);
      this.guild = guild;
    }
    async create(channel, options) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      let { topic, privacyLevel, sendStartNotification } = options;
      const data = await this.client.rest.post(Routes.stageInstances(), {
        body: {
          channel_id: channelId,
          topic,
          privacy_level: privacyLevel,
          send_start_notification: sendStartNotification
        }
      });
      return this._add(data);
    }
    async fetch(channel, { cache = true, force = false } = {}) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      if (!force) {
        const existing = this.cache.find((stageInstance) => stageInstance.channelId === channelId);
        if (existing)
          return existing;
      }
      const data = await this.client.rest.get(Routes.stageInstance(channelId));
      return this._add(data, cache);
    }
    async edit(channel, options) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      let { topic, privacyLevel } = options;
      const data = await this.client.rest.patch(Routes.stageInstance(channelId), {
        body: {
          topic,
          privacy_level: privacyLevel
        }
      });
      if (this.cache.has(data.id)) {
        const clone = this.cache.get(data.id)._clone();
        clone._patch(data);
        return clone;
      }
      return this._add(data);
    }
    async delete(channel) {
      const channelId = this.guild.channels.resolveId(channel);
      if (!channelId)
        throw new DiscordjsError(ErrorCodes.StageChannelResolve);
      await this.client.rest.delete(Routes.stageInstance(channelId));
    }
  }
  module.exports = StageInstanceManager;
});

// node_modules/discord.js/src/managers/VoiceStateManager.js
var require_VoiceStateManager = __commonJS((exports, module) => {
  var CachedManager = require_CachedManager();
  var VoiceState = require_VoiceState();

  class VoiceStateManager extends CachedManager {
    constructor(guild, iterable) {
      super(guild.client, VoiceState, iterable);
      this.guild = guild;
    }
    _add(data, cache = true) {
      const existing = this.cache.get(data.user_id);
      if (existing)
        return existing._patch(data);
      const entry = new this.holds(this.guild, data);
      if (cache)
        this.cache.set(data.user_id, entry);
      return entry;
    }
  }
  module.exports = VoiceStateManager;
});

// node_modules/discord.js/src/util/SystemChannelFlagsBitField.js
var require_SystemChannelFlagsBitField = __commonJS((exports, module) => {
  var { GuildSystemChannelFlags } = require_v106();
  var BitField = require_BitField();

  class SystemChannelFlagsBitField extends BitField {
    static Flags = GuildSystemChannelFlags;
  }
  module.exports = SystemChannelFlagsBitField;
});

// node_modules/discord.js/src/structures/Guild.js
var require_Guild = __commonJS((exports) => {
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { ChannelType, GuildPremiumTier, Routes, GuildFeature } = require_v106();
  var AnonymousGuild = require_AnonymousGuild();
  var GuildAuditLogs = require_GuildAuditLogs();
  var { GuildOnboarding } = require_GuildOnboarding();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Integration = require_Integration();
  var Webhook = require_Webhook();
  var WelcomeScreen = require_WelcomeScreen();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var AutoModerationRuleManager = require_AutoModerationRuleManager();
  var GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  var GuildBanManager = require_GuildBanManager();
  var GuildChannelManager = require_GuildChannelManager();
  var GuildEmojiManager = require_GuildEmojiManager();
  var GuildInviteManager = require_GuildInviteManager();
  var GuildMemberManager = require_GuildMemberManager();
  var GuildScheduledEventManager = require_GuildScheduledEventManager();
  var GuildStickerManager = require_GuildStickerManager();
  var PresenceManager = require_PresenceManager();
  var RoleManager = require_RoleManager();
  var StageInstanceManager = require_StageInstanceManager();
  var VoiceStateManager = require_VoiceStateManager();
  var DataResolver = require_DataResolver();
  var Status = require_Status();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { discordSort, getSortableGroupTypes } = require_Util();

  class Guild extends AnonymousGuild {
    constructor(client, data) {
      super(client, data, false);
      this.commands = new GuildApplicationCommandManager(this);
      this.members = new GuildMemberManager(this);
      this.channels = new GuildChannelManager(this);
      this.bans = new GuildBanManager(this);
      this.roles = new RoleManager(this);
      this.presences = new PresenceManager(this.client);
      this.voiceStates = new VoiceStateManager(this);
      this.stageInstances = new StageInstanceManager(this);
      this.invites = new GuildInviteManager(this);
      this.scheduledEvents = new GuildScheduledEventManager(this);
      this.autoModerationRules = new AutoModerationRuleManager(this);
      if (!data)
        return;
      if (data.unavailable) {
        this.available = false;
      } else {
        this._patch(data);
        if (!data.channels)
          this.available = false;
      }
      this.shardId = data.shardId;
    }
    get shard() {
      return this.client.ws.shards.get(this.shardId);
    }
    _patch(data) {
      super._patch(data);
      this.id = data.id;
      if ("name" in data)
        this.name = data.name;
      if ("icon" in data)
        this.icon = data.icon;
      if ("unavailable" in data) {
        this.available = !data.unavailable;
      } else {
        this.available ??= true;
      }
      if ("discovery_splash" in data) {
        this.discoverySplash = data.discovery_splash;
      }
      if ("member_count" in data) {
        this.memberCount = data.member_count;
      }
      if ("large" in data) {
        this.large = Boolean(data.large);
      }
      if ("premium_progress_bar_enabled" in data) {
        this.premiumProgressBarEnabled = data.premium_progress_bar_enabled;
      }
      if ("application_id" in data) {
        this.applicationId = data.application_id;
      }
      if ("afk_timeout" in data) {
        this.afkTimeout = data.afk_timeout;
      }
      if ("afk_channel_id" in data) {
        this.afkChannelId = data.afk_channel_id;
      }
      if ("system_channel_id" in data) {
        this.systemChannelId = data.system_channel_id;
      }
      if ("premium_tier" in data) {
        this.premiumTier = data.premium_tier;
      }
      if ("widget_enabled" in data) {
        this.widgetEnabled = data.widget_enabled;
      } else {
        this.widgetEnabled ??= null;
      }
      if ("widget_channel_id" in data) {
        this.widgetChannelId = data.widget_channel_id;
      } else {
        this.widgetChannelId ??= null;
      }
      if ("explicit_content_filter" in data) {
        this.explicitContentFilter = data.explicit_content_filter;
      }
      if ("mfa_level" in data) {
        this.mfaLevel = data.mfa_level;
      }
      if ("joined_at" in data) {
        this.joinedTimestamp = Date.parse(data.joined_at);
      }
      if ("default_message_notifications" in data) {
        this.defaultMessageNotifications = data.default_message_notifications;
      }
      if ("system_channel_flags" in data) {
        this.systemChannelFlags = new SystemChannelFlagsBitField(data.system_channel_flags).freeze();
      }
      if ("max_members" in data) {
        this.maximumMembers = data.max_members;
      } else {
        this.maximumMembers ??= null;
      }
      if ("max_presences" in data) {
        this.maximumPresences = data.max_presences;
      } else {
        this.maximumPresences ??= null;
      }
      if ("max_video_channel_users" in data) {
        this.maxVideoChannelUsers = data.max_video_channel_users;
      } else {
        this.maxVideoChannelUsers ??= null;
      }
      if ("max_stage_video_channel_users" in data) {
        this.maxStageVideoChannelUsers = data.max_stage_video_channel_users;
      } else {
        this.maxStageVideoChannelUsers ??= null;
      }
      if ("approximate_member_count" in data) {
        this.approximateMemberCount = data.approximate_member_count;
      } else {
        this.approximateMemberCount ??= null;
      }
      if ("approximate_presence_count" in data) {
        this.approximatePresenceCount = data.approximate_presence_count;
      } else {
        this.approximatePresenceCount ??= null;
      }
      this.vanityURLUses ??= null;
      if ("rules_channel_id" in data) {
        this.rulesChannelId = data.rules_channel_id;
      }
      if ("public_updates_channel_id" in data) {
        this.publicUpdatesChannelId = data.public_updates_channel_id;
      }
      if ("preferred_locale" in data) {
        this.preferredLocale = data.preferred_locale;
      }
      if ("safety_alerts_channel_id" in data) {
        this.safetyAlertsChannelId = data.safety_alerts_channel_id;
      } else {
        this.safetyAlertsChannelId ??= null;
      }
      if (data.channels) {
        this.channels.cache.clear();
        for (const rawChannel of data.channels) {
          this.client.channels._add(rawChannel, this);
        }
      }
      if (data.threads) {
        for (const rawThread of data.threads) {
          this.client.channels._add(rawThread, this);
        }
      }
      if (data.roles) {
        this.roles.cache.clear();
        for (const role of data.roles)
          this.roles._add(role);
      }
      if (data.members) {
        this.members.cache.clear();
        for (const guildUser of data.members)
          this.members._add(guildUser);
      }
      if ("owner_id" in data) {
        this.ownerId = data.owner_id;
      }
      if (data.presences) {
        for (const presence of data.presences) {
          this.presences._add(Object.assign(presence, { guild: this }));
        }
      }
      if (data.stage_instances) {
        this.stageInstances.cache.clear();
        for (const stageInstance of data.stage_instances) {
          this.stageInstances._add(stageInstance);
        }
      }
      if (data.guild_scheduled_events) {
        this.scheduledEvents.cache.clear();
        for (const scheduledEvent of data.guild_scheduled_events) {
          this.scheduledEvents._add(scheduledEvent);
        }
      }
      if (data.voice_states) {
        this.voiceStates.cache.clear();
        for (const voiceState of data.voice_states) {
          this.voiceStates._add(voiceState);
        }
      }
      if (!this.emojis) {
        this.emojis = new GuildEmojiManager(this);
        if (data.emojis)
          for (const emoji of data.emojis)
            this.emojis._add(emoji);
      } else if (data.emojis) {
        this.client.actions.GuildEmojisUpdate.handle({
          guild_id: this.id,
          emojis: data.emojis
        });
      }
      if (!this.stickers) {
        this.stickers = new GuildStickerManager(this);
        if (data.stickers)
          for (const sticker of data.stickers)
            this.stickers._add(sticker);
      } else if (data.stickers) {
        this.client.actions.GuildStickersUpdate.handle({
          guild_id: this.id,
          stickers: data.stickers
        });
      }
    }
    get joinedAt() {
      return new Date(this.joinedTimestamp);
    }
    discoverySplashURL(options = {}) {
      return this.discoverySplash && this.client.rest.cdn.discoverySplash(this.id, this.discoverySplash, options);
    }
    async fetchOwner(options) {
      if (!this.ownerId) {
        throw new DiscordjsError(ErrorCodes.FetchOwnerId);
      }
      const member = await this.members.fetch({ ...options, user: this.ownerId });
      return member;
    }
    get afkChannel() {
      return this.client.channels.resolve(this.afkChannelId);
    }
    get systemChannel() {
      return this.client.channels.resolve(this.systemChannelId);
    }
    get widgetChannel() {
      return this.client.channels.resolve(this.widgetChannelId);
    }
    get rulesChannel() {
      return this.client.channels.resolve(this.rulesChannelId);
    }
    get publicUpdatesChannel() {
      return this.client.channels.resolve(this.publicUpdatesChannelId);
    }
    get safetyAlertsChannel() {
      return this.client.channels.resolve(this.safetyAlertsChannelId);
    }
    get maximumBitrate() {
      if (this.features.includes(GuildFeature.VIPRegions)) {
        return 384000;
      }
      switch (this.premiumTier) {
        case GuildPremiumTier.Tier1:
          return 128000;
        case GuildPremiumTier.Tier2:
          return 256000;
        case GuildPremiumTier.Tier3:
          return 384000;
        default:
          return 96000;
      }
    }
    async fetchIntegrations() {
      const data = await this.client.rest.get(Routes.guildIntegrations(this.id));
      return data.reduce((collection, integration) => collection.set(integration.id, new Integration(this.client, integration, this)), new Collection);
    }
    async fetchTemplates() {
      const templates = await this.client.rest.get(Routes.guildTemplates(this.id));
      return templates.reduce((col, data) => col.set(data.code, new GuildTemplate(this.client, data)), new Collection);
    }
    async fetchWelcomeScreen() {
      const data = await this.client.rest.get(Routes.guildWelcomeScreen(this.id));
      return new WelcomeScreen(this, data);
    }
    async createTemplate(name, description) {
      const data = await this.client.rest.post(Routes.guildTemplates(this.id), { body: { name, description } });
      return new GuildTemplate(this.client, data);
    }
    async fetchPreview() {
      const data = await this.client.rest.get(Routes.guildPreview(this.id));
      return new GuildPreview(this.client, data);
    }
    async fetchVanityData() {
      const data = await this.client.rest.get(Routes.guildVanityUrl(this.id));
      this.vanityURLCode = data.code;
      this.vanityURLUses = data.uses;
      return data;
    }
    async fetchWebhooks() {
      const apiHooks = await this.client.rest.get(Routes.guildWebhooks(this.id));
      const hooks = new Collection;
      for (const hook of apiHooks)
        hooks.set(hook.id, new Webhook(this.client, hook));
      return hooks;
    }
    fetchWidget() {
      return this.client.fetchGuildWidget(this.id);
    }
    async fetchWidgetSettings() {
      const data = await this.client.rest.get(Routes.guildWidgetSettings(this.id));
      this.widgetEnabled = data.enabled;
      this.widgetChannelId = data.channel_id;
      return {
        enabled: data.enabled,
        channel: data.channel_id ? this.channels.cache.get(data.channel_id) : null
      };
    }
    async fetchAuditLogs({ before, after, limit, user, type } = {}) {
      const query = makeURLSearchParams({
        before: before?.id ?? before,
        after: after?.id ?? after,
        limit,
        action_type: type
      });
      if (user) {
        const userId = this.client.users.resolveId(user);
        if (!userId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "user", "UserResolvable");
        query.set("user_id", userId);
      }
      const data = await this.client.rest.get(Routes.guildAuditLog(this.id), { query });
      return new GuildAuditLogs(this, data);
    }
    async fetchOnboarding() {
      const data = await this.client.rest.get(Routes.guildOnboarding(this.id));
      return new GuildOnboarding(this.client, data);
    }
    async edit({
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      afkChannel,
      afkTimeout,
      icon,
      owner,
      splash,
      discoverySplash,
      banner,
      systemChannel,
      systemChannelFlags,
      rulesChannel,
      publicUpdatesChannel,
      preferredLocale,
      premiumProgressBarEnabled,
      safetyAlertsChannel,
      ...options
    }) {
      const data = await this.client.rest.patch(Routes.guild(this.id), {
        body: {
          ...options,
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          afk_channel_id: afkChannel && this.client.channels.resolveId(afkChannel),
          afk_timeout: afkTimeout,
          icon: icon && await DataResolver.resolveImage(icon),
          owner_id: owner && this.client.users.resolveId(owner),
          splash: splash && await DataResolver.resolveImage(splash),
          discovery_splash: discoverySplash && await DataResolver.resolveImage(discoverySplash),
          banner: banner && await DataResolver.resolveImage(banner),
          system_channel_id: systemChannel && this.client.channels.resolveId(systemChannel),
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags),
          rules_channel_id: rulesChannel && this.client.channels.resolveId(rulesChannel),
          public_updates_channel_id: publicUpdatesChannel && this.client.channels.resolveId(publicUpdatesChannel),
          preferred_locale: preferredLocale,
          premium_progress_bar_enabled: premiumProgressBarEnabled,
          safety_alerts_channel_id: safetyAlertsChannel && this.client.channels.resolveId(safetyAlertsChannel)
        },
        reason: options.reason
      });
      return this.client.actions.GuildUpdate.handle(data).updated;
    }
    async editWelcomeScreen(options) {
      const { enabled, description, welcomeChannels } = options;
      const welcome_channels = welcomeChannels?.map((welcomeChannelData) => {
        const emoji = this.emojis.resolve(welcomeChannelData.emoji);
        return {
          emoji_id: emoji?.id,
          emoji_name: emoji?.name ?? welcomeChannelData.emoji,
          channel_id: this.channels.resolveId(welcomeChannelData.channel),
          description: welcomeChannelData.description
        };
      });
      const patchData = await this.client.rest.patch(Routes.guildWelcomeScreen(this.id), {
        body: {
          welcome_channels,
          description,
          enabled
        }
      });
      return new WelcomeScreen(this, patchData);
    }
    setExplicitContentFilter(explicitContentFilter, reason) {
      return this.edit({ explicitContentFilter, reason });
    }
    setDefaultMessageNotifications(defaultMessageNotifications, reason) {
      return this.edit({ defaultMessageNotifications, reason });
    }
    setSystemChannelFlags(systemChannelFlags, reason) {
      return this.edit({ systemChannelFlags, reason });
    }
    setName(name, reason) {
      return this.edit({ name, reason });
    }
    setVerificationLevel(verificationLevel, reason) {
      return this.edit({ verificationLevel, reason });
    }
    setAFKChannel(afkChannel, reason) {
      return this.edit({ afkChannel, reason });
    }
    setSystemChannel(systemChannel, reason) {
      return this.edit({ systemChannel, reason });
    }
    setAFKTimeout(afkTimeout, reason) {
      return this.edit({ afkTimeout, reason });
    }
    setIcon(icon, reason) {
      return this.edit({ icon, reason });
    }
    setOwner(owner, reason) {
      return this.edit({ owner, reason });
    }
    setSplash(splash, reason) {
      return this.edit({ splash, reason });
    }
    setDiscoverySplash(discoverySplash, reason) {
      return this.edit({ discoverySplash, reason });
    }
    setBanner(banner, reason) {
      return this.edit({ banner, reason });
    }
    setRulesChannel(rulesChannel, reason) {
      return this.edit({ rulesChannel, reason });
    }
    setPublicUpdatesChannel(publicUpdatesChannel, reason) {
      return this.edit({ publicUpdatesChannel, reason });
    }
    setPreferredLocale(preferredLocale, reason) {
      return this.edit({ preferredLocale, reason });
    }
    setPremiumProgressBarEnabled(enabled = true, reason) {
      return this.edit({ premiumProgressBarEnabled: enabled, reason });
    }
    setSafetyAlertsChannel(safetyAlertsChannel, reason) {
      return this.edit({ safetyAlertsChannel, reason });
    }
    async setWidgetSettings(settings, reason) {
      await this.client.rest.patch(Routes.guildWidgetSettings(this.id), {
        body: {
          enabled: settings.enabled,
          channel_id: this.channels.resolveId(settings.channel)
        },
        reason
      });
      return this;
    }
    async setMFALevel(level, reason) {
      await this.client.rest.post(Routes.guildMFA(this.id), {
        body: {
          level
        },
        reason
      });
      return this;
    }
    async leave() {
      if (this.ownerId === this.client.user.id)
        throw new DiscordjsError(ErrorCodes.GuildOwned);
      await this.client.rest.delete(Routes.userGuild(this.id));
      return this;
    }
    async delete() {
      await this.client.rest.delete(Routes.guild(this.id));
      return this;
    }
    async disableInvites(disabled = true) {
      const features = this.features.filter((feature) => feature !== GuildFeature.InvitesDisabled);
      if (disabled)
        features.push(GuildFeature.InvitesDisabled);
      return this.edit({ features });
    }
    equals(guild) {
      return guild && guild instanceof this.constructor && this.id === guild.id && this.available === guild.available && this.splash === guild.splash && this.discoverySplash === guild.discoverySplash && this.name === guild.name && this.memberCount === guild.memberCount && this.large === guild.large && this.icon === guild.icon && this.ownerId === guild.ownerId && this.verificationLevel === guild.verificationLevel && (this.features === guild.features || this.features.length === guild.features.length && this.features.every((feat, i) => feat === guild.features[i]));
    }
    toJSON() {
      const json = super.toJSON({
        available: false,
        createdTimestamp: true,
        nameAcronym: true,
        presences: false,
        voiceStates: false
      });
      json.iconURL = this.iconURL();
      json.splashURL = this.splashURL();
      json.discoverySplashURL = this.discoverySplashURL();
      json.bannerURL = this.bannerURL();
      return json;
    }
    get voiceAdapterCreator() {
      return (methods) => {
        this.client.voice.adapters.set(this.id, methods);
        return {
          sendPayload: (data) => {
            if (this.shard.status !== Status.Ready)
              return false;
            this.shard.send(data);
            return true;
          },
          destroy: () => {
            this.client.voice.adapters.delete(this.id);
          }
        };
      };
    }
    _sortedRoles() {
      return discordSort(this.roles.cache);
    }
    _sortedChannels(channel) {
      const channelIsCategory = channel.type === ChannelType.GuildCategory;
      const types = getSortableGroupTypes(channel.type);
      return discordSort(this.channels.cache.filter((c) => types.includes(c.type) && (channelIsCategory || c.parentId === channel.parentId)));
    }
  }
  exports.Guild = Guild;
});

// node_modules/discord.js/src/structures/OAuth2Guild.js
var require_OAuth2Guild = __commonJS((exports, module) => {
  var BaseGuild = require_BaseGuild();
  var PermissionsBitField = require_PermissionsBitField();

  class OAuth2Guild extends BaseGuild {
    constructor(client, data) {
      super(client, data);
      this.owner = data.owner;
      this.permissions = new PermissionsBitField(BigInt(data.permissions)).freeze();
    }
  }
  module.exports = OAuth2Guild;
});

// node_modules/discord.js/src/managers/GuildManager.js
var require_GuildManager = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { Guild } = require_Guild();
  var GuildChannel = require_GuildChannel();
  var GuildEmoji = require_GuildEmoji();
  var { GuildMember } = require_GuildMember();
  var Invite = require_Invite();
  var OAuth2Guild = require_OAuth2Guild();
  var { Role } = require_Role();
  var DataResolver = require_DataResolver();
  var Events = require_Events();
  var PermissionsBitField = require_PermissionsBitField();
  var SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  var { resolveColor } = require_Util();
  var cacheWarningEmitted = false;

  class GuildManager extends CachedManager {
    constructor(client, iterable) {
      super(client, Guild, iterable);
      if (!cacheWarningEmitted && this._cache.constructor.name !== "Collection") {
        cacheWarningEmitted = true;
        process2.emitWarning(`Overriding the cache handling for ${this.constructor.name} is unsupported and breaks functionality.`, "UnsupportedCacheOverwriteWarning");
      }
    }
    resolve(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolve(guild.guild);
      }
      return super.resolve(guild);
    }
    resolveId(guild) {
      if (guild instanceof GuildChannel || guild instanceof GuildMember || guild instanceof GuildEmoji || guild instanceof Role || guild instanceof Invite && guild.guild) {
        return super.resolveId(guild.guild.id);
      }
      return super.resolveId(guild);
    }
    async create({
      name,
      icon = null,
      verificationLevel,
      defaultMessageNotifications,
      explicitContentFilter,
      roles = [],
      channels = [],
      afkChannelId,
      afkTimeout,
      systemChannelId,
      systemChannelFlags
    }) {
      const data = await this.client.rest.post(Routes.guilds(), {
        body: {
          name,
          icon: icon && await DataResolver.resolveImage(icon),
          verification_level: verificationLevel,
          default_message_notifications: defaultMessageNotifications,
          explicit_content_filter: explicitContentFilter,
          roles: roles.map(({ color, permissions, ...options }) => ({
            ...options,
            color: color && resolveColor(color),
            permissions: permissions === undefined ? undefined : PermissionsBitField.resolve(permissions).toString()
          })),
          channels: channels.map(({
            parentId,
            userLimit,
            rtcRegion,
            videoQualityMode,
            permissionOverwrites,
            rateLimitPerUser,
            ...options
          }) => ({
            ...options,
            parent_id: parentId,
            user_limit: userLimit,
            rtc_region: rtcRegion,
            video_quality_mode: videoQualityMode,
            permission_overwrites: permissionOverwrites?.map(({ allow, deny, ...permissionOverwriteOptions }) => ({
              ...permissionOverwriteOptions,
              allow: allow === undefined ? undefined : PermissionsBitField.resolve(allow).toString(),
              deny: deny === undefined ? undefined : PermissionsBitField.resolve(deny).toString()
            })),
            rate_limit_per_user: rateLimitPerUser
          })),
          afk_channel_id: afkChannelId,
          afk_timeout: afkTimeout,
          system_channel_id: systemChannelId,
          system_channel_flags: systemChannelFlags === undefined ? undefined : SystemChannelFlagsBitField.resolve(systemChannelFlags)
        }
      });
      return this.client.guilds.cache.get(data.id) ?? new Promise((resolve) => {
        const handleGuild = (guild) => {
          if (guild.id === data.id) {
            clearTimeout2(timeout);
            this.client.decrementMaxListeners();
            resolve(guild);
          }
        };
        this.client.incrementMaxListeners();
        this.client.once(Events.GuildCreate, handleGuild);
        const timeout = setTimeout2(() => {
          this.client.removeListener(Events.GuildCreate, handleGuild);
          this.client.decrementMaxListeners();
          resolve(this.client.guilds._add(data));
        }, 1e4).unref();
      });
    }
    async fetch(options = {}) {
      const id = this.resolveId(options) ?? this.resolveId(options.guild);
      if (id) {
        if (!options.force) {
          const existing = this.cache.get(id);
          if (existing)
            return existing;
        }
        const data2 = await this.client.rest.get(Routes.guild(id), {
          query: makeURLSearchParams({ with_counts: options.withCounts ?? true })
        });
        return this._add(data2, options.cache);
      }
      const data = await this.client.rest.get(Routes.userGuilds(), { query: makeURLSearchParams(options) });
      return data.reduce((coll, guild) => coll.set(guild.id, new OAuth2Guild(this.client, guild)), new Collection);
    }
  }
  module.exports = GuildManager;
});

// node_modules/discord.js/src/managers/UserManager.js
var require_UserManager = __commonJS((exports, module) => {
  var { ChannelType, Routes } = require_v106();
  var CachedManager = require_CachedManager();
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var { GuildMember } = require_GuildMember();
  var { Message } = require_Message();
  var ThreadMember = require_ThreadMember();
  var User = require_User();

  class UserManager extends CachedManager {
    constructor(client, iterable) {
      super(client, User, iterable);
    }
    dmChannel(userId) {
      return this.client.channels.cache.find((c) => c.type === ChannelType.DM && c.recipientId === userId) ?? null;
    }
    async createDM(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const dmChannel = this.dmChannel(id);
        if (dmChannel && !dmChannel.partial)
          return dmChannel;
      }
      const data = await this.client.rest.post(Routes.userChannels(), { body: { recipient_id: id } });
      return this.client.channels._add(data, null, { cache });
    }
    async deleteDM(user) {
      const id = this.resolveId(user);
      const dmChannel = this.dmChannel(id);
      if (!dmChannel)
        throw new DiscordjsError(ErrorCodes.UserNoDMChannel);
      await this.client.rest.delete(Routes.channel(dmChannel.id));
      this.client.channels._remove(dmChannel.id);
      return dmChannel;
    }
    async fetch(user, { cache = true, force = false } = {}) {
      const id = this.resolveId(user);
      if (!force) {
        const existing = this.cache.get(id);
        if (existing && !existing.partial)
          return existing;
      }
      const data = await this.client.rest.get(Routes.user(id));
      return this._add(data, cache);
    }
    async fetchFlags(user, options) {
      return (await this.fetch(user, options)).flags;
    }
    async send(user, options) {
      return (await this.createDM(user)).send(options);
    }
    resolve(user) {
      if (user instanceof GuildMember || user instanceof ThreadMember)
        return user.user;
      if (user instanceof Message)
        return user.author;
      return super.resolve(user);
    }
    resolveId(user) {
      if (user instanceof ThreadMember)
        return user.id;
      if (user instanceof GuildMember)
        return user.user.id;
      if (user instanceof Message)
        return user.author.id;
      return super.resolveId(user);
    }
  }
  module.exports = UserManager;
});

// node_modules/discord.js/src/sharding/ShardClientUtil.js
var require_ShardClientUtil = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { calculateShardId } = require_dist();
  var { DiscordjsError, DiscordjsTypeError, ErrorCodes } = require_errors2();
  var Events = require_Events();
  var { makeError, makePlainError } = require_Util();

  class ShardClientUtil {
    constructor(client, mode) {
      this.client = client;
      this.mode = mode;
      this.parentPort = null;
      switch (mode) {
        case "process":
          process2.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            process2.send({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            process2.send({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            process2.send({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            process2.send({ _resume: true });
          });
          break;
        case "worker":
          this.parentPort = __require("node:worker_threads").parentPort;
          this.parentPort.on("message", this._handleMessage.bind(this));
          client.on(Events.ShardReady, () => {
            this.parentPort.postMessage({ _ready: true });
          });
          client.on(Events.ShardDisconnect, () => {
            this.parentPort.postMessage({ _disconnect: true });
          });
          client.on(Events.ShardReconnecting, () => {
            this.parentPort.postMessage({ _reconnecting: true });
          });
          client.on(Events.ShardResume, () => {
            this.parentPort.postMessage({ _resume: true });
          });
          break;
      }
    }
    get ids() {
      return this.client.options.shards;
    }
    get count() {
      return this.client.options.shardCount;
    }
    send(message) {
      return new Promise((resolve, reject) => {
        switch (this.mode) {
          case "process":
            process2.send(message, (err) => {
              if (err)
                reject(err);
              else
                resolve();
            });
            break;
          case "worker":
            this.parentPort.postMessage(message);
            resolve();
            break;
        }
      });
    }
    fetchClientValues(prop, shard) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        const listener = (message) => {
          if (message?._sFetchProp !== prop || message._sFetchPropShard !== shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    broadcastEval(script, options = {}) {
      return new Promise((resolve, reject) => {
        const parent = this.parentPort ?? process2;
        if (typeof script !== "function") {
          reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
          return;
        }
        script = `(${script})(this, ${JSON.stringify(options.context)})`;
        const listener = (message) => {
          if (message?._sEval !== script || message._sEvalShard !== options.shard)
            return;
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(parent);
        parent.on("message", listener);
        this.send({ _sEval: script, _sEvalShard: options.shard }).catch((err) => {
          parent.removeListener("message", listener);
          this.decrementMaxListeners(parent);
          reject(err);
        });
      });
    }
    respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      return this.send({ _sRespawnAll: { shardDelay, respawnDelay, timeout } });
    }
    async _handleMessage(message) {
      if (!message)
        return;
      if (message._fetchProp) {
        try {
          const props = message._fetchProp.split(".");
          let value = this.client;
          for (const prop of props)
            value = value[prop];
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _result: value });
        } catch (err) {
          this._respond("fetchProp", { _fetchProp: message._fetchProp, _error: makePlainError(err) });
        }
      } else if (message._eval) {
        try {
          this._respond("eval", { _eval: message._eval, _result: await this.client._eval(message._eval) });
        } catch (err) {
          this._respond("eval", { _eval: message._eval, _error: makePlainError(err) });
        }
      }
    }
    _respond(type, message) {
      this.send(message).catch((err) => {
        const error = new Error(`Error when sending ${type} response to master process: ${err.message}`);
        error.stack = err.stack;
        this.client.emit(Events.Error, error);
      });
    }
    static singleton(client, mode) {
      if (!this._singleton) {
        this._singleton = new this(client, mode);
      } else {
        client.emit(Events.Warn, "Multiple clients created in child process/worker; only the first will handle sharding helpers.");
      }
      return this._singleton;
    }
    static shardIdForGuildId(guildId, shardCount) {
      const shard = calculateShardId(guildId, shardCount);
      if (shard < 0)
        throw new DiscordjsError(ErrorCodes.ShardingShardMiscalculation, shard, guildId, shardCount);
      return shard;
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = ShardClientUtil;
});

// node_modules/discord.js/src/structures/ClientPresence.js
var require_ClientPresence = __commonJS((exports, module) => {
  var { GatewayOpcodes, ActivityType } = require_v106();
  var { Presence } = require_Presence();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class ClientPresence extends Presence {
    constructor(client, data = {}) {
      super(client, Object.assign(data, { status: data.status ?? "online", user: { id: null } }));
    }
    set(presence) {
      const packet = this._parse(presence);
      this._patch(packet);
      if (presence.shardId === undefined) {
        this.client.ws.broadcast({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      } else if (Array.isArray(presence.shardId)) {
        for (const shardId of presence.shardId) {
          this.client.ws.shards.get(shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
        }
      } else {
        this.client.ws.shards.get(presence.shardId).send({ op: GatewayOpcodes.PresenceUpdate, d: packet });
      }
      return this;
    }
    _parse({ status, since, afk, activities }) {
      const data = {
        activities: [],
        afk: typeof afk === "boolean" ? afk : false,
        since: typeof since === "number" && !Number.isNaN(since) ? since : null,
        status: status ?? this.status
      };
      if (activities?.length) {
        for (const [i, activity] of activities.entries()) {
          if (typeof activity.name !== "string") {
            throw new DiscordjsTypeError(ErrorCodes.InvalidType, `activities[${i}].name`, "string");
          }
          activity.type ??= ActivityType.Playing;
          if (activity.type === ActivityType.Custom && !activity.state) {
            activity.state = activity.name;
            activity.name = "Custom Status";
          }
          data.activities.push({
            type: activity.type,
            name: activity.name,
            state: activity.state,
            url: activity.url
          });
        }
      } else if (!activities && (status || afk || since) && this.activities.length) {
        data.activities.push(...this.activities.map((a) => ({
          name: a.name,
          state: a.state ?? undefined,
          type: a.type,
          url: a.url ?? undefined
        })));
      }
      return data;
    }
  }
  module.exports = ClientPresence;
});

// node_modules/discord.js/src/structures/StickerPack.js
var require_StickerPack = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { DiscordSnowflake } = require_dist3();
  var Base = require_Base();
  var { Sticker } = require_Sticker();

  class StickerPack extends Base {
    constructor(client, pack) {
      super(client);
      this.id = pack.id;
      this.stickers = new Collection(pack.stickers.map((s) => [s.id, new Sticker(client, s)]));
      this.name = pack.name;
      this.skuId = pack.sku_id;
      this.coverStickerId = pack.cover_sticker_id ?? null;
      this.description = pack.description;
      this.bannerId = pack.banner_asset_id ?? null;
    }
    get createdTimestamp() {
      return DiscordSnowflake.timestampFrom(this.id);
    }
    get createdAt() {
      return new Date(this.createdTimestamp);
    }
    get coverSticker() {
      return this.coverStickerId && this.stickers.get(this.coverStickerId);
    }
    bannerURL(options = {}) {
      return this.bannerId && this.client.rest.cdn.stickerPackBanner(this.bannerId, options);
    }
  }
  module.exports = StickerPack;
});

// node_modules/discord.js/src/structures/VoiceRegion.js
var require_VoiceRegion = __commonJS((exports, module) => {
  var { flatten } = require_Util();

  class VoiceRegion {
    constructor(data) {
      this.id = data.id;
      this.name = data.name;
      this.deprecated = data.deprecated;
      this.optimal = data.optimal;
      this.custom = data.custom;
    }
    toJSON() {
      return flatten(this);
    }
  }
  module.exports = VoiceRegion;
});

// node_modules/discord.js/src/structures/WidgetMember.js
var require_WidgetMember = __commonJS((exports, module) => {
  var Base = require_Base();

  class WidgetMember extends Base {
    constructor(client, data) {
      super(client);
      this.id = data.id;
      this.username = data.username;
      this.discriminator = data.discriminator;
      this.avatar = data.avatar;
      this.status = data.status;
      this.deaf = data.deaf ?? null;
      this.mute = data.mute ?? null;
      this.selfDeaf = data.self_deaf ?? null;
      this.selfMute = data.self_mute ?? null;
      this.suppress = data.suppress ?? null;
      this.channelId = data.channel_id ?? null;
      this.avatarURL = data.avatar_url;
      this.activity = data.activity ?? null;
    }
  }
  module.exports = WidgetMember;
});

// node_modules/discord.js/src/structures/Widget.js
var require_Widget = __commonJS((exports, module) => {
  var { Collection } = require_dist2();
  var { Routes } = require_v106();
  var Base = require_Base();
  var WidgetMember = require_WidgetMember();

  class Widget extends Base {
    constructor(client, data) {
      super(client);
      this._patch(data);
    }
    _patch(data) {
      this.id = data.id;
      if ("name" in data) {
        this.name = data.name;
      }
      if ("instant_invite" in data) {
        this.instantInvite = data.instant_invite;
      }
      this.channels = new Collection;
      for (const channel of data.channels) {
        this.channels.set(channel.id, channel);
      }
      this.members = new Collection;
      for (const member of data.members) {
        this.members.set(member.id, new WidgetMember(this.client, member));
      }
      if ("presence_count" in data) {
        this.presenceCount = data.presence_count;
      }
    }
    async fetch() {
      const data = await this.client.rest.get(Routes.guildWidgetJSON(this.id));
      this._patch(data);
      return this;
    }
  }
  module.exports = Widget;
});

// node_modules/discord.js/src/util/IntentsBitField.js
var require_IntentsBitField = __commonJS((exports, module) => {
  var { GatewayIntentBits } = require_v106();
  var BitField = require_BitField();

  class IntentsBitField extends BitField {
    static Flags = GatewayIntentBits;
  }
  module.exports = IntentsBitField;
});

// node_modules/discord.js/src/util/Sweepers.js
var require_Sweepers = __commonJS((exports, module) => {
  var { setInterval: setInterval2, clearInterval: clearInterval2 } = __require("node:timers");
  var { ThreadChannelTypes, SweeperKeys } = require_Constants();
  var Events = require_Events();
  var { DiscordjsTypeError, ErrorCodes } = require_errors2();

  class Sweepers {
    constructor(client, options) {
      Object.defineProperty(this, "client", { value: client });
      this.options = options;
      this.intervals = Object.fromEntries(SweeperKeys.map((key) => [key, null]));
      for (const key of SweeperKeys) {
        if (!(key in options))
          continue;
        this._validateProperties(key);
        const clonedOptions = { ...this.options[key] };
        if (!("filter" in clonedOptions)) {
          switch (key) {
            case "invites":
              clonedOptions.filter = this.constructor.expiredInviteSweepFilter(clonedOptions.lifetime);
              break;
            case "messages":
              clonedOptions.filter = this.constructor.outdatedMessageSweepFilter(clonedOptions.lifetime);
              break;
            case "threads":
              clonedOptions.filter = this.constructor.archivedThreadSweepFilter(clonedOptions.lifetime);
          }
        }
        this._initInterval(key, `sweep${key[0].toUpperCase()}${key.slice(1)}`, clonedOptions);
      }
    }
    sweepApplicationCommands(filter) {
      const { guilds, items: guildCommands } = this._sweepGuildDirectProp("commands", filter, { emit: false });
      const globalCommands = this.client.application?.commands.cache.sweep(filter) ?? 0;
      this.client.emit(Events.CacheSweep, `Swept ${globalCommands} global application commands and ${guildCommands} guild commands in ${guilds} guilds.`);
      return guildCommands + globalCommands;
    }
    sweepAutoModerationRules(filter) {
      return this._sweepGuildDirectProp("autoModerationRules", filter).items;
    }
    sweepBans(filter) {
      return this._sweepGuildDirectProp("bans", filter).items;
    }
    sweepEmojis(filter) {
      return this._sweepGuildDirectProp("emojis", filter).items;
    }
    sweepInvites(filter) {
      return this._sweepGuildDirectProp("invites", filter).items;
    }
    sweepGuildMembers(filter) {
      return this._sweepGuildDirectProp("members", filter, { outputName: "guild members" }).items;
    }
    sweepMessages(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        messages += channel.messages.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${messages} messages in ${channels} text-based channels.`);
      return messages;
    }
    sweepPresences(filter) {
      return this._sweepGuildDirectProp("presences", filter).items;
    }
    sweepReactions(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let channels = 0;
      let messages = 0;
      let reactions = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!channel.isTextBased())
          continue;
        channels++;
        for (const message of channel.messages.cache.values()) {
          messages++;
          reactions += message.reactions.cache.sweep(filter);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${reactions} reactions on ${messages} messages in ${channels} text-based channels.`);
      return reactions;
    }
    sweepStageInstances(filter) {
      return this._sweepGuildDirectProp("stageInstances", filter, { outputName: "stage instances" }).items;
    }
    sweepStickers(filter) {
      return this._sweepGuildDirectProp("stickers", filter).items;
    }
    sweepThreadMembers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      let members = 0;
      for (const channel of this.client.channels.cache.values()) {
        if (!ThreadChannelTypes.includes(channel.type))
          continue;
        threads++;
        members += channel.members.cache.sweep(filter);
      }
      this.client.emit(Events.CacheSweep, `Swept ${members} thread members in ${threads} threads.`);
      return members;
    }
    sweepThreads(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let threads = 0;
      for (const [key, val] of this.client.channels.cache.entries()) {
        if (!ThreadChannelTypes.includes(val.type))
          continue;
        if (filter(val, key, this.client.channels.cache)) {
          threads++;
          this.client.channels._remove(key);
        }
      }
      this.client.emit(Events.CacheSweep, `Swept ${threads} threads.`);
      return threads;
    }
    sweepUsers(filter) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      const users = this.client.users.cache.sweep(filter);
      this.client.emit(Events.CacheSweep, `Swept ${users} users.`);
      return users;
    }
    sweepVoiceStates(filter) {
      return this._sweepGuildDirectProp("voiceStates", filter, { outputName: "voice states" }).items;
    }
    destroy() {
      for (const key of SweeperKeys) {
        if (this.intervals[key])
          clearInterval2(this.intervals[key]);
      }
    }
    static filterByLifetime({
      lifetime = 14400,
      getComparisonTimestamp = (e) => e?.createdTimestamp,
      excludeFromSweep = () => false
    } = {}) {
      if (typeof lifetime !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "lifetime", "number");
      }
      if (typeof getComparisonTimestamp !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "getComparisonTimestamp", "function");
      }
      if (typeof excludeFromSweep !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "excludeFromSweep", "function");
      }
      return () => {
        if (lifetime <= 0)
          return null;
        const lifetimeMs = lifetime * 1000;
        const now = Date.now();
        return (entry, key, coll) => {
          if (excludeFromSweep(entry, key, coll)) {
            return false;
          }
          const comparisonTimestamp = getComparisonTimestamp(entry, key, coll);
          if (!comparisonTimestamp || typeof comparisonTimestamp !== "number")
            return false;
          return now - comparisonTimestamp > lifetimeMs;
        };
      };
    }
    static archivedThreadSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (e) => e.archiveTimestamp,
        excludeFromSweep: (e) => !e.archived
      });
    }
    static expiredInviteSweepFilter(lifetime = 14400) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (i) => i.expiresTimestamp
      });
    }
    static outdatedMessageSweepFilter(lifetime = 3600) {
      return this.filterByLifetime({
        lifetime,
        getComparisonTimestamp: (m) => m.editedTimestamp ?? m.createdTimestamp
      });
    }
    _sweepGuildDirectProp(key, filter, { emit = true, outputName } = {}) {
      if (typeof filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "filter", "function");
      }
      let guilds = 0;
      let items = 0;
      for (const guild of this.client.guilds.cache.values()) {
        const { cache } = guild[key];
        guilds++;
        items += cache.sweep(filter);
      }
      if (emit) {
        this.client.emit(Events.CacheSweep, `Swept ${items} ${outputName ?? key} in ${guilds} guilds.`);
      }
      return { guilds, items };
    }
    _validateProperties(key) {
      const props = this.options[key];
      if (typeof props !== "object") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}`, "object", true);
      }
      if (typeof props.interval !== "number") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.interval`, "number");
      }
      if (["invites", "messages", "threads"].includes(key) && !("filter" in props)) {
        if (typeof props.lifetime !== "number") {
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.lifetime`, "number");
        }
        return;
      }
      if (typeof props.filter !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, `sweepers.${key}.filter`, "function");
      }
    }
    _initInterval(intervalKey, sweepKey, opts) {
      if (opts.interval <= 0 || opts.interval === Infinity)
        return;
      this.intervals[intervalKey] = setInterval2(() => {
        const sweepFn = opts.filter();
        if (sweepFn === null)
          return;
        if (typeof sweepFn !== "function")
          throw new DiscordjsTypeError(ErrorCodes.SweepFilterReturn);
        this[sweepKey](sweepFn);
      }, opts.interval * 1000).unref();
    }
  }
  module.exports = Sweepers;
});

// node_modules/discord.js/src/client/Client.js
var require_Client = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var { Collection } = require_dist2();
  var { makeURLSearchParams } = require_dist7();
  var { OAuth2Scopes, Routes } = require_v106();
  var BaseClient = require_BaseClient();
  var ActionsManager = require_ActionsManager();
  var ClientVoiceManager = require_ClientVoiceManager();
  var WebSocketManager = require_WebSocketManager();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  var ChannelManager = require_ChannelManager();
  var GuildManager = require_GuildManager();
  var UserManager = require_UserManager();
  var ShardClientUtil = require_ShardClientUtil();
  var ClientPresence = require_ClientPresence();
  var GuildPreview = require_GuildPreview();
  var GuildTemplate = require_GuildTemplate();
  var Invite = require_Invite();
  var { Sticker } = require_Sticker();
  var StickerPack = require_StickerPack();
  var VoiceRegion = require_VoiceRegion();
  var Webhook = require_Webhook();
  var Widget = require_Widget();
  var DataResolver = require_DataResolver();
  var Events = require_Events();
  var IntentsBitField = require_IntentsBitField();
  var Options = require_Options();
  var PermissionsBitField = require_PermissionsBitField();
  var Status = require_Status();
  var Sweepers = require_Sweepers();

  class Client extends BaseClient {
    constructor(options) {
      super(options);
      const data = __require("node:worker_threads").workerData ?? process2.env;
      const defaults = Options.createDefault();
      if (this.options.shards === defaults.shards) {
        if ("SHARDS" in data) {
          this.options.shards = JSON.parse(data.SHARDS);
        }
      }
      if (this.options.shardCount === defaults.shardCount) {
        if ("SHARD_COUNT" in data) {
          this.options.shardCount = Number(data.SHARD_COUNT);
        } else if (Array.isArray(this.options.shards)) {
          this.options.shardCount = this.options.shards.length;
        }
      }
      const typeofShards = typeof this.options.shards;
      if (typeofShards === "undefined" && typeof this.options.shardCount === "number") {
        this.options.shards = Array.from({ length: this.options.shardCount }, (_, i) => i);
      }
      if (typeofShards === "number")
        this.options.shards = [this.options.shards];
      if (Array.isArray(this.options.shards)) {
        this.options.shards = [
          ...new Set(this.options.shards.filter((item) => !isNaN(item) && item >= 0 && item < Infinity && item === (item | 0)))
        ];
      }
      this._validateOptions();
      this.ws = new WebSocketManager(this);
      this.actions = new ActionsManager(this);
      this.voice = new ClientVoiceManager(this);
      this.shard = process2.env.SHARDING_MANAGER ? ShardClientUtil.singleton(this, process2.env.SHARDING_MANAGER_MODE) : null;
      this.users = new UserManager(this);
      this.guilds = new GuildManager(this);
      this.channels = new ChannelManager(this);
      this.sweepers = new Sweepers(this, this.options.sweepers);
      this.presence = new ClientPresence(this, this.options.presence);
      Object.defineProperty(this, "token", { writable: true });
      if (!this.token && ("DISCORD_TOKEN" in process2.env)) {
        this.token = process2.env.DISCORD_TOKEN;
      } else {
        this.token = null;
      }
      this.user = null;
      this.application = null;
      this.readyTimestamp = null;
    }
    get emojis() {
      const emojis = new BaseGuildEmojiManager(this);
      for (const guild of this.guilds.cache.values()) {
        if (guild.available)
          for (const emoji of guild.emojis.cache.values())
            emojis.cache.set(emoji.id, emoji);
      }
      return emojis;
    }
    get readyAt() {
      return this.readyTimestamp && new Date(this.readyTimestamp);
    }
    get uptime() {
      return this.readyTimestamp && Date.now() - this.readyTimestamp;
    }
    async login(token = this.token) {
      if (!token || typeof token !== "string")
        throw new DiscordjsError(ErrorCodes.TokenInvalid);
      this.token = token = token.replace(/^(Bot|Bearer)\s*/i, "");
      this.rest.setToken(token);
      this.emit(Events.Debug, `Provided token: ${this._censoredToken}`);
      if (this.options.presence) {
        this.options.ws.presence = this.presence._parse(this.options.presence);
      }
      this.emit(Events.Debug, "Preparing to connect to the gateway...");
      try {
        await this.ws.connect();
        return this.token;
      } catch (error) {
        await this.destroy();
        throw error;
      }
    }
    isReady() {
      return this.ws.status === Status.Ready;
    }
    async destroy() {
      super.destroy();
      this.sweepers.destroy();
      await this.ws.destroy();
      this.token = null;
      this.rest.setToken(null);
    }
    async deleteWebhook(id, { token, reason } = {}) {
      await this.rest.delete(Routes.webhook(id, token), { auth: !token, reason });
    }
    async fetchInvite(invite, options) {
      const code = DataResolver.resolveInviteCode(invite);
      const query = makeURLSearchParams({
        with_counts: true,
        with_expiration: true,
        guild_scheduled_event_id: options?.guildScheduledEventId
      });
      const data = await this.rest.get(Routes.invite(code), { query });
      return new Invite(this, data);
    }
    async fetchGuildTemplate(template) {
      const code = DataResolver.resolveGuildTemplateCode(template);
      const data = await this.rest.get(Routes.template(code));
      return new GuildTemplate(this, data);
    }
    async fetchWebhook(id, token) {
      const data = await this.rest.get(Routes.webhook(id, token), { auth: token === undefined });
      return new Webhook(this, { token, ...data });
    }
    async fetchVoiceRegions() {
      const apiRegions = await this.rest.get(Routes.voiceRegions());
      const regions = new Collection;
      for (const region of apiRegions)
        regions.set(region.id, new VoiceRegion(region));
      return regions;
    }
    async fetchSticker(id) {
      const data = await this.rest.get(Routes.sticker(id));
      return new Sticker(this, data);
    }
    async fetchPremiumStickerPacks() {
      const data = await this.rest.get(Routes.nitroStickerPacks());
      return new Collection(data.sticker_packs.map((p) => [p.id, new StickerPack(this, p)]));
    }
    async fetchGuildPreview(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildPreview(id));
      return new GuildPreview(this, data);
    }
    async fetchGuildWidget(guild) {
      const id = this.guilds.resolveId(guild);
      if (!id)
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "guild", "GuildResolvable");
      const data = await this.rest.get(Routes.guildWidgetJSON(id));
      return new Widget(this, data);
    }
    generateInvite(options = {}) {
      if (typeof options !== "object")
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options", "object", true);
      if (!this.application)
        throw new DiscordjsError(ErrorCodes.ClientNotReady, "generate an invite link");
      const { scopes } = options;
      if (scopes === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!Array.isArray(scopes)) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidType, "scopes", "Array of Invite Scopes", true);
      }
      if (!scopes.some((scope) => [OAuth2Scopes.Bot, OAuth2Scopes.ApplicationsCommands].includes(scope))) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidMissingScopes);
      }
      if (!scopes.includes(OAuth2Scopes.Bot) && options.permissions) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidScopesWithPermissions);
      }
      const validScopes = Object.values(OAuth2Scopes);
      const invalidScope = scopes.find((scope) => !validScopes.includes(scope));
      if (invalidScope) {
        throw new DiscordjsTypeError(ErrorCodes.InvalidElement, "Array", "scopes", invalidScope);
      }
      const query = makeURLSearchParams({
        client_id: this.application.id,
        scope: scopes.join(" "),
        disable_guild_select: options.disableGuildSelect
      });
      if (options.permissions) {
        const permissions = PermissionsBitField.resolve(options.permissions);
        if (permissions)
          query.set("permissions", permissions.toString());
      }
      if (options.guild) {
        const guildId = this.guilds.resolveId(options.guild);
        if (!guildId)
          throw new DiscordjsTypeError(ErrorCodes.InvalidType, "options.guild", "GuildResolvable");
        query.set("guild_id", guildId);
      }
      return `${this.options.rest.api}${Routes.oauth2Authorization()}?${query}`;
    }
    toJSON() {
      return super.toJSON({
        actions: false,
        presence: false
      });
    }
    get _censoredToken() {
      if (!this.token)
        return null;
      return this.token.split(".").map((val, i) => i > 1 ? val.replace(/./g, "*") : val).join(".");
    }
    _eval(script) {
      return (0, eval)(script);
    }
    _validateOptions(options = this.options) {
      if (options.intents === undefined) {
        throw new DiscordjsTypeError(ErrorCodes.ClientMissingIntents);
      } else {
        options.intents = new IntentsBitField(options.intents).freeze();
      }
      if (typeof options.shardCount !== "number" || isNaN(options.shardCount) || options.shardCount < 1) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardCount", "a number greater than or equal to 1");
      }
      if (options.shards && !(options.shards === "auto" || Array.isArray(options.shards))) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shards", "'auto', a number or array of numbers");
      }
      if (options.shards && !options.shards.length)
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidProvidedShards);
      if (typeof options.makeCache !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "makeCache", "a function");
      }
      if (typeof options.sweepers !== "object" || options.sweepers === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "sweepers", "an object");
      }
      if (!Array.isArray(options.partials)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "partials", "an Array");
      }
      if (typeof options.waitGuildTimeout !== "number" || isNaN(options.waitGuildTimeout)) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "waitGuildTimeout", "a number");
      }
      if (typeof options.failIfNotExists !== "boolean") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "failIfNotExists", "a boolean");
      }
      if (typeof options.allowedMentions !== "object" && options.allowedMentions !== undefined || options.allowedMentions === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "allowedMentions", "an object");
      }
      if (typeof options.presence !== "object" || options.presence === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "presence", "an object");
      }
      if (typeof options.ws !== "object" || options.ws === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "ws", "an object");
      }
      if (typeof options.rest !== "object" || options.rest === null) {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "rest", "an object");
      }
      if (typeof options.jsonTransformer !== "function") {
        throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "jsonTransformer", "a function");
      }
    }
  }
  module.exports = Client;
});

// node_modules/discord.js/src/util/ShardEvents.js
var require_ShardEvents = __commonJS((exports, module) => {
  module.exports = {
    Death: "death",
    Disconnect: "disconnect",
    Error: "error",
    Message: "message",
    Ready: "ready",
    Reconnecting: "reconnecting",
    Resume: "resume",
    Spawn: "spawn"
  };
});

// node_modules/discord.js/src/sharding/Shard.js
var require_Shard = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: setTimeout2, clearTimeout: clearTimeout2 } = __require("node:timers");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { DiscordjsError, ErrorCodes } = require_errors2();
  var ShardEvents = require_ShardEvents();
  var { makeError, makePlainError } = require_Util();
  var childProcess = null;
  var Worker = null;

  class Shard extends EventEmitter {
    constructor(manager, id) {
      super();
      switch (manager.mode) {
        case "process":
          childProcess = __require("node:child_process");
          break;
        case "worker":
          Worker = __require("node:worker_threads").Worker;
          break;
      }
      this.manager = manager;
      this.id = id;
      this.silent = manager.silent;
      this.args = manager.shardArgs ?? [];
      this.execArgv = manager.execArgv;
      this.env = Object.assign({}, process2.env, {
        SHARDING_MANAGER: true,
        SHARDS: this.id,
        SHARD_COUNT: this.manager.totalShards,
        DISCORD_TOKEN: this.manager.token
      });
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals = new Map;
      this._fetches = new Map;
      this._exitListener = null;
    }
    spawn(timeout = 30000) {
      if (this.process)
        throw new DiscordjsError(ErrorCodes.ShardingProcessExists, this.id);
      if (this.worker)
        throw new DiscordjsError(ErrorCodes.ShardingWorkerExists, this.id);
      this._exitListener = this._handleExit.bind(this, undefined, timeout);
      switch (this.manager.mode) {
        case "process":
          this.process = childProcess.fork(path.resolve(this.manager.file), this.args, {
            env: this.env,
            execArgv: this.execArgv,
            silent: this.silent
          }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
        case "worker":
          this.worker = new Worker(path.resolve(this.manager.file), { workerData: this.env }).on("message", this._handleMessage.bind(this)).on("exit", this._exitListener);
          break;
      }
      this._evals.clear();
      this._fetches.clear();
      const child = this.process ?? this.worker;
      this.emit(ShardEvents.Spawn, child);
      if (timeout === -1 || timeout === Infinity)
        return Promise.resolve(child);
      return new Promise((resolve, reject) => {
        const cleanup = () => {
          clearTimeout2(spawnTimeoutTimer);
          this.off("ready", onReady);
          this.off("disconnect", onDisconnect);
          this.off("death", onDeath);
        };
        const onReady = () => {
          cleanup();
          resolve(child);
        };
        const onDisconnect = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDisconnected, this.id));
        };
        const onDeath = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyDied, this.id));
        };
        const onTimeout = () => {
          cleanup();
          reject(new DiscordjsError(ErrorCodes.ShardingReadyTimeout, this.id));
        };
        const spawnTimeoutTimer = setTimeout2(onTimeout, timeout);
        this.once("ready", onReady);
        this.once("disconnect", onDisconnect);
        this.once("death", onDeath);
      });
    }
    kill() {
      if (this.process) {
        this.process.removeListener("exit", this._exitListener);
        this.process.kill();
      } else {
        this.worker.removeListener("exit", this._exitListener);
        this.worker.terminate();
      }
      this._handleExit(false);
    }
    async respawn({ delay = 500, timeout = 30000 } = {}) {
      this.kill();
      if (delay > 0)
        await sleep(delay);
      return this.spawn(timeout);
    }
    send(message) {
      return new Promise((resolve, reject) => {
        if (this.process) {
          this.process.send(message, (err) => {
            if (err)
              reject(err);
            else
              resolve(this);
          });
        } else {
          this.worker.postMessage(message);
          resolve(this);
        }
      });
    }
    fetchClientValue(prop) {
      if (!this.process && !this.worker) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));
      }
      if (this._fetches.has(prop))
        return this._fetches.get(prop);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._fetchProp !== prop)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _fetchProp: prop }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._fetches.delete(prop);
          reject(err);
        });
      });
      this._fetches.set(prop, promise);
      return promise;
    }
    eval(script, context) {
      const _eval = typeof script === "function" ? `(${script})(this, ${JSON.stringify(context)})` : script;
      if (!this.process && !this.worker) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoChildExists, this.id));
      }
      if (this._evals.has(_eval))
        return this._evals.get(_eval);
      const promise = new Promise((resolve, reject) => {
        const child = this.process ?? this.worker;
        const listener = (message) => {
          if (message?._eval !== _eval)
            return;
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          if (!message._error)
            resolve(message._result);
          else
            reject(makeError(message._error));
        };
        this.incrementMaxListeners(child);
        child.on("message", listener);
        this.send({ _eval }).catch((err) => {
          child.removeListener("message", listener);
          this.decrementMaxListeners(child);
          this._evals.delete(_eval);
          reject(err);
        });
      });
      this._evals.set(_eval, promise);
      return promise;
    }
    _handleMessage(message) {
      if (message) {
        if (message._ready) {
          this.ready = true;
          this.emit(ShardEvents.Ready);
          return;
        }
        if (message._disconnect) {
          this.ready = false;
          this.emit(ShardEvents.Disconnect);
          return;
        }
        if (message._reconnecting) {
          this.ready = false;
          this.emit(ShardEvents.Reconnecting);
          return;
        }
        if (message._resume) {
          this.ready = true;
          this.emit(ShardEvents.Resume);
          return;
        }
        if (message._sFetchProp) {
          const resp = { _sFetchProp: message._sFetchProp, _sFetchPropShard: message._sFetchPropShard };
          this.manager.fetchClientValues(message._sFetchProp, message._sFetchPropShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sEval) {
          const resp = { _sEval: message._sEval, _sEvalShard: message._sEvalShard };
          this.manager._performOnShards("eval", [message._sEval], message._sEvalShard).then((results) => this.send({ ...resp, _result: results }), (err) => this.send({ ...resp, _error: makePlainError(err) }));
          return;
        }
        if (message._sRespawnAll) {
          const { shardDelay, respawnDelay, timeout } = message._sRespawnAll;
          this.manager.respawnAll({ shardDelay, respawnDelay, timeout }).catch(() => {
          });
          return;
        }
      }
      this.emit(ShardEvents.Message, message);
    }
    _handleExit(respawn = this.manager.respawn, timeout) {
      this.emit(ShardEvents.Death, this.process ?? this.worker);
      this.ready = false;
      this.process = null;
      this.worker = null;
      this._evals.clear();
      this._fetches.clear();
      if (respawn)
        this.spawn(timeout).catch((err) => this.emit(ShardEvents.Error, err));
    }
    incrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners + 1);
      }
    }
    decrementMaxListeners(emitter) {
      const maxListeners = emitter.getMaxListeners();
      if (maxListeners !== 0) {
        emitter.setMaxListeners(maxListeners - 1);
      }
    }
  }
  module.exports = Shard;
});

// node_modules/discord.js/src/sharding/ShardingManager.js
var require_ShardingManager = __commonJS((exports, module) => {
  var EventEmitter = __require("node:events");
  var fs = __require("node:fs");
  var path = __require("node:path");
  var process2 = __require("node:process");
  var { setTimeout: sleep } = __require("node:timers/promises");
  var { Collection } = require_dist2();
  var Shard = require_Shard();
  var { DiscordjsError, DiscordjsTypeError, DiscordjsRangeError, ErrorCodes } = require_errors2();
  var { mergeDefault, fetchRecommendedShardCount } = require_Util();

  class ShardingManager extends EventEmitter {
    constructor(file, options = {}) {
      super();
      options = mergeDefault({
        totalShards: "auto",
        mode: "process",
        respawn: true,
        silent: false,
        shardArgs: [],
        execArgv: [],
        token: process2.env.DISCORD_TOKEN
      }, options);
      this.file = file;
      if (!file)
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "specified.");
      if (!path.isAbsolute(file))
        this.file = path.resolve(process2.cwd(), file);
      const stats = fs.statSync(this.file);
      if (!stats.isFile())
        throw new DiscordjsError(ErrorCodes.ClientInvalidOption, "File", "a file");
      this.shardList = options.shardList ?? "auto";
      if (this.shardList !== "auto") {
        if (!Array.isArray(this.shardList)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array.");
        }
        this.shardList = [...new Set(this.shardList)];
        if (this.shardList.length < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "shardList", "at least 1 id.");
        }
        if (this.shardList.some((shardId) => typeof shardId !== "number" || isNaN(shardId) || !Number.isInteger(shardId) || shardId < 0)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "shardList", "an array of positive integers.");
        }
      }
      this.totalShards = options.totalShards || "auto";
      if (this.totalShards !== "auto") {
        if (typeof this.totalShards !== "number" || isNaN(this.totalShards)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (this.totalShards < 1) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        }
        if (!Number.isInteger(this.totalShards)) {
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      this.mode = options.mode;
      if (this.mode !== "process" && this.mode !== "worker") {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Sharding mode", '"process" or "worker"');
      }
      this.respawn = options.respawn;
      this.silent = options.silent;
      this.shardArgs = options.shardArgs;
      this.execArgv = options.execArgv;
      this.token = options.token?.replace(/^Bot\s*/i, "") ?? null;
      this.shards = new Collection;
      process2.env.SHARDING_MANAGER = true;
      process2.env.SHARDING_MANAGER_MODE = this.mode;
      process2.env.DISCORD_TOKEN = this.token;
    }
    createShard(id = this.shards.size) {
      const shard = new Shard(this, id);
      this.shards.set(id, shard);
      this.emit("shardCreate", shard);
      return shard;
    }
    async spawn({ amount = this.totalShards, delay = 5500, timeout = 30000 } = {}) {
      if (amount === "auto") {
        amount = await fetchRecommendedShardCount(this.token);
      } else {
        if (typeof amount !== "number" || isNaN(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "a number.");
        }
        if (amount < 1)
          throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "at least 1.");
        if (!Number.isInteger(amount)) {
          throw new DiscordjsTypeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "an integer.");
        }
      }
      if (this.shards.size >= amount)
        throw new DiscordjsError(ErrorCodes.ShardingAlreadySpawned, this.shards.size);
      if (this.shardList === "auto" || this.totalShards === "auto" || this.totalShards !== amount) {
        this.shardList = [...Array(amount).keys()];
      }
      if (this.totalShards === "auto" || this.totalShards !== amount) {
        this.totalShards = amount;
      }
      if (this.shardList.some((shardId) => shardId >= amount)) {
        throw new DiscordjsRangeError(ErrorCodes.ClientInvalidOption, "Amount of shards", "bigger than the highest shardId in the shardList option.");
      }
      for (const shardId of this.shardList) {
        const promises = [];
        const shard = this.createShard(shardId);
        promises.push(shard.spawn(timeout));
        if (delay > 0 && this.shards.size !== this.shardList.length)
          promises.push(sleep(delay));
        await Promise.all(promises);
      }
      return this.shards;
    }
    broadcast(message) {
      const promises = [];
      for (const shard of this.shards.values())
        promises.push(shard.send(message));
      return Promise.all(promises);
    }
    broadcastEval(script, options = {}) {
      if (typeof script !== "function") {
        return Promise.reject(new DiscordjsTypeError(ErrorCodes.ShardingInvalidEvalBroadcast));
      }
      return this._performOnShards("eval", [`(${script})(this, ${JSON.stringify(options.context)})`], options.shard);
    }
    fetchClientValues(prop, shard) {
      return this._performOnShards("fetchClientValue", [prop], shard);
    }
    _performOnShards(method, args, shard) {
      if (this.shards.size === 0)
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingNoShards));
      if (typeof shard === "number") {
        if (this.shards.has(shard))
          return this.shards.get(shard)[method](...args);
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingShardNotFound, shard));
      }
      if (this.shards.size !== this.shardList.length) {
        return Promise.reject(new DiscordjsError(ErrorCodes.ShardingInProcess));
      }
      const promises = [];
      for (const sh of this.shards.values())
        promises.push(sh[method](...args));
      return Promise.all(promises);
    }
    async respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 } = {}) {
      let s = 0;
      for (const shard of this.shards.values()) {
        const promises = [shard.respawn({ delay: respawnDelay, timeout })];
        if (++s < this.shards.size && shardDelay > 0)
          promises.push(sleep(shardDelay));
        await Promise.all(promises);
      }
      return this.shards;
    }
  }
  module.exports = ShardingManager;
});

// node_modules/discord.js/src/util/Formatters.js
var require_Formatters = __commonJS((exports, module) => {
  var { deprecate } = __require("node:util");
  var {
    blockQuote,
    bold,
    channelMention,
    codeBlock,
    formatEmoji,
    hideLinkEmbed,
    hyperlink,
    inlineCode,
    italic,
    quote,
    roleMention,
    spoiler,
    strikethrough,
    time,
    TimestampStyles,
    underscore,
    userMention
  } = require_dist10();

  class Formatters extends null {
    static blockQuote = deprecate(blockQuote, "Formatters.blockQuote() is deprecated. Import this method directly from discord.js instead.");
    static bold = deprecate(bold, "Formatters.bold() is deprecated. Import this method directly from discord.js instead.");
    static channelMention = deprecate(channelMention, "Formatters.channelMention() is deprecated. Import this method directly from discord.js instead.");
    static codeBlock = deprecate(codeBlock, "Formatters.codeBlock() is deprecated. Import this method directly from discord.js instead.");
    static formatEmoji = deprecate(formatEmoji, "Formatters.formatEmoji() is deprecated. Import this method directly from discord.js instead.");
    static hideLinkEmbed = deprecate(hideLinkEmbed, "Formatters.hideLinkEmbed() is deprecated. Import this method directly from discord.js instead.");
    static hyperlink = deprecate(hyperlink, "Formatters.hyperlink() is deprecated. Import this method directly from discord.js instead.");
    static inlineCode = deprecate(inlineCode, "Formatters.inlineCode() is deprecated. Import this method directly from discord.js instead.");
    static italic = deprecate(italic, "Formatters.italic() is deprecated. Import this method directly from discord.js instead.");
    static quote = deprecate(quote, "Formatters.quote() is deprecated. Import this method directly from discord.js instead.");
    static roleMention = deprecate(roleMention, "Formatters.roleMention() is deprecated. Import this method directly from discord.js instead.");
    static spoiler = deprecate(spoiler, "Formatters.spoiler() is deprecated. Import this method directly from discord.js instead.");
    static strikethrough = deprecate(strikethrough, "Formatters.strikethrough() is deprecated. Import this method directly from discord.js instead.");
    static time = deprecate(time, "Formatters.time() is deprecated. Import this method directly from discord.js instead.");
    static TimestampStyles = TimestampStyles;
    static underscore = deprecate(underscore, "Formatters.underscore() is deprecated. Import this method directly from discord.js instead.");
    static userMention = deprecate(userMention, "Formatters.userMention() is deprecated. Import this method directly from discord.js instead.");
  }
  module.exports = Formatters;
});

// node_modules/discord.js/src/structures/EmbedBuilder.js
var require_EmbedBuilder = __commonJS((exports, module) => {
  var { EmbedBuilder: BuildersEmbed, embedLength } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolveColor } = require_Util();

  class EmbedBuilder extends BuildersEmbed {
    constructor(data) {
      super(toSnakeCase(data));
    }
    setColor(color) {
      return super.setColor(color && resolveColor(color));
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
    get length() {
      return embedLength(this.data);
    }
  }
  module.exports = EmbedBuilder;
});

// node_modules/discord.js/src/structures/AttachmentBuilder.js
var require_AttachmentBuilder = __commonJS((exports, module) => {
  var { basename, flatten } = require_Util();

  class AttachmentBuilder {
    constructor(attachment, data = {}) {
      this.attachment = attachment;
      this.name = data.name;
      this.description = data.description;
    }
    setDescription(description) {
      this.description = description;
      return this;
    }
    setFile(attachment) {
      this.attachment = attachment;
      return this;
    }
    setName(name) {
      this.name = name;
      return this;
    }
    setSpoiler(spoiler = true) {
      if (spoiler === this.spoiler)
        return this;
      if (!spoiler) {
        while (this.spoiler) {
          this.name = this.name.slice("SPOILER_".length);
        }
        return this;
      }
      this.name = `SPOILER_${this.name}`;
      return this;
    }
    get spoiler() {
      return basename(this.name).startsWith("SPOILER_");
    }
    toJSON() {
      return flatten(this);
    }
    static from(other) {
      return new AttachmentBuilder(other.attachment, {
        name: other.name,
        description: other.description
      });
    }
  }
  module.exports = AttachmentBuilder;
});

// node_modules/discord.js/src/structures/ModalBuilder.js
var require_ModalBuilder = __commonJS((exports, module) => {
  var { ModalBuilder: BuildersModal, ComponentBuilder } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();

  class ModalBuilder extends BuildersModal {
    constructor({ components, ...data } = {}) {
      super({
        ...toSnakeCase(data),
        components: components?.map((c) => c instanceof ComponentBuilder ? c : toSnakeCase(c))
      });
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = ModalBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuBuilder.js
var require_SelectMenuBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  var deprecationEmitted = false;

  class SelectMenuBuilder2 extends StringSelectMenuBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuBuilder class is deprecated. Use StringSelectMenuBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuBuilder2;
});

// node_modules/discord.js/src/structures/SelectMenuComponent.js
var require_SelectMenuComponent = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuComponent = require_StringSelectMenuComponent();
  var deprecationEmitted = false;

  class SelectMenuComponent extends StringSelectMenuComponent {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuComponent class is deprecated. Use StringSelectMenuComponent instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuComponent;
});

// node_modules/discord.js/src/structures/SelectMenuInteraction.js
var require_SelectMenuInteraction = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  var deprecationEmitted = false;

  class SelectMenuInteraction extends StringSelectMenuInteraction {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuInteraction class is deprecated. Use StringSelectMenuInteraction instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuInteraction;
});

// node_modules/discord.js/src/structures/StringSelectMenuOptionBuilder.js
var require_StringSelectMenuOptionBuilder = __commonJS((exports, module) => {
  var { SelectMenuOptionBuilder: BuildersSelectMenuOption } = require_dist10();
  var { isJSONEncodable } = require_dist();
  var { toSnakeCase } = require_Transformers();
  var { resolvePartialEmoji } = require_Util();

  class StringSelectMenuOptionBuilder extends BuildersSelectMenuOption {
    constructor({ emoji, ...data } = {}) {
      super(toSnakeCase({
        ...data,
        emoji: emoji && typeof emoji === "string" ? resolvePartialEmoji(emoji) : emoji
      }));
    }
    setEmoji(emoji) {
      if (typeof emoji === "string") {
        return super.setEmoji(resolvePartialEmoji(emoji));
      }
      return super.setEmoji(emoji);
    }
    static from(other) {
      return new this(isJSONEncodable(other) ? other.toJSON() : other);
    }
  }
  module.exports = StringSelectMenuOptionBuilder;
});

// node_modules/discord.js/src/structures/SelectMenuOptionBuilder.js
var require_SelectMenuOptionBuilder = __commonJS((exports, module) => {
  var process2 = __require("node:process");
  var StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  var deprecationEmitted = false;

  class SelectMenuOptionBuilder2 extends StringSelectMenuOptionBuilder {
    constructor(...params) {
      super(...params);
      if (!deprecationEmitted) {
        process2.emitWarning("The SelectMenuOptionBuilder class is deprecated. Use StringSelectMenuOptionBuilder instead.", "DeprecationWarning");
        deprecationEmitted = true;
      }
    }
  }
  module.exports = SelectMenuOptionBuilder2;
});

// node_modules/discord.js/src/index.js
var require_src = __commonJS((exports) => {
  var { __exportStar } = require_tslib();
  exports.BaseClient = require_BaseClient();
  exports.Client = require_Client();
  exports.Shard = require_Shard();
  exports.ShardClientUtil = require_ShardClientUtil();
  exports.ShardingManager = require_ShardingManager();
  exports.WebhookClient = require_WebhookClient();
  exports.DiscordjsError = require_DJSError().DiscordjsError;
  exports.DiscordjsTypeError = require_DJSError().DiscordjsTypeError;
  exports.DiscordjsRangeError = require_DJSError().DiscordjsRangeError;
  exports.DiscordjsErrorCodes = require_ErrorCodes();
  exports.ActivityFlagsBitField = require_ActivityFlagsBitField();
  exports.ApplicationFlagsBitField = require_ApplicationFlagsBitField();
  exports.AttachmentFlagsBitField = require_AttachmentFlagsBitField();
  exports.BaseManager = require_BaseManager();
  exports.BitField = require_BitField();
  exports.ChannelFlagsBitField = require_ChannelFlagsBitField();
  exports.Collection = require_dist2().Collection;
  exports.Constants = require_Constants();
  exports.Colors = require_Colors();
  exports.DataResolver = require_DataResolver();
  exports.Events = require_Events();
  exports.Formatters = require_Formatters();
  exports.GuildMemberFlagsBitField = require_GuildMemberFlagsBitField().GuildMemberFlagsBitField;
  exports.IntentsBitField = require_IntentsBitField();
  exports.LimitedCollection = require_LimitedCollection();
  exports.MessageFlagsBitField = require_MessageFlagsBitField();
  exports.Options = require_Options();
  exports.Partials = require_Partials();
  exports.PermissionsBitField = require_PermissionsBitField();
  exports.RoleFlagsBitField = require_RoleFlagsBitField();
  exports.ShardEvents = require_ShardEvents();
  exports.Status = require_Status();
  exports.SnowflakeUtil = require_dist3().DiscordSnowflake;
  exports.Sweepers = require_Sweepers();
  exports.SystemChannelFlagsBitField = require_SystemChannelFlagsBitField();
  exports.ThreadMemberFlagsBitField = require_ThreadMemberFlagsBitField();
  exports.UserFlagsBitField = require_UserFlagsBitField();
  __exportStar(require_Util(), exports);
  exports.WebSocketShardEvents = require_WebSocketShardEvents();
  exports.version = require_package().version;
  exports.ApplicationCommandManager = require_ApplicationCommandManager();
  exports.ApplicationCommandPermissionsManager = require_ApplicationCommandPermissionsManager();
  exports.AutoModerationRuleManager = require_AutoModerationRuleManager();
  exports.BaseGuildEmojiManager = require_BaseGuildEmojiManager();
  exports.CachedManager = require_CachedManager();
  exports.ChannelManager = require_ChannelManager();
  exports.ClientVoiceManager = require_ClientVoiceManager();
  exports.DataManager = require_DataManager();
  exports.DMMessageManager = require_DMMessageManager();
  exports.GuildApplicationCommandManager = require_GuildApplicationCommandManager();
  exports.GuildBanManager = require_GuildBanManager();
  exports.GuildChannelManager = require_GuildChannelManager();
  exports.GuildEmojiManager = require_GuildEmojiManager();
  exports.GuildEmojiRoleManager = require_GuildEmojiRoleManager();
  exports.GuildForumThreadManager = require_GuildForumThreadManager();
  exports.GuildInviteManager = require_GuildInviteManager();
  exports.GuildManager = require_GuildManager();
  exports.GuildMemberManager = require_GuildMemberManager();
  exports.GuildMemberRoleManager = require_GuildMemberRoleManager();
  exports.GuildMessageManager = require_GuildMessageManager();
  exports.GuildScheduledEventManager = require_GuildScheduledEventManager();
  exports.GuildStickerManager = require_GuildStickerManager();
  exports.GuildTextThreadManager = require_GuildTextThreadManager();
  exports.MessageManager = require_MessageManager();
  exports.PermissionOverwriteManager = require_PermissionOverwriteManager();
  exports.PresenceManager = require_PresenceManager();
  exports.ReactionManager = require_ReactionManager();
  exports.ReactionUserManager = require_ReactionUserManager();
  exports.RoleManager = require_RoleManager();
  exports.StageInstanceManager = require_StageInstanceManager();
  exports.ThreadManager = require_ThreadManager();
  exports.ThreadMemberManager = require_ThreadMemberManager();
  exports.UserManager = require_UserManager();
  exports.VoiceStateManager = require_VoiceStateManager();
  exports.WebSocketManager = require_WebSocketManager();
  exports.WebSocketShard = require_WebSocketShard();
  exports.ActionRow = require_ActionRow();
  exports.ActionRowBuilder = require_ActionRowBuilder();
  exports.Activity = require_Presence().Activity;
  exports.AnonymousGuild = require_AnonymousGuild();
  exports.Application = require_Application();
  exports.ApplicationCommand = require_ApplicationCommand();
  exports.ApplicationRoleConnectionMetadata = require_ApplicationRoleConnectionMetadata().ApplicationRoleConnectionMetadata;
  exports.AutocompleteInteraction = require_AutocompleteInteraction();
  exports.AutoModerationActionExecution = require_AutoModerationActionExecution();
  exports.AutoModerationRule = require_AutoModerationRule();
  exports.Base = require_Base();
  exports.BaseGuild = require_BaseGuild();
  exports.BaseGuildEmoji = require_BaseGuildEmoji();
  exports.BaseGuildTextChannel = require_BaseGuildTextChannel();
  exports.BaseGuildVoiceChannel = require_BaseGuildVoiceChannel();
  exports.ButtonBuilder = require_ButtonBuilder();
  exports.ButtonComponent = require_ButtonComponent();
  exports.ButtonInteraction = require_ButtonInteraction();
  exports.CategoryChannel = require_CategoryChannel();
  exports.BaseChannel = require_BaseChannel().BaseChannel;
  exports.ChatInputCommandInteraction = require_ChatInputCommandInteraction();
  exports.ClientApplication = require_ClientApplication();
  exports.ClientPresence = require_ClientPresence();
  exports.ClientUser = require_ClientUser();
  exports.CommandInteraction = require_CommandInteraction();
  exports.Collector = require_Collector();
  exports.CommandInteractionOptionResolver = require_CommandInteractionOptionResolver();
  exports.Component = require_Component();
  exports.ContextMenuCommandInteraction = require_ContextMenuCommandInteraction();
  exports.DMChannel = require_DMChannel();
  exports.Embed = require_Embed();
  exports.EmbedBuilder = require_EmbedBuilder();
  exports.Emoji = require_Emoji().Emoji;
  exports.ForumChannel = require_ForumChannel();
  exports.Guild = require_Guild().Guild;
  exports.GuildAuditLogs = require_GuildAuditLogs();
  exports.GuildAuditLogsEntry = require_GuildAuditLogsEntry();
  exports.GuildBan = require_GuildBan();
  exports.GuildChannel = require_GuildChannel();
  exports.GuildEmoji = require_GuildEmoji();
  exports.GuildMember = require_GuildMember().GuildMember;
  exports.GuildOnboarding = require_GuildOnboarding().GuildOnboarding;
  exports.GuildOnboardingPrompt = require_GuildOnboardingPrompt().GuildOnboardingPrompt;
  exports.GuildOnboardingPromptOption = require_GuildOnboardingPromptOption().GuildOnboardingPromptOption;
  exports.GuildPreview = require_GuildPreview();
  exports.GuildPreviewEmoji = require_GuildPreviewEmoji();
  exports.GuildScheduledEvent = require_GuildScheduledEvent().GuildScheduledEvent;
  exports.GuildTemplate = require_GuildTemplate();
  exports.Integration = require_Integration();
  exports.IntegrationApplication = require_IntegrationApplication();
  exports.BaseInteraction = require_BaseInteraction();
  exports.InteractionCollector = require_InteractionCollector();
  exports.InteractionResponse = require_InteractionResponse();
  exports.InteractionWebhook = require_InteractionWebhook();
  exports.Invite = require_Invite();
  exports.InviteStageInstance = require_InviteStageInstance();
  exports.InviteGuild = require_InviteGuild();
  exports.Message = require_Message().Message;
  exports.Attachment = require_Attachment();
  exports.AttachmentBuilder = require_AttachmentBuilder();
  exports.ModalBuilder = require_ModalBuilder();
  exports.MessageCollector = require_MessageCollector();
  exports.MessageComponentInteraction = require_MessageComponentInteraction();
  exports.MessageContextMenuCommandInteraction = require_MessageContextMenuCommandInteraction();
  exports.MessageMentions = require_MessageMentions();
  exports.MessagePayload = require_MessagePayload();
  exports.MessageReaction = require_MessageReaction();
  exports.ModalSubmitInteraction = require_ModalSubmitInteraction();
  exports.ModalSubmitFields = require_ModalSubmitFields();
  exports.NewsChannel = require_NewsChannel();
  exports.OAuth2Guild = require_OAuth2Guild();
  exports.PartialGroupDMChannel = require_PartialGroupDMChannel();
  exports.PermissionOverwrites = require_PermissionOverwrites();
  exports.Presence = require_Presence().Presence;
  exports.ReactionCollector = require_ReactionCollector();
  exports.ReactionEmoji = require_ReactionEmoji();
  exports.RichPresenceAssets = require_Presence().RichPresenceAssets;
  exports.Role = require_Role().Role;
  exports.SelectMenuBuilder = require_SelectMenuBuilder();
  exports.ChannelSelectMenuBuilder = require_ChannelSelectMenuBuilder();
  exports.MentionableSelectMenuBuilder = require_MentionableSelectMenuBuilder();
  exports.RoleSelectMenuBuilder = require_RoleSelectMenuBuilder();
  exports.StringSelectMenuBuilder = require_StringSelectMenuBuilder();
  exports.UserSelectMenuBuilder = require_UserSelectMenuBuilder();
  exports.BaseSelectMenuComponent = require_BaseSelectMenuComponent();
  exports.SelectMenuComponent = require_SelectMenuComponent();
  exports.ChannelSelectMenuComponent = require_ChannelSelectMenuComponent();
  exports.MentionableSelectMenuComponent = require_MentionableSelectMenuComponent();
  exports.RoleSelectMenuComponent = require_RoleSelectMenuComponent();
  exports.StringSelectMenuComponent = require_StringSelectMenuComponent();
  exports.UserSelectMenuComponent = require_UserSelectMenuComponent();
  exports.SelectMenuInteraction = require_SelectMenuInteraction();
  exports.ChannelSelectMenuInteraction = require_ChannelSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.MentionableSelectMenuInteraction = require_MentionableSelectMenuInteraction();
  exports.RoleSelectMenuInteraction = require_RoleSelectMenuInteraction();
  exports.StringSelectMenuInteraction = require_StringSelectMenuInteraction();
  exports.UserSelectMenuInteraction = require_UserSelectMenuInteraction();
  exports.SelectMenuOptionBuilder = require_SelectMenuOptionBuilder();
  exports.StringSelectMenuOptionBuilder = require_StringSelectMenuOptionBuilder();
  exports.StageChannel = require_StageChannel();
  exports.StageInstance = require_StageInstance().StageInstance;
  exports.Sticker = require_Sticker().Sticker;
  exports.StickerPack = require_StickerPack();
  exports.Team = require_Team();
  exports.TeamMember = require_TeamMember();
  exports.TextChannel = require_TextChannel();
  exports.TextInputBuilder = require_TextInputBuilder();
  exports.TextInputComponent = require_TextInputComponent();
  exports.ThreadChannel = require_ThreadChannel();
  exports.ThreadMember = require_ThreadMember();
  exports.Typing = require_Typing();
  exports.User = require_User();
  exports.UserContextMenuCommandInteraction = require_UserContextMenuCommandInteraction();
  exports.VoiceChannel = require_VoiceChannel();
  exports.VoiceRegion = require_VoiceRegion();
  exports.VoiceState = require_VoiceState();
  exports.Webhook = require_Webhook();
  exports.Widget = require_Widget();
  exports.WidgetMember = require_WidgetMember();
  exports.WelcomeChannel = require_WelcomeChannel();
  exports.WelcomeScreen = require_WelcomeScreen();
  __exportStar(require_v106(), exports);
  __exportStar(require_dist10(), exports);
  __exportStar(require_dist9(), exports);
  __exportStar(require_dist7(), exports);
  __exportStar(require_dist(), exports);
  __exportStar(require_dist11(), exports);
});

// node_modules/@prisma/client/runtime/library.js
var require_library = __commonJS((exports, module) => {
  var Hi = function(e) {
    return typeof e == "function" ? e : (t) => t.$extends(e);
  };
  var Wi = function(e) {
    return e;
  };
  var zi = function(...e) {
    return (t) => t;
  };
  var to = function(e) {
    return e.substring(0, 1).toLowerCase() + e.substring(1);
  };
  var An = function(e, t) {
    return t ? `${t}.${e}` : e;
  };
  var su = function(e) {
    let t = (0, Pr.default)(e), r = Object.assign((...n) => (t.log = r.log, n.length !== 0 && Mt.push([e, ...n]), Mt.length > ou && Mt.shift(), t("", ...n)), t);
    return r;
  };
  var mo = function(e = 7500) {
    let t = Mt.map((r) => r.map((n) => typeof n == "string" ? n : JSON.stringify(n)).join(" ")).join(`
`);
    return t.length < e ? t : t.slice(-e);
  };
  var fo = function() {
    Mt.length = 0;
  };
  var _ = function(e, t) {
    let r = new RegExp(`\\x1b\\[${t}m`, "g"), n = `\x1B[${e}m`, i = `\x1B[${t}m`;
    return function(o) {
      return !au.enabled || o == null ? o : n + (~("" + o).indexOf(i) ? o.replace(r, i + n) : o) + i;
    };
  };
  var _n = function() {
    let e = process.env.PRISMA_QUERY_ENGINE_LIBRARY;
    if (!(e && bo.default.existsSync(e)) && process.arch === "ia32")
      throw new Error('The default query engine type (Node-API, "library") is currently not supported for 32bit Node. Please set `engineType = "binary"` in the "generator" block of your "schema.prisma" file (or use the environment variables "PRISMA_CLIENT_ENGINE_TYPE=binary" and/or "PRISMA_CLI_QUERY_ENGINE_TYPE=binary".)');
  };
  var Nn = function(e, t) {
    let r = t === "url";
    return e.includes("windows") ? r ? "query_engine.dll.node" : `query_engine-${e}.dll.node` : e.includes("darwin") ? r ? `${Tr}.dylib.node` : `${Tr}-${e}.dylib.node` : r ? `${Tr}.so.node` : `${Tr}-${e}.so.node`;
  };
  var Je = function(e) {
    var t;
    return (t = {})[Cr] = function() {
      return { match: function(r) {
        return { matched: !!e(r) };
      } };
    }, t;
  };
  var ot = function(e) {
    return new uu(e, []);
  };
  var Ft = function(e) {
    return (0, So.default)(e, e, { fallback: te });
  };
  var kt = function(e, ...t) {
    mu.warn() && console.warn(`${du.warn} ${e}`, ...t);
  };
  async function Do() {
    let e = Mr.default.platform(), t = process.arch;
    if (e === "freebsd") {
      let s = await Sr("freebsd-version");
      if (s && s.trim().length > 0) {
        let l = /^(\d+)\.?/.exec(s);
        if (l)
          return { platform: "freebsd", targetDistro: `freebsd${l[1]}`, arch: t };
      }
    }
    if (e !== "linux")
      return { platform: e, arch: t };
    let r = await hu(), n = await Cu(), i = bu({ arch: t, archFromUname: n, familyDistro: r.familyDistro }), { libssl: o } = await Eu(i);
    return { platform: "linux", libssl: o, arch: t, archFromUname: n, ...r };
  }
  var yu = function(e) {
    let t = /^ID="?([^"\n]*)"?$/im, r = /^ID_LIKE="?([^"\n]*)"?$/im, n = t.exec(e), i = n && n[1] && n[1].toLowerCase() || "", o = r.exec(e), s = o && o[1] && o[1].toLowerCase() || "", a = ot({ id: i, idLike: s }).with({ id: "alpine" }, ({ id: l }) => ({ targetDistro: "musl", familyDistro: l, originalDistro: l })).with({ id: "raspbian" }, ({ id: l }) => ({ targetDistro: "arm", familyDistro: "debian", originalDistro: l })).with({ id: "nixos" }, ({ id: l }) => ({ targetDistro: "nixos", originalDistro: l, familyDistro: "nixos" })).with({ id: "debian" }, { id: "ubuntu" }, ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).with({ id: "rhel" }, { id: "centos" }, { id: "fedora" }, ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).when(({ idLike: l }) => l.includes("debian") || l.includes("ubuntu"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "debian", originalDistro: l })).when(({ idLike: l }) => i === "arch" || l.includes("arch"), ({ id: l }) => ({ targetDistro: "debian", familyDistro: "arch", originalDistro: l })).when(({ idLike: l }) => l.includes("centos") || l.includes("fedora") || l.includes("rhel") || l.includes("suse"), ({ id: l }) => ({ targetDistro: "rhel", familyDistro: "rhel", originalDistro: l })).otherwise(({ id: l }) => ({ targetDistro: undefined, familyDistro: undefined, originalDistro: l }));
    return ie(`Found distro info:
${JSON.stringify(a, null, 2)}`), a;
  };
  async function hu() {
    let e = "/etc/os-release";
    try {
      let t = await jn.default.readFile(e, { encoding: "utf-8" });
      return yu(t);
    } catch {
      return { targetDistro: undefined, familyDistro: undefined, originalDistro: undefined };
    }
  }
  var xu = function(e) {
    let t = /^OpenSSL\s(\d+\.\d+)\.\d+/.exec(e);
    if (t) {
      let r = `${t[1]}.x`;
      return _o(r);
    }
  };
  var Io = function(e) {
    let t = /libssl\.so\.(\d)(\.\d)?/.exec(e);
    if (t) {
      let r = `${t[1]}${t[2] ?? ".0"}.x`;
      return _o(r);
    }
  };
  var _o = function(e) {
    let t = (() => {
      if (Lo(e))
        return e;
      let r = e.split(".");
      return r[1] = "0", r.join(".");
    })();
    if (gu.includes(t))
      return t;
  };
  var bu = function(e) {
    return ot(e).with({ familyDistro: "musl" }, () => (ie('Trying platform-specific paths for "alpine"'), ["/lib"])).with({ familyDistro: "debian" }, ({ archFromUname: t }) => (ie('Trying platform-specific paths for "debian" (and "ubuntu")'), [`/usr/lib/${t}-linux-gnu`, `/lib/${t}-linux-gnu`])).with({ familyDistro: "rhel" }, () => (ie('Trying platform-specific paths for "rhel"'), ["/lib64", "/usr/lib64"])).otherwise(({ familyDistro: t, arch: r, archFromUname: n }) => (ie(`Don't know any platform-specific paths for "${t}" on ${r} (${n})`), []));
  };
  async function Eu(e) {
    let t = 'grep -v "libssl.so.0"', r = await Fo(e);
    if (r) {
      ie(`Found libssl.so file using platform-specific paths: ${r}`);
      let o = Io(r);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "libssl-specific-path" };
    }
    ie('Falling back to "ldconfig" and other generic paths');
    let n = await Sr(`ldconfig -p | sed "s/.*=>s*//" | sed "s|.*/||" | grep libssl | sort | ${t}`);
    if (n || (n = await Fo(["/lib64", "/usr/lib64", "/lib"])), n) {
      ie(`Found libssl.so file using "ldconfig" or other generic paths: ${n}`);
      let o = Io(n);
      if (ie(`The parsed libssl version is: ${o}`), o)
        return { libssl: o, strategy: "ldconfig" };
    }
    let i = await Sr("openssl version -v");
    if (i) {
      ie(`Found openssl binary with version: ${i}`);
      let o = xu(i);
      if (ie(`The parsed openssl version is: ${o}`), o)
        return { libssl: o, strategy: "openssl-binary" };
    }
    return ie("Couldn't find any version of libssl or OpenSSL in the system"), {};
  }
  async function Fo(e) {
    for (let t of e) {
      let r = await wu(t);
      if (r)
        return r;
    }
  }
  async function wu(e) {
    try {
      return (await jn.default.readdir(e)).find((r) => r.startsWith("libssl.so.") && !r.startsWith("libssl.so.0"));
    } catch (t) {
      if (t.code === "ENOENT")
        return;
      throw t;
    }
  }
  async function lt() {
    let { binaryTarget: e } = await No();
    return e;
  }
  var Pu = function(e) {
    return e.binaryTarget !== undefined;
  };
  async function Bn() {
    let { memoized: e, ...t } = await No();
    return t;
  }
  async function No() {
    if (Pu(Rr))
      return Promise.resolve({ ...Rr, memoized: true });
    let e = await Do(), t = vu(e);
    return Rr = { ...e, binaryTarget: t }, { ...Rr, memoized: false };
  }
  var vu = function(e) {
    let { platform: t, arch: r, archFromUname: n, libssl: i, targetDistro: o, familyDistro: s, originalDistro: a } = e;
    t === "linux" && !["x64", "arm64"].includes(r) && kt(`Prisma only officially supports Linux on amd64 (x86_64) and arm64 (aarch64) system architectures. If you are using your own custom Prisma engines, you can ignore this warning, as long as you've compiled the engines for your system architecture "${n}".`);
    let l = "1.1.x";
    if (t === "linux" && i === undefined) {
      let c = ot({ familyDistro: s }).with({ familyDistro: "debian" }, () => "Please manually install OpenSSL via `apt-get update -y && apt-get install -y openssl` and try installing Prisma again. If you're running Prisma on Docker, add this command to your Dockerfile, or switch to an image that already has OpenSSL installed.").otherwise(() => "Please manually install OpenSSL and try installing Prisma again.");
      kt(`Prisma failed to detect the libssl/openssl version to use, and may not work as expected. Defaulting to "openssl-${l}".
${c}`);
    }
    let u = "debian";
    if (t === "linux" && o === undefined && kt(`Prisma doesn't know which engines to download for the Linux distro "${a}". Falling back to Prisma engines built "${u}".
Please report your experience by creating an issue at ${Ft("https://github.com/prisma/prisma/issues")} so we can add your distro to the list of known supported distros.`), t === "darwin" && r === "arm64")
      return "darwin-arm64";
    if (t === "darwin")
      return "darwin";
    if (t === "win32")
      return "windows";
    if (t === "freebsd")
      return o;
    if (t === "openbsd")
      return "openbsd";
    if (t === "netbsd")
      return "netbsd";
    if (t === "linux" && o === "nixos")
      return "linux-nixos";
    if (t === "linux" && r === "arm64")
      return `${o === "musl" ? "linux-musl-arm64" : "linux-arm64"}-openssl-${i || l}`;
    if (t === "linux" && r === "arm")
      return `linux-arm-openssl-${i || l}`;
    if (t === "linux" && o === "musl") {
      let c = "linux-musl";
      return !i || Lo(i) ? c : `${c}-openssl-${i}`;
    }
    return t === "linux" && o && i ? `${o}-openssl-${i}` : (t !== "linux" && kt(`Prisma detected unknown OS "${t}" and may not work as expected. Defaulting to "linux".`), i ? `${u}-openssl-${i}` : o ? `${o}-openssl-${l}` : `${u}-openssl-${l}`);
  };
  async function Tu(e) {
    try {
      return await e();
    } catch {
      return;
    }
  }
  var Sr = function(e) {
    return Tu(async () => {
      let t = await fu(e);
      return ie(`Command "${e}" successfully returned "${t.stdout}"`), t.stdout;
    });
  };
  async function Cu() {
    return typeof Mr.default.machine == "function" ? Mr.default.machine() : (await Sr("uname -m"))?.trim();
  }
  var Lo = function(e) {
    return e.startsWith("1.");
  };
  var jo = function(e) {
    let t = e.ignoreProcessEnv ? {} : process.env, r = (n) => n.match(/(.?\${(?:[a-zA-Z0-9_]+)?})/g)?.reduce(function(o, s) {
      let a = /(.?)\${([a-zA-Z0-9_]+)?}/g.exec(s);
      if (!a)
        return o;
      let l = a[1], u, c;
      if (l === "\\")
        c = a[0], u = c.replace("\\$", "$");
      else {
        let p = a[2];
        c = a[0].substring(l.length), u = Object.hasOwnProperty.call(t, p) ? t[p] : e.parsed[p] || "", u = r(u);
      }
      return o.replace(c, u);
    }, n) ?? n;
    for (let n in e.parsed) {
      let i = Object.hasOwnProperty.call(t, n) ? t[n] : e.parsed[n];
      e.parsed[n] = r(i);
    }
    for (let n in e.parsed)
      t[n] = e.parsed[n];
    return e;
  };
  var Ot = function({ rootEnvPath: e, schemaEnvPath: t }, r = { conflictCheck: "none" }) {
    let n = Bo(e);
    r.conflictCheck !== "none" && _u(n, t, r.conflictCheck);
    let i = null;
    return Uo(n?.path, t) || (i = Bo(t)), !n && !i && Qn("No Environment variables loaded"), i?.dotenvResult.error ? console.error(me(ne("Schema Env Error: ")) + i.dotenvResult.error) : { message: [n?.message, i?.message].filter(Boolean).join(`
`), parsed: { ...n?.dotenvResult?.parsed, ...i?.dotenvResult?.parsed } };
  };
  var _u = function(e, t, r) {
    let n = e?.dotenvResult.parsed, i = !Uo(e?.path, t);
    if (n && t && i && kr.default.existsSync(t)) {
      let o = Jn.default.parse(kr.default.readFileSync(t)), s = [];
      for (let a in o)
        n[a] === o[a] && s.push(a);
      if (s.length > 0) {
        let a = ut.default.relative(process.cwd(), e.path), l = ut.default.relative(process.cwd(), t);
        if (r === "error") {
          let u = `There is a conflict between env var${s.length > 1 ? "s" : ""} in ${te(a)} and ${te(l)}
Conflicting env vars:
${s.map((c) => `  ${ne(c)}`).join(`
`)}

We suggest to move the contents of ${te(l)} to ${te(a)} to consolidate your env vars.
`;
          throw new Error(u);
        } else if (r === "warn") {
          let u = `Conflict for env var${s.length > 1 ? "s" : ""} ${s.map((c) => ne(c)).join(", ")} in ${te(a)} and ${te(l)}
Env vars from ${te(l)} overwrite the ones from ${te(a)}
      `;
          console.warn(`${he("warn(prisma)")} ${u}`);
        }
      }
    }
  };
  var Bo = function(e) {
    return Nu(e) ? (Qn(`Environment variables loaded from ${e}`), { dotenvResult: jo(Jn.default.config({ path: e, debug: process.env.DOTENV_CONFIG_DEBUG ? true : undefined })), message: ke(`Environment variables loaded from ${ut.default.relative(process.cwd(), e)}`), path: e }) : (Qn(`Environment variables not found at ${e}`), null);
  };
  var Uo = function(e, t) {
    return e && t && ut.default.resolve(e) === ut.default.resolve(t);
  };
  var Nu = function(e) {
    return !!(e && kr.default.existsSync(e));
  };
  var Gn = function(e) {
    let t = Lu();
    return t || (e?.config.engineType === "library" ? "library" : e?.config.engineType === "binary" ? "binary" : Ko);
  };
  var Lu = function() {
    let e = process.env.PRISMA_CLIENT_ENGINE_TYPE;
    return e === "library" ? "library" : e === "binary" ? "binary" : undefined;
  };
  var zo = function() {
    return N.default.join(__dirname, "../");
  };
  var zn = function(e) {
    if (process.platform === "win32")
      return;
    let t = Wn.default.statSync(e), r = t.mode | 64 | 8 | 1;
    if (t.mode === r) {
      Yo(`Execution permissions of ${e} are fine`);
      return;
    }
    let n = r.toString(8).slice(-3);
    Yo(`Have to call chmodPlusX on ${e}`), Wn.default.chmodSync(e, n);
  };
  var Yn = function(e) {
    let t = e.e, r = (a) => `Prisma cannot find the required \`${a}\` system library in your system`, n = t.message.includes("cannot open shared object file"), i = `Please refer to the documentation about Prisma's system requirements: ${Ft("https://pris.ly/d/system-requirements")}`, o = `Unable to require(\`${ke(e.id)}\`).`, s = ot({ message: t.message, code: t.code }).with({ code: "ENOENT" }, () => "File does not exist.").when(({ message: a }) => n && a.includes("libz"), () => `${r("libz")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libgcc_s"), () => `${r("libgcc_s")}. Please install it and try again.`).when(({ message: a }) => n && a.includes("libssl"), () => {
      let a = e.platformInfo.libssl ? `openssl-${e.platformInfo.libssl}` : "openssl";
      return `${r("libssl")}. Please install ${a} and try again.`;
    }).when(({ message: a }) => a.includes("GLIBC"), () => `Prisma has detected an incompatible version of the \`glibc\` C standard library installed in your system. This probably means your system may be too old to run Prisma. ${i}`).when(({ message: a }) => e.platformInfo.platform === "linux" && a.includes("symbol not found"), () => `The Prisma engines are not compatible with your system ${e.platformInfo.originalDistro} on (${e.platformInfo.archFromUname}) which uses the \`${e.platformInfo.binaryTarget}\` binaryTarget by default. ${i}`).otherwise(() => `The Prisma engines do not seem to be compatible with your system. ${i}`);
    return `${o}
${s}

Details: ${t.message}`;
  };
  var Zn = function(e) {
    return Dt.default.sep === Dt.default.posix.sep ? e : e.split(Dt.default.sep).join(Dt.default.posix.sep);
  };
  var ti = function(e) {
    return String(new ei(e));
  };
  var Bu = function(e) {
    let t;
    if (e.length > 0) {
      let r = e.find((n) => n.fromEnvVar !== null);
      r ? t = `env("${r.fromEnvVar}")` : t = e.map((n) => n.native ? "native" : n.value);
    } else
      t = undefined;
    return t;
  };
  var Uu = function(e) {
    let t = Object.keys(e).reduce((r, n) => Math.max(r, n.length), 0);
    return Object.entries(e).map(([r, n]) => `${r.padEnd(t)} = ${Ku(n)}`).join(`
`);
  };
  var Ku = function(e) {
    return JSON.parse(JSON.stringify(e, (t, r) => Array.isArray(r) ? `[${r.map((n) => JSON.stringify(n)).join(", ")}]` : JSON.stringify(r)));
  };
  var Qu = function(...e) {
    console.log(...e);
  };
  var ri = function(e, ...t) {
    es.warn() && console.warn(`${_t.warn} ${e}`, ...t);
  };
  var Ju = function(e, ...t) {
    console.info(`${_t.info} ${e}`, ...t);
  };
  var Gu = function(e, ...t) {
    console.error(`${_t.error} ${e}`, ...t);
  };
  var Hu = function(e, ...t) {
    console.log(`${_t.query} ${e}`, ...t);
  };
  var Ge = function(e, t) {
    throw new Error(t);
  };
  var ii = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  };
  var ct = function(e, t) {
    let r = {};
    for (let n of Object.keys(e))
      r[n] = t(e[n], n);
    return r;
  };
  var si = function(e, t) {
    if (e.length === 0)
      return;
    let r = e[0];
    for (let n = 1;n < e.length; n++)
      t(r, e[n]) < 0 && (r = e[n]);
    return r;
  };
  var E = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var $t = function(e) {
    let t;
    return { get() {
      return t || (t = { value: e() }), t.value;
    } };
  };
  var as = function(e, t) {
    let r = $t(() => zu(t));
    Object.defineProperty(e, "dmmf", { get: () => r.get() });
  };
  var zu = function(e) {
    return { datamodel: { models: ai(e.models), enums: ai(e.enums), types: ai(e.types) } };
  };
  var ai = function(e) {
    return Object.entries(e).map(([t, r]) => ({ name: t, ...r }));
  };
  var ls = function(e, t = ",", r = "", n = "") {
    if (e.length === 0)
      throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
    return new oe([r, ...Array(e.length - 1).fill(t), n], e);
  };
  var li = function(e) {
    return new oe([e], []);
  };
  var ui = function(e, ...t) {
    return new oe(e, t);
  };
  var qt = function(e) {
    return { getKeys() {
      return Object.keys(e);
    }, getPropertyValue(t) {
      return e[t];
    } };
  };
  var re = function(e, t) {
    return { getKeys() {
      return [e];
    }, getPropertyValue() {
      return t();
    } };
  };
  var He = function(e) {
    let t = new xe;
    return { getKeys() {
      return e.getKeys();
    }, getPropertyValue(r) {
      return t.getOrCreate(r, () => e.getPropertyValue(r));
    }, getPropertyDescriptor(r) {
      return e.getPropertyDescriptor?.(r);
    } };
  };
  var Nr = function(e) {
    let t = new Set(e);
    return { getOwnPropertyDescriptor: () => _r, has: (r, n) => t.has(n), set: (r, n, i) => t.add(n) && Reflect.set(r, n, i), ownKeys: () => [...t] };
  };
  var be = function(e, t) {
    let r = Yu(t), n = new Set, i = new Proxy(e, { get(o, s) {
      if (n.has(s))
        return o[s];
      let a = r.get(s);
      return a ? a.getPropertyValue(s) : o[s];
    }, has(o, s) {
      if (n.has(s))
        return true;
      let a = r.get(s);
      return a ? a.has?.(s) ?? true : Reflect.has(o, s);
    }, ownKeys(o) {
      let s = ps(Reflect.ownKeys(o), r), a = ps(Array.from(r.keys()), r);
      return [...new Set([...s, ...a, ...n])];
    }, set(o, s, a) {
      return r.get(s)?.getPropertyDescriptor?.(s)?.writable === false ? false : (n.add(s), Reflect.set(o, s, a));
    }, getOwnPropertyDescriptor(o, s) {
      let a = Reflect.getOwnPropertyDescriptor(o, s);
      if (a && !a.configurable)
        return a;
      let l = r.get(s);
      return l ? l.getPropertyDescriptor ? { ..._r, ...l?.getPropertyDescriptor(s) } : _r : a;
    }, defineProperty(o, s, a) {
      return n.add(s), Reflect.defineProperty(o, s, a);
    } });
    return i[cs] = function(o, s, a = ds.inspect) {
      let l = { ...this };
      return delete l[cs], a(l, s);
    }, i;
  };
  var Yu = function(e) {
    let t = new Map;
    for (let r of e) {
      let n = r.getKeys();
      for (let i of n)
        t.set(i, r);
    }
    return t;
  };
  var ps = function(e, t) {
    return e.filter((r) => t.get(r)?.has?.(r) ?? true);
  };
  var Vt = function(e) {
    return { getKeys() {
      return e;
    }, has() {
      return false;
    }, getPropertyValue() {
    } };
  };
  var pi = function(e, t) {
    Object.defineProperty(e, "name", { value: t, configurable: true });
  };
  var mt = function(e) {
    return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
  };
  var qr = function(e) {
    return e.toString() !== "Invalid Date";
  };
  var W = function(e) {
    var t, r, n, i = e.length - 1, o = "", s = e[0];
    if (i > 0) {
      for (o += s, t = 1;t < i; t++)
        n = e[t] + "", r = b - n.length, r && (o += De(r)), o += n;
      s = e[t], n = s + "", r = b - n.length, r && (o += De(r));
    } else if (s === 0)
      return "0";
    for (;s % 10 === 0; )
      s /= 10;
    return o + s;
  };
  var se = function(e, t, r) {
    if (e !== ~~e || e < t || e > r)
      throw Error(Ne + e);
  };
  var Qt = function(e, t, r, n) {
    var i, o, s, a;
    for (o = e[0];o >= 10; o /= 10)
      --t;
    return --t < 0 ? (t += b, i = 0) : (i = Math.ceil((t + 1) / b), t %= b), o = j(10, b - t), a = e[i] % o | 0, n == null ? t < 3 ? (t == 0 ? a = a / 100 | 0 : t == 1 && (a = a / 10 | 0), s = r < 4 && a == 99999 || r > 3 && a == 49999 || a == 50000 || a == 0) : s = (r < 4 && a + 1 == o || r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 100 | 0) == j(10, t - 2) - 1 || (a == o / 2 || a == 0) && (e[i + 1] / o / 100 | 0) == 0 : t < 4 ? (t == 0 ? a = a / 1000 | 0 : t == 1 ? a = a / 100 | 0 : t == 2 && (a = a / 10 | 0), s = (n || r < 4) && a == 9999 || !n && r > 3 && a == 4999) : s = ((n || r < 4) && a + 1 == o || !n && r > 3 && a + 1 == o / 2) && (e[i + 1] / o / 1000 | 0) == j(10, t - 3) - 1, s;
  };
  var Vr = function(e, t, r) {
    for (var n, i = [0], o, s = 0, a = e.length;s < a; ) {
      for (o = i.length;o--; )
        i[o] *= t;
      for (i[0] += di.indexOf(e.charAt(s++)), n = 0;n < i.length; n++)
        i[n] > r - 1 && (i[n + 1] === undefined && (i[n + 1] = 0), i[n + 1] += i[n] / r | 0, i[n] %= r);
    }
    return i.reverse();
  };
  var nc = function(e, t) {
    var r, n, i;
    if (t.isZero())
      return t;
    n = t.d.length, n < 32 ? (r = Math.ceil(n / 3), i = (1 / Jr(4, r)).toString()) : (r = 16, i = "2.3283064365386962890625e-10"), e.precision += r, t = gt(e, 1, t.times(i), new e(1));
    for (var o = r;o--; ) {
      var s = t.times(t);
      t = s.times(s).minus(s).times(8).plus(1);
    }
    return e.precision -= r, t;
  };
  var h = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor;
    e:
      if (t != null) {
        if (p = e.d, !p)
          return e;
        for (i = 1, a = p[0];a >= 10; a /= 10)
          i++;
        if (o = t - i, o < 0)
          o += b, s = t, c = p[d = 0], l = c / j(10, i - s - 1) % 10 | 0;
        else if (d = Math.ceil((o + 1) / b), a = p.length, d >= a)
          if (n) {
            for (;a++ <= d; )
              p.push(0);
            c = l = 0, i = 1, o %= b, s = o - b + 1;
          } else
            break e;
        else {
          for (c = a = p[d], i = 1;a >= 10; a /= 10)
            i++;
          o %= b, s = o - b + i, l = s < 0 ? 0 : c / j(10, i - s - 1) % 10 | 0;
        }
        if (n = n || t < 0 || p[d + 1] !== undefined || (s < 0 ? c : c % j(10, i - s - 1)), u = r < 4 ? (l || n) && (r == 0 || r == (e.s < 0 ? 3 : 2)) : l > 5 || l == 5 && (r == 4 || n || r == 6 && (o > 0 ? s > 0 ? c / j(10, i - s) : 0 : p[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !p[0])
          return p.length = 0, u ? (t -= e.e + 1, p[0] = j(10, (b - t % b) % b), e.e = -t || 0) : p[0] = e.e = 0, e;
        if (o == 0 ? (p.length = d, a = 1, d--) : (p.length = d + 1, a = j(10, b - o), p[d] = s > 0 ? (c / j(10, i - s) % j(10, s) | 0) * a : 0), u)
          for (;; )
            if (d == 0) {
              for (o = 1, s = p[0];s >= 10; s /= 10)
                o++;
              for (s = p[0] += a, a = 1;s >= 10; s /= 10)
                a++;
              o != a && (e.e++, p[0] == ge && (p[0] = 1));
              break;
            } else {
              if (p[d] += a, p[d] != ge)
                break;
              p[d--] = 0, a = 1;
            }
        for (o = p.length;p[--o] === 0; )
          p.pop();
      }
    return w && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e;
  };
  var Ee = function(e, t, r) {
    if (!e.isFinite())
      return Ts(e);
    var n, i = e.e, o = W(e.d), s = o.length;
    return t ? (r && (n = r - s) > 0 ? o = o.charAt(0) + "." + o.slice(1) + De(n) : s > 1 && (o = o.charAt(0) + "." + o.slice(1)), o = o + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (o = "0." + De(-i - 1) + o, r && (n = r - s) > 0 && (o += De(n))) : i >= s ? (o += De(i + 1 - s), r && (n = r - i - 1) > 0 && (o = o + "." + De(n))) : ((n = i + 1) < s && (o = o.slice(0, n) + "." + o.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (o += "."), o += De(n))), o;
  };
  var Qr = function(e, t) {
    var r = e[0];
    for (t *= b;r >= 10; r /= 10)
      t++;
    return t;
  };
  var Ur = function(e, t, r) {
    if (t > rc)
      throw w = true, r && (e.precision = r), Error(hs);
    return h(new e(jr), t, 1, true);
  };
  var fe = function(e, t, r) {
    if (t > fi)
      throw Error(hs);
    return h(new e(Br), t, r, true);
  };
  var ws = function(e) {
    var t = e.length - 1, r = t * b + 1;
    if (t = e[t], t) {
      for (;t % 10 == 0; t /= 10)
        r--;
      for (t = e[0];t >= 10; t /= 10)
        r++;
    }
    return r;
  };
  var De = function(e) {
    for (var t = "";e--; )
      t += "0";
    return t;
  };
  var Ps = function(e, t, r, n) {
    var i, o = new e(1), s = Math.ceil(n / b + 4);
    for (w = false;; ) {
      if (r % 2 && (o = o.times(t), fs(o.d, s) && (i = true)), r = ee(r / 2), r === 0) {
        r = o.d.length - 1, i && o.d[r] === 0 && ++o.d[r];
        break;
      }
      t = t.times(t), fs(t.d, s);
    }
    return w = true, o;
  };
  var ms = function(e) {
    return e.d[e.d.length - 1] & 1;
  };
  var vs = function(e, t, r) {
    for (var n, i = new e(t[0]), o = 0;++o < t.length; )
      if (n = new e(t[o]), n.s)
        i[r](n) && (i = n);
      else {
        i = n;
        break;
      }
    return i;
  };
  var gi = function(e, t) {
    var r, n, i, o, s, a, l, u = 0, c = 0, p = 0, d = e.constructor, f = d.rounding, y = d.precision;
    if (!e.d || !e.d[0] || e.e > 17)
      return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : 0 / 0);
    for (t == null ? (w = false, l = y) : l = t, a = new d(0.03125);e.e > -2; )
      e = e.times(a), p += 5;
    for (n = Math.log(j(2, p)) / Math.LN10 * 2 + 5 | 0, l += n, r = o = s = new d(1), d.precision = l;; ) {
      if (o = h(o.times(e), l, 1), r = r.times(++c), a = s.plus(O(o, r, l, 1)), W(a.d).slice(0, l) === W(s.d).slice(0, l)) {
        for (i = p;i--; )
          s = h(s.times(s), l, 1);
        if (t == null)
          if (u < 3 && Qt(s.d, l - n, f, u))
            d.precision = l += 10, r = o = a = new d(1), c = 0, u++;
          else
            return h(s, d.precision = y, f, w = true);
        else
          return d.precision = y, s;
      }
      s = a;
    }
  };
  var _e = function(e, t) {
    var r, n, i, o, s, a, l, u, c, p, d, f = 1, y = 10, g = e, P = g.d, T = g.constructor, C = T.rounding, x = T.precision;
    if (g.s < 0 || !P || !P[0] || !g.e && P[0] == 1 && P.length == 1)
      return new T(P && !P[0] ? -1 / 0 : g.s != 1 ? NaN : P ? 0 : g);
    if (t == null ? (w = false, c = x) : c = t, T.precision = c += y, r = W(P), n = r.charAt(0), Math.abs(o = g.e) < 1500000000000000) {
      for (;n < 7 && n != 1 || n == 1 && r.charAt(1) > 3; )
        g = g.times(e), r = W(g.d), n = r.charAt(0), f++;
      o = g.e, n > 1 ? (g = new T("0." + r), o++) : g = new T(n + "." + r.slice(1));
    } else
      return u = Ur(T, c + 2, x).times(o + ""), g = _e(new T(n + "." + r.slice(1)), c - y).plus(u), T.precision = x, t == null ? h(g, x, C, w = true) : g;
    for (p = g, l = s = g = O(g.minus(1), g.plus(1), c, 1), d = h(g.times(g), c, 1), i = 3;; ) {
      if (s = h(s.times(d), c, 1), u = l.plus(O(s, new T(i), c, 1)), W(u.d).slice(0, c) === W(l.d).slice(0, c))
        if (l = l.times(2), o !== 0 && (l = l.plus(Ur(T, c + 2, x).times(o + ""))), l = O(l, new T(f), c, 1), t == null)
          if (Qt(l.d, c - y, C, a))
            T.precision = c += y, u = s = g = O(p.minus(1), p.plus(1), c, 1), d = h(g.times(g), c, 1), i = a = 1;
          else
            return h(l, T.precision = x, C, w = true);
        else
          return T.precision = x, l;
      l = u, i += 2;
    }
  };
  var Ts = function(e) {
    return String(e.s * e.s / 0);
  };
  var yi = function(e, t) {
    var r, n, i;
    for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0;t.charCodeAt(n) === 48; n++)
      ;
    for (i = t.length;t.charCodeAt(i - 1) === 48; --i)
      ;
    if (t = t.slice(n, i), t) {
      if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % b, r < 0 && (n += b), n < i) {
        for (n && e.d.push(+t.slice(0, n)), i -= b;n < i; )
          e.d.push(+t.slice(n, n += b));
        t = t.slice(n), n = b - t.length;
      } else
        n -= i;
      for (;n--; )
        t += "0";
      e.d.push(+t), w && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]));
    } else
      e.e = 0, e.d = [0];
    return e;
  };
  var ic = function(e, t) {
    var r, n, i, o, s, a, l, u, c;
    if (t.indexOf("_") > -1) {
      if (t = t.replace(/(\d)_(?=\d)/g, "$1"), Es.test(t))
        return yi(e, t);
    } else if (t === "Infinity" || t === "NaN")
      return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
    if (Xu.test(t))
      r = 16, t = t.toLowerCase();
    else if (Zu.test(t))
      r = 2;
    else if (ec.test(t))
      r = 8;
    else
      throw Error(Ne + t);
    for (o = t.search(/p/i), o > 0 ? (l = +t.slice(o + 1), t = t.substring(2, o)) : t = t.slice(2), o = t.indexOf("."), s = o >= 0, n = e.constructor, s && (t = t.replace(".", ""), a = t.length, o = a - o, i = Ps(n, new n(r), o, o * 2)), u = Vr(t, r, ge), c = u.length - 1, o = c;u[o] === 0; --o)
      u.pop();
    return o < 0 ? new n(e.s * 0) : (e.e = Qr(u, c), e.d = u, w = false, s && (e = O(e, i, a * 4)), l && (e = e.times(Math.abs(l) < 54 ? j(2, l) : We.pow(2, l))), w = true, e);
  };
  var oc = function(e, t) {
    var r, n = t.d.length;
    if (n < 3)
      return t.isZero() ? t : gt(e, 2, t, t);
    r = 1.4 * Math.sqrt(n), r = r > 16 ? 16 : r | 0, t = t.times(1 / Jr(5, r)), t = gt(e, 2, t, t);
    for (var i, o = new e(5), s = new e(16), a = new e(20);r--; )
      i = t.times(t), t = t.times(o.plus(i.times(s.times(i).minus(a))));
    return t;
  };
  var gt = function(e, t, r, n, i) {
    var o, s, a, l, u = 1, c = e.precision, p = Math.ceil(c / b);
    for (w = false, l = r.times(r), a = new e(n);; ) {
      if (s = O(a.times(l), new e(t++ * t++), c, 1), a = i ? n.plus(s) : n.minus(s), n = O(s.times(l), new e(t++ * t++), c, 1), s = a.plus(n), s.d[p] !== undefined) {
        for (o = p;s.d[o] === a.d[o] && o--; )
          ;
        if (o == -1)
          break;
      }
      o = a, a = n, n = s, s = o, u++;
    }
    return w = true, s.d.length = p + 1, s;
  };
  var Jr = function(e, t) {
    for (var r = e;--t; )
      r *= e;
    return r;
  };
  var Cs = function(e, t) {
    var r, n = t.s < 0, i = fe(e, e.precision, 1), o = i.times(0.5);
    if (t = t.abs(), t.lte(o))
      return Re = n ? 4 : 1, t;
    if (r = t.divToInt(i), r.isZero())
      Re = n ? 3 : 2;
    else {
      if (t = t.minus(r.times(i)), t.lte(o))
        return Re = ms(r) ? n ? 2 : 3 : n ? 4 : 1, t;
      Re = ms(r) ? n ? 1 : 4 : n ? 3 : 2;
    }
    return t.minus(i).abs();
  };
  var hi = function(e, t, r, n) {
    var i, o, s, a, l, u, c, p, d, f = e.constructor, y = r !== undefined;
    if (y ? (se(r, 1, Le), n === undefined ? n = f.rounding : se(n, 0, 8)) : (r = f.precision, n = f.rounding), !e.isFinite())
      c = Ts(e);
    else {
      for (c = Ee(e), s = c.indexOf("."), y ? (i = 2, t == 16 ? r = r * 4 - 3 : t == 8 && (r = r * 3 - 2)) : i = t, s >= 0 && (c = c.replace(".", ""), d = new f(1), d.e = c.length - s, d.d = Vr(Ee(d), 10, i), d.e = d.d.length), p = Vr(c, 10, i), o = l = p.length;p[--l] == 0; )
        p.pop();
      if (!p[0])
        c = y ? "0p+0" : "0";
      else {
        if (s < 0 ? o-- : (e = new f(e), e.d = p, e.e = o, e = O(e, d, r, n, 0, i), p = e.d, o = e.e, u = ys), s = p[r], a = i / 2, u = u || p[r + 1] !== undefined, u = n < 4 ? (s !== undefined || u) && (n === 0 || n === (e.s < 0 ? 3 : 2)) : s > a || s === a && (n === 4 || u || n === 6 && p[r - 1] & 1 || n === (e.s < 0 ? 8 : 7)), p.length = r, u)
          for (;++p[--r] > i - 1; )
            p[r] = 0, r || (++o, p.unshift(1));
        for (l = p.length;!p[l - 1]; --l)
          ;
        for (s = 0, c = "";s < l; s++)
          c += di.charAt(p[s]);
        if (y) {
          if (l > 1)
            if (t == 16 || t == 8) {
              for (s = t == 16 ? 4 : 3, --l;l % s; l++)
                c += "0";
              for (p = Vr(c, i, t), l = p.length;!p[l - 1]; --l)
                ;
              for (s = 1, c = "1.";s < l; s++)
                c += di.charAt(p[s]);
            } else
              c = c.charAt(0) + "." + c.slice(1);
          c = c + (o < 0 ? "p" : "p+") + o;
        } else if (o < 0) {
          for (;++o; )
            c = "0" + c;
          c = "0." + c;
        } else if (++o > l)
          for (o -= l;o--; )
            c += "0";
        else
          o < l && (c = c.slice(0, o) + "." + c.slice(o));
      }
      c = (t == 16 ? "0x" : t == 2 ? "0b" : t == 8 ? "0o" : "") + c;
    }
    return e.s < 0 ? "-" + c : c;
  };
  var fs = function(e, t) {
    if (e.length > t)
      return e.length = t, true;
  };
  var sc = function(e) {
    return new this(e).abs();
  };
  var ac = function(e) {
    return new this(e).acos();
  };
  var lc = function(e) {
    return new this(e).acosh();
  };
  var uc = function(e, t) {
    return new this(e).plus(t);
  };
  var cc = function(e) {
    return new this(e).asin();
  };
  var pc = function(e) {
    return new this(e).asinh();
  };
  var dc = function(e) {
    return new this(e).atan();
  };
  var mc = function(e) {
    return new this(e).atanh();
  };
  var fc = function(e, t) {
    e = new this(e), t = new this(t);
    var r, n = this.precision, i = this.rounding, o = n + 4;
    return !e.s || !t.s ? r = new this(NaN) : !e.d && !t.d ? (r = fe(this, o, 1).times(t.s > 0 ? 0.25 : 0.75), r.s = e.s) : !t.d || e.isZero() ? (r = t.s < 0 ? fe(this, n, i) : new this(0), r.s = e.s) : !e.d || t.isZero() ? (r = fe(this, o, 1).times(0.5), r.s = e.s) : t.s < 0 ? (this.precision = o, this.rounding = 1, r = this.atan(O(e, t, o, 1)), t = fe(this, o, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(O(e, t, o, 1)), r;
  };
  var gc = function(e) {
    return new this(e).cbrt();
  };
  var yc = function(e) {
    return h(e = new this(e), e.e + 1, 2);
  };
  var hc = function(e, t, r) {
    return new this(e).clamp(t, r);
  };
  var xc = function(e) {
    if (!e || typeof e != "object")
      throw Error(Kr + "Object expected");
    var t, r, n, i = e.defaults === true, o = ["precision", 1, Le, "rounding", 0, 8, "toExpNeg", -ft, 0, "toExpPos", 0, ft, "maxE", 0, ft, "minE", -ft, 0, "modulo", 0, 9];
    for (t = 0;t < o.length; t += 3)
      if (r = o[t], i && (this[r] = mi[r]), (n = e[r]) !== undefined)
        if (ee(n) === n && n >= o[t + 1] && n <= o[t + 2])
          this[r] = n;
        else
          throw Error(Ne + r + ": " + n);
    if (r = "crypto", i && (this[r] = mi[r]), (n = e[r]) !== undefined)
      if (n === true || n === false || n === 0 || n === 1)
        if (n)
          if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
            this[r] = true;
          else
            throw Error(xs);
        else
          this[r] = false;
      else
        throw Error(Ne + r + ": " + n);
    return this;
  };
  var bc = function(e) {
    return new this(e).cos();
  };
  var Ec = function(e) {
    return new this(e).cosh();
  };
  var As = function(e) {
    var t, r, n;
    function i(o) {
      var s, a, l, u = this;
      if (!(u instanceof i))
        return new i(o);
      if (u.constructor = i, gs(o)) {
        u.s = o.s, w ? !o.d || o.e > i.maxE ? (u.e = NaN, u.d = null) : o.e < i.minE ? (u.e = 0, u.d = [0]) : (u.e = o.e, u.d = o.d.slice()) : (u.e = o.e, u.d = o.d ? o.d.slice() : o.d);
        return;
      }
      if (l = typeof o, l === "number") {
        if (o === 0) {
          u.s = 1 / o < 0 ? -1 : 1, u.e = 0, u.d = [0];
          return;
        }
        if (o < 0 ? (o = -o, u.s = -1) : u.s = 1, o === ~~o && o < 1e7) {
          for (s = 0, a = o;a >= 10; a /= 10)
            s++;
          w ? s > i.maxE ? (u.e = NaN, u.d = null) : s < i.minE ? (u.e = 0, u.d = [0]) : (u.e = s, u.d = [o]) : (u.e = s, u.d = [o]);
          return;
        } else if (o * 0 !== 0) {
          o || (u.s = NaN), u.e = NaN, u.d = null;
          return;
        }
        return yi(u, o.toString());
      } else if (l !== "string")
        throw Error(Ne + o);
      return (a = o.charCodeAt(0)) === 45 ? (o = o.slice(1), u.s = -1) : (a === 43 && (o = o.slice(1)), u.s = 1), Es.test(o) ? yi(u, o) : ic(u, o);
    }
    if (i.prototype = m, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.EUCLID = 9, i.config = i.set = xc, i.clone = As, i.isDecimal = gs, i.abs = sc, i.acos = ac, i.acosh = lc, i.add = uc, i.asin = cc, i.asinh = pc, i.atan = dc, i.atanh = mc, i.atan2 = fc, i.cbrt = gc, i.ceil = yc, i.clamp = hc, i.cos = bc, i.cosh = Ec, i.div = wc, i.exp = Pc, i.floor = vc, i.hypot = Tc, i.ln = Cc, i.log = Ac, i.log10 = Mc, i.log2 = Rc, i.max = Sc, i.min = Ic, i.mod = Fc, i.mul = kc, i.pow = Oc, i.random = Dc, i.round = _c, i.sign = Nc, i.sin = Lc, i.sinh = $c, i.sqrt = qc, i.sub = Vc, i.sum = jc, i.tan = Bc, i.tanh = Uc, i.trunc = Kc, e === undefined && (e = {}), e && e.defaults !== true)
      for (n = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], t = 0;t < n.length; )
        e.hasOwnProperty(r = n[t++]) || (e[r] = this[r]);
    return i.config(e), i;
  };
  var wc = function(e, t) {
    return new this(e).div(t);
  };
  var Pc = function(e) {
    return new this(e).exp();
  };
  var vc = function(e) {
    return h(e = new this(e), e.e + 1, 3);
  };
  var Tc = function() {
    var e, t, r = new this(0);
    for (w = false, e = 0;e < arguments.length; )
      if (t = new this(arguments[e++]), t.d)
        r.d && (r = r.plus(t.times(t)));
      else {
        if (t.s)
          return w = true, new this(1 / 0);
        r = t;
      }
    return w = true, r.sqrt();
  };
  var gs = function(e) {
    return e instanceof We || e && e.toStringTag === bs || false;
  };
  var Cc = function(e) {
    return new this(e).ln();
  };
  var Ac = function(e, t) {
    return new this(e).log(t);
  };
  var Rc = function(e) {
    return new this(e).log(2);
  };
  var Mc = function(e) {
    return new this(e).log(10);
  };
  var Sc = function() {
    return vs(this, arguments, "lt");
  };
  var Ic = function() {
    return vs(this, arguments, "gt");
  };
  var Fc = function(e, t) {
    return new this(e).mod(t);
  };
  var kc = function(e, t) {
    return new this(e).mul(t);
  };
  var Oc = function(e, t) {
    return new this(e).pow(t);
  };
  var Dc = function(e) {
    var t, r, n, i, o = 0, s = new this(1), a = [];
    if (e === undefined ? e = this.precision : se(e, 1, Le), n = Math.ceil(e / b), this.crypto)
      if (crypto.getRandomValues)
        for (t = crypto.getRandomValues(new Uint32Array(n));o < n; )
          i = t[o], i >= 4290000000 ? t[o] = crypto.getRandomValues(new Uint32Array(1))[0] : a[o++] = i % 1e7;
      else if (crypto.randomBytes) {
        for (t = crypto.randomBytes(n *= 4);o < n; )
          i = t[o] + (t[o + 1] << 8) + (t[o + 2] << 16) + ((t[o + 3] & 127) << 24), i >= 2140000000 ? crypto.randomBytes(4).copy(t, o) : (a.push(i % 1e7), o += 4);
        o = n / 4;
      } else
        throw Error(xs);
    else
      for (;o < n; )
        a[o++] = Math.random() * 1e7 | 0;
    for (n = a[--o], e %= b, n && e && (i = j(10, b - e), a[o] = (n / i | 0) * i);a[o] === 0; o--)
      a.pop();
    if (o < 0)
      r = 0, a = [0];
    else {
      for (r = -1;a[0] === 0; r -= b)
        a.shift();
      for (n = 1, i = a[0];i >= 10; i /= 10)
        n++;
      n < b && (r -= b - n);
    }
    return s.e = r, s.d = a, s;
  };
  var _c = function(e) {
    return h(e = new this(e), e.e + 1, this.rounding);
  };
  var Nc = function(e) {
    return e = new this(e), e.d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN;
  };
  var Lc = function(e) {
    return new this(e).sin();
  };
  var $c = function(e) {
    return new this(e).sinh();
  };
  var qc = function(e) {
    return new this(e).sqrt();
  };
  var Vc = function(e, t) {
    return new this(e).sub(t);
  };
  var jc = function() {
    var e = 0, t = arguments, r = new this(t[e]);
    for (w = false;r.s && ++e < t.length; )
      r = r.plus(t[e]);
    return w = true, h(r, this.precision, this.rounding);
  };
  var Bc = function(e) {
    return new this(e).tan();
  };
  var Uc = function(e) {
    return new this(e).tanh();
  };
  var Kc = function(e) {
    return h(e = new this(e), e.e + 1, 1);
  };
  var yt = function(e) {
    return We.isDecimal(e) ? true : e !== null && typeof e == "object" && typeof e.s == "number" && typeof e.e == "number" && typeof e.toFixed == "function" && Array.isArray(e.d);
  };
  var ht = function(e) {
    return e instanceof Jt;
  };
  var Yr = function(e) {
    return new xi(Ss(e));
  };
  var Ss = function(e) {
    let t = new Q;
    for (let [r, n] of Object.entries(e)) {
      let i = new zr(r, Is(n));
      t.addField(i);
    }
    return t;
  };
  var Is = function(e) {
    if (typeof e == "string")
      return new J(JSON.stringify(e));
    if (typeof e == "number" || typeof e == "boolean")
      return new J(String(e));
    if (typeof e == "bigint")
      return new J(`${e}n`);
    if (e === null)
      return new J("null");
    if (e === undefined)
      return new J("undefined");
    if (yt(e))
      return new J(`new Prisma.Decimal("${e.toFixed()}")`);
    if (e instanceof Uint8Array)
      return Buffer.isBuffer(e) ? new J(`Buffer.alloc(${e.byteLength})`) : new J(`new Uint8Array(${e.byteLength})`);
    if (e instanceof Date) {
      let t = qr(e) ? e.toISOString() : "Invalid Date";
      return new J(`new Date("${t}")`);
    }
    return e instanceof Ae ? new J(`Prisma.${e._getName()}`) : ht(e) ? new J(`prisma.${to(e.modelName)}.\$fields.${e.name}`) : Array.isArray(e) ? Jc(e) : typeof e == "object" ? Ss(e) : new J(Object.prototype.toString.call(e));
  };
  var Jc = function(e) {
    let t = new bt;
    for (let r of e)
      t.addItem(Is(r));
    return t;
  };
  var Fs = function(e) {
    if (e === undefined)
      return "";
    let t = Yr(e);
    return new dt(0, { colors: Wr }).write(t).toString();
  };
  var ks = function(e) {
    var t = e.split(`
`);
    return t.reduce(function(r, n) {
      var i = Wc(n) || Yc(n) || ep(n) || ip(n) || rp(n);
      return i && r.push(i), r;
    }, []);
  };
  var Wc = function(e) {
    var t = Gc.exec(e);
    if (!t)
      return null;
    var r = t[2] && t[2].indexOf("native") === 0, n = t[2] && t[2].indexOf("eval") === 0, i = Hc.exec(t[2]);
    return n && i != null && (t[2] = i[1], t[3] = i[2], t[4] = i[3]), { file: r ? null : t[2], methodName: t[1] || Gt, arguments: r ? [t[2]] : [], lineNumber: t[3] ? +t[3] : null, column: t[4] ? +t[4] : null };
  };
  var Yc = function(e) {
    var t = zc.exec(e);
    return t ? { file: t[2], methodName: t[1] || Gt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var ep = function(e) {
    var t = Zc.exec(e);
    if (!t)
      return null;
    var r = t[3] && t[3].indexOf(" > eval") > -1, n = Xc.exec(t[3]);
    return r && n != null && (t[3] = n[1], t[4] = n[2], t[5] = null), { file: t[3], methodName: t[1] || Gt, arguments: t[2] ? t[2].split(",") : [], lineNumber: t[4] ? +t[4] : null, column: t[5] ? +t[5] : null };
  };
  var rp = function(e) {
    var t = tp.exec(e);
    return t ? { file: t[3], methodName: t[1] || Gt, arguments: [], lineNumber: +t[4], column: t[5] ? +t[5] : null } : null;
  };
  var ip = function(e) {
    var t = np.exec(e);
    return t ? { file: t[2], methodName: t[1] || Gt, arguments: [], lineNumber: +t[3], column: t[4] ? +t[4] : null } : null;
  };
  var qe = function(e) {
    return e === "minimal" ? new bi : new Ei;
  };
  var Et = function(e = {}) {
    let t = sp(e);
    return Object.entries(t).reduce((n, [i, o]) => (Os[i] !== undefined ? n.select[i] = { select: o } : n[i] = o, n), { select: {} });
  };
  var sp = function(e = {}) {
    return typeof e._count == "boolean" ? { ...e, _count: { _all: e._count } } : e;
  };
  var Zr = function(e = {}) {
    return (t) => (typeof e._count == "boolean" && (t._count = t._count._all), t);
  };
  var Ds = function(e, t) {
    let r = Zr(e);
    return t({ action: "aggregate", unpacker: r, argsMapper: Et })(e);
  };
  var ap = function(e = {}) {
    let { select: t, ...r } = e;
    return typeof t == "object" ? Et({ ...r, _count: t }) : Et({ ...r, _count: { _all: true } });
  };
  var lp = function(e = {}) {
    return typeof e.select == "object" ? (t) => Zr(e)(t)._count : (t) => Zr(e)(t)._count._all;
  };
  var _s = function(e, t) {
    return t({ action: "count", unpacker: lp(e), argsMapper: ap })(e);
  };
  var up = function(e = {}) {
    let t = Et(e);
    if (Array.isArray(t.by))
      for (let r of t.by)
        typeof r == "string" && (t.select[r] = true);
    else
      typeof t.by == "string" && (t.select[t.by] = true);
    return t;
  };
  var cp = function(e = {}) {
    return (t) => (typeof e?._count == "boolean" && t.forEach((r) => {
      r._count = r._count._all;
    }), t);
  };
  var Ns = function(e, t) {
    return t({ action: "groupBy", unpacker: cp(e), argsMapper: up })(e);
  };
  var Ls = function(e, t, r) {
    if (t === "aggregate")
      return (n) => Ds(n, r);
    if (t === "count")
      return (n) => _s(n, r);
    if (t === "groupBy")
      return (n) => Ns(n, r);
  };
  var $s = function(e, t) {
    let r = t.fields.filter((i) => !i.relationName), n = oi(r, (i) => i.name);
    return new Proxy({}, { get(i, o) {
      if ((o in i) || typeof o == "symbol")
        return i[o];
      let s = n[o];
      if (s)
        return new Jt(e, o, s.type, s.isList, s.kind === "enum");
    }, ...Nr(Object.keys(n)) });
  };
  var pp = function(e, t) {
    return e === undefined || t === undefined ? [] : [...t, "select", e];
  };
  var dp = function(e, t, r) {
    return t === undefined ? e ?? {} : Vs(t, r, e || true);
  };
  var Pi = function(e, t, r, n, i, o) {
    let a = e._runtimeDataModel.models[t].fields.reduce((l, u) => ({ ...l, [u.name]: u }), {});
    return (l) => {
      let u = qe(e._errorFormat), c = pp(n, i), p = dp(l, o, c), d = r({ dataPath: c, callsite: u })(p), f = mp(e, t);
      return new Proxy(d, { get(y, g) {
        if (!f.includes(g))
          return y[g];
        let T = [a[g].type, r, g], C = [c, p];
        return Pi(e, ...T, ...C);
      }, ...Nr([...f, ...Object.getOwnPropertyNames(d)]) });
    };
  };
  var mp = function(e, t) {
    return e._runtimeDataModel.models[t].fields.filter((r) => r.kind === "object").map((r) => r.name);
  };
  var ye = function(e, t, r, n, i) {
    this.type = e, this.content = t, this.alias = r, this.length = (n || "").length | 0, this.greedy = !!i;
  };
  var yp = function(e) {
    return js[e] || fp;
  };
  var Bs = function(e) {
    return hp(e, v.languages.javascript);
  };
  var hp = function(e, t) {
    return v.tokenize(e, t).map((n) => ye.stringify(n)).join("");
  };
  var Ks = function(e) {
    return (0, Us.default)(e);
  };
  var Ep = function({ callsite: e, message: t, originalMethod: r, isPanic: n, callArguments: i }, o) {
    let s = { functionName: `prisma.${r}()`, message: t, isPanic: n ?? false, callArguments: i };
    if (!e || typeof window < "u" || false)
      return s;
    let a = e.getLocation();
    if (!a || !a.lineNumber || !a.columnNumber)
      return s;
    let l = Math.max(1, a.lineNumber - 3), u = en.read(a.fileName)?.slice(l, a.lineNumber), c = u?.lineAt(a.lineNumber);
    if (u && c) {
      let p = Pp(c), d = wp(c);
      if (!d)
        return s;
      s.functionName = `${d.code})`, s.location = a, n || (u = u.mapLineAt(a.lineNumber, (y) => y.slice(0, d.openingBraceIndex))), u = o.highlightSource(u);
      let f = String(u.lastLineNumber).length;
      if (s.contextLines = u.mapLines((y, g) => o.gray(String(g).padStart(f)) + " " + y).mapLines((y) => o.dim(y)).prependSymbolAt(a.lineNumber, o.bold(o.red("\u2192"))), i) {
        let y = p + f + 1;
        y += 2, s.callArguments = (0, Js.default)(i, y).slice(y);
      }
    }
    return s;
  };
  var wp = function(e) {
    let t = Object.keys(pe.ModelAction).join("|"), n = new RegExp(String.raw`\.(${t})\(`).exec(e);
    if (n) {
      let i = n.index + n[0].length, o = e.lastIndexOf(" ", n.index) + 1;
      return { code: e.slice(o, i), openingBraceIndex: i };
    }
    return null;
  };
  var Pp = function(e) {
    let t = 0;
    for (let r = 0;r < e.length; r++) {
      if (e.charAt(r) !== " ")
        return t;
      t++;
    }
    return t;
  };
  var vp = function({ functionName: e, location: t, message: r, isPanic: n, contextLines: i, callArguments: o }, s) {
    let a = [""], l = t ? " in" : ":";
    if (n ? (a.push(s.red(`Oops, an unknown error occurred! This is ${s.bold("on us")}, you did nothing wrong.`)), a.push(s.red(`It occurred in the ${s.bold(`\`${e}\``)} invocation${l}`))) : a.push(s.red(`Invalid ${s.bold(`\`${e}\``)} invocation${l}`)), t && a.push(s.underline(Tp(t))), i) {
      a.push("");
      let u = [i.toString()];
      o && (u.push(o), u.push(s.dim(")"))), a.push(u.join("")), o && a.push("");
    } else
      a.push(""), o && a.push(o), a.push("");
    return a.push(r), a.join(`
`);
  };
  var Tp = function(e) {
    let t = [e.fileName];
    return e.lineNumber && t.push(String(e.lineNumber)), e.columnNumber && t.push(String(e.columnNumber)), t.join(":");
  };
  var wt = function(e) {
    let t = e.showColors ? xp : bp, r = Ep(e, t);
    return vp(r, t);
  };
  var Gs = function(e, t, r, n) {
    return e === pe.ModelAction.findFirstOrThrow || e === pe.ModelAction.findUniqueOrThrow ? Cp(t, r, n) : n;
  };
  var Cp = function(e, t, r) {
    return async (n) => {
      if ("rejectOnNotFound" in n.args) {
        let o = wt({ originalMethod: n.clientMethod, callsite: n.callsite, message: "'rejectOnNotFound' option is not supported" });
        throw new X(o, { clientVersion: t });
      }
      return await r(n).catch((o) => {
        throw o instanceof U && o.code === "P2025" ? new Ce(`No ${e} found`, t) : o;
      });
    };
  };
  var ve = function(e) {
    return e.replace(/^./, (t) => t.toLowerCase());
  };
  var vi = function(e, t) {
    let r = e._extensions.getAllModelExtensions(t) ?? {}, n = [Mp(e, t), Ip(e, t), qt(r), re("name", () => t), re("$name", () => t), re("$parent", () => e._appliedParent)];
    return be({}, n);
  };
  var Mp = function(e, t) {
    let r = ve(t), n = Object.keys(pe.ModelAction).concat("count");
    return { getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = i, s = (l) => e._request(l);
      s = Gs(o, t, e._clientVersion, s);
      let a = (l) => (u) => {
        let c = qe(e._errorFormat);
        return e._createPrismaPromise((p) => {
          let d = { args: u, dataPath: [], action: o, model: t, clientMethod: `${r}.${i}`, jsModelName: r, transaction: p, callsite: c };
          return s({ ...d, ...l });
        });
      };
      return Ap.includes(o) ? Pi(e, t, a) : Sp(i) ? Ls(e, i, a) : a({});
    } };
  };
  var Sp = function(e) {
    return Rp.includes(e);
  };
  var Ip = function(e, t) {
    return He(re("fields", () => {
      let r = e._runtimeDataModel.models[t];
      return $s(t, r);
    }));
  };
  var Hs = function(e) {
    return e.replace(/^./, (t) => t.toUpperCase());
  };
  var Ht = function(e) {
    let t = [Fp(e), re(Ti, () => e), re("$parent", () => e._appliedParent)], r = e._extensions.getAllClientExtensions();
    return r && t.push(qt(r)), be(e, t);
  };
  var Fp = function(e) {
    let t = Object.keys(e._runtimeDataModel.models), r = t.map(ve), n = [...new Set(t.concat(r))];
    return He({ getKeys() {
      return n;
    }, getPropertyValue(i) {
      let o = Hs(i);
      if (e._runtimeDataModel.models[o] !== undefined)
        return vi(e, o);
      if (e._runtimeDataModel.models[i] !== undefined)
        return vi(e, i);
    }, getPropertyDescriptor(i) {
      if (!r.includes(i))
        return { enumerable: false };
    } });
  };
  var tn = function(e) {
    return e[Ti] ? e[Ti] : e;
  };
  var Ws = function(e) {
    if (typeof e == "function")
      return e(this);
    let t = tn(this), r = Object.create(t, { _extensions: { value: this._extensions.append(e) }, _appliedParent: { value: this, configurable: true }, $use: { value: undefined }, $on: { value: undefined } });
    return Ht(r);
  };
  var zs = function({ result: e, modelName: t, select: r, extensions: n }) {
    let i = n.getAllComputedFields(t);
    if (!i)
      return e;
    let o = [], s = [];
    for (let a of Object.values(i)) {
      if (r) {
        if (!r[a.name])
          continue;
        let l = a.needs.filter((u) => !r[u]);
        l.length > 0 && s.push(Vt(l));
      }
      kp(e, a.needs) && o.push(Op(a, be(e, o)));
    }
    return o.length > 0 || s.length > 0 ? be(e, [...o, ...s]) : e;
  };
  var kp = function(e, t) {
    return t.every((r) => ii(e, r));
  };
  var Op = function(e, t) {
    return He(re(e.name, () => e.compute(t)));
  };
  var rn = function({ visitor: e, result: t, args: r, runtimeDataModel: n, modelName: i }) {
    if (Array.isArray(t)) {
      for (let s = 0;s < t.length; s++)
        t[s] = rn({ result: t[s], args: r, modelName: i, runtimeDataModel: n, visitor: e });
      return t;
    }
    let o = e(t, i, r) ?? t;
    return r.include && Ys({ includeOrSelect: r.include, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), r.select && Ys({ includeOrSelect: r.select, result: o, parentModelName: i, runtimeDataModel: n, visitor: e }), o;
  };
  var Ys = function({ includeOrSelect: e, result: t, parentModelName: r, runtimeDataModel: n, visitor: i }) {
    for (let [o, s] of Object.entries(e)) {
      if (!s || t[o] == null)
        continue;
      let l = n.models[r].fields.find((c) => c.name === o);
      if (!l || l.kind !== "object" || !l.relationName)
        continue;
      let u = typeof s == "object" ? s : {};
      t[o] = rn({ visitor: i, result: t[o], args: u, modelName: l.type, runtimeDataModel: n });
    }
  };
  var Zs = function({ result: e, modelName: t, args: r, extensions: n, runtimeDataModel: i }) {
    return n.isEmpty() || e == null || typeof e != "object" || !i.models[t] ? e : rn({ result: e, args: r ?? {}, modelName: t, runtimeDataModel: i, visitor: (s, a, l) => zs({ result: s, modelName: ve(a), select: l.select, extensions: n }) });
  };
  var Xs = function(e) {
    if (e instanceof oe)
      return Dp(e);
    if (Array.isArray(e)) {
      let r = [e[0]];
      for (let n = 1;n < e.length; n++)
        r[n] = Wt(e[n]);
      return r;
    }
    let t = {};
    for (let r in e)
      t[r] = Wt(e[r]);
    return t;
  };
  var Dp = function(e) {
    return new oe(e.strings, e.values);
  };
  var Wt = function(e) {
    if (typeof e != "object" || e == null || e instanceof Ae || ht(e))
      return e;
    if (yt(e))
      return new we(e.toFixed());
    if (mt(e))
      return new Date(+e);
    if (ArrayBuffer.isView(e))
      return e.slice(0);
    if (Array.isArray(e)) {
      let t = e.length, r;
      for (r = Array(t);t--; )
        r[t] = Wt(e[t]);
      return r;
    }
    if (typeof e == "object") {
      let t = {};
      for (let r in e)
        r === "__proto__" ? Object.defineProperty(t, r, { value: Wt(e[r]), configurable: true, enumerable: true, writable: true }) : t[r] = Wt(e[r]);
      return t;
    }
    Ge(e, "Unknown value");
  };
  var ta = function(e, t, r, n = 0) {
    return e._createPrismaPromise((i) => {
      let o = t.customDataProxyFetch;
      return ("transaction" in t) && i !== undefined && (t.transaction?.kind === "batch" && t.transaction.lock.then(), t.transaction = i), n === r.length ? e._executeRequest(t) : r[n]({ model: t.model, operation: t.model ? t.action : t.clientMethod, args: Xs(t.args ?? {}), __internalParams: t, query: (s, a = t) => {
        let l = a.customDataProxyFetch;
        return a.customDataProxyFetch = oa(o, l), a.args = s, ta(e, a, r, n + 1);
      } });
    });
  };
  var ra = function(e, t) {
    let { jsModelName: r, action: n, clientMethod: i } = t, o = r ? n : i;
    if (e._extensions.isEmpty())
      return e._executeRequest(t);
    let s = e._extensions.getAllQueryCallbacks(r ?? "$none", o);
    return ta(e, t, s);
  };
  var na = function(e) {
    return (t) => {
      let r = { requests: t }, n = t[0].extensions.getAllBatchQueryCallbacks();
      return n.length ? ia(r, n, 0, e) : e(r);
    };
  };
  var ia = function(e, t, r, n) {
    if (r === t.length)
      return n(e);
    let i = e.customDataProxyFetch, o = e.requests[0].transaction;
    return t[r]({ args: { queries: e.requests.map((s) => ({ model: s.modelName, operation: s.action, args: s.args })), transaction: o ? { isolationLevel: o.kind === "batch" ? o.isolationLevel : undefined } : undefined }, __internalParams: e, query(s, a = e) {
      let l = a.customDataProxyFetch;
      return a.customDataProxyFetch = oa(i, l), ia(a, t, r + 1, n);
    } });
  };
  var oa = function(e = ea, t = ea) {
    return (r) => e(t(r));
  };
  var aa = function(e, t, r) {
    let n = ve(r);
    return !t.result || !(t.result.$allModels || t.result[n]) ? e : _p({ ...e, ...sa(t.name, e, t.result.$allModels), ...sa(t.name, e, t.result[n]) });
  };
  var _p = function(e) {
    let t = new xe, r = (n, i) => t.getOrCreate(n, () => i.has(n) ? [n] : (i.add(n), e[n] ? e[n].needs.flatMap((o) => r(o, i)) : [n]));
    return ct(e, (n) => ({ ...n, needs: r(n.name, new Set) }));
  };
  var sa = function(e, t, r) {
    return r ? ct(r, ({ needs: n, compute: i }, o) => ({ name: o, needs: n ? Object.keys(n).filter((s) => n[s]) : [], compute: Np(t, o, i) })) : {};
  };
  var Np = function(e, t, r) {
    let n = e?.[t]?.compute;
    return n ? (i) => r({ ...i, [t]: n(i) }) : r;
  };
  var la = function(e, t) {
    if (!t)
      return e;
    let r = { ...e };
    for (let n of Object.values(t))
      if (e[n.name])
        for (let i of n.needs)
          r[i] = true;
    return r;
  };
  var pa = function({ postinstall: e, ciName: t, clientVersion: r }) {
    if (ua("checkPlatformCaching:postinstall", e), ua("checkPlatformCaching:ciName", t), e === true && t && (t in ca)) {
      let n = `Prisma has detected that this project was built on ${t}, which caches dependencies. This leads to an outdated Prisma Client because Prisma's auto-generation isn't triggered. To fix this, make sure to run the \`prisma generate\` command during the build process.

Learn how: https://pris.ly/d/${ca[t]}-build`;
      throw console.error(n), new k(n, r);
    }
  };
  var da = function(e, t) {
    return e ? e.datasources ? e.datasources : e.datasourceUrl ? { [t[0]]: { url: e.datasourceUrl } } : {} : {};
  };
  var zt = function({ error: e, user_facing_error: t }, r) {
    return t.error_code ? new U(t.message, { code: t.error_code, clientVersion: r, meta: t.meta, batchRequestIdx: t.batch_request_idx }) : new K(e, { clientVersion: r, batchRequestIdx: t.batch_request_idx });
  };
  var sn = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Add "${t}" to \`binaryTargets\` in the "schema.prisma" file and run \`prisma generate\` after saving it:

${Lp(e)}`;
  };
  var Lp = function(e) {
    let { generator: t, generatorBinaryTargets: r, runtimeBinaryTarget: n } = e, i = { fromEnvVar: null, value: n }, o = [...r, i];
    return ti({ ...t, binaryTargets: o });
  };
  var Ve = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `Prisma Client could not locate the Query Engine for runtime "${t}".`;
  };
  var je = function(e) {
    let { searchedLocations: t } = e;
    return `The following locations have been searched:
${[...new Set(t)].map((i) => `  ${i}`).join(`
`)}`;
  };
  var ma = function(e) {
    let { runtimeBinaryTarget: t } = e;
    return `${Ve(e)}

This happened because \`binaryTargets\` have been pinned, but the actual deployment also required "${t}".
${sn(e)}

${je(e)}`;
  };
  var an = function(e) {
    return `We would appreciate if you could take the time to share some information with us.
Please help us by answering a few questions: https://pris.ly/${e}`;
  };
  var fa = function(e) {
    let { queryEngineName: t } = e;
    return `${Ve(e)}

This is likely caused by a bundler that has not copied "${t}" next to the resulting bundle.
Ensure that "${t}" has been copied next to the bundle or in "${e.expectedLocation}".

${an("engine-not-found-bundler-investigation")}

${je(e)}`;
  };
  var ga = function(e) {
    let { runtimeBinaryTarget: t, generatorBinaryTargets: r } = e, n = r.find((i) => i.native);
    return `${Ve(e)}

This happened because Prisma Client was generated for "${n?.value ?? "unknown"}", but the actual deployment required "${t}".
${sn(e)}

${je(e)}`;
  };
  var ya = function(e) {
    let { queryEngineName: t } = e;
    return `${Ve(e)}

This is likely caused by tooling that has not copied "${t}" to the deployment folder.
Ensure that you ran \`prisma generate\` and that "${t}" has been copied to "${e.expectedLocation}".

${an("engine-not-found-tooling-investigation")}

${je(e)}`;
  };
  async function xa(e, t) {
    let r = { binary: process.env.PRISMA_QUERY_ENGINE_BINARY, library: process.env.PRISMA_QUERY_ENGINE_LIBRARY }[e] ?? t.prismaPath;
    if (r !== undefined)
      return r;
    let { enginePath: n, searchedLocations: i } = await Vp(e, t);
    if ($p("enginePath", n), n !== undefined && e === "binary" && zn(n), n !== undefined)
      return t.prismaPath = n;
    let o = await lt(), s = t.generator?.binaryTargets ?? [], a = s.some((d) => d.native), l = !s.some((d) => d.value === o), u = __filename.match(qp()) === null, c = { searchedLocations: i, generatorBinaryTargets: s, generator: t.generator, runtimeBinaryTarget: o, queryEngineName: ba(e, o), expectedLocation: Yt.default.relative(process.cwd(), t.dirname) }, p;
    throw a && l ? p = ga(c) : l ? p = ma(c) : u ? p = fa(c) : p = ya(c), new k(p, t.clientVersion);
  }
  async function Vp(engineType, config) {
    let binaryTarget = await lt(), searchedLocations = [], dirname = (0, eval)("__dirname"), searchLocations = [config.dirname, Yt.default.resolve(dirname, ".."), config.generator?.output?.value ?? dirname, Yt.default.resolve(dirname, "../../../.prisma/client"), "/tmp/prisma-engines", config.cwd];
    __filename.includes("resolveEnginePath") && searchLocations.push(zo());
    for (let e of searchLocations) {
      let t = ba(engineType, binaryTarget), r = Yt.default.join(e, t);
      if (searchedLocations.push(e), ha.default.existsSync(r))
        return { enginePath: r, searchedLocations };
    }
    return { enginePath: undefined, searchedLocations };
  }
  var ba = function(e, t) {
    return e === "library" ? Nn(t, "fs") : `query-engine-${t}${t === "windows" ? ".exe" : ""}`;
  };
  var ln = function(e, t) {
    return { batch: e, transaction: t?.kind === "batch" ? { isolationLevel: t.options.isolationLevel } : undefined };
  };
  var Ea = function(e) {
    return e ? e.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t) => `${t[0]}5`) : "";
  };
  var wa = function(e) {
    return e.split(`
`).map((t) => t.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
  };
  var va = function({ title: e, user: t = "prisma", repo: r = "prisma", template: n = "bug_report.md", body: i }) {
    return (0, Pa.default)({ user: t, repo: r, template: n, title: e, body: i });
  };
  var Ta = function({ version: e, platform: t, title: r, description: n, engineVersion: i, database: o, query: s }) {
    let a = mo(6000 - (s?.length ?? 0)), l = wa((0, Ci.default)(a)), u = n ? `# Description
\`\`\`
${n}
\`\`\`` : "", c = (0, Ci.default)(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${process.version?.padEnd(19)}| 
| OS              | ${t?.padEnd(19)}|
| Prisma Client   | ${e?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o?.padEnd(19)}|

${u}

## Logs
\`\`\`
${l}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s ? Ea(s) : ""}
\`\`\`
`), p = va({ title: r, body: c });
    return `${r}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${te(p)}

If you want the Prisma team to look into it, please open the link above \uD83D\uDE4F
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
  };
  var un = function({ inlineDatasources: e, overrideDatasources: t, env: r, clientVersion: n }) {
    let i, o = Object.keys(e)[0], s = e[o]?.url, a = t[o]?.url;
    if (o === undefined ? i = undefined : a ? i = a : s?.value ? i = s.value : s?.fromEnvVar && (i = r[s.fromEnvVar]), s?.fromEnvVar !== undefined && i === undefined)
      throw new k(`error: Environment variable not found: ${s.fromEnvVar}.`, n);
    if (i === undefined)
      throw new k("error: Missing URL environment variable, value, or override.", n);
    return i;
  };
  var M = function(e, t) {
    return { ...e, isRetryable: t };
  };
  async function Up(e) {
    let t;
    try {
      t = await e.text();
    } catch {
      return { type: "EmptyError" };
    }
    try {
      let r = JSON.parse(t);
      if (typeof r == "string")
        switch (r) {
          case "InternalDataProxyError":
            return { type: "DataProxyError", body: r };
          default:
            return { type: "UnknownTextError", body: r };
        }
      if (typeof r == "object" && r !== null) {
        if (("is_panic" in r) && ("message" in r) && ("error_code" in r))
          return { type: "QueryEngineError", body: r };
        if (("EngineNotStarted" in r) || ("InteractiveTransactionMisrouted" in r) || ("InvalidRequestError" in r)) {
          let n = Object.values(r)[0].reason;
          return typeof n == "string" && !["SchemaMissing", "EngineVersionNotSupported"].includes(n) ? { type: "UnknownJsonError", body: r } : { type: "DataProxyError", body: r };
        }
      }
      return { type: "UnknownJsonError", body: r };
    } catch {
      return t === "" ? { type: "EmptyError" } : { type: "UnknownTextError", body: t };
    }
  }
  async function lr(e, t) {
    if (e.ok)
      return;
    let r = { clientVersion: t, response: e }, n = await Up(e);
    if (n.type === "QueryEngineError")
      throw new U(n.body.message, { code: n.body.error_code, clientVersion: t });
    if (n.type === "DataProxyError") {
      if (n.body === "InternalDataProxyError")
        throw new Tt(r, "Internal Data Proxy error");
      if ("EngineNotStarted" in n.body) {
        if (n.body.EngineNotStarted.reason === "SchemaMissing")
          return new Ze(r);
        if (n.body.EngineNotStarted.reason === "EngineVersionNotSupported")
          throw new tr(r);
        if ("EngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, logs: o } = n.body.EngineNotStarted.reason.EngineStartupError;
          throw new er(r, i, o);
        }
        if ("KnownEngineStartupError" in n.body.EngineNotStarted.reason) {
          let { msg: i, error_code: o } = n.body.EngineNotStarted.reason.KnownEngineStartupError;
          throw new k(i, t, o);
        }
        if ("HealthcheckTimeout" in n.body.EngineNotStarted.reason) {
          let { logs: i } = n.body.EngineNotStarted.reason.HealthcheckTimeout;
          throw new Xt(r, i);
        }
      }
      if ("InteractiveTransactionMisrouted" in n.body) {
        let i = { IDParseError: "Could not parse interactive transaction ID", NoQueryEngineFoundError: "Could not find Query Engine for the specified host and transaction ID", TransactionStartError: "Could not start interactive transaction" };
        throw new nr(r, i[n.body.InteractiveTransactionMisrouted.reason]);
      }
      if ("InvalidRequestError" in n.body)
        throw new ir(r, n.body.InvalidRequestError.reason);
    }
    if (e.status === 401 || e.status === 403)
      throw new sr(r, Ct(Ii, n));
    if (e.status === 404)
      return new or(r, Ct(Mi, n));
    if (e.status === 429)
      throw new ar(r, Ct(Fi, n));
    if (e.status === 504)
      throw new rr(r, Ct(Ri, n));
    if (e.status >= 500)
      throw new Tt(r, Ct(Si, n));
    if (e.status >= 400)
      throw new Zt(r, Ct(Ai, n));
  }
  var Ct = function(e, t) {
    return t.type === "EmptyError" ? e : `${e}: ${JSON.stringify(t)}`;
  };
  var Ca = function(e) {
    let t = Math.pow(2, e) * 50, r = Math.ceil(Math.random() * t) - Math.ceil(t / 2), n = t + r;
    return new Promise((i) => setTimeout(() => i(n), n));
  };
  var Aa = function(e) {
    if (!!e.generator?.previewFeatures.some((r) => r.toLowerCase().includes("metrics")))
      throw new k("The `metrics` preview feature is not yet available with Accelerate.\nPlease remove `metrics` from the `previewFeatures` in your schema.\n\nMore information about Accelerate: https://pris.ly/d/accelerate", e.clientVersion);
  };
  async function Xe(e, t, r = (n) => n) {
    let n = t.clientVersion;
    try {
      return typeof fetch == "function" ? await r(fetch)(e, t) : await r(ki)(e, t);
    } catch (i) {
      console.log(e);
      let o = i.message ?? "Unknown error";
      throw new ur(o, { clientVersion: n });
    }
  }
  var Qp = function(e) {
    return { ...e.headers, "Content-Type": "application/json" };
  };
  var Jp = function(e) {
    return { method: e.method, headers: Qp(e) };
  };
  var Gp = function(e, t) {
    return { text: () => Promise.resolve(Buffer.concat(e).toString()), json: () => Promise.resolve().then(() => JSON.parse(Buffer.concat(e).toString())), ok: t.statusCode >= 200 && t.statusCode <= 299, status: t.statusCode, url: t.url, headers: new Oi(t.headers) };
  };
  async function ki(e, t = {}) {
    let r = Hp("https"), n = Jp(t), i = [], { origin: o } = new URL(e);
    return new Promise((s, a) => {
      let l = r.request(e, n, (u) => {
        let { statusCode: c, headers: { location: p } } = u;
        c >= 301 && c <= 399 && p && (p.startsWith("http") === false ? s(ki(`${o}${p}`, t)) : s(ki(p, t))), u.on("data", (d) => i.push(d)), u.on("end", () => s(Gp(i, u))), u.on("error", a);
      });
      l.on("error", a), l.end(t.body ?? "");
    });
  }
  async function zp(e, t) {
    let r = Ra["@prisma/engines-version"], n = t.clientVersion ?? "unknown";
    if (process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION)
      return process.env.PRISMA_CLIENT_DATA_PROXY_CLIENT_VERSION;
    if (e.includes("accelerate") && n !== "0.0.0" && n !== "in-memory")
      return n;
    let [i, o] = n?.split("-") ?? [];
    if (o === undefined && Wp.test(i))
      return i;
    if (o !== undefined || n === "0.0.0" || n === "in-memory") {
      if (e.startsWith("localhost") || e.startsWith("127.0.0.1"))
        return "0.0.0";
      let [s] = r.split("-") ?? [], [a, l, u] = s.split("."), c = Yp(`<=${a}.${l}.${u}`), p = await Xe(c, { clientVersion: n });
      if (!p.ok)
        throw new Error(`Failed to fetch stable Prisma version, unpkg.com status ${p.status} ${p.statusText}, response body: ${await p.text() || "<empty body>"}`);
      let d = await p.text();
      Ma("length of body fetched from unpkg.com", d.length);
      let f;
      try {
        f = JSON.parse(d);
      } catch (y) {
        throw console.error("JSON.parse error: body fetched from unpkg.com: ", d), y;
      }
      return f.version;
    }
    throw new Ye("Only `major.minor.patch` versions are supported by Accelerate.", { clientVersion: n });
  }
  async function Sa(e, t) {
    let r = await zp(e, t);
    return Ma("version", r), r;
  }
  var Yp = function(e) {
    return encodeURI(`https://unpkg.com/prisma@${e}/package.json`);
  };
  var Fa = function(e) {
    if (e?.kind === "itx")
      return e.options.id;
  };
  var Zp = function() {
    let e = globalThis;
    return e[Ni] === undefined && (e[Ni] = {}), e[Ni];
  };
  var Xp = function(e) {
    let t = Zp();
    if (t[e] !== undefined)
      return t[e];
    let r = ka.default.toNamespacedPath(e), n = { exports: {} }, i = 0;
    return process.platform !== "win32" && (i = Li.default.constants.dlopen.RTLD_LAZY | Li.default.constants.dlopen.RTLD_DEEPBIND), process.dlopen(n, r, i), t[e] = n.exports, n.exports;
  };
  var ed = function(e) {
    return e.item_type === "query" && ("query" in e);
  };
  var td = function(e) {
    return "level" in e ? e.level === "error" && e.message === "PANIC" : false;
  };
  var Na = function(e, t) {
    let r;
    try {
      r = un({ inlineDatasources: t.inlineDatasources, overrideDatasources: t.overrideDatasources, env: { ...t.env, ...process.env }, clientVersion: t.clientVersion });
    } catch {
    }
    e.noEngine !== true && r?.startsWith("prisma://") && Lt("recommend--no-engine", "In production, we recommend using `prisma generate --no-engine` (See: `prisma generate --help`)");
    let n = Gn(t.generator);
    if (r?.startsWith("prisma://") || e.noEngine)
      return new cr(t);
    if (n === "library")
      return new pr(t);
    throw "binary", new X("Invalid client engine type, please use `library` or `binary`", { clientVersion: t.clientVersion });
  };
  var Va = function(e, t) {
    let r = ja(e), n = rd(r), i = id(n);
    i ? dn(i, t) : t.addErrorMessage(() => "Unknown error");
  };
  var ja = function(e) {
    return e.errors.flatMap((t) => t.kind === "Union" ? ja(t) : [t]);
  };
  var rd = function(e) {
    let t = new Map, r = [];
    for (let n of e) {
      if (n.kind !== "InvalidArgumentType") {
        r.push(n);
        continue;
      }
      let i = `${n.selectionPath.join(".")}:${n.argumentPath.join(".")}`, o = t.get(i);
      o ? t.set(i, { ...n, argument: { ...n.argument, typeNames: nd(o.argument.typeNames, n.argument.typeNames) } }) : t.set(i, n);
    }
    return r.push(...t.values()), r;
  };
  var nd = function(e, t) {
    return [...new Set(e.concat(t))];
  };
  var id = function(e) {
    return si(e, (t, r) => {
      let n = $a(t), i = $a(r);
      return n !== i ? n - i : qa(t) - qa(r);
    });
  };
  var $a = function(e) {
    let t = 0;
    return Array.isArray(e.selectionPath) && (t += e.selectionPath.length), Array.isArray(e.argumentPath) && (t += e.argumentPath.length), t;
  };
  var qa = function(e) {
    switch (e.kind) {
      case "InvalidArgumentValue":
      case "ValueTooLarge":
        return 20;
      case "InvalidArgumentType":
        return 10;
      case "RequiredArgumentMissing":
        return -10;
      default:
        return 0;
    }
  };
  var dn = function(e, t) {
    switch (e.kind) {
      case "IncludeAndSelect":
        od(e, t);
        break;
      case "IncludeOnScalar":
        sd(e, t);
        break;
      case "EmptySelection":
        ad(e, t);
        break;
      case "UnknownSelectionField":
        ld(e, t);
        break;
      case "UnknownArgument":
        ud(e, t);
        break;
      case "UnknownInputField":
        cd(e, t);
        break;
      case "RequiredArgumentMissing":
        pd(e, t);
        break;
      case "InvalidArgumentType":
        dd(e, t);
        break;
      case "InvalidArgumentValue":
        md(e, t);
        break;
      case "ValueTooLarge":
        fd(e, t);
        break;
      case "SomeFieldsMissing":
        gd(e, t);
        break;
      case "TooManyFieldsGiven":
        yd(e, t);
        break;
      case "Union":
        Va(e, t);
        break;
      default:
        throw new Error("not implemented: " + e.kind);
    }
  };
  var od = function(e, t) {
    let r = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    r && r instanceof Q && (r.getField("include")?.markAsError(), r.getField("select")?.markAsError()), t.addErrorMessage((n) => `Please ${n.bold("either")} use ${n.green("`include`")} or ${n.green("`select`")}, but ${n.red("not both")} at the same time.`);
  };
  var sd = function(e, t) {
    let [r, n] = fn(e.selectionPath), i = e.outputType, o = t.arguments.getDeepSelectionParent(r)?.value;
    if (o && (o.getField(n)?.markAsError(), i))
      for (let s of i.fields)
        s.isRelation && o.addSuggestion(new Se(s.name, "true"));
    t.addErrorMessage((s) => {
      let a = `Invalid scalar field ${s.red(`\`${n}\``)} for ${s.bold("include")} statement`;
      return i ? a += ` on model ${s.bold(i.name)}. ${dr(s)}` : a += ".", a += `
Note that ${s.bold("include")} statements only accept relation fields.`, a;
    });
  };
  var ad = function(e, t) {
    let r = e.outputType, n = t.arguments.getDeepSelectionParent(e.selectionPath)?.value, i = n?.isEmpty() ?? false;
    n && (n.removeAllFields(), Qa(n, r)), t.addErrorMessage((o) => i ? `The ${o.red("`select`")} statement for type ${o.bold(r.name)} must not be empty. ${dr(o)}` : `The ${o.red("`select`")} statement for type ${o.bold(r.name)} needs ${o.bold("at least one truthy value")}.`);
  };
  var ld = function(e, t) {
    let [r, n] = fn(e.selectionPath), i = t.arguments.getDeepSelectionParent(r);
    i && (i.value.getField(n)?.markAsError(), Qa(i.value, e.outputType)), t.addErrorMessage((o) => {
      let s = [`Unknown field ${o.red(`\`${n}\``)}`];
      return i && s.push(`for ${o.bold(i.kind)} statement`), s.push(`on model ${o.bold(`\`${e.outputType.name}\``)}.`), s.push(dr(o)), s.join(" ");
    });
  };
  var ud = function(e, t) {
    let r = e.argumentPath[0], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && (n.getField(r)?.markAsError(), hd(n, e.arguments)), t.addErrorMessage((i) => Ua(i, r, e.arguments.map((o) => o.name)));
  };
  var cd = function(e, t) {
    let [r, n] = fn(e.argumentPath), i = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (i instanceof Q) {
      i.getDeepField(e.argumentPath)?.markAsError();
      let o = i.getDeepFieldValue(r);
      o instanceof Q && Ja(o, e.inputType);
    }
    t.addErrorMessage((o) => Ua(o, n, e.inputType.fields.map((s) => s.name)));
  };
  var Ua = function(e, t, r) {
    let n = [`Unknown argument \`${e.red(t)}\`.`], i = bd(t, r);
    return i && n.push(`Did you mean \`${e.green(i)}\`?`), r.length > 0 && n.push(dr(e)), n.join(" ");
  };
  var pd = function(e, t) {
    let r;
    t.addErrorMessage((l) => r?.value instanceof J && r.value.text === "null" ? `Argument \`${l.green(o)}\` must not be ${l.red("null")}.` : `Argument \`${l.green(o)}\` is missing.`);
    let n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (!(n instanceof Q))
      return;
    let [i, o] = fn(e.argumentPath), s = new mn, a = n.getDeepFieldValue(i);
    if (a instanceof Q)
      if (r = a.getField(o), r && a.removeField(o), e.inputTypes.length === 1 && e.inputTypes[0].kind === "object") {
        for (let l of e.inputTypes[0].fields)
          s.addField(l.name, l.typeNames.join(" | "));
        a.addSuggestion(new Se(o, s).makeRequired());
      } else {
        let l = e.inputTypes.map(Ka).join(" | ");
        a.addSuggestion(new Se(o, l).makeRequired());
      }
  };
  var Ka = function(e) {
    return e.kind === "list" ? `${Ka(e.elementType)}[]` : e.name;
  };
  var dd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = gn("or", e.argument.typeNames.map((s) => i.green(s)));
      return `Argument \`${i.bold(r)}\`: Invalid value provided. Expected ${o}, provided ${i.red(e.inferredType)}.`;
    });
  };
  var md = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    n instanceof Q && n.getDeepFieldValue(e.argumentPath)?.markAsError(), t.addErrorMessage((i) => {
      let o = [`Invalid value for argument \`${i.bold(r)}\``];
      if (e.underlyingError && o.push(`: ${e.underlyingError}`), o.push("."), e.argument.typeNames.length > 0) {
        let s = gn("or", e.argument.typeNames.map((a) => i.green(a)));
        o.push(` Expected ${s}.`);
      }
      return o.join("");
    });
  };
  var fd = function(e, t) {
    let r = e.argument.name, n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i;
    if (n instanceof Q) {
      let s = n.getDeepField(e.argumentPath)?.value;
      s?.markAsError(), s instanceof J && (i = s.text);
    }
    t.addErrorMessage((o) => {
      let s = ["Unable to fit value"];
      return i && s.push(o.red(i)), s.push(`into a 64-bit signed integer for field \`${o.bold(r)}\``), s.join(" ");
    });
  };
  var gd = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath);
    if (n instanceof Q) {
      let i = n.getDeepFieldValue(e.argumentPath);
      i instanceof Q && Ja(i, e.inputType);
    }
    t.addErrorMessage((i) => {
      let o = [`Argument \`${i.bold(r)}\` of type ${i.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 ? e.constraints.requiredFields ? o.push(`${i.green("at least one of")} ${gn("or", e.constraints.requiredFields.map((s) => `\`${i.bold(s)}\``))} arguments.`) : o.push(`${i.green("at least one")} argument.`) : o.push(`${i.green(`at least ${e.constraints.minFieldCount}`)} arguments.`), o.push(dr(i)), o.join(" ");
    });
  };
  var yd = function(e, t) {
    let r = e.argumentPath[e.argumentPath.length - 1], n = t.arguments.getDeepSubSelectionValue(e.selectionPath), i = [];
    if (n instanceof Q) {
      let o = n.getDeepFieldValue(e.argumentPath);
      o instanceof Q && (o.markAsError(), i = Object.keys(o.getFields()));
    }
    t.addErrorMessage((o) => {
      let s = [`Argument \`${o.bold(r)}\` of type ${o.bold(e.inputType.name)} needs`];
      return e.constraints.minFieldCount === 1 && e.constraints.maxFieldCount == 1 ? s.push(`${o.green("exactly one")} argument,`) : e.constraints.maxFieldCount == 1 ? s.push(`${o.green("at most one")} argument,`) : s.push(`${o.green(`at most ${e.constraints.maxFieldCount}`)} arguments,`), s.push(`but you provided ${gn("and", i.map((a) => o.red(a)))}. Please choose`), e.constraints.maxFieldCount === 1 ? s.push("one.") : s.push(`${e.constraints.maxFieldCount}.`), s.join(" ");
    });
  };
  var Qa = function(e, t) {
    for (let r of t.fields)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, "true"));
  };
  var hd = function(e, t) {
    for (let r of t)
      e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var Ja = function(e, t) {
    if (t.kind === "object")
      for (let r of t.fields)
        e.hasField(r.name) || e.addSuggestion(new Se(r.name, r.typeNames.join(" | ")));
  };
  var fn = function(e) {
    let t = [...e], r = t.pop();
    if (!r)
      throw new Error("unexpected empty path");
    return [t, r];
  };
  var dr = function({ green: e }) {
    return `Available options are listed in ${e("green")}.`;
  };
  var gn = function(e, t) {
    if (t.length === 1)
      return t[0];
    let r = [...t], n = r.pop();
    return `${r.join(", ")} ${e} ${n}`;
  };
  var bd = function(e, t) {
    let r = 1 / 0, n;
    for (let i of t) {
      let o = (0, Ba.default)(e, i);
      o > xd || o < r && (r = o, n = i);
    }
    return n;
  };
  var yn = function({ args: e, errors: t, errorFormat: r, callsite: n, originalMethod: i, clientVersion: o }) {
    let s = Yr(e);
    for (let p of t)
      dn(p, s);
    let a = r === "pretty" ? Rs : Wr, l = s.renderAllMessages(a), u = new dt(0, { colors: a }).write(s).toString(), c = wt({ message: l, callsite: n, originalMethod: i, showColors: r === "pretty", callArguments: u });
    throw new X(c, { clientVersion: o });
  };
  var Ga = function({ modelName: e, action: t, args: r, runtimeDataModel: n, extensions: i, callsite: o, clientMethod: s, errorFormat: a, clientVersion: l }) {
    let u = new qi({ runtimeDataModel: n, modelName: e, action: t, rootArgs: r, callsite: o, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s, errorFormat: a, clientVersion: l });
    return { modelName: e, action: Ed[t], query: Vi(r, u) };
  };
  var Vi = function({ select: e, include: t, ...r } = {}, n) {
    return { arguments: Wa(r, n), selection: wd(e, t, n) };
  };
  var wd = function(e, t, r) {
    return e && t && r.throwValidationError({ kind: "IncludeAndSelect", selectionPath: r.getSelectionPath() }), e ? Td(e, r) : Pd(r, t);
  };
  var Pd = function(e, t) {
    let r = {};
    return e.model && !e.isRawAction() && (r.$composites = true, r.$scalars = true), t && vd(r, t, e), r;
  };
  var vd = function(e, t, r) {
    for (let [n, i] of Object.entries(t)) {
      let o = r.findField(n);
      o && o?.kind !== "object" && r.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r.getSelectionPath().concat(n), outputType: r.getOutputTypeDescription() }), i === true ? e[n] = true : typeof i == "object" && (e[n] = Vi(i, r.nestSelection(n)));
    }
  };
  var Td = function(e, t) {
    let r = {}, n = t.getComputedFields(), i = la(e, n);
    for (let [o, s] of Object.entries(i)) {
      let a = t.findField(o);
      n?.[o] && !a || (s === true ? r[o] = true : typeof s == "object" && (r[o] = Vi(s, t.nestSelection(o))));
    }
    return r;
  };
  var Ha = function(e, t) {
    if (e === null)
      return null;
    if (typeof e == "string" || typeof e == "number" || typeof e == "boolean")
      return e;
    if (typeof e == "bigint")
      return { $type: "BigInt", value: String(e) };
    if (mt(e)) {
      if (qr(e))
        return { $type: "DateTime", value: e.toISOString() };
      t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
    }
    if (ht(e))
      return { $type: "FieldRef", value: { _ref: e.name, _container: e.modelName } };
    if (Array.isArray(e))
      return Cd(e, t);
    if (ArrayBuffer.isView(e))
      return { $type: "Bytes", value: Buffer.from(e).toString("base64") };
    if (Ad(e))
      return e.values;
    if (yt(e))
      return { $type: "Decimal", value: e.toFixed() };
    if (e instanceof Ae) {
      if (e !== $r.instances[e._getName()])
        throw new Error("Invalid ObjectEnumValue");
      return { $type: "Enum", value: e._getName() };
    }
    if (Rd(e))
      return e.toJSON();
    if (typeof e == "object")
      return Wa(e, t);
    t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t.getSelectionPath(), argumentPath: t.getArgumentPath(), argument: { name: t.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
  };
  var Wa = function(e, t) {
    if (e.$type)
      return { $type: "Json", value: JSON.stringify(e) };
    let r = {};
    for (let n in e) {
      let i = e[n];
      i !== undefined && (r[n] = Ha(i, t.nestArgument(n)));
    }
    return r;
  };
  var Cd = function(e, t) {
    let r = [];
    for (let n = 0;n < e.length; n++) {
      let i = t.nestArgument(String(n)), o = e[n];
      o === undefined && t.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t.getArgumentName()}[${n}]`, typeNames: [] }, underlyingError: "Can not use `undefined` value within array. Use `null` or filter out `undefined` values" }), r.push(Ha(o, i));
    }
    return r;
  };
  var Ad = function(e) {
    return typeof e == "object" && e !== null && e.__prismaRawParameters__ === true;
  };
  var Rd = function(e) {
    return typeof e == "object" && e !== null && typeof e.toJSON == "function";
  };
  var mr = function(e) {
    try {
      return Za(e, "fast");
    } catch {
      return Za(e, "slow");
    }
  };
  var Za = function(e, t) {
    return JSON.stringify(e.map((r) => Md(r, t)));
  };
  var Md = function(e, t) {
    return typeof e == "bigint" ? { prisma__type: "bigint", prisma__value: e.toString() } : mt(e) ? { prisma__type: "date", prisma__value: e.toJSON() } : we.isDecimal(e) ? { prisma__type: "decimal", prisma__value: e.toJSON() } : Buffer.isBuffer(e) ? { prisma__type: "bytes", prisma__value: e.toString("base64") } : Sd(e) || ArrayBuffer.isView(e) ? { prisma__type: "bytes", prisma__value: Buffer.from(e).toString("base64") } : typeof e == "object" && t === "slow" ? el(e) : e;
  };
  var Sd = function(e) {
    return e instanceof ArrayBuffer || e instanceof SharedArrayBuffer ? true : typeof e == "object" && e !== null ? e[Symbol.toStringTag] === "ArrayBuffer" || e[Symbol.toStringTag] === "SharedArrayBuffer" : false;
  };
  var el = function(e) {
    if (typeof e != "object" || e === null)
      return e;
    if (typeof e.toJSON == "function")
      return e.toJSON();
    if (Array.isArray(e))
      return e.map(Xa);
    let t = {};
    for (let r of Object.keys(e))
      t[r] = Xa(e[r]);
    return t;
  };
  var Xa = function(e) {
    return typeof e == "bigint" ? e.toString() : el(e);
  };
  var ji = function(e, t, r, n) {
    if (!(e !== "postgresql" && e !== "cockroachdb") && r.length > 0 && Id.exec(t))
      throw new Error(`Running ALTER using ${n} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
  };
  var Ui = function(e) {
    return function(r) {
      let n, i = (o = e) => {
        try {
          return o === undefined || o?.kind === "itx" ? n ?? (n = il(r(o))) : il(r(o));
        } catch (s) {
          return Promise.reject(s);
        }
      };
      return { then(o, s) {
        return i().then(o, s);
      }, catch(o) {
        return i().catch(o);
      }, finally(o) {
        return i().finally(o);
      }, requestTransaction(o) {
        let s = i(o);
        return s.requestTransaction ? s.requestTransaction(o) : s;
      }, [Symbol.toStringTag]: "PrismaPromise" };
    };
  };
  var il = function(e) {
    return typeof e.then == "function" ? e : Promise.resolve(e);
  };
  var sl = function(e) {
    return e.includes("tracing") ? new Ki : ol;
  };
  var al = function(e, t = () => {
  }) {
    let r, n = new Promise((i) => r = i);
    return { then(i) {
      return --e === 0 && r(t()), i?.(n);
    } };
  };
  var ll = function(e) {
    return typeof e == "string" ? e : e.reduce((t, r) => {
      let n = typeof r == "string" ? r : r.level;
      return n === "query" ? t : t && (r === "info" || t === "info") ? "info" : n;
    }, undefined);
  };
  var xn = function(e) {
    return typeof e.batchRequestIdx == "number";
  };
  var bn = function(e) {
    return e === null ? e : Array.isArray(e) ? e.map(bn) : typeof e == "object" ? kd(e) ? Od(e) : ct(e, bn) : e;
  };
  var kd = function(e) {
    return e !== null && typeof e == "object" && typeof e.$type == "string";
  };
  var Od = function({ $type: e, value: t }) {
    switch (e) {
      case "BigInt":
        return BigInt(t);
      case "Bytes":
        return Buffer.from(t, "base64");
      case "DateTime":
        return new Date(t);
      case "Decimal":
        return new we(t);
      case "Json":
        return JSON.parse(t);
      default:
        Ge(t, "Unknown tagged value");
    }
  };
  var cl = function(e) {
    if (e.action !== "findUnique" && e.action !== "findUniqueOrThrow")
      return;
    let t = [];
    return e.modelName && t.push(e.modelName), e.query.arguments && t.push(Qi(e.query.arguments)), t.push(Qi(e.query.selection)), t.join("");
  };
  var Qi = function(e) {
    return `(${Object.keys(e).sort().map((r) => {
      let n = e[r];
      return typeof n == "object" && n !== null ? `(${r} ${Qi(n)})` : r;
    }).join(" ")})`;
  };
  var Ji = function(e) {
    return Dd[e];
  };
  var Nd = function(e) {
    if (e) {
      if (e.kind === "batch")
        return { kind: "batch", options: { isolationLevel: e.isolationLevel } };
      if (e.kind === "itx")
        return { kind: "itx", options: dl(e) };
      Ge(e, "Unknown transaction kind");
    }
  };
  var dl = function(e) {
    return { id: e.id, payload: e.payload };
  };
  var Ld = function(e, t) {
    return xn(e) && t?.kind === "batch" && e.batchRequestIdx !== t.index;
  };
  var $d = function(e) {
    return e.code === "P2009" || e.code === "P2012";
  };
  var ml = function(e) {
    if (e.kind === "Union")
      return { kind: "Union", errors: e.errors.map(ml) };
    if (Array.isArray(e.selectionPath)) {
      let [, ...t] = e.selectionPath;
      return { ...e, selectionPath: t };
    }
    return e;
  };
  var yl = function(e) {
    return e.map((t) => {
      let r = {};
      for (let n of Object.keys(t))
        r[n] = hl(t[n]);
      return r;
    });
  };
  var hl = function({ prisma__type: e, prisma__value: t }) {
    switch (e) {
      case "bigint":
        return BigInt(t);
      case "bytes":
        return Buffer.from(t, "base64");
      case "decimal":
        return new we(t);
      case "datetime":
      case "date":
        return new Date(t);
      case "time":
        return new Date(`1970-01-01T${t}Z`);
      case "array":
        return t.map(hl);
      default:
        return t;
    }
  };
  var Pl = function(e, t) {
    for (let [r, n] of Object.entries(e)) {
      if (!xl.includes(r)) {
        let i = At(r, xl);
        throw new V(`Unknown property ${r} provided to PrismaClient constructor.${i}`);
      }
      Vd[r](n, t);
    }
    if (e.datasourceUrl && e.datasources)
      throw new V('Can not use "datasourceUrl" and "datasources" options at the same time. Pick one of them');
  };
  var At = function(e, t) {
    if (t.length === 0 || typeof e != "string")
      return "";
    let r = jd(e, t);
    return r ? ` Did you mean "${r}"?` : "";
  };
  var jd = function(e, t) {
    if (t.length === 0)
      return null;
    let r = t.map((i) => ({ value: i, distance: (0, wl.default)(e, i) }));
    r.sort((i, o) => i.distance < o.distance ? -1 : 1);
    let n = r[0];
    return n.distance < 3 ? n.value : null;
  };
  var vl = function(e) {
    return e.length === 0 ? Promise.resolve([]) : new Promise((t, r) => {
      let n = new Array(e.length), i = null, o = false, s = 0, a = () => {
        o || (s++, s === e.length && (o = true, i ? r(i) : t(n)));
      }, l = (u) => {
        o || (o = true, r(u));
      };
      for (let u = 0;u < e.length; u++)
        e[u].then((c) => {
          n[u] = c, a();
        }, (c) => {
          if (!xn(c)) {
            l(c);
            return;
          }
          c.batchRequestIdx === u ? l(c) : (i || (i = c), a());
        });
    });
  };
  var Ml = function(e) {

    class t {
      constructor(n) {
        this._middlewares = new hn;
        this._createPrismaPromise = Ui();
        this.$extends = Ws;
        pa(e), n && Pl(n, e.datasourceNames);
        let i = new Al.EventEmitter().on("error", () => {
        });
        this._extensions = on.empty(), this._previewFeatures = e.generator?.previewFeatures ?? [], this._clientVersion = e.clientVersion ?? gl, this._activeProvider = e.activeProvider, this._tracingHelper = sl(this._previewFeatures);
        let o = { rootEnvPath: e.relativeEnvPaths.rootEnvPath && fr.default.resolve(e.dirname, e.relativeEnvPaths.rootEnvPath), schemaEnvPath: e.relativeEnvPaths.schemaEnvPath && fr.default.resolve(e.dirname, e.relativeEnvPaths.schemaEnvPath) }, s = Ot(o, { conflictCheck: "none" }) || e.injectableEdgeEnv?.();
        try {
          let a = n ?? {}, l = a.__internal ?? {}, u = l.debug === true;
          u && D.enable("prisma:client");
          let c = fr.default.resolve(e.dirname, e.relativePath);
          Rl.default.existsSync(c) || (c = e.dirname), Be("dirname", e.dirname), Be("relativePath", e.relativePath), Be("cwd", c);
          let p = l.engine || {};
          if (a.errorFormat ? this._errorFormat = a.errorFormat : process.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e.runtimeDataModel, this._engineConfig = { cwd: c, dirname: e.dirname, enableDebugLogs: u, allowTriggerPanic: p.allowTriggerPanic, datamodelPath: fr.default.join(e.dirname, e.filename ?? "schema.prisma"), prismaPath: p.binaryPath ?? undefined, engineEndpoint: p.endpoint, generator: e.generator, showColors: this._errorFormat === "pretty", logLevel: a.log && ll(a.log), logQueries: a.log && !!(typeof a.log == "string" ? a.log === "query" : a.log.find((d) => typeof d == "string" ? d === "query" : d.level === "query")), env: s?.parsed ?? {}, flags: [], clientVersion: e.clientVersion, engineVersion: e.engineVersion, previewFeatures: this._previewFeatures, activeProvider: e.activeProvider, inlineSchema: e.inlineSchema, overrideDatasources: da(a, e.datasourceNames), inlineDatasources: e.inlineDatasources, inlineSchemaHash: e.inlineSchemaHash, tracingHelper: this._tracingHelper, logEmitter: i, isBundled: e.isBundled }, Be("clientVersion", e.clientVersion), this._engine = Na(e, this._engineConfig), this._requestHandler = new wn(this, i), a.log)
            for (let d of a.log) {
              let f = typeof d == "string" ? d : d.emit === "stdout" ? d.level : null;
              f && this.$on(f, (y) => {
                Nt.log(`${Nt.tags[f] ?? ""}`, y.message || y.query);
              });
            }
          this._metrics = new pt(this._engine);
        } catch (a) {
          throw a.clientVersion = this._clientVersion, a;
        }
        return this._appliedParent = Ht(this);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClient";
      }
      $use(n) {
        this._middlewares.use(n);
      }
      $on(n, i) {
        n === "beforeExit" ? this._engine.on("beforeExit", i) : this._engine.on(n, (o) => {
          let s = o.fields;
          return i(n === "query" ? { timestamp: o.timestamp, query: s?.query ?? o.query, params: s?.params ?? o.params, duration: s?.duration_ms ?? o.duration, target: o.target } : { timestamp: o.timestamp, message: s?.message ?? o.message, target: o.target });
        });
      }
      $connect() {
        try {
          return this._engine.start();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        }
      }
      async $disconnect() {
        try {
          await this._engine.stop();
        } catch (n) {
          throw n.clientVersion = this._clientVersion, n;
        } finally {
          fo();
        }
      }
      $executeRawInternal(n, i, o, s) {
        return this._request({ action: "executeRaw", args: o, transaction: n, clientMethod: i, argsMapper: Bi(this._activeProvider, i), callsite: qe(this._errorFormat), dataPath: [], middlewareArgsMapper: s });
      }
      $executeRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined) {
            let [s, a] = Tl(n, i);
            return ji(this._activeProvider, s.text, s.values, Array.isArray(n) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o, "$executeRaw", s, a);
          }
          throw new X("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
        });
      }
      $executeRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => (ji(this._activeProvider, n, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o, "$executeRawUnsafe", [n, ...i])));
      }
      $runCommandRaw(n) {
        if (e.activeProvider !== "mongodb")
          throw new X(`The ${e.activeProvider} provider does not support \$runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
        return this._createPrismaPromise((i) => this._request({ args: n, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: za, callsite: qe(this._errorFormat), transaction: i }));
      }
      async $queryRawInternal(n, i, o, s) {
        return this._request({ action: "queryRaw", args: o, transaction: n, clientMethod: i, argsMapper: Bi(this._activeProvider, i), callsite: qe(this._errorFormat), dataPath: [], middlewareArgsMapper: s }).then(yl);
      }
      $queryRaw(n, ...i) {
        return this._createPrismaPromise((o) => {
          if (n.raw !== undefined || n.sql !== undefined)
            return this.$queryRawInternal(o, "$queryRaw", ...Tl(n, i));
          throw new X("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
        });
      }
      $queryRawUnsafe(n, ...i) {
        return this._createPrismaPromise((o) => this.$queryRawInternal(o, "$queryRawUnsafe", [n, ...i]));
      }
      _transactionWithArray({ promises: n, options: i }) {
        let o = Kd.nextId(), s = al(n.length), a = n.map((l, u) => {
          if (l?.[Symbol.toStringTag] !== "PrismaPromise")
            throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
          let c = i?.isolationLevel, p = { kind: "batch", id: o, index: u, isolationLevel: c, lock: s };
          return l.requestTransaction?.(p) ?? l;
        });
        return vl(a);
      }
      async _transactionWithCallback({ callback: n, options: i }) {
        let o = { traceparent: this._tracingHelper.getTraceParent() }, s = await this._engine.transaction("start", o, i), a;
        try {
          let l = { kind: "itx", ...s };
          a = await n(this._createItxClient(l)), await this._engine.transaction("commit", o, s);
        } catch (l) {
          throw await this._engine.transaction("rollback", o, s).catch(() => {
          }), l;
        }
        return a;
      }
      _createItxClient(n) {
        return Ht(be(tn(this), [re("_appliedParent", () => this._appliedParent._createItxClient(n)), re("_createPrismaPromise", () => Ui(n)), re(Ud, () => n.id), Vt(ul)]));
      }
      $transaction(n, i) {
        let o;
        typeof n == "function" ? o = () => this._transactionWithCallback({ callback: n, options: i }) : o = () => this._transactionWithArray({ promises: n, options: i });
        let s = { name: "transaction", attributes: { method: "$transaction" } };
        return this._tracingHelper.runInChildSpan(s, o);
      }
      _request(n) {
        n.otelParentCtx = this._tracingHelper.getActiveContext();
        let i = n.middlewareArgsMapper ?? Bd, o = { args: i.requestArgsToMiddlewareArgs(n.args), dataPath: n.dataPath, runInTransaction: !!n.transaction, action: n.action, model: n.model }, s = { middleware: { name: "middleware", middleware: true, attributes: { method: "$use" }, active: false }, operation: { name: "operation", attributes: { method: o.action, model: o.model, name: o.model ? `${o.model}.${o.action}` : o.action } } }, a = -1, l = async (u) => {
          let c = this._middlewares.get(++a);
          if (c)
            return this._tracingHelper.runInChildSpan(s.middleware, (P) => c(u, (T) => (P?.end(), l(T))));
          let { runInTransaction: p, args: d, ...f } = u, y = { ...n, ...f };
          d && (y.args = i.middlewareArgsToRequestArgs(d)), n.transaction !== undefined && p === false && delete y.transaction;
          let g = await ra(this, y);
          return y.model ? Zs({ result: g, modelName: y.model, args: y.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel }) : g;
        };
        return this._tracingHelper.runInChildSpan(s.operation, () => new Cl.AsyncResource("prisma-client-request").runInAsyncScope(() => l(o)));
      }
      async _executeRequest({ args: n, clientMethod: i, dataPath: o, callsite: s, action: a, model: l, argsMapper: u, transaction: c, unpacker: p, otelParentCtx: d, customDataProxyFetch: f }) {
        try {
          n = u ? u(n) : n;
          let y = { name: "serialize" }, g = this._tracingHelper.runInChildSpan(y, () => Ga({ modelName: l, runtimeDataModel: this._runtimeDataModel, action: a, args: n, clientMethod: i, callsite: s, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion }));
          return D.enabled("prisma:client") && (Be("Prisma Client call:"), Be(`prisma.${i}(${Fs(n)})`), Be("Generated request:"), Be(JSON.stringify(g, null, 2) + `
`)), c?.kind === "batch" && await c.lock, this._requestHandler.request({ protocolQuery: g, modelName: l, action: a, clientMethod: i, dataPath: o, callsite: s, args: n, extensions: this._extensions, transaction: c, unpacker: p, otelParentCtx: d, otelChildCtx: this._tracingHelper.getActiveContext(), customDataProxyFetch: f });
        } catch (y) {
          throw y.clientVersion = this._clientVersion, y;
        }
      }
      get $metrics() {
        if (!this._hasPreviewFlag("metrics"))
          throw new X("`metrics` preview feature must be enabled in order to access metrics API", { clientVersion: this._clientVersion });
        return this._metrics;
      }
      _hasPreviewFlag(n) {
        return !!this._engineConfig.previewFeatures?.includes(n);
      }
    }
    return t;
  };
  var Tl = function(e, t) {
    return Qd(e) ? [new oe(e, t), rl] : [e, nl];
  };
  var Qd = function(e) {
    return Array.isArray(e) && Array.isArray(e.raw);
  };
  var Sl = function(e) {
    return new Proxy(e, { get(t, r) {
      if (r in t)
        return t[r];
      if (!Jd.has(r))
        throw new TypeError(`Invalid enum value: ${String(r)}`);
    } });
  };
  var Il = function(e) {
    Ot(e, { conflictCheck: "warn" });
  };
  var __dirname = "/Users/jjh/dev/epyc_discord_bun/node_modules/@prisma/client/runtime", __filename = "/Users/jjh/dev/epyc_discord_bun/node_modules/@prisma/client/runtime/library.js";
  var Fl = Object.create;
  var yr = Object.defineProperty;
  var kl = Object.getOwnPropertyDescriptor;
  var Ol = Object.getOwnPropertyNames;
  var Dl = Object.getPrototypeOf;
  var _l = Object.prototype.hasOwnProperty;
  var q = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
  var Rt = (e, t) => {
    for (var r in t)
      yr(e, r, { get: t[r], enumerable: true });
  };
  var Gi = (e, t, r, n) => {
    if (t && typeof t == "object" || typeof t == "function")
      for (let i of Ol(t))
        !_l.call(e, i) && i !== r && yr(e, i, { get: () => t[i], enumerable: !(n = kl(t, i)) || n.enumerable });
    return e;
  };
  var S = (e, t, r) => (r = e != null ? Fl(Dl(e)) : {}, Gi(t || !e || !e.__esModule ? yr(r, "default", { value: e, enumerable: true }) : r, e));
  var Nl = (e) => Gi(yr({}, "__esModule", { value: true }), e);
  var no = q((om, ro) => {
    var tt = 1000, rt = tt * 60, nt = rt * 60, Ke = nt * 24, Ll = Ke * 7, $l = Ke * 365.25;
    ro.exports = function(e, t) {
      t = t || {};
      var r = typeof e;
      if (r === "string" && e.length > 0)
        return ql(e);
      if (r === "number" && isFinite(e))
        return t.long ? jl(e) : Vl(e);
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };
    function ql(e) {
      if (e = String(e), !(e.length > 100)) {
        var t = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
        if (t) {
          var r = parseFloat(t[1]), n = (t[2] || "ms").toLowerCase();
          switch (n) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return r * $l;
            case "weeks":
            case "week":
            case "w":
              return r * Ll;
            case "days":
            case "day":
            case "d":
              return r * Ke;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return r * nt;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return r * rt;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return r * tt;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return r;
            default:
              return;
          }
        }
      }
    }
    function Vl(e) {
      var t = Math.abs(e);
      return t >= Ke ? Math.round(e / Ke) + "d" : t >= nt ? Math.round(e / nt) + "h" : t >= rt ? Math.round(e / rt) + "m" : t >= tt ? Math.round(e / tt) + "s" : e + "ms";
    }
    function jl(e) {
      var t = Math.abs(e);
      return t >= Ke ? xr(e, t, Ke, "day") : t >= nt ? xr(e, t, nt, "hour") : t >= rt ? xr(e, t, rt, "minute") : t >= tt ? xr(e, t, tt, "second") : e + " ms";
    }
    function xr(e, t, r, n) {
      var i = t >= r * 1.5;
      return Math.round(e / r) + " " + n + (i ? "s" : "");
    }
  });
  var Rn = q((sm, io) => {
    function Bl(e) {
      r.debug = r, r.default = r, r.coerce = l, r.disable = o, r.enable = i, r.enabled = s, r.humanize = no(), r.destroy = u, Object.keys(e).forEach((c) => {
        r[c] = e[c];
      }), r.names = [], r.skips = [], r.formatters = {};
      function t(c) {
        let p = 0;
        for (let d = 0;d < c.length; d++)
          p = (p << 5) - p + c.charCodeAt(d), p |= 0;
        return r.colors[Math.abs(p) % r.colors.length];
      }
      r.selectColor = t;
      function r(c) {
        let p, d = null, f, y;
        function g(...P) {
          if (!g.enabled)
            return;
          let T = g, C = Number(new Date), x = C - (p || C);
          T.diff = x, T.prev = p, T.curr = C, p = C, P[0] = r.coerce(P[0]), typeof P[0] != "string" && P.unshift("%O");
          let R = 0;
          P[0] = P[0].replace(/%([a-zA-Z%])/g, (G, Ue) => {
            if (G === "%%")
              return "%";
            R++;
            let $ = r.formatters[Ue];
            if (typeof $ == "function") {
              let z = P[R];
              G = $.call(T, z), P.splice(R, 1), R--;
            }
            return G;
          }), r.formatArgs.call(T, P), (T.log || r.log).apply(T, P);
        }
        return g.namespace = c, g.useColors = r.useColors(), g.color = r.selectColor(c), g.extend = n, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: true, configurable: false, get: () => d !== null ? d : (f !== r.namespaces && (f = r.namespaces, y = r.enabled(c)), y), set: (P) => {
          d = P;
        } }), typeof r.init == "function" && r.init(g), g;
      }
      function n(c, p) {
        let d = r(this.namespace + (typeof p > "u" ? ":" : p) + c);
        return d.log = this.log, d;
      }
      function i(c) {
        r.save(c), r.namespaces = c, r.names = [], r.skips = [];
        let p, d = (typeof c == "string" ? c : "").split(/[\s,]+/), f = d.length;
        for (p = 0;p < f; p++)
          d[p] && (c = d[p].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
      }
      function o() {
        let c = [...r.names.map(a), ...r.skips.map(a).map((p) => "-" + p)].join(",");
        return r.enable(""), c;
      }
      function s(c) {
        if (c[c.length - 1] === "*")
          return true;
        let p, d;
        for (p = 0, d = r.skips.length;p < d; p++)
          if (r.skips[p].test(c))
            return false;
        for (p = 0, d = r.names.length;p < d; p++)
          if (r.names[p].test(c))
            return true;
        return false;
      }
      function a(c) {
        return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function l(c) {
        return c instanceof Error ? c.stack || c.message : c;
      }
      function u() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      return r.enable(r.load()), r;
    }
    io.exports = Bl;
  });
  var oo = q((le, br) => {
    le.formatArgs = Kl;
    le.save = Ql;
    le.load = Jl;
    le.useColors = Ul;
    le.storage = Gl();
    le.destroy = (() => {
      let e = false;
      return () => {
        e || (e = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
      };
    })();
    le.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function Ul() {
      return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function Kl(e) {
      if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + br.exports.humanize(this.diff), !this.useColors)
        return;
      let t = "color: " + this.color;
      e.splice(1, 0, t, "color: inherit");
      let r = 0, n = 0;
      e[0].replace(/%[a-zA-Z%]/g, (i) => {
        i !== "%%" && (r++, i === "%c" && (n = r));
      }), e.splice(n, 0, t);
    }
    le.log = console.debug || console.log || (() => {
    });
    function Ql(e) {
      try {
        e ? le.storage.setItem("debug", e) : le.storage.removeItem("debug");
      } catch {
      }
    }
    function Jl() {
      let e;
      try {
        e = le.storage.getItem("debug");
      } catch {
      }
      return !e && typeof process < "u" && ("env" in process) && (e = process.env.DEBUG), e;
    }
    function Gl() {
      try {
        return localStorage;
      } catch {
      }
    }
    br.exports = Rn()(le);
    var { formatters: Hl } = br.exports;
    Hl.j = function(e) {
      try {
        return JSON.stringify(e);
      } catch (t) {
        return "[UnexpectedJSONParseError]: " + t.message;
      }
    };
  });
  var Mn = q((am, so) => {
    so.exports = (e, t = process.argv) => {
      let r = e.startsWith("-") ? "" : e.length === 1 ? "-" : "--", n = t.indexOf(r + e), i = t.indexOf("--");
      return n !== -1 && (i === -1 || n < i);
    };
  });
  var Fn = q((lm, lo) => {
    var Wl = __require("os"), ao = __require("tty"), de = Mn(), { env: B } = process, Fe;
    de("no-color") || de("no-colors") || de("color=false") || de("color=never") ? Fe = 0 : (de("color") || de("colors") || de("color=true") || de("color=always")) && (Fe = 1);
    ("FORCE_COLOR" in B) && (B.FORCE_COLOR === "true" ? Fe = 1 : B.FORCE_COLOR === "false" ? Fe = 0 : Fe = B.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(B.FORCE_COLOR, 10), 3));
    function Sn(e) {
      return e === 0 ? false : { level: e, hasBasic: true, has256: e >= 2, has16m: e >= 3 };
    }
    function In(e, t) {
      if (Fe === 0)
        return 0;
      if (de("color=16m") || de("color=full") || de("color=truecolor"))
        return 3;
      if (de("color=256"))
        return 2;
      if (e && !t && Fe === undefined)
        return 0;
      let r = Fe || 0;
      if (B.TERM === "dumb")
        return r;
      if (process.platform === "win32") {
        let n = Wl.release().split(".");
        return Number(n[0]) >= 10 && Number(n[2]) >= 10586 ? Number(n[2]) >= 14931 ? 3 : 2 : 1;
      }
      if ("CI" in B)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((n) => (n in B)) || B.CI_NAME === "codeship" ? 1 : r;
      if ("TEAMCITY_VERSION" in B)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(B.TEAMCITY_VERSION) ? 1 : 0;
      if (B.COLORTERM === "truecolor")
        return 3;
      if ("TERM_PROGRAM" in B) {
        let n = parseInt((B.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (B.TERM_PROGRAM) {
          case "iTerm.app":
            return n >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(B.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(B.TERM) || ("COLORTERM" in B) ? 1 : r;
    }
    function zl(e) {
      let t = In(e, e && e.isTTY);
      return Sn(t);
    }
    lo.exports = { supportsColor: zl, stdout: Sn(In(true, ao.isatty(1))), stderr: Sn(In(true, ao.isatty(2))) };
  });
  var co = q((H, wr) => {
    var Yl = __require("tty"), Er = __require("util");
    H.init = iu;
    H.log = tu;
    H.formatArgs = Xl;
    H.save = ru;
    H.load = nu;
    H.useColors = Zl;
    H.destroy = Er.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    H.colors = [6, 2, 3, 4, 5, 1];
    try {
      let e = Fn();
      e && (e.stderr || e).level >= 2 && (H.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
    } catch {
    }
    H.inspectOpts = Object.keys(process.env).filter((e) => /^debug_/i.test(e)).reduce((e, t) => {
      let r = t.substring(6).toLowerCase().replace(/_([a-z])/g, (i, o) => o.toUpperCase()), n = process.env[t];
      return /^(yes|on|true|enabled)$/i.test(n) ? n = true : /^(no|off|false|disabled)$/i.test(n) ? n = false : n === "null" ? n = null : n = Number(n), e[r] = n, e;
    }, {});
    function Zl() {
      return "colors" in H.inspectOpts ? !!H.inspectOpts.colors : Yl.isatty(process.stderr.fd);
    }
    function Xl(e) {
      let { namespace: t, useColors: r } = this;
      if (r) {
        let n = this.color, i = "\x1B[3" + (n < 8 ? n : "8;5;" + n), o = `  ${i};1m${t} \x1B[0m`;
        e[0] = o + e[0].split(`
`).join(`
` + o), e.push(i + "m+" + wr.exports.humanize(this.diff) + "\x1B[0m");
      } else
        e[0] = eu() + t + " " + e[0];
    }
    function eu() {
      return H.inspectOpts.hideDate ? "" : new Date().toISOString() + " ";
    }
    function tu(...e) {
      return process.stderr.write(Er.format(...e) + `
`);
    }
    function ru(e) {
      e ? process.env.DEBUG = e : delete process.env.DEBUG;
    }
    function nu() {
      return process.env.DEBUG;
    }
    function iu(e) {
      e.inspectOpts = {};
      let t = Object.keys(H.inspectOpts);
      for (let r = 0;r < t.length; r++)
        e.inspectOpts[t[r]] = H.inspectOpts[t[r]];
    }
    wr.exports = Rn()(H);
    var { formatters: uo } = wr.exports;
    uo.o = function(e) {
      return this.inspectOpts.colors = this.useColors, Er.inspect(e, this.inspectOpts).split(`
`).map((t) => t.trim()).join(" ");
    };
    uo.O = function(e) {
      return this.inspectOpts.colors = this.useColors, Er.inspect(e, this.inspectOpts);
    };
  });
  var po = q((um, kn) => {
    typeof process > "u" || process.type === "renderer" || false || process.__nwjs ? kn.exports = oo() : kn.exports = co();
  });
  var vo = q((jm, $n) => {
    var A = $n.exports;
    $n.exports.default = A;
    var I = "\x1B[", St = "\x1B]", st = "\x07", Ar = ";", Po = process.env.TERM_PROGRAM === "Apple_Terminal";
    A.cursorTo = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      return typeof t != "number" ? I + (e + 1) + "G" : I + (t + 1) + ";" + (e + 1) + "H";
    };
    A.cursorMove = (e, t) => {
      if (typeof e != "number")
        throw new TypeError("The `x` argument is required");
      let r = "";
      return e < 0 ? r += I + -e + "D" : e > 0 && (r += I + e + "C"), t < 0 ? r += I + -t + "A" : t > 0 && (r += I + t + "B"), r;
    };
    A.cursorUp = (e = 1) => I + e + "A";
    A.cursorDown = (e = 1) => I + e + "B";
    A.cursorForward = (e = 1) => I + e + "C";
    A.cursorBackward = (e = 1) => I + e + "D";
    A.cursorLeft = I + "G";
    A.cursorSavePosition = Po ? "\x1B7" : I + "s";
    A.cursorRestorePosition = Po ? "\x1B8" : I + "u";
    A.cursorGetPosition = I + "6n";
    A.cursorNextLine = I + "E";
    A.cursorPrevLine = I + "F";
    A.cursorHide = I + "?25l";
    A.cursorShow = I + "?25h";
    A.eraseLines = (e) => {
      let t = "";
      for (let r = 0;r < e; r++)
        t += A.eraseLine + (r < e - 1 ? A.cursorUp() : "");
      return e && (t += A.cursorLeft), t;
    };
    A.eraseEndLine = I + "K";
    A.eraseStartLine = I + "1K";
    A.eraseLine = I + "2K";
    A.eraseDown = I + "J";
    A.eraseUp = I + "1J";
    A.eraseScreen = I + "2J";
    A.scrollUp = I + "S";
    A.scrollDown = I + "T";
    A.clearScreen = "\x1Bc";
    A.clearTerminal = process.platform === "win32" ? `${A.eraseScreen}${I}0f` : `${A.eraseScreen}${I}3J${I}H`;
    A.beep = st;
    A.link = (e, t) => [St, "8", Ar, Ar, t, st, e, St, "8", Ar, Ar, st].join("");
    A.image = (e, t = {}) => {
      let r = `${St}1337;File=inline=1`;
      return t.width && (r += `;width=${t.width}`), t.height && (r += `;height=${t.height}`), t.preserveAspectRatio === false && (r += ";preserveAspectRatio=0"), r + ":" + e.toString("base64") + st;
    };
    A.iTerm = { setCwd: (e = process.cwd()) => `${St}50;CurrentDir=${e}${st}`, annotation: (e, t = {}) => {
      let r = `${St}1337;`, n = typeof t.x < "u", i = typeof t.y < "u";
      if ((n || i) && !(n && i && typeof t.length < "u"))
        throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
      return e = e.replace(/\|/g, ""), r += t.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=", t.length > 0 ? r += (n ? [e, t.length, t.x, t.y] : [t.length, e]).join("|") : r += e, r + st;
    } };
  });
  var Ao = q((Bm, Co) => {
    var cu = Fn(), at = Mn();
    function To(e) {
      if (/^\d{3,4}$/.test(e)) {
        let r = /(\d{1,2})(\d{2})/.exec(e);
        return { major: 0, minor: parseInt(r[1], 10), patch: parseInt(r[2], 10) };
      }
      let t = (e || "").split(".").map((r) => parseInt(r, 10));
      return { major: t[0], minor: t[1], patch: t[2] };
    }
    function qn(e) {
      let { env: t } = process;
      if ("FORCE_HYPERLINK" in t)
        return !(t.FORCE_HYPERLINK.length > 0 && parseInt(t.FORCE_HYPERLINK, 10) === 0);
      if (at("no-hyperlink") || at("no-hyperlinks") || at("hyperlink=false") || at("hyperlink=never"))
        return false;
      if (at("hyperlink=true") || at("hyperlink=always") || ("NETLIFY" in t))
        return true;
      if (!cu.supportsColor(e) || e && !e.isTTY || process.platform === "win32" || ("CI" in t) || ("TEAMCITY_VERSION" in t))
        return false;
      if ("TERM_PROGRAM" in t) {
        let r = To(t.TERM_PROGRAM_VERSION);
        switch (t.TERM_PROGRAM) {
          case "iTerm.app":
            return r.major === 3 ? r.minor >= 1 : r.major > 3;
          case "WezTerm":
            return r.major >= 20200620;
          case "vscode":
            return r.major > 1 || r.major === 1 && r.minor >= 72;
        }
      }
      if ("VTE_VERSION" in t) {
        if (t.VTE_VERSION === "0.50.0")
          return false;
        let r = To(t.VTE_VERSION);
        return r.major > 0 || r.minor >= 50;
      }
      return false;
    }
    Co.exports = { supportsHyperlink: qn, stdout: qn(process.stdout), stderr: qn(process.stderr) };
  });
  var Mo = q((Um, It) => {
    var pu = vo(), Vn = Ao(), Ro = (e, t, { target: r = "stdout", ...n } = {}) => Vn[r] ? pu.link(e, t) : n.fallback === false ? e : typeof n.fallback == "function" ? n.fallback(e, t) : `${e} (\u200B${t}\u200B)`;
    It.exports = (e, t, r = {}) => Ro(e, t, r);
    It.exports.stderr = (e, t, r = {}) => Ro(e, t, { target: "stderr", ...r });
    It.exports.isSupported = Vn.stdout;
    It.exports.stderr.isSupported = Vn.stderr;
  });
  var $o = q((lf, Au) => {
    Au.exports = { name: "dotenv", version: "16.0.3", description: "Loads environment variables from .env file", main: "lib/main.js", types: "lib/main.d.ts", exports: { ".": { require: "./lib/main.js", types: "./lib/main.d.ts", default: "./lib/main.js" }, "./config": "./config.js", "./config.js": "./config.js", "./lib/env-options": "./lib/env-options.js", "./lib/env-options.js": "./lib/env-options.js", "./lib/cli-options": "./lib/cli-options.js", "./lib/cli-options.js": "./lib/cli-options.js", "./package.json": "./package.json" }, scripts: { "dts-check": "tsc --project tests/types/tsconfig.json", lint: "standard", "lint-readme": "standard-markdown", pretest: "npm run lint && npm run dts-check", test: "tap tests/*.js --100 -Rspec", prerelease: "npm test", release: "standard-version" }, repository: { type: "git", url: "git://github.com/motdotla/dotenv.git" }, keywords: ["dotenv", "env", ".env", "environment", "variables", "config", "settings"], readmeFilename: "README.md", license: "BSD-2-Clause", devDependencies: { "@types/node": "^17.0.9", decache: "^4.6.1", dtslint: "^3.7.0", sinon: "^12.0.1", standard: "^16.0.4", "standard-markdown": "^7.1.0", "standard-version": "^9.3.2", tap: "^15.1.6", tar: "^6.1.11", typescript: "^4.5.4" }, engines: { node: ">=12" } };
  });
  var Vo = q((uf, Fr) => {
    var Ru = __require("fs"), qo = __require("path"), Mu = __require("os"), Su = $o(), Iu = Su.version, Fu = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function ku(e) {
      let t = {}, r = e.toString();
      r = r.replace(/\r\n?/mg, `
`);
      let n;
      for (;(n = Fu.exec(r)) != null; ) {
        let i = n[1], o = n[2] || "";
        o = o.trim();
        let s = o[0];
        o = o.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), s === '"' && (o = o.replace(/\\n/g, `
`), o = o.replace(/\\r/g, "\r")), t[i] = o;
      }
      return t;
    }
    function Kn(e) {
      console.log(`[dotenv@${Iu}][DEBUG] ${e}`);
    }
    function Ou(e) {
      return e[0] === "~" ? qo.join(Mu.homedir(), e.slice(1)) : e;
    }
    function Du(e) {
      let t = qo.resolve(process.cwd(), ".env"), r = "utf8", n = !!(e && e.debug), i = !!(e && e.override);
      e && (e.path != null && (t = Ou(e.path)), e.encoding != null && (r = e.encoding));
      try {
        let o = Ir.parse(Ru.readFileSync(t, { encoding: r }));
        return Object.keys(o).forEach(function(s) {
          Object.prototype.hasOwnProperty.call(process.env, s) ? (i === true && (process.env[s] = o[s]), n && Kn(i === true ? `"${s}" is already defined in \`process.env\` and WAS overwritten` : `"${s}" is already defined in \`process.env\` and was NOT overwritten`)) : process.env[s] = o[s];
        }), { parsed: o };
      } catch (o) {
        return n && Kn(`Failed to load ${t} ${o.message}`), { error: o };
      }
    }
    var Ir = { config: Du, parse: ku };
    Fr.exports.config = Ir.config;
    Fr.exports.parse = Ir.parse;
    Fr.exports = Ir;
  });
  var Jo = q((yf, Qo) => {
    Qo.exports = (e) => {
      let t = e.match(/^[ \t]*(?=\S)/gm);
      return t ? t.reduce((r, n) => Math.min(r, n.length), 1 / 0) : 0;
    };
  });
  var Ho = q((hf, Go) => {
    var $u = Jo();
    Go.exports = (e) => {
      let t = $u(e);
      if (t === 0)
        return e;
      let r = new RegExp(`^[ \\t]{${t}}`, "gm");
      return e.replace(r, "");
    };
  });
  var Wo = q((xf, qu) => {
    qu.exports = { name: "@prisma/engines-version", version: "5.3.1-2.61e140623197a131c2a6189271ffee05a7aa9a59", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "61e140623197a131c2a6189271ffee05a7aa9a59" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.17.15", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
  });
  var Hn = q((Or) => {
    Object.defineProperty(Or, "__esModule", { value: true });
    Or.enginesVersion = undefined;
    Or.enginesVersion = Wo().prisma.enginesVersion;
  });
  var Xn = q((Ff, Zo) => {
    Zo.exports = (e, t = 1, r) => {
      if (r = { indent: " ", includeEmptyLines: false, ...r }, typeof e != "string")
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e}\``);
      if (typeof t != "number")
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t}\``);
      if (typeof r.indent != "string")
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r.indent}\``);
      if (t === 0)
        return e;
      let n = r.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return e.replace(n, r.indent.repeat(t));
    };
  });
  var rs = q((Df, ts) => {
    ts.exports = ({ onlyFirst: e = false } = {}) => {
      let t = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");
      return new RegExp(t, e ? undefined : "g");
    };
  });
  var ni = q((_f, ns) => {
    var Wu = rs();
    ns.exports = (e) => typeof e == "string" ? e.replace(Wu(), "") : e;
  });
  var is = q((Lf, Dr) => {
    Dr.exports = (e = {}) => {
      let t;
      if (e.repoUrl)
        t = e.repoUrl;
      else if (e.user && e.repo)
        t = `https://github.com/${e.user}/${e.repo}`;
      else
        throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
      let r = new URL(`${t}/issues/new`), n = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
      for (let i of n) {
        let o = e[i];
        if (o !== undefined) {
          if (i === "labels" || i === "projects") {
            if (!Array.isArray(o))
              throw new TypeError(`The \`${i}\` option should be an array`);
            o = o.join(",");
          }
          r.searchParams.set(i, o);
        }
      }
      return r.toString();
    };
    Dr.exports.default = Dr.exports;
  });
  var $i = q((iP, La) => {
    La.exports = function() {
      function e(t, r, n, i, o) {
        return t < r || n < r ? t > n ? n + 1 : t + 1 : i === o ? r : r + 1;
      }
      return function(t, r) {
        if (t === r)
          return 0;
        if (t.length > r.length) {
          var n = t;
          t = r, r = n;
        }
        for (var i = t.length, o = r.length;i > 0 && t.charCodeAt(i - 1) === r.charCodeAt(o - 1); )
          i--, o--;
        for (var s = 0;s < i && t.charCodeAt(s) === r.charCodeAt(s); )
          s++;
        if (i -= s, o -= s, i === 0 || o < 3)
          return o;
        var a = 0, l, u, c, p, d, f, y, g, P, T, C, x, R = [];
        for (l = 0;l < i; l++)
          R.push(l + 1), R.push(t.charCodeAt(s + l));
        for (var ce = R.length - 1;a < o - 3; )
          for (P = r.charCodeAt(s + (u = a)), T = r.charCodeAt(s + (c = a + 1)), C = r.charCodeAt(s + (p = a + 2)), x = r.charCodeAt(s + (d = a + 3)), f = a += 4, l = 0;l < ce; l += 2)
            y = R[l], g = R[l + 1], u = e(y, u, c, P, g), c = e(u, c, p, T, g), p = e(c, p, d, C, g), f = e(p, d, f, x, g), R[l] = f, d = p, p = c, c = u, u = y;
        for (;a < o; )
          for (P = r.charCodeAt(s + (u = a)), f = ++a, l = 0;l < ce; l += 2)
            y = R[l], R[l] = f = e(y, u, f, P, R[l + 1]), u = y;
        return f;
      };
    }();
  });
  var Gd = {};
  Rt(Gd, { DMMF: () => pe, DMMFClass: () => hr, Debug: () => On, Decimal: () => we, Extensions: () => vn, MetricsClient: () => pt, NotFoundError: () => Ce, PrismaClientInitializationError: () => k, PrismaClientKnownRequestError: () => U, PrismaClientRustPanicError: () => ue, PrismaClientUnknownRequestError: () => K, PrismaClientValidationError: () => X, Public: () => Tn, Sql: () => oe, Types: () => Cn, defineDmmfProperty: () => as, empty: () => us, getPrismaClient: () => Ml, join: () => ls, makeStrictEnum: () => Sl, objectEnumValues: () => $r, raw: () => li, sqltag: () => ui, warnEnvConflicts: () => Il, warnOnce: () => Lt });
  module.exports = Nl(Gd);
  var vn = {};
  Rt(vn, { defineExtension: () => Hi, getExtensionContext: () => Wi });
  var Tn = {};
  Rt(Tn, { validator: () => zi });
  var Cn = {};
  Rt(Cn, { Extensions: () => Yi, Public: () => Zi, Result: () => Xi, Utils: () => eo });
  var Yi = {};
  var Zi = {};
  var Xi = {};
  var eo = {};
  var Ie = (e, t) => {
    let r = {};
    for (let n of e) {
      let i = n[t];
      r[i] = n;
    }
    return r;
  };
  var hr = class {
    constructor(t) {
      this.document = t;
      this.compositeNames = new Set(this.datamodel.types.map((r) => r.name)), this.typeAndModelMap = this.buildTypeModelMap(), this.mappingsMap = this.buildMappingsMap(), this.outputTypeMap = this.buildMergedOutputTypeMap(), this.rootFieldMap = this.buildRootFieldMap(), this.inputTypesByName = this.buildInputTypesMap();
    }
    get datamodel() {
      return this.document.datamodel;
    }
    get mappings() {
      return this.document.mappings;
    }
    get schema() {
      return this.document.schema;
    }
    get inputObjectTypes() {
      return this.schema.inputObjectTypes;
    }
    get outputObjectTypes() {
      return this.schema.outputObjectTypes;
    }
    isComposite(t) {
      return this.compositeNames.has(t);
    }
    getOtherOperationNames() {
      return [Object.values(this.mappings.otherOperations.write), Object.values(this.mappings.otherOperations.read)].flat();
    }
    hasEnumInNamespace(t, r) {
      return this.schema.enumTypes[r]?.find((n) => n.name === t) !== undefined;
    }
    resolveInputObjectType(t) {
      return this.inputTypesByName.get(An(t.type, t.namespace));
    }
    resolveOutputObjectType(t) {
      if (t.location === "outputObjectTypes")
        return this.outputObjectTypes[t.namespace ?? "prisma"].find((r) => r.name === t.type);
    }
    buildModelMap() {
      return Ie(this.datamodel.models, "name");
    }
    buildTypeMap() {
      return Ie(this.datamodel.types, "name");
    }
    buildTypeModelMap() {
      return { ...this.buildTypeMap(), ...this.buildModelMap() };
    }
    buildMappingsMap() {
      return Ie(this.mappings.modelOperations, "model");
    }
    buildMergedOutputTypeMap() {
      return { model: Ie(this.schema.outputObjectTypes.model, "name"), prisma: Ie(this.schema.outputObjectTypes.prisma, "name") };
    }
    buildRootFieldMap() {
      return { ...Ie(this.outputTypeMap.prisma.Query.fields, "name"), ...Ie(this.outputTypeMap.prisma.Mutation.fields, "name") };
    }
    buildInputTypesMap() {
      let t = new Map;
      for (let r of this.inputObjectTypes.prisma)
        t.set(An(r.name, "prisma"), r);
      if (!this.inputObjectTypes.model)
        return t;
      for (let r of this.inputObjectTypes.model)
        t.set(An(r.name, "model"), r);
      return t;
    }
  };
  var pe;
  ((t) => {
    let e;
    ((x) => (x.findUnique = "findUnique", x.findUniqueOrThrow = "findUniqueOrThrow", x.findFirst = "findFirst", x.findFirstOrThrow = "findFirstOrThrow", x.findMany = "findMany", x.create = "create", x.createMany = "createMany", x.update = "update", x.updateMany = "updateMany", x.upsert = "upsert", x.delete = "delete", x.deleteMany = "deleteMany", x.groupBy = "groupBy", x.count = "count", x.aggregate = "aggregate", x.findRaw = "findRaw", x.aggregateRaw = "aggregateRaw"))(e = t.ModelAction || (t.ModelAction = {}));
  })(pe || (pe = {}));
  var Pr = S(po());
  var ou = 100;
  var Mt = [];
  typeof process < "u" && typeof process.stderr?.write != "function" && (Pr.default.log = console.debug ?? console.log);
  var On = Object.assign(su, Pr.default);
  var D = On;
  var Dn;
  var go;
  var yo;
  var ho;
  var xo = true;
  typeof process < "u" && ({ FORCE_COLOR: Dn, NODE_DISABLE_COLORS: go, NO_COLOR: yo, TERM: ho } = process.env || {}, xo = process.stdout && process.stdout.isTTY);
  var au = { enabled: !go && yo == null && ho !== "dumb" && (Dn != null && Dn !== "0" || xo) };
  var pm = _(0, 0);
  var ne = _(1, 22);
  var ke = _(2, 22);
  var dm = _(3, 23);
  var te = _(4, 24);
  var mm = _(7, 27);
  var fm = _(8, 28);
  var gm = _(9, 29);
  var ym = _(30, 39);
  var me = _(31, 39);
  var Qe = _(32, 39);
  var he = _(33, 39);
  var it = _(34, 39);
  var hm = _(35, 39);
  var Oe = _(36, 39);
  var xm = _(37, 39);
  var vr = _(90, 39);
  var bm = _(90, 39);
  var Em = _(40, 49);
  var wm = _(41, 49);
  var Pm = _(42, 49);
  var vm = _(43, 49);
  var Tm = _(44, 49);
  var Cm = _(45, 49);
  var Am = _(46, 49);
  var Rm = _(47, 49);
  var bo = S(__require("fs"));
  var Tr = "libquery_engine";
  var ko = S(__require("child_process"));
  var jn = S(__require("fs/promises"));
  var Mr = S(__require("os"));
  var Cr = Symbol("@ts-pattern/matcher");
  var Eo = "@ts-pattern/anonymous-select-key";
  var wo = function(e) {
    return !!(e && typeof e == "object");
  };
  var Ln = function(e) {
    return e && !!e[Cr];
  };
  var lu = function e(t, r, n) {
    if (wo(t)) {
      if (Ln(t)) {
        var i = t[Cr]().match(r), o = i.matched, s = i.selections;
        return o && s && Object.keys(s).forEach(function(l) {
          return n(l, s[l]);
        }), o;
      }
      if (!wo(r))
        return false;
      if (Array.isArray(t))
        return !!Array.isArray(r) && t.length === r.length && t.every(function(l, u) {
          return e(l, r[u], n);
        });
      if (t instanceof Map)
        return r instanceof Map && Array.from(t.keys()).every(function(l) {
          return e(t.get(l), r.get(l), n);
        });
      if (t instanceof Set) {
        if (!(r instanceof Set))
          return false;
        if (t.size === 0)
          return r.size === 0;
        if (t.size === 1) {
          var a = Array.from(t.values())[0];
          return Ln(a) ? Array.from(r.values()).every(function(l) {
            return e(a, l, n);
          }) : r.has(a);
        }
        return Array.from(t.values()).every(function(l) {
          return r.has(l);
        });
      }
      return Object.keys(t).every(function(l) {
        var u, c = t[l];
        return ((l in r) || Ln(u = c) && u[Cr]().matcherType === "optional") && e(c, r[l], n);
      });
    }
    return Object.is(r, t);
  };
  var Om = Je(function(e) {
    return true;
  });
  var Dm = Je(function(e) {
    return typeof e == "string";
  });
  var _m = Je(function(e) {
    return typeof e == "number";
  });
  var Nm = Je(function(e) {
    return typeof e == "boolean";
  });
  var Lm = Je(function(e) {
    return typeof e == "bigint";
  });
  var $m = Je(function(e) {
    return typeof e == "symbol";
  });
  var qm = Je(function(e) {
    return e == null;
  });
  var uu = function() {
    function e(r, n) {
      this.value = undefined, this.cases = undefined, this.value = r, this.cases = n;
    }
    var t = e.prototype;
    return t.with = function() {
      var r = [].slice.call(arguments), n = r[r.length - 1], i = [r[0]], o = [];
      return r.length === 3 && typeof r[1] == "function" ? (i.push(r[0]), o.push(r[1])) : r.length > 2 && i.push.apply(i, r.slice(1, r.length - 1)), new e(this.value, this.cases.concat([{ match: function(s) {
        var a = {}, l = !!(i.some(function(u) {
          return lu(u, s, function(c, p) {
            a[c] = p;
          });
        }) && o.every(function(u) {
          return u(s);
        }));
        return { matched: l, value: l && Object.keys(a).length ? Eo in a ? a[Eo] : a : s };
      }, handler: n }]));
    }, t.when = function(r, n) {
      return new e(this.value, this.cases.concat([{ match: function(i) {
        return { matched: !!r(i), value: i };
      }, handler: n }]));
    }, t.otherwise = function(r) {
      return new e(this.value, this.cases.concat([{ match: function(n) {
        return { matched: true, value: n };
      }, handler: r }])).run();
    }, t.exhaustive = function() {
      return this.run();
    }, t.run = function() {
      for (var r = this.value, n = undefined, i = 0;i < this.cases.length; i++) {
        var o = this.cases[i], s = o.match(this.value);
        if (s.matched) {
          r = s.value, n = o.handler;
          break;
        }
      }
      if (!n) {
        var a;
        try {
          a = JSON.stringify(this.value);
        } catch {
          a = this.value;
        }
        throw new Error("Pattern matching error: no pattern matches value " + a);
      }
      return n(r, this.value);
    }, e;
  }();
  var Oo = __require("util");
  var So = S(Mo());
  var du = { warn: he("prisma:warn") };
  var mu = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var fu = (0, Oo.promisify)(ko.default.exec);
  var ie = D("prisma:get-platform");
  var gu = ["1.0.x", "1.1.x", "3.0.x"];
  var Rr = {};
  var Un = ["darwin", "darwin-arm64", "debian-openssl-1.0.x", "debian-openssl-1.1.x", "debian-openssl-3.0.x", "rhel-openssl-1.0.x", "rhel-openssl-1.1.x", "rhel-openssl-3.0.x", "linux-arm64-openssl-1.1.x", "linux-arm64-openssl-1.0.x", "linux-arm64-openssl-3.0.x", "linux-arm-openssl-1.1.x", "linux-arm-openssl-1.0.x", "linux-arm-openssl-3.0.x", "linux-musl", "linux-musl-openssl-3.0.x", "linux-musl-arm64-openssl-1.1.x", "linux-musl-arm64-openssl-3.0.x", "linux-nixos", "linux-static-x64", "linux-static-arm64", "windows", "freebsd11", "freebsd12", "freebsd13", "openbsd", "netbsd", "arm"];
  var Jn = S(Vo());
  var kr = S(__require("fs"));
  var ut = S(__require("path"));
  var Qn = D("prisma:tryLoadEnv");
  var Ko = "library";
  var Vu = S(Hn());
  var N = S(__require("path"));
  var ju = S(Hn());
  var wf = D("prisma:engines");
  N.default.join(__dirname, "../query-engine-darwin");
  N.default.join(__dirname, "../query-engine-darwin-arm64");
  N.default.join(__dirname, "../query-engine-debian-openssl-1.0.x");
  N.default.join(__dirname, "../query-engine-debian-openssl-1.1.x");
  N.default.join(__dirname, "../query-engine-debian-openssl-3.0.x");
  N.default.join(__dirname, "../query-engine-linux-static-x64");
  N.default.join(__dirname, "../query-engine-linux-static-arm64");
  N.default.join(__dirname, "../query-engine-rhel-openssl-1.0.x");
  N.default.join(__dirname, "../query-engine-rhel-openssl-1.1.x");
  N.default.join(__dirname, "../query-engine-rhel-openssl-3.0.x");
  N.default.join(__dirname, "../libquery_engine-darwin.dylib.node");
  N.default.join(__dirname, "../libquery_engine-darwin-arm64.dylib.node");
  N.default.join(__dirname, "../libquery_engine-debian-openssl-1.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-debian-openssl-1.1.x.so.node");
  N.default.join(__dirname, "../libquery_engine-debian-openssl-3.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-1.1.x.so.node");
  N.default.join(__dirname, "../libquery_engine-linux-arm64-openssl-3.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-linux-musl.so.node");
  N.default.join(__dirname, "../libquery_engine-linux-musl-openssl-3.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-rhel-openssl-1.0.x.so.node");
  N.default.join(__dirname, "../libquery_engine-rhel-openssl-1.1.x.so.node");
  N.default.join(__dirname, "../libquery_engine-rhel-openssl-3.0.x.so.node");
  N.default.join(__dirname, "../query_engine-windows.dll.node");
  var Wn = S(__require("fs"));
  var Yo = D("chmodPlusX");
  var Dt = S(__require("path"));
  var Xo = S(Xn());
  var ei = class {
    constructor(t) {
      this.config = t;
    }
    toString() {
      let { config: t } = this, r = t.provider.fromEnvVar ? `env("${t.provider.fromEnvVar}")` : t.provider.value, n = JSON.parse(JSON.stringify({ provider: r, binaryTargets: Bu(t.binaryTargets) }));
      return `generator ${t.name} {
${(0, Xo.default)(Uu(n), 2)}
}`;
    }
  };
  var Nt = {};
  Rt(Nt, { error: () => Gu, info: () => Ju, log: () => Qu, query: () => Hu, should: () => es, tags: () => _t, warn: () => ri });
  var _t = { error: me("prisma:error"), warn: he("prisma:warn"), info: Oe("prisma:info"), query: it("prisma:query") };
  var es = { warn: () => !process.env.PRISMA_DISABLE_WARNINGS };
  var oi = (e, t) => e.reduce((r, n) => (r[t(n)] = n, r), {});
  var os = new Set;
  var Lt = (e, t, ...r) => {
    os.has(e) || (os.add(e), ri(t, ...r));
  };
  var U = class extends Error {
    constructor(r, { code: n, clientVersion: i, meta: o, batchRequestIdx: s }) {
      super(r);
      this.name = "PrismaClientKnownRequestError", this.code = n, this.clientVersion = i, this.meta = o, Object.defineProperty(this, "batchRequestIdx", { value: s, enumerable: false, writable: true });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientKnownRequestError";
    }
  };
  E(U, "PrismaClientKnownRequestError");
  var Ce = class extends U {
    constructor(t, r) {
      super(t, { code: "P2025", clientVersion: r }), this.name = "NotFoundError";
    }
  };
  E(Ce, "NotFoundError");
  var k = class e extends Error {
    constructor(r, n, i) {
      super(r);
      this.name = "PrismaClientInitializationError", this.clientVersion = n, this.errorCode = i, Error.captureStackTrace(e);
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientInitializationError";
    }
  };
  E(k, "PrismaClientInitializationError");
  var ue = class extends Error {
    constructor(r, n) {
      super(r);
      this.name = "PrismaClientRustPanicError", this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientRustPanicError";
    }
  };
  E(ue, "PrismaClientRustPanicError");
  var K = class extends Error {
    constructor(r, { clientVersion: n, batchRequestIdx: i }) {
      super(r);
      this.name = "PrismaClientUnknownRequestError", this.clientVersion = n, Object.defineProperty(this, "batchRequestIdx", { value: i, writable: true, enumerable: false });
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientUnknownRequestError";
    }
  };
  E(K, "PrismaClientUnknownRequestError");
  var X = class extends Error {
    constructor(r, { clientVersion: n }) {
      super(r);
      this.name = "PrismaClientValidationError";
      this.clientVersion = n;
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientValidationError";
    }
  };
  E(X, "PrismaClientValidationError");
  var pt = class {
    constructor(t) {
      this._engine = t;
    }
    prometheus(t) {
      return this._engine.metrics({ format: "prometheus", ...t });
    }
    json(t) {
      return this._engine.metrics({ format: "json", ...t });
    }
  };
  var Cl = __require("async_hooks");
  var Al = __require("events");
  var Rl = S(__require("fs"));
  var fr = S(__require("path"));
  var oe = class e {
    constructor(t, r) {
      if (t.length - 1 !== r.length)
        throw t.length === 0 ? new TypeError("Expected at least 1 string") : new TypeError(`Expected ${t.length} strings to have ${t.length - 1} values`);
      let n = r.reduce((s, a) => s + (a instanceof e ? a.values.length : 1), 0);
      this.values = new Array(n), this.strings = new Array(n + 1), this.strings[0] = t[0];
      let i = 0, o = 0;
      for (;i < r.length; ) {
        let s = r[i++], a = t[i];
        if (s instanceof e) {
          this.strings[o] += s.strings[0];
          let l = 0;
          for (;l < s.values.length; )
            this.values[o++] = s.values[l++], this.strings[o] = s.strings[l];
          this.strings[o] += a;
        } else
          this.values[o++] = s, this.strings[o] = a;
      }
    }
    get text() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `\$${t}${this.strings[t++]}`;
      return r;
    }
    get sql() {
      let t = 1, r = this.strings[0];
      for (;t < this.strings.length; )
        r += `?${this.strings[t++]}`;
      return r;
    }
    inspect() {
      return { text: this.text, sql: this.sql, values: this.values };
    }
  };
  var us = li("");
  var xe = class {
    constructor() {
      this._map = new Map;
    }
    get(t) {
      return this._map.get(t)?.value;
    }
    set(t, r) {
      this._map.set(t, { value: r });
    }
    getOrCreate(t, r) {
      let n = this._map.get(t);
      if (n)
        return n.value;
      let i = r();
      return this.set(t, i), i;
    }
  };
  var ds = __require("util");
  var _r = { enumerable: true, configurable: true, writable: true };
  var cs = Symbol.for("nodejs.util.inspect.custom");
  var dt = class {
    constructor(t = 0, r) {
      this.context = r;
      this.lines = [];
      this.currentLine = "";
      this.currentIndent = 0;
      this.currentIndent = t;
    }
    write(t) {
      return typeof t == "string" ? this.currentLine += t : t.write(this), this;
    }
    writeJoined(t, r) {
      let n = r.length - 1;
      for (let i = 0;i < r.length; i++)
        this.write(r[i]), i !== n && this.write(t);
      return this;
    }
    writeLine(t) {
      return this.write(t).newLine();
    }
    newLine() {
      this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = undefined;
      let t = this.afterNextNewLineCallback;
      return this.afterNextNewLineCallback = undefined, t?.(), this;
    }
    withIndent(t) {
      return this.indent(), t(this), this.unindent(), this;
    }
    afterNextNewline(t) {
      return this.afterNextNewLineCallback = t, this;
    }
    indent() {
      return this.currentIndent++, this;
    }
    unindent() {
      return this.currentIndent > 0 && this.currentIndent--, this;
    }
    addMarginSymbol(t) {
      return this.marginSymbol = t, this;
    }
    toString() {
      return this.lines.concat(this.indentedCurrentLine()).join(`
`);
    }
    getCurrentLineLength() {
      return this.currentLine.length;
    }
    indentedCurrentLine() {
      let t = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
      return this.marginSymbol ? this.marginSymbol + t.slice(1) : t;
    }
  };
  var Lr = Symbol();
  var ci = new WeakMap;
  var Ae = class {
    constructor(t) {
      t === Lr ? ci.set(this, `Prisma.${this._getName()}`) : ci.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
    }
    _getName() {
      return this.constructor.name;
    }
    toString() {
      return ci.get(this);
    }
  };
  var jt = class extends Ae {
    _getNamespace() {
      return "NullTypes";
    }
  };
  var Bt = class extends jt {
  };
  pi(Bt, "DbNull");
  var Ut = class extends jt {
  };
  pi(Ut, "JsonNull");
  var Kt = class extends jt {
  };
  pi(Kt, "AnyNull");
  var $r = { classes: { DbNull: Bt, JsonNull: Ut, AnyNull: Kt }, instances: { DbNull: new Bt(Lr), JsonNull: new Ut(Lr), AnyNull: new Kt(Lr) } };
  var ft = 9000000000000000;
  var Le = 1e9;
  var di = "0123456789abcdef";
  var jr = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var Br = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var mi = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -ft, maxE: ft, crypto: false };
  var ys;
  var Re;
  var w = true;
  var Kr = "[DecimalError] ";
  var Ne = Kr + "Invalid argument: ";
  var hs = Kr + "Precision limit exceeded";
  var xs = Kr + "crypto unavailable";
  var bs = "[object Decimal]";
  var ee = Math.floor;
  var j = Math.pow;
  var Zu = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var Xu = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var ec = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var Es = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var ge = 1e7;
  var b = 7;
  var tc = 9007199254740991;
  var rc = jr.length - 1;
  var fi = Br.length - 1;
  var m = { toStringTag: bs };
  m.absoluteValue = m.abs = function() {
    var e = new this.constructor(this);
    return e.s < 0 && (e.s = 1), h(e);
  };
  m.ceil = function() {
    return h(new this.constructor(this), this.e + 1, 2);
  };
  m.clampedTo = m.clamp = function(e, t) {
    var r, n = this, i = n.constructor;
    if (e = new i(e), t = new i(t), !e.s || !t.s)
      return new i(NaN);
    if (e.gt(t))
      throw Error(Ne + t);
    return r = n.cmp(e), r < 0 ? e : n.cmp(t) > 0 ? t : new i(n);
  };
  m.comparedTo = m.cmp = function(e) {
    var t, r, n, i, o = this, s = o.d, a = (e = new o.constructor(e)).d, l = o.s, u = e.s;
    if (!s || !a)
      return !l || !u ? NaN : l !== u ? l : s === a ? 0 : !s ^ l < 0 ? 1 : -1;
    if (!s[0] || !a[0])
      return s[0] ? l : a[0] ? -u : 0;
    if (l !== u)
      return l;
    if (o.e !== e.e)
      return o.e > e.e ^ l < 0 ? 1 : -1;
    for (n = s.length, i = a.length, t = 0, r = n < i ? n : i;t < r; ++t)
      if (s[t] !== a[t])
        return s[t] > a[t] ^ l < 0 ? 1 : -1;
    return n === i ? 0 : n > i ^ l < 0 ? 1 : -1;
  };
  m.cosine = m.cos = function() {
    var e, t, r = this, n = r.constructor;
    return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = nc(n, Cs(n, r)), n.precision = e, n.rounding = t, h(Re == 2 || Re == 3 ? r.neg() : r, e, t, true)) : new n(1) : new n(NaN);
  };
  m.cubeRoot = m.cbrt = function() {
    var e, t, r, n, i, o, s, a, l, u, c = this, p = c.constructor;
    if (!c.isFinite() || c.isZero())
      return new p(c);
    for (w = false, o = c.s * j(c.s * c, 1 / 3), !o || Math.abs(o) == 1 / 0 ? (r = W(c.d), e = c.e, (o = (e - r.length + 1) % 3) && (r += o == 1 || o == -2 ? "0" : "00"), o = j(r, 1 / 3), e = ee((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), o == 1 / 0 ? r = "5e" + e : (r = o.toExponential(), r = r.slice(0, r.indexOf("e") + 1) + e), n = new p(r), n.s = c.s) : n = new p(o.toString()), s = (e = p.precision) + 3;; )
      if (a = n, l = a.times(a).times(a), u = l.plus(c), n = O(u.plus(c).times(a), u.plus(l), s + 2, 1), W(a.d).slice(0, s) === (r = W(n.d)).slice(0, s))
        if (r = r.slice(s - 3, s + 1), r == "9999" || !i && r == "4999") {
          if (!i && (h(a, e + 1, 0), a.times(a).times(a).eq(c))) {
            n = a;
            break;
          }
          s += 4, i = 1;
        } else {
          (!+r || !+r.slice(1) && r.charAt(0) == "5") && (h(n, e + 1, 1), t = !n.times(n).times(n).eq(c));
          break;
        }
    return w = true, h(n, e, p.rounding, t);
  };
  m.decimalPlaces = m.dp = function() {
    var e, t = this.d, r = NaN;
    if (t) {
      if (e = t.length - 1, r = (e - ee(this.e / b)) * b, e = t[e], e)
        for (;e % 10 == 0; e /= 10)
          r--;
      r < 0 && (r = 0);
    }
    return r;
  };
  m.dividedBy = m.div = function(e) {
    return O(this, new this.constructor(e));
  };
  m.dividedToIntegerBy = m.divToInt = function(e) {
    var t = this, r = t.constructor;
    return h(O(t, new r(e), 0, 1, 1), r.precision, r.rounding);
  };
  m.equals = m.eq = function(e) {
    return this.cmp(e) === 0;
  };
  m.floor = function() {
    return h(new this.constructor(this), this.e + 1, 3);
  };
  m.greaterThan = m.gt = function(e) {
    return this.cmp(e) > 0;
  };
  m.greaterThanOrEqualTo = m.gte = function(e) {
    var t = this.cmp(e);
    return t == 1 || t === 0;
  };
  m.hyperbolicCosine = m.cosh = function() {
    var e, t, r, n, i, o = this, s = o.constructor, a = new s(1);
    if (!o.isFinite())
      return new s(o.s ? 1 / 0 : NaN);
    if (o.isZero())
      return a;
    r = s.precision, n = s.rounding, s.precision = r + Math.max(o.e, o.sd()) + 4, s.rounding = 1, i = o.d.length, i < 32 ? (e = Math.ceil(i / 3), t = (1 / Jr(4, e)).toString()) : (e = 16, t = "2.3283064365386962890625e-10"), o = gt(s, 1, o.times(t), new s(1), true);
    for (var l, u = e, c = new s(8);u--; )
      l = o.times(o), o = a.minus(l.times(c.minus(l.times(c))));
    return h(o, s.precision = r, s.rounding = n, true);
  };
  m.hyperbolicSine = m.sinh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    if (!i.isFinite() || i.isZero())
      return new o(i);
    if (t = o.precision, r = o.rounding, o.precision = t + Math.max(i.e, i.sd()) + 4, o.rounding = 1, n = i.d.length, n < 3)
      i = gt(o, 2, i, i, true);
    else {
      e = 1.4 * Math.sqrt(n), e = e > 16 ? 16 : e | 0, i = i.times(1 / Jr(5, e)), i = gt(o, 2, i, i, true);
      for (var s, a = new o(5), l = new o(16), u = new o(20);e--; )
        s = i.times(i), i = i.times(a.plus(s.times(l.times(s).plus(u))));
    }
    return o.precision = t, o.rounding = r, h(i, t, r, true);
  };
  m.hyperbolicTangent = m.tanh = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, O(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s);
  };
  m.inverseCosine = m.acos = function() {
    var e, t = this, r = t.constructor, n = t.abs().cmp(1), i = r.precision, o = r.rounding;
    return n !== -1 ? n === 0 ? t.isNeg() ? fe(r, i, o) : new r(0) : new r(NaN) : t.isZero() ? fe(r, i + 4, o).times(0.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = fe(r, i + 4, o).times(0.5), r.precision = i, r.rounding = o, e.minus(t));
  };
  m.inverseHyperbolicCosine = m.acosh = function() {
    var e, t, r = this, n = r.constructor;
    return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, w = false, r = r.times(r).minus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln()) : new n(r);
  };
  m.inverseHyperbolicSine = m.asinh = function() {
    var e, t, r = this, n = r.constructor;
    return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, w = false, r = r.times(r).plus(1).sqrt().plus(r), w = true, n.precision = e, n.rounding = t, r.ln());
  };
  m.inverseHyperbolicTangent = m.atanh = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isFinite() ? i.e >= 0 ? new o(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = o.precision, t = o.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? h(new o(i), e, t, true) : (o.precision = r = n - i.e, i = O(i.plus(1), new o(1).minus(i), r + e, 1), o.precision = e + 4, o.rounding = 1, i = i.ln(), o.precision = e, o.rounding = t, i.times(0.5))) : new o(NaN);
  };
  m.inverseSine = m.asin = function() {
    var e, t, r, n, i = this, o = i.constructor;
    return i.isZero() ? new o(i) : (t = i.abs().cmp(1), r = o.precision, n = o.rounding, t !== -1 ? t === 0 ? (e = fe(o, r + 4, n).times(0.5), e.s = i.s, e) : new o(NaN) : (o.precision = r + 6, o.rounding = 1, i = i.div(new o(1).minus(i.times(i)).sqrt().plus(1)).atan(), o.precision = r, o.rounding = n, i.times(2)));
  };
  m.inverseTangent = m.atan = function() {
    var e, t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding;
    if (u.isFinite()) {
      if (u.isZero())
        return new c(u);
      if (u.abs().eq(1) && p + 4 <= fi)
        return s = fe(c, p + 4, d).times(0.25), s.s = u.s, s;
    } else {
      if (!u.s)
        return new c(NaN);
      if (p + 4 <= fi)
        return s = fe(c, p + 4, d).times(0.5), s.s = u.s, s;
    }
    for (c.precision = a = p + 10, c.rounding = 1, r = Math.min(28, a / b + 2 | 0), e = r;e; --e)
      u = u.div(u.times(u).plus(1).sqrt().plus(1));
    for (w = false, t = Math.ceil(a / b), n = 1, l = u.times(u), s = new c(u), i = u;e !== -1; )
      if (i = i.times(l), o = s.minus(i.div(n += 2)), i = i.times(l), s = o.plus(i.div(n += 2)), s.d[t] !== undefined)
        for (e = t;s.d[e] === o.d[e] && e--; )
          ;
    return r && (s = s.times(2 << r - 1)), w = true, h(s, c.precision = p, c.rounding = d, true);
  };
  m.isFinite = function() {
    return !!this.d;
  };
  m.isInteger = m.isInt = function() {
    return !!this.d && ee(this.e / b) > this.d.length - 2;
  };
  m.isNaN = function() {
    return !this.s;
  };
  m.isNegative = m.isNeg = function() {
    return this.s < 0;
  };
  m.isPositive = m.isPos = function() {
    return this.s > 0;
  };
  m.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  m.lessThan = m.lt = function(e) {
    return this.cmp(e) < 0;
  };
  m.lessThanOrEqualTo = m.lte = function(e) {
    return this.cmp(e) < 1;
  };
  m.logarithm = m.log = function(e) {
    var t, r, n, i, o, s, a, l, u = this, c = u.constructor, p = c.precision, d = c.rounding, f = 5;
    if (e == null)
      e = new c(10), t = true;
    else {
      if (e = new c(e), r = e.d, e.s < 0 || !r || !r[0] || e.eq(1))
        return new c(NaN);
      t = e.eq(10);
    }
    if (r = u.d, u.s < 0 || !r || !r[0] || u.eq(1))
      return new c(r && !r[0] ? -1 / 0 : u.s != 1 ? NaN : r ? 0 : 1 / 0);
    if (t)
      if (r.length > 1)
        o = true;
      else {
        for (i = r[0];i % 10 === 0; )
          i /= 10;
        o = i !== 1;
      }
    if (w = false, a = p + f, s = _e(u, a), n = t ? Ur(c, a + 10) : _e(e, a), l = O(s, n, a, 1), Qt(l.d, i = p, d))
      do
        if (a += 10, s = _e(u, a), n = t ? Ur(c, a + 10) : _e(e, a), l = O(s, n, a, 1), !o) {
          +W(l.d).slice(i + 1, i + 15) + 1 == 100000000000000 && (l = h(l, p + 1, 0));
          break;
        }
      while (Qt(l.d, i += 10, d));
    return w = true, h(l, p, d);
  };
  m.minus = m.sub = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.constructor;
    if (e = new y(e), !f.d || !e.d)
      return !f.s || !e.s ? e = new y(NaN) : f.d ? e.s = -e.s : e = new y(e.d || f.s !== e.s ? f : NaN), e;
    if (f.s != e.s)
      return e.s = -e.s, f.plus(e);
    if (u = f.d, d = e.d, a = y.precision, l = y.rounding, !u[0] || !d[0]) {
      if (d[0])
        e.s = -e.s;
      else if (u[0])
        e = new y(f);
      else
        return new y(l === 3 ? -0 : 0);
      return w ? h(e, a, l) : e;
    }
    if (r = ee(e.e / b), c = ee(f.e / b), u = u.slice(), o = c - r, o) {
      for (p = o < 0, p ? (t = u, o = -o, s = d.length) : (t = d, r = c, s = u.length), n = Math.max(Math.ceil(a / b), s) + 2, o > n && (o = n, t.length = 1), t.reverse(), n = o;n--; )
        t.push(0);
      t.reverse();
    } else {
      for (n = u.length, s = d.length, p = n < s, p && (s = n), n = 0;n < s; n++)
        if (u[n] != d[n]) {
          p = u[n] < d[n];
          break;
        }
      o = 0;
    }
    for (p && (t = u, u = d, d = t, e.s = -e.s), s = u.length, n = d.length - s;n > 0; --n)
      u[s++] = 0;
    for (n = d.length;n > o; ) {
      if (u[--n] < d[n]) {
        for (i = n;i && u[--i] === 0; )
          u[i] = ge - 1;
        --u[i], u[n] += ge;
      }
      u[n] -= d[n];
    }
    for (;u[--s] === 0; )
      u.pop();
    for (;u[0] === 0; u.shift())
      --r;
    return u[0] ? (e.d = u, e.e = Qr(u, r), w ? h(e, a, l) : e) : new y(l === 3 ? -0 : 0);
  };
  m.modulo = m.mod = function(e) {
    var t, r = this, n = r.constructor;
    return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? h(new n(r), n.precision, n.rounding) : (w = false, n.modulo == 9 ? (t = O(r, e.abs(), 0, 3, 1), t.s *= e.s) : t = O(r, e, 0, n.modulo, 1), t = t.times(e), w = true, r.minus(t));
  };
  m.naturalExponential = m.exp = function() {
    return gi(this);
  };
  m.naturalLogarithm = m.ln = function() {
    return _e(this);
  };
  m.negated = m.neg = function() {
    var e = new this.constructor(this);
    return e.s = -e.s, h(e);
  };
  m.plus = m.add = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p = this, d = p.constructor;
    if (e = new d(e), !p.d || !e.d)
      return !p.s || !e.s ? e = new d(NaN) : p.d || (e = new d(e.d || p.s === e.s ? p : NaN)), e;
    if (p.s != e.s)
      return e.s = -e.s, p.minus(e);
    if (u = p.d, c = e.d, a = d.precision, l = d.rounding, !u[0] || !c[0])
      return c[0] || (e = new d(p)), w ? h(e, a, l) : e;
    if (o = ee(p.e / b), n = ee(e.e / b), u = u.slice(), i = o - n, i) {
      for (i < 0 ? (r = u, i = -i, s = c.length) : (r = c, n = o, s = u.length), o = Math.ceil(a / b), s = o > s ? o + 1 : s + 1, i > s && (i = s, r.length = 1), r.reverse();i--; )
        r.push(0);
      r.reverse();
    }
    for (s = u.length, i = c.length, s - i < 0 && (i = s, r = c, c = u, u = r), t = 0;i; )
      t = (u[--i] = u[i] + c[i] + t) / ge | 0, u[i] %= ge;
    for (t && (u.unshift(t), ++n), s = u.length;u[--s] == 0; )
      u.pop();
    return e.d = u, e.e = Qr(u, n), w ? h(e, a, l) : e;
  };
  m.precision = m.sd = function(e) {
    var t, r = this;
    if (e !== undefined && e !== !!e && e !== 1 && e !== 0)
      throw Error(Ne + e);
    return r.d ? (t = ws(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t;
  };
  m.round = function() {
    var e = this, t = e.constructor;
    return h(new t(e), e.e + 1, t.rounding);
  };
  m.sine = m.sin = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + b, n.rounding = 1, r = oc(n, Cs(n, r)), n.precision = e, n.rounding = t, h(Re > 2 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.squareRoot = m.sqrt = function() {
    var e, t, r, n, i, o, s = this, a = s.d, l = s.e, u = s.s, c = s.constructor;
    if (u !== 1 || !a || !a[0])
      return new c(!u || u < 0 && (!a || a[0]) ? NaN : a ? s : 1 / 0);
    for (w = false, u = Math.sqrt(+s), u == 0 || u == 1 / 0 ? (t = W(a), (t.length + l) % 2 == 0 && (t += "0"), u = Math.sqrt(t), l = ee((l + 1) / 2) - (l < 0 || l % 2), u == 1 / 0 ? t = "5e" + l : (t = u.toExponential(), t = t.slice(0, t.indexOf("e") + 1) + l), n = new c(t)) : n = new c(u.toString()), r = (l = c.precision) + 3;; )
      if (o = n, n = o.plus(O(s, o, r + 2, 1)).times(0.5), W(o.d).slice(0, r) === (t = W(n.d)).slice(0, r))
        if (t = t.slice(r - 3, r + 1), t == "9999" || !i && t == "4999") {
          if (!i && (h(o, l + 1, 0), o.times(o).eq(s))) {
            n = o;
            break;
          }
          r += 4, i = 1;
        } else {
          (!+t || !+t.slice(1) && t.charAt(0) == "5") && (h(n, l + 1, 1), e = !n.times(n).eq(s));
          break;
        }
    return w = true, h(n, l, c.rounding, e);
  };
  m.tangent = m.tan = function() {
    var e, t, r = this, n = r.constructor;
    return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, r = r.sin(), r.s = 1, r = O(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, h(Re == 2 || Re == 4 ? r.neg() : r, e, t, true)) : new n(NaN);
  };
  m.times = m.mul = function(e) {
    var t, r, n, i, o, s, a, l, u, c = this, p = c.constructor, d = c.d, f = (e = new p(e)).d;
    if (e.s *= c.s, !d || !d[0] || !f || !f[0])
      return new p(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : !d || !f ? e.s / 0 : e.s * 0);
    for (r = ee(c.e / b) + ee(e.e / b), l = d.length, u = f.length, l < u && (o = d, d = f, f = o, s = l, l = u, u = s), o = [], s = l + u, n = s;n--; )
      o.push(0);
    for (n = u;--n >= 0; ) {
      for (t = 0, i = l + n;i > n; )
        a = o[i] + f[n] * d[i - n - 1] + t, o[i--] = a % ge | 0, t = a / ge | 0;
      o[i] = (o[i] + t) % ge | 0;
    }
    for (;!o[--s]; )
      o.pop();
    return t ? ++r : o.shift(), e.d = o, e.e = Qr(o, r), w ? h(e, p.precision, p.rounding) : e;
  };
  m.toBinary = function(e, t) {
    return hi(this, 2, e, t);
  };
  m.toDecimalPlaces = m.toDP = function(e, t) {
    var r = this, n = r.constructor;
    return r = new n(r), e === undefined ? r : (se(e, 0, Le), t === undefined ? t = n.rounding : se(t, 0, 8), h(r, e + r.e + 1, t));
  };
  m.toExponential = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = Ee(n, true) : (se(e, 0, Le), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e + 1, t), r = Ee(n, true, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toFixed = function(e, t) {
    var r, n, i = this, o = i.constructor;
    return e === undefined ? r = Ee(i) : (se(e, 0, Le), t === undefined ? t = o.rounding : se(t, 0, 8), n = h(new o(i), e + i.e + 1, t), r = Ee(n, false, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r;
  };
  m.toFraction = function(e) {
    var t, r, n, i, o, s, a, l, u, c, p, d, f = this, y = f.d, g = f.constructor;
    if (!y)
      return new g(f);
    if (u = r = new g(1), n = l = new g(0), t = new g(n), o = t.e = ws(y) - f.e - 1, s = o % b, t.d[0] = j(10, s < 0 ? b + s : s), e == null)
      e = o > 0 ? t : u;
    else {
      if (a = new g(e), !a.isInt() || a.lt(u))
        throw Error(Ne + a);
      e = a.gt(t) ? o > 0 ? t : u : a;
    }
    for (w = false, a = new g(W(y)), c = g.precision, g.precision = o = y.length * b * 2;p = O(a, t, 0, 1, 1), i = r.plus(p.times(n)), i.cmp(e) != 1; )
      r = n, n = i, i = u, u = l.plus(p.times(i)), l = i, i = t, t = a.minus(p.times(i)), a = i;
    return i = O(e.minus(r), n, 0, 1, 1), l = l.plus(i.times(u)), r = r.plus(i.times(n)), l.s = u.s = f.s, d = O(u, n, o, 1).minus(f).abs().cmp(O(l, r, o, 1).minus(f).abs()) < 1 ? [u, n] : [l, r], g.precision = c, w = true, d;
  };
  m.toHexadecimal = m.toHex = function(e, t) {
    return hi(this, 16, e, t);
  };
  m.toNearest = function(e, t) {
    var r = this, n = r.constructor;
    if (r = new n(r), e == null) {
      if (!r.d)
        return r;
      e = new n(1), t = n.rounding;
    } else {
      if (e = new n(e), t === undefined ? t = n.rounding : se(t, 0, 8), !r.d)
        return e.s ? r : e;
      if (!e.d)
        return e.s && (e.s = r.s), e;
    }
    return e.d[0] ? (w = false, r = O(r, e, 0, t, 1).times(e), w = true, h(r)) : (e.s = r.s, r = e), r;
  };
  m.toNumber = function() {
    return +this;
  };
  m.toOctal = function(e, t) {
    return hi(this, 8, e, t);
  };
  m.toPower = m.pow = function(e) {
    var t, r, n, i, o, s, a = this, l = a.constructor, u = +(e = new l(e));
    if (!a.d || !e.d || !a.d[0] || !e.d[0])
      return new l(j(+a, u));
    if (a = new l(a), a.eq(1))
      return a;
    if (n = l.precision, o = l.rounding, e.eq(1))
      return h(a, n, o);
    if (t = ee(e.e / b), t >= e.d.length - 1 && (r = u < 0 ? -u : u) <= tc)
      return i = Ps(l, a, r, n), e.s < 0 ? new l(1).div(i) : h(i, n, o);
    if (s = a.s, s < 0) {
      if (t < e.d.length - 1)
        return new l(NaN);
      if (e.d[t] & 1 || (s = 1), a.e == 0 && a.d[0] == 1 && a.d.length == 1)
        return a.s = s, a;
    }
    return r = j(+a, u), t = r == 0 || !isFinite(r) ? ee(u * (Math.log("0." + W(a.d)) / Math.LN10 + a.e + 1)) : new l(r + "").e, t > l.maxE + 1 || t < l.minE - 1 ? new l(t > 0 ? s / 0 : 0) : (w = false, l.rounding = a.s = 1, r = Math.min(12, (t + "").length), i = gi(e.times(_e(a, n + r)), n), i.d && (i = h(i, n + 5, 1), Qt(i.d, n, o) && (t = n + 10, i = h(gi(e.times(_e(a, t + r)), t), t + 5, 1), +W(i.d).slice(n + 1, n + 15) + 1 == 100000000000000 && (i = h(i, n + 1, 0)))), i.s = s, w = true, l.rounding = o, h(i, n, o));
  };
  m.toPrecision = function(e, t) {
    var r, n = this, i = n.constructor;
    return e === undefined ? r = Ee(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (se(e, 1, Le), t === undefined ? t = i.rounding : se(t, 0, 8), n = h(new i(n), e, t), r = Ee(n, e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r;
  };
  m.toSignificantDigits = m.toSD = function(e, t) {
    var r = this, n = r.constructor;
    return e === undefined ? (e = n.precision, t = n.rounding) : (se(e, 1, Le), t === undefined ? t = n.rounding : se(t, 0, 8)), h(new n(r), e, t);
  };
  m.toString = function() {
    var e = this, t = e.constructor, r = Ee(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() && !e.isZero() ? "-" + r : r;
  };
  m.truncated = m.trunc = function() {
    return h(new this.constructor(this), this.e + 1, 1);
  };
  m.valueOf = m.toJSON = function() {
    var e = this, t = e.constructor, r = Ee(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
    return e.isNeg() ? "-" + r : r;
  };
  var O = function() {
    function e(n, i, o) {
      var s, a = 0, l = n.length;
      for (n = n.slice();l--; )
        s = n[l] * i + a, n[l] = s % o | 0, a = s / o | 0;
      return a && n.unshift(a), n;
    }
    function t(n, i, o, s) {
      var a, l;
      if (o != s)
        l = o > s ? 1 : -1;
      else
        for (a = l = 0;a < o; a++)
          if (n[a] != i[a]) {
            l = n[a] > i[a] ? 1 : -1;
            break;
          }
      return l;
    }
    function r(n, i, o, s) {
      for (var a = 0;o--; )
        n[o] -= a, a = n[o] < i[o] ? 1 : 0, n[o] = a * s + n[o] - i[o];
      for (;!n[0] && n.length > 1; )
        n.shift();
    }
    return function(n, i, o, s, a, l) {
      var u, c, p, d, f, y, g, P, T, C, x, R, ce, G, Ue, $, z, Te, Y, et, gr = n.constructor, Pn = n.s == i.s ? 1 : -1, Z = n.d, F = i.d;
      if (!Z || !Z[0] || !F || !F[0])
        return new gr(!n.s || !i.s || (Z ? F && Z[0] == F[0] : !F) ? NaN : Z && Z[0] == 0 || !F ? Pn * 0 : Pn / 0);
      for (l ? (f = 1, c = n.e - i.e) : (l = ge, f = b, c = ee(n.e / f) - ee(i.e / f)), Y = F.length, z = Z.length, T = new gr(Pn), C = T.d = [], p = 0;F[p] == (Z[p] || 0); p++)
        ;
      if (F[p] > (Z[p] || 0) && c--, o == null ? (G = o = gr.precision, s = gr.rounding) : a ? G = o + (n.e - i.e) + 1 : G = o, G < 0)
        C.push(1), y = true;
      else {
        if (G = G / f + 2 | 0, p = 0, Y == 1) {
          for (d = 0, F = F[0], G++;(p < z || d) && G--; p++)
            Ue = d * l + (Z[p] || 0), C[p] = Ue / F | 0, d = Ue % F | 0;
          y = d || p < z;
        } else {
          for (d = l / (F[0] + 1) | 0, d > 1 && (F = e(F, d, l), Z = e(Z, d, l), Y = F.length, z = Z.length), $ = Y, x = Z.slice(0, Y), R = x.length;R < Y; )
            x[R++] = 0;
          et = F.slice(), et.unshift(0), Te = F[0], F[1] >= l / 2 && ++Te;
          do
            d = 0, u = t(F, x, Y, R), u < 0 ? (ce = x[0], Y != R && (ce = ce * l + (x[1] || 0)), d = ce / Te | 0, d > 1 ? (d >= l && (d = l - 1), g = e(F, d, l), P = g.length, R = x.length, u = t(g, x, P, R), u == 1 && (d--, r(g, Y < P ? et : F, P, l))) : (d == 0 && (u = d = 1), g = F.slice()), P = g.length, P < R && g.unshift(0), r(x, g, R, l), u == -1 && (R = x.length, u = t(F, x, Y, R), u < 1 && (d++, r(x, Y < R ? et : F, R, l))), R = x.length) : u === 0 && (d++, x = [0]), C[p++] = d, u && x[0] ? x[R++] = Z[$] || 0 : (x = [Z[$]], R = 1);
          while (($++ < z || x[0] !== undefined) && G--);
          y = x[0] !== undefined;
        }
        C[0] || C.shift();
      }
      if (f == 1)
        T.e = c, ys = y;
      else {
        for (p = 1, d = C[0];d >= 10; d /= 10)
          p++;
        T.e = p + c * f - 1, h(T, a ? o + T.e + 1 : o, s, y);
      }
      return T;
    };
  }();
  m[Symbol.for("nodejs.util.inspect.custom")] = m.toString;
  m[Symbol.toStringTag] = "Decimal";
  var We = m.constructor = As(mi);
  jr = new We(jr);
  Br = new We(Br);
  var we = We;
  var Jt = class {
    constructor(t, r, n, i, o) {
      this.modelName = t, this.name = r, this.typeName = n, this.isList = i, this.isEnum = o;
    }
    _toGraphQLInputType() {
      let t = this.isList ? "List" : "", r = this.isEnum ? "Enum" : "";
      return `${t}${r}${this.typeName}FieldRefInput<${this.modelName}>`;
    }
  };
  var Gr = class {
    constructor(t) {
      this.value = t;
    }
    write(t) {
      t.write(this.value);
    }
    markAsError() {
      this.value.markAsError();
    }
  };
  var Hr = (e) => e;
  var Wr = { bold: Hr, red: Hr, green: Hr, dim: Hr };
  var Rs = { bold: ne, red: me, green: Qe, dim: ke };
  var xt = { write(e) {
    e.writeLine(",");
  } };
  var Pe = class {
    constructor(t) {
      this.contents = t;
      this.isUnderlined = false;
      this.color = (t2) => t2;
    }
    underline() {
      return this.isUnderlined = true, this;
    }
    setColor(t) {
      return this.color = t, this;
    }
    write(t) {
      let r = t.getCurrentLineLength();
      t.write(this.color(this.contents)), this.isUnderlined && t.afterNextNewline(() => {
        t.write(" ".repeat(r)).writeLine(this.color("~".repeat(this.contents.length)));
      });
    }
  };
  var $e = class {
    constructor() {
      this.hasError = false;
    }
    markAsError() {
      return this.hasError = true, this;
    }
  };
  var bt = class extends $e {
    constructor() {
      super(...arguments);
      this.items = [];
    }
    addItem(r) {
      return this.items.push(new Gr(r)), this;
    }
    getField(r) {
      return this.items[r];
    }
    getPrintWidth() {
      return this.items.length === 0 ? 2 : Math.max(...this.items.map((n) => n.value.getPrintWidth())) + 2;
    }
    write(r) {
      if (this.items.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithItems(r);
    }
    writeEmpty(r) {
      let n = new Pe("[]");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithItems(r) {
      let { colors: n } = r.context;
      r.writeLine("[").withIndent(() => r.writeJoined(xt, this.items).newLine()).write("]"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(n.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var Ms = ": ";
  var zr = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.hasError = false;
    }
    markAsError() {
      this.hasError = true;
    }
    getPrintWidth() {
      return this.name.length + this.value.getPrintWidth() + Ms.length;
    }
    write(t) {
      let r = new Pe(this.name);
      this.hasError && r.underline().setColor(t.context.colors.red), t.write(r).write(Ms).write(this.value);
    }
  };
  var Q = class e extends $e {
    constructor() {
      super(...arguments);
      this.fields = {};
      this.suggestions = [];
    }
    addField(r) {
      this.fields[r.name] = r;
    }
    addSuggestion(r) {
      this.suggestions.push(r);
    }
    getField(r) {
      return this.fields[r];
    }
    getDeepField(r) {
      let [n, ...i] = r, o = this.getField(n);
      if (!o)
        return;
      let s = o;
      for (let a of i) {
        let l;
        if (s.value instanceof e ? l = s.value.getField(a) : s.value instanceof bt && (l = s.value.getField(Number(a))), !l)
          return;
        s = l;
      }
      return s;
    }
    getDeepFieldValue(r) {
      return r.length === 0 ? this : this.getDeepField(r)?.value;
    }
    hasField(r) {
      return !!this.getField(r);
    }
    removeAllFields() {
      this.fields = {};
    }
    removeField(r) {
      delete this.fields[r];
    }
    getFields() {
      return this.fields;
    }
    isEmpty() {
      return Object.keys(this.fields).length === 0;
    }
    getFieldValue(r) {
      return this.getField(r)?.value;
    }
    getDeepSubSelectionValue(r) {
      let n = this;
      for (let i of r) {
        if (!(n instanceof e))
          return;
        let o = n.getSubSelectionValue(i);
        if (!o)
          return;
        n = o;
      }
      return n;
    }
    getDeepSelectionParent(r) {
      let n = this.getSelectionParent();
      if (!n)
        return;
      let i = n;
      for (let o of r) {
        let s = i.value.getFieldValue(o);
        if (!s || !(s instanceof e))
          return;
        let a = s.getSelectionParent();
        if (!a)
          return;
        i = a;
      }
      return i;
    }
    getSelectionParent() {
      let r = this.getField("select");
      if (r?.value instanceof e)
        return { kind: "select", value: r.value };
      let n = this.getField("include");
      if (n?.value instanceof e)
        return { kind: "include", value: n.value };
    }
    getSubSelectionValue(r) {
      return this.getSelectionParent()?.value.fields[r].value;
    }
    getPrintWidth() {
      let r = Object.values(this.fields);
      return r.length == 0 ? 2 : Math.max(...r.map((i) => i.getPrintWidth())) + 2;
    }
    write(r) {
      let n = Object.values(this.fields);
      if (n.length === 0 && this.suggestions.length === 0) {
        this.writeEmpty(r);
        return;
      }
      this.writeWithContents(r, n);
    }
    writeEmpty(r) {
      let n = new Pe("{}");
      this.hasError && n.setColor(r.context.colors.red).underline(), r.write(n);
    }
    writeWithContents(r, n) {
      r.writeLine("{").withIndent(() => {
        r.writeJoined(xt, [...n, ...this.suggestions]).newLine();
      }), r.write("}"), this.hasError && r.afterNextNewline(() => {
        r.writeLine(r.context.colors.red("~".repeat(this.getPrintWidth())));
      });
    }
  };
  var J = class extends $e {
    constructor(r) {
      super();
      this.text = r;
    }
    getPrintWidth() {
      return this.text.length;
    }
    write(r) {
      let n = new Pe(this.text);
      this.hasError && n.underline().setColor(r.context.colors.red), r.write(n);
    }
  };
  var xi = class {
    constructor(t) {
      this.errorMessages = [];
      this.arguments = t;
    }
    write(t) {
      t.write(this.arguments);
    }
    addErrorMessage(t) {
      this.errorMessages.push(t);
    }
    renderAllMessages(t) {
      return this.errorMessages.map((r) => r(t)).join(`
`);
    }
  };
  var Gt = "<unknown>";
  var Gc = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
  var Hc = /\((\S*)(?::(\d+))(?::(\d+))\)/;
  var zc = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var Zc = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
  var Xc = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
  var tp = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
  var np = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
  var bi = class {
    getLocation() {
      return null;
    }
  };
  var Ei = class {
    constructor() {
      this._error = new Error;
    }
    getLocation() {
      let t = this._error.stack;
      if (!t)
        return null;
      let n = ks(t).find((i) => {
        if (!i.file)
          return false;
        let o = Zn(i.file);
        return o !== "<anonymous>" && !o.includes("@prisma") && !o.includes("/packages/client/src/runtime/") && !o.endsWith("/runtime/binary.js") && !o.endsWith("/runtime/library.js") && !o.endsWith("/runtime/edge.js") && !o.endsWith("/runtime/edge-esm.js") && !o.startsWith("internal/") && !i.methodName.includes("new ") && !i.methodName.includes("getCallSite") && !i.methodName.includes("Proxy.") && i.methodName.split(".").length < 4;
      });
      return !n || !n.file ? null : { fileName: n.file, lineNumber: n.lineNumber, columnNumber: n.column };
    }
  };
  var Os = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
  var qs = (e) => Array.isArray(e) ? e : e.split(".");
  var wi = (e, t) => qs(t).reduce((r, n) => r && r[n], e);
  var Vs = (e, t, r) => qs(t).reduceRight((n, i, o, s) => Object.assign({}, wi(e, s.slice(0, o)), { [i]: n }), r);
  var Js = S(Xn());
  var Qs = S(__require("fs"));
  var js = { keyword: Oe, entity: Oe, value: (e) => ne(it(e)), punctuation: it, directive: Oe, function: Oe, variable: (e) => ne(it(e)), string: (e) => ne(Qe(e)), boolean: he, number: Oe, comment: vr };
  var fp = (e) => e;
  var Xr = {};
  var gp = 0;
  var v = { manual: Xr.Prism && Xr.Prism.manual, disableWorkerMessageHandler: Xr.Prism && Xr.Prism.disableWorkerMessageHandler, util: { encode: function(e) {
    if (e instanceof ye) {
      let t = e;
      return new ye(t.type, v.util.encode(t.content), t.alias);
    } else
      return Array.isArray(e) ? e.map(v.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
  }, type: function(e) {
    return Object.prototype.toString.call(e).slice(8, -1);
  }, objId: function(e) {
    return e.__id || Object.defineProperty(e, "__id", { value: ++gp }), e.__id;
  }, clone: function e(t, r) {
    let n, i, o = v.util.type(t);
    switch (r = r || {}, o) {
      case "Object":
        if (i = v.util.objId(t), r[i])
          return r[i];
        n = {}, r[i] = n;
        for (let s in t)
          t.hasOwnProperty(s) && (n[s] = e(t[s], r));
        return n;
      case "Array":
        return i = v.util.objId(t), r[i] ? r[i] : (n = [], r[i] = n, t.forEach(function(s, a) {
          n[a] = e(s, r);
        }), n);
      default:
        return t;
    }
  } }, languages: { extend: function(e, t) {
    let r = v.util.clone(v.languages[e]);
    for (let n in t)
      r[n] = t[n];
    return r;
  }, insertBefore: function(e, t, r, n) {
    n = n || v.languages;
    let i = n[e], o = {};
    for (let a in i)
      if (i.hasOwnProperty(a)) {
        if (a == t)
          for (let l in r)
            r.hasOwnProperty(l) && (o[l] = r[l]);
        r.hasOwnProperty(a) || (o[a] = i[a]);
      }
    let s = n[e];
    return n[e] = o, v.languages.DFS(v.languages, function(a, l) {
      l === s && a != e && (this[a] = o);
    }), o;
  }, DFS: function e(t, r, n, i) {
    i = i || {};
    let o = v.util.objId;
    for (let s in t)
      if (t.hasOwnProperty(s)) {
        r.call(t, s, t[s], n || s);
        let a = t[s], l = v.util.type(a);
        l === "Object" && !i[o(a)] ? (i[o(a)] = true, e(a, r, null, i)) : l === "Array" && !i[o(a)] && (i[o(a)] = true, e(a, r, s, i));
      }
  } }, plugins: {}, highlight: function(e, t, r) {
    let n = { code: e, grammar: t, language: r };
    return v.hooks.run("before-tokenize", n), n.tokens = v.tokenize(n.code, n.grammar), v.hooks.run("after-tokenize", n), ye.stringify(v.util.encode(n.tokens), n.language);
  }, matchGrammar: function(e, t, r, n, i, o, s) {
    for (let g in r) {
      if (!r.hasOwnProperty(g) || !r[g])
        continue;
      if (g == s)
        return;
      let P = r[g];
      P = v.util.type(P) === "Array" ? P : [P];
      for (let T = 0;T < P.length; ++T) {
        let C = P[T], x = C.inside, R = !!C.lookbehind, ce = !!C.greedy, G = 0, Ue = C.alias;
        if (ce && !C.pattern.global) {
          let $ = C.pattern.toString().match(/[imuy]*$/)[0];
          C.pattern = RegExp(C.pattern.source, $ + "g");
        }
        C = C.pattern || C;
        for (let $ = n, z = i;$ < t.length; z += t[$].length, ++$) {
          let Te = t[$];
          if (t.length > e.length)
            return;
          if (Te instanceof ye)
            continue;
          if (ce && $ != t.length - 1) {
            C.lastIndex = z;
            var p = C.exec(e);
            if (!p)
              break;
            var c = p.index + (R ? p[1].length : 0), d = p.index + p[0].length, a = $, l = z;
            for (let F = t.length;a < F && (l < d || !t[a].type && !t[a - 1].greedy); ++a)
              l += t[a].length, c >= l && (++$, z = l);
            if (t[$] instanceof ye)
              continue;
            u = a - $, Te = e.slice(z, l), p.index -= z;
          } else {
            C.lastIndex = 0;
            var p = C.exec(Te), u = 1;
          }
          if (!p) {
            if (o)
              break;
            continue;
          }
          R && (G = p[1] ? p[1].length : 0);
          var c = p.index + G, p = p[0].slice(G), d = c + p.length, f = Te.slice(0, c), y = Te.slice(d);
          let Y = [$, u];
          f && (++$, z += f.length, Y.push(f));
          let et = new ye(g, x ? v.tokenize(p, x) : p, Ue, p, ce);
          if (Y.push(et), y && Y.push(y), Array.prototype.splice.apply(t, Y), u != 1 && v.matchGrammar(e, t, r, $, z, true, g), o)
            break;
        }
      }
    }
  }, tokenize: function(e, t) {
    let r = [e], n = t.rest;
    if (n) {
      for (let i in n)
        t[i] = n[i];
      delete t.rest;
    }
    return v.matchGrammar(e, r, t, 0, 0, false), r;
  }, hooks: { all: {}, add: function(e, t) {
    let r = v.hooks.all;
    r[e] = r[e] || [], r[e].push(t);
  }, run: function(e, t) {
    let r = v.hooks.all[e];
    if (!(!r || !r.length))
      for (var n = 0, i;i = r[n++]; )
        i(t);
  } }, Token: ye };
  v.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/, punctuation: /[{}[\];(),.:]/ };
  v.languages.javascript = v.languages.extend("clike", { "class-name": [v.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: true }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: true }, { pattern: /(^|[^.])\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /-[-=]?|\+[+=]?|!=?=?|<<?=?|>>?>?=?|=(?:==?|>)?|&[&=]?|\|[|=]?|\*\*?=?|\/=?|~|\^=?|%=?|\?|\.{3}/ });
  v.languages.javascript["class-name"][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/;
  v.languages.insertBefore("javascript", "keyword", { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=\s*($|[\r\n,.;})\]]))/, lookbehind: true, greedy: true }, "function-variable": { pattern: /[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: true, inside: v.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: v.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: true, inside: v.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: true, inside: v.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
  v.languages.markup && v.languages.markup.tag.addInlined("script", "javascript");
  v.languages.js = v.languages.javascript;
  v.languages.typescript = v.languages.extend("javascript", { keyword: /\b(?:abstract|as|async|await|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|is|keyof|let|module|namespace|new|null|of|package|private|protected|public|readonly|return|require|set|static|super|switch|this|throw|try|type|typeof|var|void|while|with|yield)\b/, builtin: /\b(?:string|Function|any|number|boolean|Array|symbol|console|Promise|unknown|never)\b/ });
  v.languages.ts = v.languages.typescript;
  ye.stringify = function(e, t) {
    return typeof e == "string" ? e : Array.isArray(e) ? e.map(function(r) {
      return ye.stringify(r, t);
    }).join("") : yp(e.type)(e.content);
  };
  var Us = S(Ho());
  var en = class e {
    static read(t) {
      let r;
      try {
        r = Qs.default.readFileSync(t, "utf-8");
      } catch {
        return null;
      }
      return e.fromContent(r);
    }
    static fromContent(t) {
      let r = t.split(/\r?\n/);
      return new e(1, r);
    }
    constructor(t, r) {
      this.firstLineNumber = t, this.lines = r;
    }
    get lastLineNumber() {
      return this.firstLineNumber + this.lines.length - 1;
    }
    mapLineAt(t, r) {
      if (t < this.firstLineNumber || t > this.lines.length + this.firstLineNumber)
        return this;
      let n = t - this.firstLineNumber, i = [...this.lines];
      return i[n] = r(i[n]), new e(this.firstLineNumber, i);
    }
    mapLines(t) {
      return new e(this.firstLineNumber, this.lines.map((r, n) => t(r, this.firstLineNumber + n)));
    }
    lineAt(t) {
      return this.lines[t - this.firstLineNumber];
    }
    prependSymbolAt(t, r) {
      return this.mapLines((n, i) => i === t ? `${r} ${n}` : `  ${n}`);
    }
    slice(t, r) {
      let n = this.lines.slice(t - 1, r).join(`
`);
      return new e(t, Ks(n).split(`
`));
    }
    highlight() {
      let t = Bs(this.toString());
      return new e(this.firstLineNumber, t.split(`
`));
    }
    toString() {
      return this.lines.join(`
`);
    }
  };
  var xp = { red: me, gray: vr, dim: ke, bold: ne, underline: te, highlightSource: (e) => e.highlight() };
  var bp = { red: (e) => e, gray: (e) => e, dim: (e) => e, bold: (e) => e, underline: (e) => e, highlightSource: (e) => e };
  var Ap = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
  var Rp = ["aggregate", "count", "groupBy"];
  var Ti = Symbol();
  var ea = (e) => e;
  var nn = class {
    constructor(t, r) {
      this.extension = t;
      this.previous = r;
      this.computedFieldsCache = new xe;
      this.modelExtensionsCache = new xe;
      this.queryCallbacksCache = new xe;
      this.clientExtensions = $t(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      this.batchCallbacks = $t(() => {
        let t2 = this.previous?.getAllBatchQueryCallbacks() ?? [], r2 = this.extension.query?.$__internalBatch;
        return r2 ? t2.concat(r2) : t2;
      });
    }
    getAllComputedFields(t) {
      return this.computedFieldsCache.getOrCreate(t, () => aa(this.previous?.getAllComputedFields(t), this.extension, t));
    }
    getAllClientExtensions() {
      return this.clientExtensions.get();
    }
    getAllModelExtensions(t) {
      return this.modelExtensionsCache.getOrCreate(t, () => {
        let r = ve(t);
        return !this.extension.model || !(this.extension.model[r] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t) : { ...this.previous?.getAllModelExtensions(t), ...this.extension.model.$allModels, ...this.extension.model[r] };
      });
    }
    getAllQueryCallbacks(t, r) {
      return this.queryCallbacksCache.getOrCreate(`${t}:${r}`, () => {
        let n = this.previous?.getAllQueryCallbacks(t, r) ?? [], i = [], o = this.extension.query;
        return !o || !(o[t] || o.$allModels || o[r] || o.$allOperations) ? n : (o[t] !== undefined && (o[t][r] !== undefined && i.push(o[t][r]), o[t].$allOperations !== undefined && i.push(o[t].$allOperations)), t !== "$none" && o.$allModels !== undefined && (o.$allModels[r] !== undefined && i.push(o.$allModels[r]), o.$allModels.$allOperations !== undefined && i.push(o.$allModels.$allOperations)), o[r] !== undefined && i.push(o[r]), o.$allOperations !== undefined && i.push(o.$allOperations), n.concat(i));
      });
    }
    getAllBatchQueryCallbacks() {
      return this.batchCallbacks.get();
    }
  };
  var on = class e {
    constructor(t) {
      this.head = t;
    }
    static empty() {
      return new e;
    }
    static single(t) {
      return new e(new nn(t));
    }
    isEmpty() {
      return this.head === undefined;
    }
    append(t) {
      return new e(new nn(t, this.head));
    }
    getAllComputedFields(t) {
      return this.head?.getAllComputedFields(t);
    }
    getAllClientExtensions() {
      return this.head?.getAllClientExtensions();
    }
    getAllModelExtensions(t) {
      return this.head?.getAllModelExtensions(t);
    }
    getAllQueryCallbacks(t, r) {
      return this.head?.getAllQueryCallbacks(t, r) ?? [];
    }
    getAllBatchQueryCallbacks() {
      return this.head?.getAllBatchQueryCallbacks() ?? [];
    }
  };
  var ua = D("prisma:client");
  var ca = { Vercel: "vercel", "Netlify CI": "netlify" };
  var Pt = class {
  };
  var ha = S(__require("fs"));
  var Yt = S(__require("path"));
  var $p = D("prisma:client:engines:resolveEnginePath");
  var qp = () => new RegExp("runtime[\\\\/]library\\.m?js$");
  var Ci = S(ni());
  var Pa = S(is());
  var cn = class extends Error {
    constructor(r, n) {
      super(r);
      this.clientVersion = n.clientVersion, this.cause = n.cause;
    }
    get [Symbol.toStringTag]() {
      return this.name;
    }
  };
  var ae = class extends cn {
    constructor(r, n) {
      super(r, n);
      this.isRetryable = n.isRetryable ?? true;
    }
  };
  var vt = class extends ae {
    constructor(r) {
      super("This request must be retried", M(r, true));
      this.name = "ForcedRetryError";
      this.code = "P5001";
    }
  };
  E(vt, "ForcedRetryError");
  var ze = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "InvalidDatasourceError";
      this.code = "P5002";
    }
  };
  E(ze, "InvalidDatasourceError");
  var Ye = class extends ae {
    constructor(r, n) {
      super(r, M(n, false));
      this.name = "NotImplementedYetError";
      this.code = "P5004";
    }
  };
  E(Ye, "NotImplementedYetError");
  var L = class extends ae {
    constructor(r, n) {
      super(r, n);
      this.response = n.response;
      let i = this.response.headers.get("prisma-request-id");
      if (i) {
        let o = `(The request id was: ${i})`;
        this.message = this.message + " " + o;
      }
    }
  };
  var Ze = class extends L {
    constructor(r) {
      super("Schema needs to be uploaded", M(r, true));
      this.name = "SchemaMissingError";
      this.code = "P5005";
    }
  };
  E(Ze, "SchemaMissingError");
  var Ai = "This request could not be understood by the server";
  var Zt = class extends L {
    constructor(r, n, i) {
      super(n || Ai, M(r, false));
      this.name = "BadRequestError";
      this.code = "P5000";
      i && (this.code = i);
    }
  };
  E(Zt, "BadRequestError");
  var Xt = class extends L {
    constructor(r, n) {
      super("Engine not started: healthcheck timeout", M(r, true));
      this.name = "HealthcheckTimeoutError";
      this.code = "P5013";
      this.logs = n;
    }
  };
  E(Xt, "HealthcheckTimeoutError");
  var er = class extends L {
    constructor(r, n, i) {
      super(n, M(r, true));
      this.name = "EngineStartupError";
      this.code = "P5014";
      this.logs = i;
    }
  };
  E(er, "EngineStartupError");
  var tr = class extends L {
    constructor(r) {
      super("Engine version is not supported", M(r, false));
      this.name = "EngineVersionNotSupportedError";
      this.code = "P5012";
    }
  };
  E(tr, "EngineVersionNotSupportedError");
  var Ri = "Request timed out";
  var rr = class extends L {
    constructor(r, n = Ri) {
      super(n, M(r, false));
      this.name = "GatewayTimeoutError";
      this.code = "P5009";
    }
  };
  E(rr, "GatewayTimeoutError");
  var jp = "Interactive transaction error";
  var nr = class extends L {
    constructor(r, n = jp) {
      super(n, M(r, false));
      this.name = "InteractiveTransactionError";
      this.code = "P5015";
    }
  };
  E(nr, "InteractiveTransactionError");
  var Bp = "Request parameters are invalid";
  var ir = class extends L {
    constructor(r, n = Bp) {
      super(n, M(r, false));
      this.name = "InvalidRequestError";
      this.code = "P5011";
    }
  };
  E(ir, "InvalidRequestError");
  var Mi = "Requested resource does not exist";
  var or = class extends L {
    constructor(r, n = Mi) {
      super(n, M(r, false));
      this.name = "NotFoundError";
      this.code = "P5003";
    }
  };
  E(or, "NotFoundError");
  var Si = "Unknown server error";
  var Tt = class extends L {
    constructor(r, n, i) {
      super(n || Si, M(r, true));
      this.name = "ServerError";
      this.code = "P5006";
      this.logs = i;
    }
  };
  E(Tt, "ServerError");
  var Ii = "Unauthorized, check your connection string";
  var sr = class extends L {
    constructor(r, n = Ii) {
      super(n, M(r, false));
      this.name = "UnauthorizedError";
      this.code = "P5007";
    }
  };
  E(sr, "UnauthorizedError");
  var Fi = "Usage exceeded, retry again later";
  var ar = class extends L {
    constructor(r, n = Fi) {
      super(n, M(r, true));
      this.name = "UsageExceededError";
      this.code = "P5008";
    }
  };
  E(ar, "UsageExceededError");
  var Ra = { "@prisma/debug": "workspace:*", "@prisma/engines-version": "5.3.1-2.61e140623197a131c2a6189271ffee05a7aa9a59", "@prisma/fetch-engine": "workspace:*", "@prisma/get-platform": "workspace:*", "@swc/core": "1.3.75", "@swc/jest": "0.2.29", "@types/jest": "29.5.4", "@types/node": "18.17.12", execa: "5.1.1", jest: "29.6.4", typescript: "5.2.2" };
  var ur = class extends ae {
    constructor(r, n) {
      super(`Cannot fetch data from service:
${r}`, M(n, true));
      this.name = "RequestError";
      this.code = "P5010";
    }
  };
  E(ur, "RequestError");
  var Hp = typeof require < "u" ? require : () => {
  };
  var Oi = class {
    constructor(t = {}) {
      this.headers = new Map;
      for (let [r, n] of Object.entries(t))
        if (typeof n == "string")
          this.headers.set(r, n);
        else if (Array.isArray(n))
          for (let i of n)
            this.headers.set(r, i);
    }
    append(t, r) {
      this.headers.set(t, r);
    }
    delete(t) {
      this.headers.delete(t);
    }
    get(t) {
      return this.headers.get(t) ?? null;
    }
    has(t) {
      return this.headers.has(t);
    }
    set(t, r) {
      this.headers.set(t, r);
    }
    forEach(t, r) {
      for (let [n, i] of this.headers)
        t.call(r, i, n, this);
    }
  };
  var Wp = /^[1-9][0-9]*\.[0-9]+\.[0-9]+$/;
  var Ma = D("prisma:client:dataproxyEngine");
  var Ia = 3;
  var Di = D("prisma:client:dataproxyEngine");
  var _i = class {
    constructor({ apiKey: t, tracingHelper: r, logLevel: n, logQueries: i }) {
      this.apiKey = t, this.tracingHelper = r, this.logLevel = n, this.logQueries = i;
    }
    build({ traceparent: t, interactiveTransaction: r } = {}) {
      let n = { Authorization: `Bearer ${this.apiKey}` };
      this.tracingHelper.isEnabled() && (n.traceparent = t ?? this.tracingHelper.getTraceParent()), r && (n["X-transaction-id"] = r.id);
      let i = this.buildCaptureSettings();
      return i.length > 0 && (n["X-capture-telemetry"] = i.join(", ")), n;
    }
    buildCaptureSettings() {
      let t = [];
      return this.tracingHelper.isEnabled() && t.push("tracing"), this.logLevel && t.push(this.logLevel), this.logQueries && t.push("query"), t;
    }
  };
  var cr = class extends Pt {
    constructor(r) {
      super();
      Aa(r), this.config = r, this.env = { ...this.config.env, ...process.env }, this.inlineSchema = r.inlineSchema ?? "", this.inlineDatasources = r.inlineDatasources ?? {}, this.inlineSchemaHash = r.inlineSchemaHash ?? "", this.clientVersion = r.clientVersion ?? "unknown", this.logEmitter = r.logEmitter, this.tracingHelper = this.config.tracingHelper;
    }
    apiKey() {
      return this.headerBuilder.apiKey;
    }
    version() {
      return "unknown";
    }
    async start() {
      this.startPromise !== undefined && await this.startPromise, this.startPromise = (async () => {
        let [r, n] = this.extractHostAndApiKey();
        this.host = r, this.headerBuilder = new _i({ apiKey: n, tracingHelper: this.tracingHelper, logLevel: this.config.logLevel, logQueries: this.config.logQueries }), this.remoteClientVersion = await Sa(r, this.config), Di("host", this.host);
      })(), await this.startPromise;
    }
    async stop() {
    }
    propagateResponseExtensions(r) {
      r?.logs?.length && r.logs.forEach((n) => {
        switch (n.level) {
          case "debug":
          case "error":
          case "trace":
          case "warn":
          case "info":
            break;
          case "query": {
            let i = typeof n.attributes.query == "string" ? n.attributes.query : "";
            if (!this.tracingHelper.isEnabled()) {
              let [o] = i.split("/* traceparent");
              i = o;
            }
            this.logEmitter.emit("query", { query: i, timestamp: n.timestamp, duration: n.attributes.duration_ms, params: n.attributes.params, target: n.attributes.target });
          }
        }
      }), r?.traces?.length && this.tracingHelper.createEngineSpan({ span: true, spans: r.traces });
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the remote query engine');
      this.logEmitter.on(r, n);
    }
    async url(r) {
      return await this.start(), `https://${this.host}/${this.remoteClientVersion}/${this.inlineSchemaHash}/${r}`;
    }
    async uploadSchema() {
      let r = { name: "schemaUpload", internal: true };
      return this.tracingHelper.runInChildSpan(r, async () => {
        let n = await Xe(await this.url("schema"), { method: "PUT", headers: this.headerBuilder.build(), body: this.inlineSchema, clientVersion: this.clientVersion });
        n.ok || Di("schema response status", n.status);
        let i = await lr(n, this.clientVersion);
        if (i)
          throw this.logEmitter.emit("warn", { message: `Error while uploading schema: ${i.message}` }), i;
        this.logEmitter.emit("info", { message: `Schema (re)uploaded (hash: ${this.inlineSchemaHash})` });
      });
    }
    request(r, { traceparent: n, interactiveTransaction: i, customDataProxyFetch: o }) {
      return this.requestInternal({ body: r, traceparent: n, interactiveTransaction: i, customDataProxyFetch: o });
    }
    async requestBatch(r, { traceparent: n, transaction: i, customDataProxyFetch: o }) {
      let s = i?.kind === "itx" ? i.options : undefined, a = ln(r, i), { batchResult: l, elapsed: u } = await this.requestInternal({ body: a, customDataProxyFetch: o, interactiveTransaction: s, traceparent: n });
      return l.map((c) => ("errors" in c) && c.errors.length > 0 ? zt(c.errors[0], this.clientVersion) : { data: c, elapsed: u });
    }
    requestInternal({ body: r, traceparent: n, customDataProxyFetch: i, interactiveTransaction: o }) {
      return this.withRetry({ actionGerund: "querying", callback: async ({ logHttpCall: s }) => {
        let a = o ? `${o.payload.endpoint}/graphql` : await this.url("graphql");
        s(a);
        let l = await Xe(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n, interactiveTransaction: o }), body: JSON.stringify(r), clientVersion: this.clientVersion }, i);
        l.ok || Di("graphql response status", l.status), await this.handleError(await lr(l, this.clientVersion));
        let u = await l.json(), c = u.extensions;
        if (c && this.propagateResponseExtensions(c), u.errors)
          throw u.errors.length === 1 ? zt(u.errors[0], this.config.clientVersion) : new K(u.errors, { clientVersion: this.config.clientVersion });
        return u;
      } });
    }
    async transaction(r, n, i) {
      let o = { start: "starting", commit: "committing", rollback: "rolling back" };
      return this.withRetry({ actionGerund: `${o[r]} transaction`, callback: async ({ logHttpCall: s }) => {
        if (r === "start") {
          let a = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel }), l = await this.url("transaction/start");
          s(l);
          let u = await Xe(l, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), body: a, clientVersion: this.clientVersion });
          await this.handleError(await lr(u, this.clientVersion));
          let c = await u.json(), p = c.extensions;
          p && this.propagateResponseExtensions(p);
          let d = c.id, f = c["data-proxy"].endpoint;
          return { id: d, payload: { endpoint: f } };
        } else {
          let a = `${i.payload.endpoint}/${r}`;
          s(a);
          let l = await Xe(a, { method: "POST", headers: this.headerBuilder.build({ traceparent: n.traceparent }), clientVersion: this.clientVersion });
          await this.handleError(await lr(l, this.clientVersion));
          let c = (await l.json()).extensions;
          c && this.propagateResponseExtensions(c);
          return;
        }
      } });
    }
    extractHostAndApiKey() {
      let r = { clientVersion: this.clientVersion }, n = Object.keys(this.inlineDatasources)[0], i = un({ inlineDatasources: this.inlineDatasources, overrideDatasources: this.config.overrideDatasources, clientVersion: this.clientVersion, env: this.env }), o;
      try {
        o = new URL(i);
      } catch {
        throw new ze(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      }
      let { protocol: s, host: a, searchParams: l } = o;
      if (s !== "prisma:")
        throw new ze(`Error validating datasource \`${n}\`: the URL must start with the protocol \`prisma://\``, r);
      let u = l.get("api_key");
      if (u === null || u.length < 1)
        throw new ze(`Error validating datasource \`${n}\`: the URL must contain a valid API key`, r);
      return [a, u];
    }
    metrics() {
      throw new Ye("Metrics are not yet supported for Accelerate", { clientVersion: this.clientVersion });
    }
    async withRetry(r) {
      for (let n = 0;; n++) {
        let i = (o) => {
          this.logEmitter.emit("info", { message: `Calling ${o} (n=${n})` });
        };
        try {
          return await r.callback({ logHttpCall: i });
        } catch (o) {
          if (!(o instanceof ae) || !o.isRetryable)
            throw o;
          if (n >= Ia)
            throw o instanceof vt ? o.cause : o;
          this.logEmitter.emit("warn", { message: `Attempt ${n + 1}/${Ia} failed for ${r.actionGerund}: ${o.message ?? "(unknown)"}` });
          let s = await Ca(n);
          this.logEmitter.emit("warn", { message: `Retrying after ${s}ms` });
        }
      }
    }
    async handleError(r) {
      if (r instanceof Ze)
        throw await this.uploadSchema(), new vt({ clientVersion: this.clientVersion, cause: r });
      if (r)
        throw r;
    }
  };
  var _a = S(__require("fs"));
  var Li = S(__require("os"));
  var ka = S(__require("path"));
  var Ni = Symbol("PrismaLibraryEngineCache");
  var pn = class {
    constructor(t) {
      this.config = t;
    }
    async loadLibrary() {
      let t = await Bn(), r = await xa("library", this.config);
      try {
        return this.config.tracingHelper.runInChildSpan({ name: "loadLibrary", internal: true }, () => Xp(r));
      } catch (n) {
        let i = Yn({ e: n, platformInfo: t, id: r });
        throw new k(i, this.config.clientVersion);
      }
    }
  };
  var Me = D("prisma:client:libraryEngine");
  var Oa = [...Un, "native"];
  var Da = 0;
  var pr = class extends Pt {
    constructor(r, n = new pn(r)) {
      super();
      try {
        this.datamodel = _a.default.readFileSync(r.datamodelPath, "utf-8");
      } catch (s) {
        throw s.stack.match(/\/\.next|\/next@|\/next\//) ? new k(`Your schema.prisma could not be found, and we detected that you are using Next.js.
Find out why and learn how to fix this: https://pris.ly/d/schema-not-found-nextjs`, r.clientVersion) : r.isBundled === true ? new k("Prisma Client could not find its `schema.prisma`. This is likely caused by a bundling step, which leads to `schema.prisma` not being copied near the resulting bundle. We would appreciate if you could take the time to share some information with us.\nPlease help us by answering a few questions: https://pris.ly/bundler-investigation-error", r.clientVersion) : s;
      }
      this.config = r, this.libraryStarted = false, this.logQueries = r.logQueries ?? false, this.logLevel = r.logLevel ?? "error", this.libraryLoader = n, this.logEmitter = r.logEmitter, r.enableDebugLogs && (this.logLevel = "debug");
      let i = Object.keys(r.overrideDatasources)[0], o = r.overrideDatasources[i]?.url;
      i !== undefined && o !== undefined && (this.datasourceOverrides = { [i]: o }), this.libraryInstantiationPromise = this.instantiateLibrary(), this.checkForTooManyEngines();
    }
    checkForTooManyEngines() {
      Da === 10 && console.warn(`${he("warn(prisma-client)")} This is the 10th instance of Prisma Client being started. Make sure this is intentional.`);
    }
    async transaction(r, n, i) {
      await this.start();
      let o = JSON.stringify(n), s;
      if (r === "start") {
        let l = JSON.stringify({ max_wait: i?.maxWait ?? 2000, timeout: i?.timeout ?? 5000, isolation_level: i?.isolationLevel });
        s = await this.engine?.startTransaction(l, o);
      } else
        r === "commit" ? s = await this.engine?.commitTransaction(i.id, o) : r === "rollback" && (s = await this.engine?.rollbackTransaction(i.id, o));
      let a = this.parseEngineResponse(s);
      if (a.error_code)
        throw new U(a.message, { code: a.error_code, clientVersion: this.config.clientVersion, meta: a.meta });
      return a;
    }
    async instantiateLibrary() {
      if (Me("internalSetup"), this.libraryInstantiationPromise)
        return this.libraryInstantiationPromise;
      _n(), this.platform = await this.getPlatform(), await this.loadEngine(), this.version();
    }
    async getPlatform() {
      if (this.platform)
        return this.platform;
      let r = await lt();
      if (!Oa.includes(r))
        throw new k(`Unknown ${me("PRISMA_QUERY_ENGINE_LIBRARY")} ${me(ne(r))}. Possible binaryTargets: ${Qe(Oa.join(", "))} or a path to the query engine library.
You may have to run ${Qe("prisma generate")} for your changes to take effect.`, this.config.clientVersion);
      return r;
    }
    parseEngineResponse(r) {
      if (!r)
        throw new K("Response from the Engine was empty", { clientVersion: this.config.clientVersion });
      try {
        return JSON.parse(r);
      } catch {
        throw new K("Unable to JSON.parse response from engine", { clientVersion: this.config.clientVersion });
      }
    }
    async loadEngine() {
      if (!this.engine) {
        this.QueryEngineConstructor || (this.library = await this.libraryLoader.loadLibrary(), this.QueryEngineConstructor = this.library.QueryEngine);
        try {
          let r = new WeakRef(this);
          this.engine = new this.QueryEngineConstructor({ datamodel: this.datamodel, env: process.env, logQueries: this.config.logQueries ?? false, ignoreEnvVarErrors: true, datasourceOverrides: this.datasourceOverrides ?? {}, logLevel: this.logLevel, configDir: this.config.cwd, engineProtocol: "json" }, (n) => {
            r.deref()?.logger(n);
          }), Da++;
        } catch (r) {
          let n = r, i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new k(i.message, this.config.clientVersion, i.error_code);
        }
      }
    }
    logger(r) {
      let n = this.parseEngineResponse(r);
      if (n) {
        if ("span" in n) {
          this.config.tracingHelper.createEngineSpan(n);
          return;
        }
        n.level = n?.level.toLowerCase() ?? "unknown", ed(n) ? this.logEmitter.emit("query", { timestamp: new Date, query: n.query, params: n.params, duration: Number(n.duration_ms), target: n.module_path }) : td(n) ? this.loggerRustPanic = new ue(this.getErrorMessageWithLink(`${n.message}: ${n.reason} in ${n.file}:${n.line}:${n.column}`), this.config.clientVersion) : this.logEmitter.emit(n.level, { timestamp: new Date, message: n.message, target: n.module_path });
      }
    }
    getErrorMessageWithLink(r) {
      return Ta({ platform: this.platform, title: r, version: this.config.clientVersion, engineVersion: this.versionInfo?.commit, database: this.config.activeProvider, query: this.lastQuery });
    }
    parseInitError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    parseRequestError(r) {
      try {
        return JSON.parse(r);
      } catch {
      }
      return r;
    }
    on(r, n) {
      if (r === "beforeExit")
        throw new Error('"beforeExit" hook is not applicable to the library engine since Prisma 5.0.0, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      this.logEmitter.on(r, n);
    }
    async start() {
      if (await this.libraryInstantiationPromise, await this.libraryStoppingPromise, this.libraryStartingPromise)
        return Me(`library already starting, this.libraryStarted: ${this.libraryStarted}`), this.libraryStartingPromise;
      if (this.libraryStarted)
        return;
      let r = async () => {
        Me("library starting");
        try {
          let n = { traceparent: this.config.tracingHelper.getTraceParent() };
          await this.engine?.connect(JSON.stringify(n)), this.libraryStarted = true, Me("library started");
        } catch (n) {
          let i = this.parseInitError(n.message);
          throw typeof i == "string" ? n : new k(i.message, this.config.clientVersion, i.error_code);
        } finally {
          this.libraryStartingPromise = undefined;
        }
      };
      return this.libraryStartingPromise = this.config.tracingHelper.runInChildSpan("connect", r), this.libraryStartingPromise;
    }
    async stop() {
      if (await this.libraryStartingPromise, await this.executingQueryPromise, this.libraryStoppingPromise)
        return Me("library is already stopping"), this.libraryStoppingPromise;
      if (!this.libraryStarted)
        return;
      let r = async () => {
        await new Promise((i) => setTimeout(i, 5)), Me("library stopping");
        let n = { traceparent: this.config.tracingHelper.getTraceParent() };
        await this.engine?.disconnect(JSON.stringify(n)), this.libraryStarted = false, this.libraryStoppingPromise = undefined, Me("library stopped");
      };
      return this.libraryStoppingPromise = this.config.tracingHelper.runInChildSpan("disconnect", r), this.libraryStoppingPromise;
    }
    version() {
      return this.versionInfo = this.library?.version(), this.versionInfo?.version ?? "unknown";
    }
    debugPanic(r) {
      return this.library?.debugPanic(r);
    }
    async request(r, { traceparent: n, interactiveTransaction: i }) {
      Me(`sending request, this.libraryStarted: ${this.libraryStarted}`);
      let o = JSON.stringify({ traceparent: n }), s = JSON.stringify(r);
      try {
        await this.start(), this.executingQueryPromise = this.engine?.query(s, o, i?.id), this.lastQuery = s;
        let a = this.parseEngineResponse(await this.executingQueryPromise);
        if (a.errors)
          throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
        if (this.loggerRustPanic)
          throw this.loggerRustPanic;
        return { data: a, elapsed: 0 };
      } catch (a) {
        if (a instanceof k)
          throw a;
        if (a.code === "GenericFailure" && a.message?.startsWith("PANIC:"))
          throw new ue(this.getErrorMessageWithLink(a.message), this.config.clientVersion);
        let l = this.parseRequestError(a.message);
        throw typeof l == "string" ? a : new K(`${l.message}
${l.backtrace}`, { clientVersion: this.config.clientVersion });
      }
    }
    async requestBatch(r, { transaction: n, traceparent: i }) {
      Me("requestBatch");
      let o = ln(r, n);
      await this.start(), this.lastQuery = JSON.stringify(o), this.executingQueryPromise = this.engine.query(this.lastQuery, JSON.stringify({ traceparent: i }), Fa(n));
      let s = await this.executingQueryPromise, a = this.parseEngineResponse(s);
      if (a.errors)
        throw a.errors.length === 1 ? this.buildQueryError(a.errors[0]) : new K(JSON.stringify(a.errors), { clientVersion: this.config.clientVersion });
      let { batchResult: l, errors: u } = a;
      if (Array.isArray(l))
        return l.map((c) => c.errors && c.errors.length > 0 ? this.loggerRustPanic ?? this.buildQueryError(c.errors[0]) : { data: c, elapsed: 0 });
      throw u && u.length === 1 ? new Error(u[0].error) : new Error(JSON.stringify(a));
    }
    buildQueryError(r) {
      return r.user_facing_error.is_panic ? new ue(this.getErrorMessageWithLink(r.user_facing_error.message), this.config.clientVersion) : zt(r, this.config.clientVersion);
    }
    async metrics(r) {
      await this.start();
      let n = await this.engine.metrics(JSON.stringify(r));
      return r.format === "prometheus" ? n : this.parseEngineResponse(n);
    }
  };
  var Ba = S($i());
  var Se = class {
    constructor(t, r) {
      this.name = t;
      this.value = r;
      this.isRequired = false;
    }
    makeRequired() {
      return this.isRequired = true, this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.addMarginSymbol(r(this.isRequired ? "+" : "?")), t.write(r(this.name)), this.isRequired || t.write(r("?")), t.write(r(": ")), typeof this.value == "string" ? t.write(r(this.value)) : t.write(this.value);
    }
  };
  var mn = class {
    constructor() {
      this.fields = [];
    }
    addField(t, r) {
      return this.fields.push({ write(n) {
        let { green: i, dim: o } = n.context.colors;
        n.write(i(o(`${t}: ${r}`))).addMarginSymbol(i(o("+")));
      } }), this;
    }
    write(t) {
      let { colors: { green: r } } = t.context;
      t.writeLine(r("{")).withIndent(() => {
        t.writeJoined(xt, this.fields).newLine();
      }).write(r("}")).addMarginSymbol(r("+"));
    }
  };
  var xd = 3;
  var Ed = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", update: "updateOne", updateMany: "updateMany", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
  var qi = class e {
    constructor(t) {
      this.params = t;
      this.params.modelName && (this.model = this.params.runtimeDataModel.models[this.params.modelName]);
    }
    throwValidationError(t) {
      yn({ errors: [t], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion });
    }
    getSelectionPath() {
      return this.params.selectionPath;
    }
    getArgumentPath() {
      return this.params.argumentPath;
    }
    getArgumentName() {
      return this.params.argumentPath[this.params.argumentPath.length - 1];
    }
    getOutputTypeDescription() {
      if (!(!this.params.modelName || !this.model))
        return { name: this.params.modelName, fields: this.model.fields.map((t) => ({ name: t.name, typeName: "boolean", isRelation: t.kind === "object" })) };
    }
    isRawAction() {
      return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
    }
    getComputedFields() {
      if (this.params.modelName)
        return this.params.extensions.getAllComputedFields(this.params.modelName);
    }
    findField(t) {
      return this.model?.fields.find((r) => r.name === t);
    }
    nestSelection(t) {
      let r = this.findField(t), n = r?.kind === "object" ? r.type : undefined;
      return new e({ ...this.params, modelName: n, selectionPath: this.params.selectionPath.concat(t) });
    }
    nestArgument(t) {
      return new e({ ...this.params, argumentPath: this.params.argumentPath.concat(t) });
    }
  };
  var za = (e) => ({ command: e });
  var Ya = (e) => e.strings.reduce((t, r, n) => `${t}@P${n}${r}`);
  var Id = /^(\s*alter\s)/i;
  var tl = D("prisma:client");
  var Bi = (e, t) => (r) => {
    let n = "", i;
    if (Array.isArray(r)) {
      let [o, ...s] = r;
      n = o, i = { values: mr(s || []), __prismaRawParameters__: true };
    } else
      switch (e) {
        case "sqlite":
        case "mysql": {
          n = r.sql, i = { values: mr(r.values), __prismaRawParameters__: true };
          break;
        }
        case "cockroachdb":
        case "postgresql": {
          n = r.text, i = { values: mr(r.values), __prismaRawParameters__: true };
          break;
        }
        case "sqlserver": {
          n = Ya(r), i = { values: mr(r.values), __prismaRawParameters__: true };
          break;
        }
        default:
          throw new Error(`The ${e} provider does not support ${t}`);
      }
    return i?.values ? tl(`prisma.${t}(${n}, ${i.values})`) : tl(`prisma.${t}(${n})`), { query: n, parameters: i };
  };
  var rl = { requestArgsToMiddlewareArgs(e) {
    return [e.strings, ...e.values];
  }, middlewareArgsToRequestArgs(e) {
    let [t, ...r] = e;
    return new oe(t, r);
  } };
  var nl = { requestArgsToMiddlewareArgs(e) {
    return [e];
  }, middlewareArgsToRequestArgs(e) {
    return e[0];
  } };
  var ol = { isEnabled() {
    return false;
  }, getTraceParent() {
    return "00-10-10-00";
  }, async createEngineSpan() {
  }, getActiveContext() {
  }, runInChildSpan(e, t) {
    return t();
  } };
  var Ki = class {
    isEnabled() {
      return this.getGlobalTracingHelper().isEnabled();
    }
    getTraceParent(t) {
      return this.getGlobalTracingHelper().getTraceParent(t);
    }
    createEngineSpan(t) {
      return this.getGlobalTracingHelper().createEngineSpan(t);
    }
    getActiveContext() {
      return this.getGlobalTracingHelper().getActiveContext();
    }
    runInChildSpan(t, r) {
      return this.getGlobalTracingHelper().runInChildSpan(t, r);
    }
    getGlobalTracingHelper() {
      return globalThis.PRISMA_INSTRUMENTATION?.helper ?? ol;
    }
  };
  var Fd = ["$connect", "$disconnect", "$on", "$transaction", "$use", "$extends"];
  var ul = Fd;
  var hn = class {
    constructor() {
      this._middlewares = [];
    }
    use(t) {
      this._middlewares.push(t);
    }
    get(t) {
      return this._middlewares[t];
    }
    has(t) {
      return !!this._middlewares[t];
    }
    length() {
      return this._middlewares.length;
    }
  };
  var pl = S(ni());
  var Dd = { aggregate: false, aggregateRaw: false, createMany: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateOne: true, upsertOne: true };
  var En = class {
    constructor(t) {
      this.options = t;
      this.tickActive = false;
      this.batches = {};
    }
    request(t) {
      let r = this.options.batchBy(t);
      return r ? (this.batches[r] || (this.batches[r] = [], this.tickActive || (this.tickActive = true, process.nextTick(() => {
        this.dispatchBatches(), this.tickActive = false;
      }))), new Promise((n, i) => {
        this.batches[r].push({ request: t, resolve: n, reject: i });
      })) : this.options.singleLoader(t);
    }
    dispatchBatches() {
      for (let t in this.batches) {
        let r = this.batches[t];
        delete this.batches[t], r.length === 1 ? this.options.singleLoader(r[0].request).then((n) => {
          n instanceof Error ? r[0].reject(n) : r[0].resolve(n);
        }).catch((n) => {
          r[0].reject(n);
        }) : (r.sort((n, i) => this.options.batchOrder(n.request, i.request)), this.options.batchLoader(r.map((n) => n.request)).then((n) => {
          if (n instanceof Error)
            for (let i = 0;i < r.length; i++)
              r[i].reject(n);
          else
            for (let i = 0;i < r.length; i++) {
              let o = n[i];
              o instanceof Error ? r[i].reject(o) : r[i].resolve(o);
            }
        }).catch((n) => {
          for (let i = 0;i < r.length; i++)
            r[i].reject(n);
        }));
      }
    }
    get [Symbol.toStringTag]() {
      return "DataLoader";
    }
  };
  var _d = D("prisma:client:request_handler");
  var wn = class {
    constructor(t, r) {
      this.logEmitter = r, this.client = t, this.dataloader = new En({ batchLoader: na(async ({ requests: n, customDataProxyFetch: i }) => {
        let { transaction: o, otelParentCtx: s } = n[0], a = n.map((p) => p.protocolQuery), l = this.client._tracingHelper.getTraceParent(s), u = n.some((p) => Ji(p.protocolQuery.action));
        return (await this.client._engine.requestBatch(a, { traceparent: l, transaction: Nd(o), containsWrite: u, customDataProxyFetch: i })).map((p, d) => {
          if (p instanceof Error)
            return p;
          try {
            return this.mapQueryEngineResult(n[d], p);
          } catch (f) {
            return f;
          }
        });
      }), singleLoader: async (n) => {
        let i = n.transaction?.kind === "itx" ? dl(n.transaction) : undefined, o = await this.client._engine.request(n.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: Ji(n.protocolQuery.action), customDataProxyFetch: n.customDataProxyFetch });
        return this.mapQueryEngineResult(n, o);
      }, batchBy: (n) => n.transaction?.id ? `transaction-${n.transaction.id}` : cl(n.protocolQuery), batchOrder(n, i) {
        return n.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n.transaction.index - i.transaction.index : 0;
      } });
    }
    async request(t) {
      try {
        return await this.dataloader.request(t);
      } catch (r) {
        let { clientMethod: n, callsite: i, transaction: o, args: s } = t;
        this.handleAndLogRequestError({ error: r, clientMethod: n, callsite: i, transaction: o, args: s });
      }
    }
    mapQueryEngineResult({ dataPath: t, unpacker: r }, n) {
      let i = n?.data, o = n?.elapsed, s = this.unpack(i, t, r);
      return process.env.PRISMA_CLIENT_GET_TIME ? { data: s, elapsed: o } : s;
    }
    handleAndLogRequestError(t) {
      try {
        this.handleRequestError(t);
      } catch (r) {
        throw this.logEmitter && this.logEmitter.emit("error", { message: r.message, target: t.clientMethod, timestamp: new Date }), r;
      }
    }
    handleRequestError({ error: t, clientMethod: r, callsite: n, transaction: i, args: o }) {
      if (_d(t), Ld(t, i) || t instanceof Ce)
        throw t;
      if (t instanceof U && $d(t)) {
        let a = ml(t.meta);
        yn({ args: o, errors: [a], callsite: n, errorFormat: this.client._errorFormat, originalMethod: r, clientVersion: this.client._clientVersion });
      }
      let s = t.message;
      throw n && (s = wt({ callsite: n, originalMethod: r, isPanic: t.isPanic, showColors: this.client._errorFormat === "pretty", message: s })), s = this.sanitizeMessage(s), t.code ? new U(s, { code: t.code, clientVersion: this.client._clientVersion, meta: t.meta, batchRequestIdx: t.batchRequestIdx }) : t.isPanic ? new ue(s, this.client._clientVersion) : t instanceof K ? new K(s, { clientVersion: this.client._clientVersion, batchRequestIdx: t.batchRequestIdx }) : t instanceof k ? new k(s, this.client._clientVersion) : t instanceof ue ? new ue(s, this.client._clientVersion) : (t.clientVersion = this.client._clientVersion, t);
    }
    sanitizeMessage(t) {
      return this.client._errorFormat && this.client._errorFormat !== "pretty" ? (0, pl.default)(t) : t;
    }
    unpack(t, r, n) {
      if (!t || (t.data && (t = t.data), !t))
        return t;
      let i = Object.values(t)[0], o = r.filter((a) => a !== "select" && a !== "include"), s = bn(wi(i, o));
      return n ? n(s) : s;
    }
    get [Symbol.toStringTag]() {
      return "RequestHandler";
    }
  };
  var fl = "5.3.1";
  var gl = fl;
  var wl = S($i());
  var V = class extends Error {
    constructor(t) {
      super(t + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
    }
    get [Symbol.toStringTag]() {
      return "PrismaClientConstructorValidationError";
    }
  };
  E(V, "PrismaClientConstructorValidationError");
  var xl = ["datasources", "datasourceUrl", "errorFormat", "log", "__internal"];
  var bl = ["pretty", "colorless", "minimal"];
  var El = ["info", "query", "warn", "error"];
  var Vd = { datasources: (e, t) => {
    if (e) {
      if (typeof e != "object" || Array.isArray(e))
        throw new V(`Invalid value ${JSON.stringify(e)} for "datasources" provided to PrismaClient constructor`);
      for (let [r, n] of Object.entries(e)) {
        if (!t.includes(r)) {
          let i = At(r, t) || ` Available datasources: ${t.join(", ")}`;
          throw new V(`Unknown datasource ${r} provided to PrismaClient constructor.${i}`);
        }
        if (typeof n != "object" || Array.isArray(n))
          throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
        if (n && typeof n == "object")
          for (let [i, o] of Object.entries(n)) {
            if (i !== "url")
              throw new V(`Invalid value ${JSON.stringify(e)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
            if (typeof o != "string")
              throw new V(`Invalid value ${JSON.stringify(o)} for datasource "${r}" provided to PrismaClient constructor.
It should have this form: { url: "CONNECTION_STRING" }`);
          }
      }
    }
  }, datasourceUrl: (e) => {
    if (typeof e < "u" && typeof e != "string")
      throw new V(`Invalid value ${JSON.stringify(e)} for "datasourceUrl" provided to PrismaClient constructor.
Expected string or undefined.`);
  }, errorFormat: (e) => {
    if (e) {
      if (typeof e != "string")
        throw new V(`Invalid value ${JSON.stringify(e)} for "errorFormat" provided to PrismaClient constructor.`);
      if (!bl.includes(e)) {
        let t = At(e, bl);
        throw new V(`Invalid errorFormat ${e} provided to PrismaClient constructor.${t}`);
      }
    }
  }, log: (e) => {
    if (!e)
      return;
    if (!Array.isArray(e))
      throw new V(`Invalid value ${JSON.stringify(e)} for "log" provided to PrismaClient constructor.`);
    function t(r) {
      if (typeof r == "string" && !El.includes(r)) {
        let n = At(r, El);
        throw new V(`Invalid log level "${r}" provided to PrismaClient constructor.${n}`);
      }
    }
    for (let r of e) {
      t(r);
      let n = { level: t, emit: (i) => {
        let o = ["stdout", "event"];
        if (!o.includes(i)) {
          let s = At(i, o);
          throw new V(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s}`);
        }
      } };
      if (r && typeof r == "object")
        for (let [i, o] of Object.entries(r))
          if (n[i])
            n[i](o);
          else
            throw new V(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
    }
  }, __internal: (e) => {
    if (!e)
      return;
    let t = ["debug", "hooks", "engine", "measurePerformance"];
    if (typeof e != "object")
      throw new V(`Invalid value ${JSON.stringify(e)} for "__internal" to PrismaClient constructor`);
    for (let [r] of Object.entries(e))
      if (!t.includes(r)) {
        let n = At(r, t);
        throw new V(`Invalid property ${JSON.stringify(r)} for "__internal" provided to PrismaClient constructor.${n}`);
      }
  } };
  var Be = D("prisma:client");
  typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
  var Bd = { requestArgsToMiddlewareArgs: (e) => e, middlewareArgsToRequestArgs: (e) => e };
  var Ud = Symbol.for("prisma.client.transaction.id");
  var Kd = { id: 0, nextId() {
    return ++this.id;
  } };
  var Jd = new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
  /*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.4.3
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  */
});

// node_modules/.prisma/client/index.js
var require_client2 = __commonJS((exports) => {
  var __dirname = "/Users/jjh/dev/epyc_discord_bun/node_modules/.prisma/client";
  Object.defineProperty(exports, "__esModule", { value: true });
  var {
    PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
    PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
    PrismaClientRustPanicError: PrismaClientRustPanicError2,
    PrismaClientInitializationError: PrismaClientInitializationError2,
    PrismaClientValidationError: PrismaClientValidationError2,
    NotFoundError: NotFoundError2,
    getPrismaClient: getPrismaClient2,
    sqltag: sqltag2,
    empty: empty2,
    join: join2,
    raw: raw2,
    Decimal: Decimal2,
    Debug: Debug2,
    objectEnumValues: objectEnumValues2,
    makeStrictEnum: makeStrictEnum2,
    Extensions: Extensions2,
    warnOnce: warnOnce2,
    defineDmmfProperty: defineDmmfProperty2,
    Public: Public2
  } = require_library();
  var Prisma = {};
  exports.Prisma = Prisma;
  exports.$Enums = {};
  Prisma.prismaVersion = {
    client: "5.3.1",
    engine: "2f302df92bd8945e20ad4595a73def5b96afa54f"
  };
  Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
  Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
  Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
  Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
  Prisma.PrismaClientValidationError = PrismaClientValidationError2;
  Prisma.NotFoundError = NotFoundError2;
  Prisma.Decimal = Decimal2;
  Prisma.sql = sqltag2;
  Prisma.empty = empty2;
  Prisma.join = join2;
  Prisma.raw = raw2;
  Prisma.validator = Public2.validator;
  Prisma.getExtensionContext = Extensions2.getExtensionContext;
  Prisma.defineExtension = Extensions2.defineExtension;
  Prisma.DbNull = objectEnumValues2.instances.DbNull;
  Prisma.JsonNull = objectEnumValues2.instances.JsonNull;
  Prisma.AnyNull = objectEnumValues2.instances.AnyNull;
  Prisma.NullTypes = {
    DbNull: objectEnumValues2.classes.DbNull,
    JsonNull: objectEnumValues2.classes.JsonNull,
    AnyNull: objectEnumValues2.classes.AnyNull
  };
  var path = __require("path");
  exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
    ReadUncommitted: "ReadUncommitted",
    ReadCommitted: "ReadCommitted",
    RepeatableRead: "RepeatableRead",
    Serializable: "Serializable"
  });
  exports.Prisma.GameScalarFieldEnum = {
    id: "id",
    discordGuildId: "discordGuildId",
    discordChannelId: "discordChannelId",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    done: "done"
  };
  exports.Prisma.TurnScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    done: "done",
    sentenceTurn: "sentenceTurn",
    sentence: "sentence",
    imageUrl: "imageUrl",
    gameId: "gameId",
    playerId: "playerId"
  };
  exports.Prisma.PlayerScalarFieldEnum = {
    id: "id",
    createdAt: "createdAt",
    updatedAt: "updatedAt",
    discordUserId: "discordUserId",
    discordUsername: "discordUsername"
  };
  exports.Prisma.SortOrder = {
    asc: "asc",
    desc: "desc"
  };
  exports.Prisma.QueryMode = {
    default: "default",
    insensitive: "insensitive"
  };
  exports.Prisma.NullsOrder = {
    first: "first",
    last: "last"
  };
  exports.Prisma.ModelName = {
    Game: "Game",
    Turn: "Turn",
    Player: "Player"
  };
  var config = {
    generator: {
      name: "client",
      provider: {
        fromEnvVar: null,
        value: "prisma-client-js"
      },
      output: {
        value: "/Users/jjh/dev/epyc_discord_bun/node_modules/@prisma/client",
        fromEnvVar: null
      },
      config: {
        engineType: "library"
      },
      binaryTargets: [
        {
          fromEnvVar: null,
          value: "darwin",
          native: true
        }
      ],
      previewFeatures: []
    },
    relativeEnvPaths: {
      rootEnvPath: null
    },
    relativePath: "../../../prisma",
    clientVersion: "5.3.1",
    engineVersion: "2f302df92bd8945e20ad4595a73def5b96afa54f",
    datasourceNames: [
      "db"
    ],
    activeProvider: "postgresql",
    inlineDatasources: {
      db: {
        url: {
          fromEnvVar: "DATABASE_URL",
          value: null
        }
      }
    },
    inlineSchema: "Ly8gVGhpcyBpcyB5b3VyIFByaXNtYSBzY2hlbWEgZmlsZSwKLy8gbGVhcm4gbW9yZSBhYm91dCBpdCBpbiB0aGUgZG9jczogaHR0cHM6Ly9wcmlzLmx5L2QvcHJpc21hLXNjaGVtYQoKZ2VuZXJhdG9yIGNsaWVudCB7CiAgcHJvdmlkZXIgPSAicHJpc21hLWNsaWVudC1qcyIKfQoKZGF0YXNvdXJjZSBkYiB7CiAgcHJvdmlkZXIgPSAicG9zdGdyZXNxbCIKICB1cmwgICAgICA9IGVudigiREFUQUJBU0VfVVJMIikKfQoKbW9kZWwgR2FtZSB7CiAgaWQgICAgICAgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIGRpc2NvcmRHdWlsZElkICAgU3RyaW5nCiAgZGlzY29yZENoYW5uZWxJZCBTdHJpbmcKICBjcmVhdGVkQXQgICAgICAgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooNikKICB1cGRhdGVkQXQgICAgICAgIERhdGVUaW1lIEB1cGRhdGVkQXQKICBkb25lICAgICAgICAgICAgIEJvb2xlYW4gIEBkZWZhdWx0KGZhbHNlKQogIHR1cm5zICAgICAgICAgICAgVHVybltdICAgQHJlbGF0aW9uKCJHYW1lVG9UdXJuIikKCiAgQEBpbmRleChbaWQsIGRvbmVdLCBtYXA6ICJpZHhfZ2FtZSIpIC8vIFdoeT8KfQoKbW9kZWwgVHVybiB7CiAgaWQgICAgICAgICAgIEludCAgICAgIEBpZCBAZGVmYXVsdChhdXRvaW5jcmVtZW50KCkpCiAgY3JlYXRlZEF0ICAgIERhdGVUaW1lIEBkZWZhdWx0KG5vdygpKSBAZGIuVGltZXN0YW1wdHooNikKICB1cGRhdGVkQXQgICAgRGF0ZVRpbWUgQHVwZGF0ZWRBdAogIGRvbmUgICAgICAgICBCb29sZWFuICBAZGVmYXVsdChmYWxzZSkKICBzZW50ZW5jZVR1cm4gQm9vbGVhbiAgQGRlZmF1bHQodHJ1ZSkKICBzZW50ZW5jZSAgICAgU3RyaW5nPwogIGltYWdlVXJsICAgICBTdHJpbmc/CgogIGdhbWUgICBHYW1lIEByZWxhdGlvbigiR2FtZVRvVHVybiIsIGZpZWxkczogW2dhbWVJZF0sIHJlZmVyZW5jZXM6IFtpZF0sIG9uVXBkYXRlOiBDYXNjYWRlKQogIGdhbWVJZCBJbnQKCiAgcGxheWVyICAgUGxheWVyIEByZWxhdGlvbihmaWVsZHM6IFtwbGF5ZXJJZF0sIHJlZmVyZW5jZXM6IFtpZF0pCiAgcGxheWVySWQgSW50CgogIEBAaW5kZXgoW2dhbWVJZF0sIG1hcDogImlkeF9nYW1lX3R1cm4iKQogIEBAaW5kZXgoW3BsYXllcklkLCBkb25lXSwgbWFwOiAiaWR4X3BsYXllcl90dXJuIikKICBAQGluZGV4KFtpZCwgZG9uZV0sIG1hcDogImlkeF90dXJuIikgLy8gV2h5Pwp9Cgptb2RlbCBQbGF5ZXIgewogIGlkICAgICAgICAgICAgICBJbnQgICAgICBAaWQgQGRlZmF1bHQoYXV0b2luY3JlbWVudCgpKQogIGNyZWF0ZWRBdCAgICAgICBEYXRlVGltZSBAZGVmYXVsdChub3coKSkgQGRiLlRpbWVzdGFtcHR6KDYpCiAgdXBkYXRlZEF0ICAgICAgIERhdGVUaW1lIEB1cGRhdGVkQXQKICBkaXNjb3JkVXNlcklkICAgU3RyaW5nICAgQHVuaXF1ZQogIGRpc2NvcmRVc2VybmFtZSBTdHJpbmcKICB0dXJucyAgICAgICAgICAgVHVybltdCn0K",
    inlineSchemaHash: "5e9540687ed61417e4759394a2afe07c9b7ca89cea1d49379559036c77622eac"
  };
  var fs = __require("fs");
  config.dirname = __dirname;
  if (!fs.existsSync(path.join(__dirname, "schema.prisma"))) {
    const alternativePaths = [
      "node_modules/.prisma/client",
      ".prisma/client"
    ];
    const alternativePath = alternativePaths.find((altPath) => {
      return fs.existsSync(path.join(process.cwd(), altPath, "schema.prisma"));
    }) ?? alternativePaths[0];
    config.dirname = path.join(process.cwd(), alternativePath);
    config.isBundled = true;
  }
  config.runtimeDataModel = JSON.parse("{\"models\":{\"Game\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"discordGuildId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"discordChannelId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"done\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"turns\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Turn\",\"relationName\":\"GameToTurn\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Turn\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"done\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":false,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"sentenceTurn\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Boolean\",\"default\":true,\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"sentence\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"imageUrl\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":false,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"game\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Game\",\"relationName\":\"GameToTurn\",\"relationFromFields\":[\"gameId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"gameId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"player\",\"kind\":\"object\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Player\",\"relationName\":\"PlayerToTurn\",\"relationFromFields\":[\"playerId\"],\"relationToFields\":[\"id\"],\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"playerId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":true,\"hasDefaultValue\":false,\"type\":\"Int\",\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false},\"Player\":{\"dbName\":null,\"fields\":[{\"name\":\"id\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":true,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"Int\",\"default\":{\"name\":\"autoincrement\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"createdAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":true,\"type\":\"DateTime\",\"default\":{\"name\":\"now\",\"args\":[]},\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"updatedAt\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"DateTime\",\"isGenerated\":false,\"isUpdatedAt\":true},{\"name\":\"discordUserId\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":true,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"discordUsername\",\"kind\":\"scalar\",\"isList\":false,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"String\",\"isGenerated\":false,\"isUpdatedAt\":false},{\"name\":\"turns\",\"kind\":\"object\",\"isList\":true,\"isRequired\":true,\"isUnique\":false,\"isId\":false,\"isReadOnly\":false,\"hasDefaultValue\":false,\"type\":\"Turn\",\"relationName\":\"PlayerToTurn\",\"relationFromFields\":[],\"relationToFields\":[],\"isGenerated\":false,\"isUpdatedAt\":false}],\"primaryKey\":null,\"uniqueFields\":[],\"uniqueIndexes\":[],\"isGenerated\":false}},\"enums\":{},\"types\":{}}");
  defineDmmfProperty2(exports.Prisma, config.runtimeDataModel);
  var { warnEnvConflicts: warnEnvConflicts2 } = require_library();
  warnEnvConflicts2({
    rootEnvPath: config.relativeEnvPaths.rootEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.rootEnvPath),
    schemaEnvPath: config.relativeEnvPaths.schemaEnvPath && path.resolve(config.dirname, config.relativeEnvPaths.schemaEnvPath)
  });
  var PrismaClient = getPrismaClient2(config);
  exports.PrismaClient = PrismaClient;
  Object.assign(exports, Prisma);
  path.join(__dirname, "libquery_engine-darwin.dylib.node");
  path.join(process.cwd(), "node_modules/.prisma/client/libquery_engine-darwin.dylib.node");
  path.join(__dirname, "schema.prisma");
  path.join(process.cwd(), "node_modules/.prisma/client/schema.prisma");
});

// node_modules/@prisma/client/index.js
var require_client3 = __commonJS((exports, module) => {
  module.exports = {
    ...require_client2()
  };
});

// src/bot.ts
var import_discord3 = __toESM(require_src(), 1);

// src/config.ts
var {
  DISCORD_TOKEN,
  DISCORD_CLIENT_ID,
  SENTENCE_TIMEOUT,
  PICTURE_TIMEOUT,
  GAME_TIMEOUT,
  HEARTBEAT,
  DATABASE_URL,
  CHANNEL,
  PICTURE_WIDTH,
  PICTURE_HEIGHT
} = Bun.env;
if (!DISCORD_TOKEN || !DISCORD_CLIENT_ID) {
  throw new Error("Missing environment variables");
}
var config_default = {
  DISCORD_TOKEN,
  DISCORD_CLIENT_ID,
  SENTENCE_TIMEOUT: SENTENCE_TIMEOUT && parseInt(SENTENCE_TIMEOUT) || 600,
  PICTURE_TIMEOUT: PICTURE_TIMEOUT && parseInt(PICTURE_TIMEOUT) || 86400,
  GAME_TIMEOUT: GAME_TIMEOUT && parseInt(GAME_TIMEOUT) || 604800,
  HEARTBEAT: HEARTBEAT && parseInt(HEARTBEAT) || 60,
  DATABASE_URL,
  CHANNEL,
  PICTURE_WIDTH: PICTURE_WIDTH && parseInt(PICTURE_WIDTH) || 50,
  PICTURE_HEIGHT: PICTURE_HEIGHT && parseInt(PICTURE_HEIGHT) || 50
};

// src/commands/help.ts
var exports_help = {};
__export(exports_help, {
  execute: () => {
    {
      return execute;
    }
  },
  data: () => {
    {
      return data;
    }
  }
});
var data = {
  name: "help",
  description: "How to play Eat Poop You Cat."
};
var execute = async (i) => {
  return {
    messageCode: "help"
  };
};

// src/commands/play.ts
var exports_play = {};
__export(exports_play, {
  execute: () => {
    {
      return execute2;
    }
  },
  data: () => {
    {
      return data2;
    }
  }
});

// src/db.ts
var client = __toESM(require_client3(), 1);
var prisma = new client.PrismaClient;
var createOrFindPlayer = async (discordUserId, discordUsername) => {
  console.log(`Creating or finding player ${discordUserId}/${discordUsername}...`);
  const user = await prisma.player.findFirst({ where: { discordUserId } });
  if (user)
    return user;
  else
    return prisma.player.create({ data: { discordUserId, discordUsername } });
};
var fetchPlayer = async (playerId) => {
  return prisma.player.findUnique({ where: { id: playerId } });
};
var touchGame = async (gameId) => {
  return prisma.game.update({
    where: { id: gameId },
    data: { updatedAt: new Date },
    include: { turns: true }
  });
};
var findPendingGame = async (player) => {
  return prisma.game.findFirst({
    where: {
      done: false,
      turns: {
        some: {
          player,
          done: false
        }
      }
    },
    include: { turns: true }
  });
};
var findAvailableGame = async (player) => {
  console.log(`Finding available game for player ${player.id}...`);
  return prisma.game.findFirst({
    where: {
      done: false,
      turns: {
        every: { done: true },
        none: { player }
      }
    },
    include: { turns: true }
  });
};
var createNewGame = async (discordGuildId, discordChannelId) => {
  console.log(`Creating new game...`);
  return prisma.game.create({
    data: {
      discordGuildId,
      discordChannelId
    },
    include: { turns: true }
  });
};
var createNewTurn = async (game, player, sentenceTurn) => {
  await prisma.turn.create({
    data: {
      game: {
        connect: {
          id: game.id
        }
      },
      player: {
        connect: {
          id: player.id
        }
      },
      sentenceTurn
    }
  });
  return touchGame(game.id);
};
var finishSentenceTurn = async (turnId, sentence) => {
  const t = await prisma.turn.update({
    where: {
      id: turnId
    },
    data: {
      sentence,
      done: true
    }
  });
  return touchGame(t.gameId);
};
var finishPictureTurn = async (turnId, imageUrl) => {
  const t = await prisma.turn.update({
    where: { id: turnId },
    data: {
      done: true,
      imageUrl
    }
  });
  return touchGame(t.gameId);
};
var getStats = async (player) => {
  const inProgress = await prisma.game.count({
    where: {
      done: false
    }
  });
  const yoursDone = await prisma.game.count({
    where: {
      done: true,
      turns: {
        every: { done: true },
        some: { player }
      }
    }
  });
  const yoursInProgress = await prisma.game.count({
    where: {
      done: false,
      turns: {
        some: { player }
      }
    }
  });
  return { inProgress, yoursDone, yoursInProgress };
};
var fetchTimedoutPendingTurns = async (config) => {
  const { pictureCutoff, sentenceCutoff } = config;
  console.log(`Finding pending picture turns that haven't been updated since ${new Date(pictureCutoff)} and pending sentence turns since ${new Date(sentenceCutoff)}`);
  return prisma.game.findMany({
    where: {
      done: false,
      turns: {
        some: {
          done: false,
          OR: [{
            sentenceTurn: false,
            updatedAt: {
              lt: new Date(pictureCutoff)
            }
          }, {
            sentenceTurn: true,
            updatedAt: {
              lt: new Date(sentenceCutoff)
            }
          }]
        }
      }
    },
    include: { turns: true }
  });
};
var fetchTimedoutPendingGames = async (gameCutoff) => {
  const games = prisma.game.findMany({
    where: {
      done: false,
      updatedAt: {
        lt: new Date(gameCutoff)
      }
    },
    include: { turns: true }
  });
  return games;
};
var deleteTurn = async (game) => {
  console.log(`Deleting turn ${game.turns[game.turns.length - 1].id}...`);
  await prisma.turn.delete({
    where: {
      id: game.turns[game.turns.length - 1].id
    }
  });
  await touchGame(game.id);
};
var updateGameStatus = async (game, status) => {
  return prisma.game.update({
    where: {
      id: game.id
    },
    data: status,
    include: { turns: true }
  });
};
var deleteGame = async (game) => {
  await prisma.turn.deleteMany({ where: { gameId: game.id } });
  await prisma.game.delete({ where: { id: game.id } });
};

// src/commands/play.ts
var data2 = {
  name: "play",
  description: "Initiate a turn in a game of Eat Poop You Cat."
};
var execute2 = async (interaction) => {
  const player = await createOrFindPlayer(interaction.userId, interaction.username);
  if (await findPendingGame(player)) {
    return { messageCode: "playButPending" };
  }
  let game = await findAvailableGame(player) || await createNewGame(interaction.serverId, interaction.channelId);
  const gameId = game.id;
  const previousTurn = game.turns[game.turns.length - 1];
  game = await createNewTurn(game, player, previousTurn ? !previousTurn.sentenceTurn : true);
  const pendingTurn = game.turns[game.turns.length - 1];
  const now = Date.now();
  if (!previousTurn) {
    console.log(`Created game ${gameId} and initiating turn ${pendingTurn.id}...`);
    return {
      messageCode: "playSentenceInitiating",
      gameId,
      timeRemaining: pendingTurn.createdAt.getTime() + config_default.SENTENCE_TIMEOUT * 1000 - now
    };
  } else if (pendingTurn.sentenceTurn) {
    console.log(`Found an available game ${gameId} and created a sentence turn ${pendingTurn.id}...`);
    return {
      messageCode: "playSentence",
      gameId,
      timeRemaining: pendingTurn.createdAt.getTime() + config_default.SENTENCE_TIMEOUT * 1000 - now,
      imageUrl: previousTurn.imageUrl
    };
  } else if (previousTurn.sentence) {
    console.log(`Found an available game ${gameId} and created a picture turn ${pendingTurn.id}...`);
    return {
      messageCode: "playPicture",
      gameId,
      timeRemaining: pendingTurn.createdAt.getTime() + config_default.PICTURE_TIMEOUT * 1000 - now,
      sentence: previousTurn.sentence
    };
  } else {
    throw new Error("ERROR! There is no sentence or media attached to the preceding turn.");
  }
};

// src/commands/submit.ts
var exports_submit = {};
__export(exports_submit, {
  execute: () => {
    {
      return execute3;
    }
  },
  data: () => {
    {
      return data3;
    }
  }
});
var data3 = {
  name: "submit",
  description: "Initiate a turn in a game of Eat Poop You Cat.",
  stringOption: {
    name: "sentence",
    description: "The sentence you want to submit."
  },
  attachmentOption: {
    name: "picture",
    description: "The picture you want to submit."
  }
};
var execute3 = async (interaction) => {
  const { sentence, imageUrl } = interaction;
  const player = await createOrFindPlayer(interaction.userId, interaction.username);
  let game = await findPendingGame(player);
  const pendingTurn = game?.turns[game.turns.length - 1];
  if (!pendingTurn)
    return { messageCode: "submitButNo" };
  if (pendingTurn.sentenceTurn) {
    console.log(`Pending turn ${pendingTurn.id} is a sentence...`);
    if (imageUrl)
      return { messageCode: "submitSentenceButPicture" };
    else if (!sentence)
      return { messageCode: "submitSentenceButEmpty" };
    else {
      console.log("Submitting sentence...");
      await finishSentenceTurn(pendingTurn.id, sentence);
      return {
        messageCode: "submitSentence",
        gameId: game.id
      };
    }
  } else if (!pendingTurn.sentenceTurn) {
    console.log(`Pending turn ${pendingTurn.id} is a picture...`);
    if (sentence)
      return { messageCode: "submitPictureButSentence" };
    else if (!imageUrl) {
      return { messageCode: "submitPictureButEmpty" };
    } else {
      console.log("Submitting picture...");
      await finishPictureTurn(pendingTurn.id, imageUrl);
      return {
        messageCode: "submitPicture",
        gameId: game.id
      };
    }
  } else
    throw new Error("ERROR! There is no sentence or media attached to this turn.");
};

// src/commands/status.ts
var exports_status = {};
__export(exports_status, {
  execute: () => {
    {
      return execute4;
    }
  },
  data: () => {
    {
      return data4;
    }
  }
});
var data4 = {
  name: "status",
  description: "Server and personal stats."
};
var execute4 = async (interaction) => {
  const player = await createOrFindPlayer(interaction.userId, interaction.username);
  const stats = await getStats(player);
  return {
    ...stats,
    messageCode: "status"
  };
};

// src/commands/index.ts
var commands = {
  help: exports_help,
  play: exports_play,
  submit: exports_submit,
  status: exports_status
};

// src/deploy_commands.ts
var import_discord = __toESM(require_src(), 1);
async function deployCommands({ guildId }) {
  try {
    console.log("Started refreshing application (/) commands.");
    await rest.put(import_discord.Routes.applicationGuildCommands(config_default.DISCORD_CLIENT_ID, guildId), {
      body: commandsData
    });
    console.log("Successfully reloaded application (/) commands.");
  } catch (error) {
    console.error(error);
  }
}
var commandsData = Object.values(commands).map((command) => {
  const { name, description } = command.data;
  const slashCommand = new import_discord.SlashCommandBuilder().setName(name).setDescription(description);
  if ("stringOption" in command.data) {
    const { name: stringName, description: stringDescription } = command.data.stringOption;
    slashCommand.addStringOption((option) => option.setName(stringName).setDescription(stringDescription));
  }
  if ("attachmentOption" in command.data) {
    const { name: attachmentName, description: attachmentDescription } = command.data.attachmentOption;
    slashCommand.addAttachmentOption((option) => option.setName(attachmentName).setDescription(attachmentDescription));
  }
  return slashCommand.toJSON();
});
var rest = new import_discord.REST({ version: "10" }).setToken(config_default.DISCORD_TOKEN);

// src/services/discordChannel.ts
var import_discord2 = __toESM(require_src(), 1);
var discord2Interaction = async (discordInteraction) => {
  const pictureAttachment = discordInteraction.options?.get("picture")?.attachment;
  const sentence = discordInteraction.options?.get("sentence")?.value;
  return {
    userId: discordInteraction.user.id,
    username: discordInteraction.user.username,
    serverId: discordInteraction.guildId || undefined,
    channelId: discordInteraction.channelId,
    imageUrl: pictureAttachment?.url || undefined,
    sentence: sentence || undefined
  };
};
var message2Embeds = (message) => {
  const embeds = new import_discord2.default.EmbedBuilder().setDescription(message.description);
  if (message.title) {
    embeds.setTitle(message.title);
  }
  if (message.imageUrl) {
    embeds.setImage(message.imageUrl);
  }
  return [embeds];
};

class DiscordService {
  client2;
  channel;
  constructor(client2) {
    this.client = client2;
  }
  onReady() {
    this.channel = this.client.channels.cache.find((channel) => channel instanceof import_discord2.default.TextChannel && channel.name === config_default.CHANNEL);
    if (!this.channel)
      throw new Error(`Could not find channel ${config_default.CHANNEL}`);
  }
  async sendDirectMessage(envelope) {
    const { playerId } = envelope;
    const player = await fetchPlayer(playerId);
    const user = await this.client.users.fetch(player.discordUserId);
    const dmChannel = await user.createDM();
    await dmChannel.send({ embeds: message2Embeds(envelope.message) });
  }
  async replyToCommand(interaction, envelope) {
    interaction.reply({
      embeds: message2Embeds(envelope.message),
      ephemeral: true
    });
  }
  async sendChannelMessage(envelope) {
    await this.channel.send({ embeds: message2Embeds(envelope.message) });
  }
}

// src/copy.ts
var countdown = (msec) => {
  let seconds = Math.floor(msec / 1000);
  let minutes = Math.floor(seconds / 60);
  let hours = Math.floor(minutes / 60);
  let days = Math.floor(hours / 24);
  seconds %= 60;
  minutes %= 60;
  hours %= 24;
  const parts = [];
  if (days)
    parts.push(`${days}d`);
  if (hours)
    parts.push(`${hours}h`);
  if (minutes)
    parts.push(`${minutes}m`);
  parts.push(`${seconds}s`);
  return parts.join(" ");
};
var render = (message) => {
  const {
    messageCode,
    inProgress,
    yoursDone,
    yoursInProgress,
    timeRemaining,
    sentence,
    imageUrl,
    gameId,
    discordUsername,
    playerId
  } = message;
  const timeString = timeRemaining && countdown(timeRemaining);
  switch (messageCode) {
    case "help":
      return {
        title: "how to play",
        description: "Eat Poop You Cat is a game where players take turns writing sentences and drawing pictures. The first player writes a sentence, the second player draws a picture of that sentence, the third player writes a sentence of that picture, and so on. At the end of the game, it gets posted to #epyc where players can admire the art, the writing, and how the concept mutated. Type `/play` to play.",
        imageUrl: "https://i.imgur.com/ipoiOMF.jpeg"
      };
    case "status":
      return {
        title: "current status",
        description: `Games in progress: ${inProgress}. Yours: ${yoursDone} done, ${yoursInProgress} in progress.`
      };
    case "playButPending":
      return {
        title: "submit to me",
        description: "You already have a pending turn! Type `/submit` to submit it."
      };
    case "playSentenceInitiating":
      return {
        title: "write for me",
        description: `You're starting off Game #${gameId}! You have ${timeString} to write a sentence.`
      };
    case "playPicture":
      return {
        title: "draw for me",
        description: `You have ${timeString} to \`/submit\` a picture of this sentence: "${sentence}"`
      };
    case "playSentence":
      return {
        title: "write for me",
        description: `You have ${timeString} to \`/submit\` a sentence of this picture:`,
        imageUrl
      };
    case "submitButNo":
      return {
        title: "try `/play`",
        description: "You don't have a pending turn! Type `/play` to start one."
      };
    case "submitPicture":
      return {
        title: "its beautiful",
        description: `You submitted a picture! I'll message you when Game #${gameId} is done.`
      };
    case "submitSentence":
      return {
        title: "very clever",
        description: `You submitted a sentence! I'll message you when Game #${gameId} is done.`
      };
    case "submitPictureButSentence":
      return {
        title: "submit to me",
        description: "You submitted a picture, but your turn is to write a sentence!"
      };
    case "submitPictureButEmpty":
      return {
        title: "submit to me",
        description: "You submitted a picture, but it was empty!"
      };
    case "submitSentenceButPicture":
      return {
        title: "submit to me",
        description: "You submitted a sentence, but your turn is to draw a picture!"
      };
    case "submitSentenceButEmpty":
      return {
        title: "submit to me",
        description: "You submitted a sentence, but it was empty!"
      };
    case "timeoutTurn":
      return {
        playerId,
        title: "timeout",
        description: `Your turn in Game #${gameId} timed out!`
      };
    case "timeoutGameIntro":
      return {
        title: "game done",
        description: `Game #${gameId} is done!`
      };
    case "timeoutGameTurn":
      return imageUrl ? {
        description: `${discordUsername} drew:`,
        imageUrl
      } : { description: `${discordUsername} wrote "${sentence}"` };
    case "timeoutGameEnd":
      return {
        description: `Thanks for playing!`
      };
    default:
      throw new Error(`Unknown messageCode: ${messageCode}`);
  }
};

// src/auditor.ts
var findTurnsTimedout = async () => {
  const now = Date.now();
  return await fetchTimedoutPendingTurns({
    pictureCutoff: now - config_default.PICTURE_TIMEOUT * 1000,
    sentenceCutoff: now - config_default.SENTENCE_TIMEOUT * 1000
  });
};
var findGamesTimedout = async () => {
  const now = Date.now();
  return await fetchTimedoutPendingGames(now - config_default.GAME_TIMEOUT * 1000);
};
var expireTurn = async (game) => {
  const isOnlyTurn = game.turns.length === 1;
  const turn = game.turns[game.turns.length - 1];
  const turnType = isOnlyTurn ? "sentenceInitiate" : turn.sentenceTurn ? "sentence" : "picture";
  console.log(`Turn ${turn.id} (${turnType}) has expired...`);
  if (isOnlyTurn) {
    console.log(`...and it was the only turn on game ${turn.gameId}, so that gets deleted too.`);
    await deleteGame(game);
  } else
    await deleteTurn(game);
  return {
    messageCode: "timeoutTurn",
    gameId: turn.gameId,
    playerId: turn.playerId
  };
};
var finishGame = async (game) => {
  console.log(`Game ${game.id} has completed...`);
  updateGameStatus(game, { done: true });
  const messages = await Promise.all(game.turns.map(async (turn) => {
    const player = await fetchPlayer(turn.playerId);
    const content = turn.sentenceTurn ? { sentence: turn.sentence } : { imageUrl: turn.imageUrl };
    return {
      messageCode: "timeoutGameTurn",
      gameId: game.id,
      channelId: game.discordChannelId,
      discordUsername: player.discordUsername,
      ...content
    };
  }));
  return [
    {
      messageCode: "timeoutGameIntro",
      gameId: game.id,
      channelId: game.discordChannelId
    },
    ...messages,
    {
      messageCode: "timeoutGameEnd",
      channelId: game.discordChannelId,
      startedAt: game.createdAt,
      endedAt: game.updatedAt
    }
  ];
};

// src/bot.ts
var client2 = new import_discord3.Client({
  intents: [
    import_discord3.GatewayIntentBits.Guilds,
    import_discord3.GatewayIntentBits.GuildMessages,
    import_discord3.GatewayIntentBits.DirectMessages
  ]
});
var chatService = new DiscordService(client2);
client2.once(import_discord3.Events.ClientReady, async (c) => {
  console.log(`Ready! Logged in as ${c.user.tag}`);
  chatService.onReady();
  const heartbeat = setInterval(async () => {
    const turnsExpired = await findTurnsTimedout();
    const turnsExpiredMessages = turnsExpired.map(expireTurn);
    for await (const message of turnsExpiredMessages) {
      await chatService.sendDirectMessage({
        playerId: message.playerId,
        message: render(message)
      });
    }
    const games = await findGamesTimedout();
    for await (const messageArray of await Promise.all(games.flatMap(finishGame))) {
      for await (const message of messageArray) {
        await chatService.sendChannelMessage({
          channelId: message.channelId,
          message: render(message)
        });
      }
    }
  }, config_default.HEARTBEAT * 1000);
});
client2.on("guildCreate", async (guild) => {
  console.log(`Joined guild ${guild.name} (${guild.id})`);
  await deployCommands({ guildId: guild.id });
});
client2.on("interactionCreate", async (discordInteraction) => {
  if (!discordInteraction.isCommand()) {
    return;
  }
  const { commandName } = discordInteraction;
  if (commands[commandName]) {
    const command = commands[commandName];
    const interaction = await discord2Interaction(discordInteraction);
    const message = await command.execute(interaction);
    console.log(interaction, "\n->\n", message, "\n");
    const messageRender = render(message);
    chatService.replyToCommand(discordInteraction, { message: messageRender });
  }
});
client2.login(config_default.DISCORD_TOKEN);
